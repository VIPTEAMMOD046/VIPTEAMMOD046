<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Editor</title>

    <!-- QR Code Library -->
    <script src="Pdf/qrcode.min.js"></script>
    
     <!-- Add this line to load the Roboto font from Google -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
<style>
/* Modern Professional Design System */
:root {
    --primary-color: #2c3e50;
    --primary-dark: #1a252f;
    --secondary-color: #5dade2;
    --accent-color: #34495e;
    --success-color: #27ae60;
    --warning-color: #f39c12;
    --danger-color: #e74c3c;
    --dark-color: #2c3e50;
    --light-color: #ffffff;
    --gray-color: #7f8c8d;
    --border-radius: 12px;
    --border-radius-sm: 8px;
    --border-radius-lg: 16px;
    --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    --box-shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.12);
    --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    
    /* Enhanced gradients for more attractive look */
    --gradient-primary: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
    --gradient-secondary: linear-gradient(135deg, #5dade2 0%, #3498db 100%);
    --gradient-accent: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
    --gradient-success: linear-gradient(135deg, #27ae60 0%, #229954 100%);
    --gradient-warning: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
    --gradient-danger: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    
    /* Sky Blue Glow Effects */
    --glow-sky-blue: 0 0 20px rgba(93, 173, 226, 0.6);
    --glow-sky-blue-hover: 0 0 30px rgba(93, 173, 226, 0.8);
    --glow-sky-blue-intense: 0 0 40px rgba(93, 173, 226, 1);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: background-color 0.3s, color 0.3s;

   font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    line-height: 1.6;
   
    overflow-x: hidden;
}

/* When the body has the 'locked' class, it will hide everything */
body.locked {
    display: none;
}

/* Login Page Styles */
.login-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    position: relative;
    overflow: hidden;
}

.login-container::before {
    content: "";
    position: absolute;
    width: 200%;
    height: 200%;
    background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%232c3e50' fill-opacity='0.03'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
    animation: bgMove 20s linear infinite;
}

@keyframes bgMove {
    0% { transform: translate(0, 0); }
    100% { transform: translate(-50px, -50px); }
}

.login-card {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(20px);
    border-radius: var(--border-radius-lg);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
    width: 420px;
    padding: 40px;
    text-align: center;
    position: relative;
    z-index: 10;
    transform: translateY(0);
    transition: var(--transition);
    border: 1px solid rgba(0, 0, 0, 0.05);
    overflow: hidden;
}

.login-card::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 5px;
    background: var(--gradient-primary);
}

.login-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 25px 70px rgba(0, 0, 0, 0.2);
}

.login-title {
    font-size: 32px;
    font-weight: 700;
    margin-bottom: 30px;
    background: var(--gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: -0.5px;
}

.form-group {
    margin-bottom: 25px;
    text-align: left;
}

.form-label {
    display: block;
    font-size: 15px;
    color: var(--gray-color);
    font-weight: 600;
    margin-bottom: 10px;
    letter-spacing: 0.25px;
}

.form-input {
    width: 100%;
    padding: 14px 16px;
    border: 2px solid #e9ecef;
    border-radius: var(--border-radius);
    background-color: white;
    font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    font-size: 15px;
    transition: var(--transition);
    color: var(--dark-color);
}

.form-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 4px rgba(44, 62, 80, 0.2);
}

.login-btn {
    width: 100%;
    padding: 14px;
    background: var(--gradient-primary);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    transition: var(--transition);
    box-shadow: 0 4px 15px rgba(44, 62, 80, 0.3);
    letter-spacing: 0.5px;
    margin-top: 10px;
    position: relative;
    overflow: hidden;
}

.login-btn::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.login-btn:hover::before {
    left: 100%;
}

.login-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(44, 62, 80, 0.4);
}

.login-btn:disabled {
    background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.error-message {
    color: var(--danger-color);
    margin-top: 15px;
    font-size: 14px;
    display: none;
    padding: 10px;
    background-color: rgba(231, 76, 60, 0.1);
    border-radius: var(--border-radius-sm);
    border-left: 4px solid var(--danger-color);
}

/* App Container Styles */
.app-container {
    display: none;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
}

header {
    background: var(--gradient-primary);
    color: white;
    padding: 18px 25px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: var(--box-shadow);
    position: relative;
    z-index: 100;
 overflow: hidden;
}

.title {
    font-size: 24px;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 12px;
    letter-spacing: -0.5px;
}

.title::before {
    content: "ðŸ“„";
    font-size: 26px;
}

.header-controls {
    display: flex;
    gap: 12px;
}

.save-btn {
    padding: 10px 18px;
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: var(--transition);
    display: flex;
    align-items: center;
    gap: 6px;
    letter-spacing: 0.25px;
    position: relative;
    overflow: hidden;
}

.save-btn::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.save-btn:hover::before {
    left: 100%;
}

.save-btn#save-btn {
    background: var(--gradient-primary);
}
.save-btn#save-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(44, 62, 80, 0.4);
}


.save-btn#FScreen-btn {
    background: var(--gradient-secondary);
}
.save-btn#FScreen-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(44, 62, 80, 0.4);
}


.save-btn#logout-btn {
    background: var(--gradient-danger);
}
.save-btn#logout-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(231, 76, 60, 0.4);
}

/* QR Code Button */
.save-btn#qr-btn {
    background: var(--gradient-success);
}
.save-btn#qr-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
}

.form-section {
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    padding: 25px;
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    align-items: flex-end;
    box-shadow: var(--box-shadow);
    max-height: 240px;
    overflow-y: auto;
    border-bottom: 1px solid #e9ecef;
}

.form-section::-webkit-scrollbar {
    width: 8px;
}

.form-section::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 10px;
}

.form-section::-webkit-scrollbar-thumb {
    background: var(--gradient-primary);
    border-radius: 10px;
}

.form-section::-webkit-scrollbar-thumb:hover {
    background: var(--gradient-secondary);
}

.form-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 1;
    min-width: 200px;
}

.form-label {
    font-size: 14px;
    color: var(--gray-color);
    font-weight: 600;
    letter-spacing: 0.25px;
}

.form-input {
    padding: 12px 16px;
    border: 2px solid #e9ecef;
    border-radius: var(--border-radius);
    background-color: white;
    font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    font-size: 14px;
    width: 100%;
    transition: var(--transition);
    color: var(--dark-color);
}

.form-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 4px rgba(44, 62, 80, 0.2);
}

.distance-input-group {
    display: flex;
    align-items: center;
}

.distance-input {
    flex: 1;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
}

.distance-suffix {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 2px solid #e9ecef;
    border-left: none;
    border-top-right-radius: var(--border-radius);
    border-bottom-right-radius: var(--border-radius);
    padding: 12px 16px;
    font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: var(--gray-color);
    font-weight: 600;
}

.radio-group {
    display: flex;
    gap: 15px;
    margin-top: 8px;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 6px;
}

.radio-option input[type="radio"] {
    margin: 0;
    width: 18px;
    height: 18px;
    accent-color: var(--primary-color);
}

.radio-option label {
    font-size: 14px;
    color: var(--gray-color);
    cursor: pointer;
    font-weight: 500;
}

.apply-btn {
    padding: 12px 24px;
    background: var(--gradient-primary);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: var(--transition);
    height: 46px;
    box-shadow: 0 4px 15px rgba(44, 62, 80, 0.3);
    letter-spacing: 0.25px;
    position: relative;
    overflow: hidden;
}

.apply-btn::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.apply-btn:hover::before {
    left: 100%;
}

.apply-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(44, 62, 80, 0.4);
}

.toolbar {
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    padding: 18px 25px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: var(--box-shadow);
    border-bottom: 1px solid #e9ecef;
}

.toolbar-group {
    display: flex;
    align-items: center;
    gap: 12px;
}

.toolbar-label {
    font-size: 14px;
    color: var(--gray-color);
    font-weight: 600;
    letter-spacing: 0.25px;
}

.page-nav {
    display: flex;
    align-items: center;
    gap: 10px;
}

.page-btn {
    width: 38px;
    height: 38px;
    border: 1px solid #e9ecef;
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    border-radius: var(--border-radius);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    transition: var(--transition);
    color: var(--dark-color);
}

.page-btn:hover:not(:disabled) {
    background: var(--gradient-primary);
    color: white;
    transform: translateY(-2px);
    box-shadow: var(--box-shadow);
}

.page-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.page-info {
    font-size: 14px;
    font-weight: 600;
    min-width: 80px;
    text-align: center;
    color: var(--primary-color);
}

.zoom-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}

.zoom-btn {
    width: 38px;
    height: 38px;
    border: 1px solid #e9ecef;
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    border-radius: var(--border-radius);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    transition: var(--transition);
    color: var(--dark-color);
}

.zoom-btn:hover {
    background: var(--gradient-accent);
    color: white;
    transform: translateY(-2px);
    box-shadow: var(--box-shadow);
}

.zoom-level {
    font-size: 14px;
    font-weight: 600;
    min-width: 50px;
    text-align: center;
    color: var(--primary-color);
}

.pdf-container {
    flex: 1;
    overflow: auto;
    background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 20px;
    position: relative;
}

.pdf-page {
    position: relative;
    box-shadow: var(--box-shadow-lg);
    background-color: white;
    margin: 20px;
    border-radius: var(--border-radius);
}

.canvas-wrapper {
    position: relative;
    display: inline-block;
    border-radius: var(--border-radius);
    overflow: hidden;
}

#pdf-canvas, #edit-canvas {
    display: block;
}

#edit-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10;
}

.text-box {
    position: absolute;
    border: 2px dashed var(--primary-color);
    background-color: rgba(44, 62, 80, 0.1);
    cursor: pointer;
    z-index: 20;
    transition: var(--transition);
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    border-radius: var(--border-radius-sm);
}

.text-box:hover {
    background-color: rgba(44, 62, 80, 0.2);
    border-color: var(--primary-dark);
    transform: scale(1.02);
}

.text-box.edited {
    border-color: var(--success-color);
    background-color: rgba(39, 174, 96, 0.1);
}

.text-input {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px;
    border: none;
    background-color: white;
    font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    z-index: 10000;
    outline: none;
    box-shadow: var(--box-shadow-lg);
    border-radius: var(--border-radius-lg);
    font-size: 16px;
    min-width: 400px;
    max-width: 80%;
}

.text-input:focus {
    box-shadow: 0 0 0 5px rgba(44, 62, 80, 0.2);
}

.edit-controls {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e9ecef;
    flex-wrap: wrap;
}

.control-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.control-label {
    font-size: 14px;
    color: var(--gray-color);
    font-weight: 600;
    min-width: 50px;
    letter-spacing: 0.25px;
}

.color-input {
    width: 50px;
    height: 36px;
    border: 2px solid #e9ecef;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
}

.font-select {
    padding: 8px 12px;
    border: 2px solid #e9ecef;
    border-radius: var(--border-radius-sm);
    background-color: white;
    font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    cursor: pointer;
    font-size: 14px;
}

.font-btn {
    padding: 8px 15px;
    border: 2px solid #e9ecef;
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-size: 14px;
    transition: var(--transition);
    color: var(--dark-color);
}

.font-btn.active {
    background: var(--gradient-primary);
    color: white;
    border-color: var(--primary-color);
}

.font-btn:hover {
    background-color: #f8f9fa;
}

.bold-btn {
    padding: 8px 15px;
    border: 2px solid #e9ecef;
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-weight: bold;
    font-size: 14px;
    transition: var(--transition);
    color: var(--dark-color);
}

.bold-btn.active {
    background: var(--gradient-primary);
    color: white;
    border-color: var(--primary-color);
}

.bold-btn:hover {
    background-color: #f8f9fa;
}

.dialog-buttons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 20px;
}

.dialog-btn {
    padding: 12px 24px;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: var(--transition);
    letter-spacing: 0.25px;
}

.dialog-btn-save {
    background: var(--gradient-primary);
    color: white;
}

.dialog-btn-save:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(44, 62, 80, 0.4);
}

.dialog-btn-cancel {
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    color: var(--gray-color);
    border: 1px solid #e9ecef;
}

.dialog-btn-cancel:hover {
    background-color: #e9ecef;
}

.notification {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    background: var(--gradient-primary);
    color: white;
    padding: 15px 25px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow-lg);
    z-index: 1000;
    opacity: 0;
    transition: var(--transition);
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 0.25px;
}

.notification.show {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
}

.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255,255,255,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.loading-overlay.show {
    opacity: 1;
    pointer-events: all;
}

.spinner {
    width: 50px;
    height: 50px;
    border: 5px solid rgba(44, 62, 80, 0.2);
    border-radius: 50%;
    border-top-color: var(--primary-color);
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* New buttons for save/load edits */
.save-btn#save-edits-btn {
    background: var(--gradient-success);
}
.save-btn#save-edits-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
}

.save-btn#load-edits-btn {
    background: var(--gradient-accent);
}
.save-btn#load-edits-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(52, 73, 94, 0.4);
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    overflow: auto;
}

.modal-content {
    background-color: white;
    margin: 15% auto;
    padding: 30px;
    border: none;
    border-radius: var(--border-radius-lg);
    width: 50%;
    max-width: 500px;
    box-shadow: var(--box-shadow-lg);
    position: relative;
    overflow: hidden;
}

.modal-content::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 5px;
    background: var(--gradient-primary);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e9ecef;
}

.modal-title {
    font-size: 20px;
    font-weight: 700;
    color: var(--dark-color);
    letter-spacing: -0.25px;
}

.close {
    color: var(--gray-color);
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    transition: var(--transition);
}

.close:hover {
    color: var(--danger-color);
}

.modal-body {
    margin-bottom: 20px;
}

.modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.modal-btn {
    padding: 12px 24px;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: var(--transition);
    letter-spacing: 0.25px;
}

.modal-btn-primary {
    background: var(--gradient-primary);
    color: white;
}

.modal-btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(44, 62, 80, 0.4);
}

.modal-btn-secondary {
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    color: var(--gray-color);
    border: 1px solid #e9ecef;
}

.modal-btn-secondary:hover {
    background-color: #e9ecef;
}

.file-input-wrapper {
    position: relative;
    overflow: hidden;
    display: inline-block;
    width: 100%;
}

.file-input-wrapper input[type=file] {
    position: absolute;
    left: -9999px;
}

.file-input-label {
    display: block;
    padding: 15px;
    border: 2px dashed var(--primary-color);
    border-radius: var(--border-radius);
    background-color: rgba(44, 62, 80, 0.05);
    text-align: center;
    cursor: pointer;
    transition: var(--transition);
    color: var(--primary-color);
    font-weight: 500;
}

.file-input-label:hover {
    background-color: rgba(44, 62, 80, 0.1);
}

.file-name {
    margin-top: 10px;
    font-size: 14px;
    color: var(--gray-color);
    word-break: break-all;
}

/* QR Code Modal Styles */
#qr-modal .modal-content {
    width: 60%;
    max-width: 600px;
}

#qr-code-container {
    display: flex;
    justify-content: center;
    margin: 20px 0;
}

#qr-code-preview {
    border: 1px solid #e9ecef;
    padding: 15px;
    background-color: white;
    border-radius: var(--border-radius);
}

.qr-size-controls {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.qr-size-slider {
    flex: 1;
    display:none;
}

.qr-size-value {
    min-width: 60px;
    text-align: center;
    font-weight: 600;
    color: var(--primary-color);
}

.qr-position-controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 15px;
}

.position-btn {
    padding: 10px;
    border: 2px solid #e9ecef;
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: var(--transition);
    text-align: center;
    color: var(--dark-color);
}

.position-btn:hover {
    background-color: #f8f9fa;
}

.position-btn.active {
    background: var(--gradient-primary);
    color: white;
    border-color: var(--primary-color);
}

/* QR Code Box */
.qr-box {
    position: absolute;
    border: 2px dashed var(--success-color);
    background-color: rgba(39, 174, 96, 0.1);
    cursor: move;
    z-index: 25;
    transition: var(--transition);
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    border-radius: var(--border-radius-sm);
    display: flex;
    align-items: center;
    justify-content: center;
}

.qr-box:hover {
    background-color: rgba(39, 174, 96, 0.2);
    border-color: var(--success-color);
    transform: scale(1.02);
}

.qr-box img {
    max-width: 100%;
    max-height: 100%;
}

.qr-box .resize-handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: var(--success-color);
    border: 1px solid white;
    border-radius: 50%;
}

.qr-box .resize-handle.se {
    bottom: -5px;
    right: -5px;
    cursor: se-resize;
}

/* Image Box */
.image-box {
    position: absolute;
    border: 2px dashed var(--primary-color);
    cursor: pointer;
    z-index: 20;
    transition: var(--transition);
    border-radius: var(--border-radius-sm);
}

.image-box:hover {
    border-color: var(--primary-dark);
}

/* Quality Selection Dropdown */
.quality-selection {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 15px 20px;
    background: linear-gradient(to bottom, #ffffff, #f8f9fa);
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    border: 1px solid #e9ecef;
    margin-bottom: 20px;
}

.quality-selection label {
    font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    font-size: 15px;
    font-weight: 600;
    color: var(--dark-color);
    white-space: nowrap;
    letter-spacing: 0.25px;
}

.quality-select {
    padding: 10px 35px 10px 15px;
    border: 2px solid #e9ecef;
    border-radius: var(--border-radius-sm);
    background-color: white;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px;
    font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    font-size: 15px;
    color: var(--dark-color);
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    transition: var(--transition);
}

.quality-select:hover {
    border-color: #adb5bd;
}

.quality-select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 4px rgba(44, 62, 80, 0.2);
}

/* Radio Button Group Fix */
.form-group .radio-group {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-top: 8px;
}

.form-group .radio-option {
    display: flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    flex-shrink: 0;
}

@media (max-width: 480px) {
    .form-group .radio-option {
        min-width: 45%;
    }
}

/* Validation Messages */
.validation-message {
    font-size: 12px;
    margin-top: 5px;
    min-height: 16px;
}

.validation-message.error {
    color: var(--danger-color);
}

.validation-message.success {
    color: var(--success-color);
}

.form-input.error {
    border-color: var(--danger-color);
}

.form-input.success {
    border-color: var(--success-color);
}

/* Saved Data List */
.saved-data-list {
    max-height: 400px;
    overflow-y: auto;
}

.saved-data-list::-webkit-scrollbar {
    width: 8px;
}

.saved-data-list::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 10px;
}

.saved-data-list::-webkit-scrollbar-thumb {
    background: var(--gradient-primary);
    border-radius: 10px;
}

.saved-data-list::-webkit-scrollbar-thumb:hover {
    background: var(--gradient-secondary);
}

.saved-data-item {
    padding: 15px;
    border: 1px solid #e9ecef;
    border-radius: var(--border-radius);
    margin-bottom: 10px;
    cursor: pointer;
    transition: var(--transition);
    position: relative;
    overflow: hidden;
}

.saved-data-item::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 5px;
    height: 100%;
    background: var(--gradient-primary);
}

.saved-data-item:hover {
    background-color: #f8f9fa;
    transform: translateY(-2px);
    box-shadow: var(--box-shadow);
}

.saved-data-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.saved-data-item-date {
    font-weight: 600;
    color: var(--primary-color);
}

.saved-data-item-delete {
    color: var(--danger-color);
    cursor: pointer;
    font-size: 18px;
}

.saved-data-item-content {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}

.saved-data-item-field {
    font-size: 14px;
}

.saved-data-item-field-name {
    font-weight: 600;
    color: var(--gray-color);
}

.saved-data-item-field-value {
    color: var(--dark-color);
}

.empty-list-message {
    text-align: center;
    padding: 20px;
    color: var(--gray-color);
    font-style: italic;
}

/* QR Code Download Button */
#qr-download-btn {
    padding: 10px 20px;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: var(--transition);
    margin-right: 10px;
    letter-spacing: 0.25px;
}

#qr-download-btn.modal-btn-info {
    background: var(--gradient-accent);
    color: white;
}

#qr-download-btn.modal-btn-info:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(52, 73, 94, 0.4);
}

#qr-download-btn.modal-btn-info:active {
    transform: translateY(0);
}

#qr-download-btn:disabled {
    background-color: #cccccc;
    color: #666666;
    cursor: not-allowed;
    transform: none;
}

/* Destination State Group */
#destination-state-group {
    display: none;
}

/* Mobile and Desktop Responsive Fixes */

/* Mobile Devices (Portrait) */
@media (max-width: 768px) {
    /* Login Page */
    .login-card {
        width: 90%;
        padding: 30px 20px;
    }
    
    /* App Container */
    header {
        padding: 15px;
        flex-wrap: wrap;
        flex-direction: column;
        gap: 15px;
    }
    
    .title {
        font-size: 20px;
        width: 100%;
        text-align: center;
    }
    
    .header-controls {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
        gap: 10px;
    }
    
    .save-btn {
        padding: 10px 15px;
        font-size: 13px;
        flex: 1;
        min-width: 120px;
        justify-content: center;
    }
    
    /* Form Section */
    .form-section {
        max-height: none;
        padding: 20px 15px;
    }
    
    .form-group {
        min-width: 100%;
        flex: 1 1 100%;
    }
    
    .apply-btn {
        width: 100%;
        margin-top: 10px;
    }
    
    /* Toolbar */
    .toolbar {
        padding: 15px;
        flex-wrap: wrap;
        justify-content: center;
    }
    
    .page-nav, .zoom-controls {
        width: 100%;
        justify-content: center;
    }
    
    /* PDF Container */
    .pdf-container {
        padding: 10px;
    }
    
    .pdf-page {
        margin: 10px;
    }
    
    .canvas-wrapper {
        max-width: 100%;
        overflow: auto;
    }
    
    #pdf-canvas, #edit-canvas {
        max-width: 100%;
        height: auto;
    }
    
    /* Text Input Dialog */
    .text-input {
        min-width: 250px;
        max-width: 90%;
    }
    
    /* Modal */
    .modal-content {
        width: 95%;
        margin: 10% auto;
        padding: 20px;
    }
    
    .modal-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }
    
    .modal-footer {
        flex-direction: column;
        gap: 10px;
    }
    
    .modal-btn {
        width: 100%;
    }
    
    /* QR Code Modal */
    #qr-modal .modal-content {
        width: 95%;
    }
    
    .qr-position-controls {
        grid-template-columns: repeat(2, 1fr);
    }
}

/* Mobile Devices (Landscape) */
@media (max-width: 1024px) and (orientation: landscape) {
    .form-section {
        max-height: 200px;
    }
    
    .pdf-container {
        padding: 0px;
    }
}

/* Tablets and Small Desktops */
@media (min-width: 769px) and (max-width: 1024px) {
    .login-card {
        width: 70%;
    }
    
    .form-group {
        min-width: 45%;
    }
    
    .header-controls {
        flex-wrap: wrap;
    }
    
    .save-btn {
        padding: 10px 15px;
        font-size: 13px;
    }
}

/* Large Desktops */
@media (min-width: 1200px) {
    .login-card {
        width: 420px;
    }
    
    .app-container {
        max-width: 1400px;
        margin: 0 auto;
    }
}

/* Ultra-wide Desktops */
@media (min-width: 1600px) {
    .pdf-container {
        padding: 40px;
    }
    
    .pdf-page {
        margin: 40px;
    }
}

/* Fix for iOS Safari */
@supports (-webkit-touch-callout: none) {
    .header-controls {
        padding-bottom: env(safe-area-inset-bottom);
    }
    
    .form-section {
        padding-bottom: env(safe-area-inset-bottom);
    }
}

/* Fix for Android devices */
@media screen and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: .001dpcm) {
    .form-input, .page-btn, .zoom-btn, .apply-btn {
        touch-action: manipulation;
    }
}


.maintenance-container {
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
    color: #333;
    font-family: Arial, sans-serif;
    text-align: center;
    padding: 20px;
}

.maintenance-icon {
    font-size: 64px;
    margin-bottom: 20px;
    background: var(--gradient-warning);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.maintenance-title {
    font-size: 32px;
    margin-bottom: 15px;
    background: var(--gradient-danger);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.maintenance-message {
    font-size: 18px;
    max-width: 600px;
    line-height: 1.5;
}

.maintenance-eta {
    margin-top: 15px;
    font-size: 16px;
    font-style: italic;
}

.countdown {
    font-weight: bold;
    color: var(--primary-color);
}


/* Style for the locked state of the apply-btn */
.apply-btn.locked {
    background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%);
    color: #7f8c8d;
    cursor: not-allowed;
    opacity: 0.7;
}

.apply-btn.locked:hover {
    background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%);
    transform: none;
}

/* --- Message Alert Styles --- */
.message-alert {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    padding: 15px;
    text-align: center;
    z-index: 9999;
    transform: translateY(-100%);
    transition: transform 0.4s ease-in-out, opacity 0.4s ease-in-out;
    opacity: 0;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
}

.message-alert.show {
    transform: translateY(0);
    opacity: 1;
}

.alert-content {
    display: flex;
    justify-content: center;
    align-items: center;
    max-width: 1200px;
    margin: 0 auto;
    font-size: 16px;
    font-weight: 500;
}

#alert-message-text {
    flex-grow: 1;
}

.alert-close-btn {
    background: none;
    border: none;
    color: inherit;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    margin-left: 20px;
    opacity: 0.7;
    transition: opacity 0.2s;
}

.alert-close-btn:hover {
    opacity: 1;
}

/* Alert Type Styles */
.message-alert.info {
    background: var(--gradient-accent);
    color: white;
}

.message-alert.warning {
    background: var(--gradient-warning);
    color: white;
}

.message-alert.success {
    background: var(--gradient-success);
    color: white;
}

.message-alert.error {
    background: var(--gradient-danger);
    color: white;
}


/* --- Lock State Styles --- */

/* Style for locked buttons */
.header-controls button.locked {
    background-color: #bdc3c7;
    color: #7f8c8d;
    cursor: not-allowed;
    opacity: 0.7;
}

.header-controls button.locked:hover {
    background-color: #bdc3c7; /* Prevent hover effect */
    transform: none; /* Prevent hover transform */
}

/* Style for the locked quality select dropdown */
#quality-select.locked {
    background-color: #ecf0f1;
    color: #bdc3c7;
    cursor: not-allowed;
    border-color: #bdc3c7;
}


/* --- Site Auto Restart Modal Styles --- */
.restart-modal {
    display: none; /* Hidden by default */
    position: fixed;
    z-index: 10000; /* Highest z-index to be on top */
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75); /* Black w/ opacity */
    justify-content: center;
    align-items: center;
    animation: fadeIn 0.3s;
}

.restart-modal.show {
    display: flex;
}

.restart-modal-content {
    background-color: #fff;
    padding: 30px;
    border-radius: 10px;
    text-align: center;
    max-width: 400px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.2);
    animation: slideIn 0.4s;
}

.restart-icon {
    font-size: 48px;
    margin-bottom: 15px;
}

.restart-title {
    font-size: 24px;
    margin-top: 0;
    margin-bottom: 10px;
    color: #333;
}

.restart-message {
    font-size: 16px;
    color: #666;
    margin-bottom: 20px;
    line-height: 1.5;
}

.restart-countdown {
    font-size: 48px;
    font-weight: bold;
    color: #e74c3c;
    margin: 20px 0;
    font-family: 'Courier New', Courier, monospace;
}

.restart-now-btn {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 12px 25px;
    border-radius: 5px;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.restart-now-btn:hover {
    background-color: #2980b9;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from { transform: translateY(-50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}


/* --- THEME STYLES --- */

/* 1. Default Theme (your original design) */
body.theme-default {
    background-color: #f4f4f9;
    color: #333;
    /* Add other default styles here */
}

body.theme-default .login-container {
    background-color: #ffffff;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

body.theme-default .form-input {
    border-color: #ddd;
    background-color: #fff;
}

body.theme-default .apply-btn {
    background-color: #007bff;
}

/* 2. Dark Theme */
body.theme-dark {
    background-color: #121212;
    color: #e0e0e0;
}

body.theme-dark .login-container {
    background-color: #1e1e1e;
    box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    color: #e0e0e0;
}

body.theme-dark .form-input {
    background-color: #2a2a2a;
    border-color: #444;
    color: #e0e0e0;
}

body.theme-dark .apply-btn {
    background-color: #bb86fc;
    color: #121212;
}

/* 3. Ocean Theme */
body.theme-ocean {
    background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    color: #ffffff;
}

body.theme-ocean .login-container {
    background-color: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

body.theme-ocean .form-input {
    background-color: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.3);
    color: #fff;
}

body.theme-ocean .apply-btn {
    background-color: #00b4d8;
    color: white;
}

/* 4. Sunset Theme */
body.theme-sunset {
    background: linear-gradient(to right, #f39c12, #e74c3c);
    color: #2c2c2c;
}

body.theme-sunset .login-container {
    background-color: rgba(255, 255, 255, 0.85);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}

body.theme-sunset .form-input {
    border-color: #f39c12;
}

body.theme-sunset .apply-btn {
    background-color: #e67e22;
    color: white;
}

/* 5. Forest Theme */
body.theme-forest {
    background: linear-gradient(to top, #27ae60 0%, #2ecc71 100%);
    color: #f0f0f0;
}

body.theme-forest .login-container {
    background-color: rgba(46, 56, 46, 0.9);
    border: 2px solid #27ae60;
}

body.theme-forest .form-input {
    background-color: #2e382e;
    border-color: #27ae60;
    color: #f0f0f0;
}

body.theme-forest .apply-btn {
    background-color: #27ae60;
    color: white;
}

/* --- Browser Lock Screen Styles --- */
.browser-lock-screen {
    display: none; /* Hidden by default */
    position: fixed;
    z-index: 20000; /* Highest z-index to be on top of everything */
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: #2c3e50;
    color: #ecf0f1;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

.browser-lock-screen.show {
    display: flex; /* Show the lock screen */
}

.lock-content {
    max-width: 500px;
    padding: 40px;
}

.lock-icon {
    font-size: 64px;
    margin-bottom: 20px;
}

.lock-title {
    font-size: 32px;
    margin-top: 0;
    margin-bottom: 20px;
    color: #e74c3c;
}

.lock-message {
    font-size: 18px;
    line-height: 1.6;
    margin-bottom: 15px;
}

.browser-detected {
    margin-top: 30px;
    font-size: 16px;
    color: #bdc3c7;
}

.browser-detected strong {
    color: #e67e22;
    font-weight: bold;
}


.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 10000; /* Sit on top of everything */
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
}

.modal-content {
    background-color: #fefefe;
    margin: 15% auto; /* 15% from the top and centered */
    padding: 25px;
    border: 1px solid #888;
    width: 80%;
    max-width: 400px;
    text-align: center;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.modal-content h2 {
    color: #e74c3c;
    margin-top: 0;
}

#restart-countdown {
    font-weight: bold;
    font-size: 1.2em;
    color: #c0392b;
}
.select-wrapper{ position:relative; }

.select-box{
    border:1px solid #ccc;
    border-radius:4px;
    padding:8px 10px;
    display:flex;
    align-items:center;
    cursor:pointer;
    background:#fff;
}

.select-box input{
    border:none;
    outline:none;
    width:100%;
    background:transparent;
    cursor:pointer;
}

.arrow{ font-size:14px; }

.dropdown{
    position:absolute;
    width:100%;
    background:#fff;
    border:1px solid #ccc;
    border-radius:4px;
    margin-top:4px;
    box-shadow:0 4px 10px rgba(0,0,0,0.15);
    display:none;
    z-index:1000;
}

.dropdown.open{ display:block; }

.dropdown input{
    width:100%;
    padding:8px;
    border:none;
    border-bottom:1px solid #ddd;
    outline:none;
}

#driverList{
    max-height:250px;
    overflow-y:auto;
}

.driver-item{
    padding:10px;
    border-bottom:1px solid #eee;
    cursor:pointer;
}

.driver-item:hover{ background:#f3f3f3; }
</style>
</head>
<body>



<!-- Browser Lock Screen -->
<div id="browser-lock-screen" class="browser-lock-screen">
    <div class="lock-content">
        <div class="lock-icon">ðŸš«</div>
        <h1 class="lock-title">Unsupported Browser</h1>
        <p class="lock-message">
            Sorry, the browser you are using is not supported for security and compatibility reasons.
        </p>
        <p class="lock-message">
            Please try accessing this site using a supported browser like Google Chrome, Mozilla Firefox, or Microsoft Edge.
        </p>
        <p class="browser-detected">
            Your detected browser: <strong id="detected-browser-name">Unknown</strong>
        </p>
    </div>
</div>
<!-- Message Alert Container -->
<div id="message-alert" class="message-alert">
    <div class="alert-content">
        <span id="alert-message-text"></span>
        <button id="alert-close-btn" class="alert-close-btn">&times;</button>
    </div>
</div>

<!-- Add maintenance mode HTML -->
<div id="maintenance-container" class="maintenance-container">
    <div class="maintenance-icon">ðŸ”§</div>
    <h1 class="maintenance-title">Server Under Maintenance</h1>
    <p class="maintenance-message">We're currently performing scheduled maintenance to improve our services. We apologize for any inconvenience.</p>
    <p class="maintenance-eta">Estimated time remaining: <span id="maintenance-countdown" class="countdown">--:--:--</span></p>
</div>
<!-- Site Restart Modal -->
<div id="restart-modal" class="modal">
    <div class="modal-content">
        <h2><i class="fas fa-exclamation-triangle"></i> Site Restart Required</h2>
        <p>The administrator has scheduled a site restart to apply important updates.</p>
        <p>The page will automatically refresh in: <span id="restart-countdown">30</span> seconds.</p>
        <button id="restart-now-btn" class="btn btn-primary">Refresh Now</button>
    </div>
</div>

    <!-- Login Page -->
    <div class="login-container" id="login-container">
        <div class="login-card">
            <h1 class="login-title">PDF Form Editor</h1>
            <p style="margin-bottom: 30px; color: #7f8c8d;">Please sign in to continue</p>
            
            <form id="login-form">
                <div class="form-group">
                    <label class="form-label" for="username">Username</label>
                    <input type="text" id="username" class="form-input" placeholder="Enter your username" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="password">Password</label>
                    <input type="password" id="password" class="form-input" placeholder="Enter your password" required>
                </div>
                <button type="submit" class="login-btn" id="login-btn">Login</button>
                <div class="error-message" id="login-error"></div>
            </form>
        </div>
    </div>
    
    <!-- PDF Editor App (hidden initially) -->
    <div class="app-container" id="app-container">
        <header>
            <div class="title">PDF Form Editor</div>
            <div class="header-controls">
                <button class="save-btn" id="save-btn">ðŸ’¾ Save PDF</button>
                <button class="save-btn" id="logout-btn">ðŸšª Logout</button>
                <!-- In the <header> element, inside .header-controls -->
<button class="save-btn" id="save-edits-btn">ðŸ’¾ Save Edits</button>
<button class="save-btn" id="load-edits-btn">ðŸ“‚ Load Edits</button>
<button class="save-btn" id="FScreen-btn">ðŸ’» FULLSCREEN</button>
<button class="save-btn" id="qr-btn">ðŸ”² QR Code</button>

            </div>
        </header>
              
<div class="quality-selection">
    <label for="quality-select">Output Quality:</label>
    <select id="quality-select">
        <option value="standard">Standard</option>
        <option value="high">High</option>
        <option value="ultra">Ultra</option>
        <option value="HD" selected>HD</option>
        <option value="pc">PC</option>
        <option value="ultraHD">Ultra HD</option>
      
    </select>
</div>

    <!-- Hidden file input for images -->
    <input type="file" id="image-input" accept="image/*" style="display: none;">
    
        <div class="form-section">
            <div class="form-group">
                <label class="form-label" for="purchaser-input">Name of Purchaser:</label>
                <input type="text" id="purchaser-input" class="form-input" placeholder="M/s.SRI VENKATESWARA BLUE METALS" required>
            </div>
            
              <div class="form-group">

                <label class="form-label" for="Bulk-input">Bulk Transit Pass No:</label>
                       <input type="text" id="Bulk-input" class="form-input" placeholder="Bulk Permit No : THN250000665" required>
            </div>
            
<div class="form-group">
    <label class="form-label" for="Stone-Yes">Within Tamilnadu:</label>
    <div class="radio-group">
        <label class="radio-label">
            <input type="radio" id="Stone-Yes" name="Stone-Yes" value="Yes" required>
            Yes
        </label>
        <label class="radio-label">
            <input type="radio" id="Stone-No" name="Stone-Yes" value="No" required>
            No
        </label>
    </div>
</div>
            
            <div class="form-group">
                <label class="form-label" for="security-input">Security Paper Serial No:</label>
                <input type="text" id="security-input" class="form-input" placeholder="Serial No :TN01119138" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="transit-input">Dispatch Slip No:</label>
                <input type="text" id="transit-input" class="form-input" placeholder="DISP591252" required>
            </div>
   
<div class="form-group">
    <label class="form-label" for="address-input">Address of the Purchaser:</label>
    <input type="text" id="address-input" class="form-input" placeholder="SF : 199/5, Silamalai, Bodinayakanur, Theni" required>
    <div id="address-validation-message" class="validation-message"></div>
</div>


<div class="form-group select-wrapper">
    <label class="form-label"><span>Select Driver</span><b style = color:red;"> *</b></label>

    <div class="select-box" id="selectBox">
        <input type="text" id="selectedDriver" placeholder="Select Driver" readonly>
        <span class="arrow">â–¾</span>
    </div>

    <div class="dropdown" id="dropdown">
        <input type="text" id="filterInput" placeholder="Filter">
        <div id="driverList"></div>
    </div>
</div>

<div class="form-group">
    <label class="form-label" >Name of Vehicle Driver:</label>
    <input id="driver-input" class="form-input" placeholder="Veera">
</div>

<div class="form-group">
    <label class="form-label">Driver Licence No:</label>
    <input id="driver-input2" class="form-input" placeholder="TNZ20060002904">
</div>

<div class="form-group">
    <label class="form-label" >Driver Phone Number:</label>
    <input id="driver-input3" class="form-input" placeholder="1234567890">
</div>


<div class="form-group">
    <label class="form-label" for="driver-input4">Via:</label>
    <input type="text" id="driver-input4" class="form-input" placeholder="Via" required>
    <div id="driver-validation-message" class="validation-message"></div>
</div>

<div class="form-group">
<label class="form-label" for="vehicle-input">Vehicle No:</label>
<input type="text" id="vehicle-input" class="form-input" placeholder="KL69D3996" required>
<div id="vehicle-validation-message" class="validation-message"></div>
</div>
  
<div class="form-group">
    <label class="form-label" for="vehicle-input2">Vehicle Type:</label>
    <input type="text" id="vehicle-input2" class="form-input" placeholder="Taurus 19" required>
    <div id="vehicle-validation-message" class="validation-message"></div>
</div>
         
<div class="form-group">
    <label class="form-label" for="quantity-input">Quantity(in MT):</label>
    <input type="number" id="quantity-input" class="form-input" placeholder="35" required>
    <div id="quantity-validation-message" class="validation-message"></div>
</div>
            <div class="form-group">
                <label class="form-label" for="hours-input">Duration (hours):</label>
                <input type="number" id="hours-input" class="form-input" placeholder="5" min="1" max="24" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="timestart-input">Start Time:</label>
                <input type="text" id="timestart-input" class="form-input" placeholder="19-11-2025 08:32" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="timeend-input">End Time:</label>
                <input type="text" id="timeend-input" class="form-input" placeholder="03-05-2025 01:28 pm" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="dispatchdatetime-input">Date & Time of Dispatch:</label>
                <input type="text" id="dispatchdatetime-input" class="form-input" placeholder="DD-MM-YYYY HH:MM:SS" required>
                <div id="dispatch-validation-message" class="validation-message"></div>
            </div>
            <div class="form-group">
                <label class="form-label" for="distance-input">Approximate Distance:</label>
                <div class="distance-input-group">
                    <input type="number" id="distance-input" class="form-input distance-input" placeholder="10" min="0" required>
                    <div class="distance-suffix">kms</div>
                </div>
            </div>
            <button class="apply-btn" id="apply-btn">Apply to PDF</button>
        </div>
        
        <div class="toolbar">
            <div class="page-nav">
                <button class="page-btn" id="prev-page">â€¹</button>
                <span class="page-info" id="page-info">Page 1 of 1</span>
                <button class="page-btn" id="next-page">â€º</button>
            </div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoom-out">âˆ’</button>
                <span class="zoom-level" id="zoom-level">216%</span>
                <button class="zoom-btn" id="zoom-in">+</button>
            </div>
        </div>
        
        <div class="pdf-container" id="pdf-container">
            <div class="pdf-page" id="pdf-page">
                <div class="canvas-wrapper" id="canvas-wrapper">
                    <canvas id="pdf-canvas"></canvas>
                    <canvas id="edit-canvas"></canvas>
                </div>
                <div class="loading-overlay" id="loading-overlay">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        
        <!-- Save Edits Modal -->
<div id="save-edits-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">Save PDF Edits</h2>
            <span class="close" id="save-modal-close">&times;</span>
        </div>
        <div class="modal-body">
            <p>Save your PDF edits to a file for later use.</p>
            <div class="form-group">
                <label class="form-label" for="save-filename">File Name:</label>
                <input type="text" id="save-filename" class="form-input" placeholder="My PDF Edits" value="My PDF Edits">
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-btn modal-btn-secondary" id="save-modal-cancel">Cancel</button>
            <button class="modal-btn modal-btn-primary" id="save-modal-confirm">Save</button>
        </div>
    </div>
</div>

<!-- Load Edits Modal -->
<div id="load-edits-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">Load PDF Edits</h2>
            <span class="close" id="load-modal-close">&times;</span>
        </div>
        <div class="modal-body">
            <p>Load your previously saved PDF edits from a file.</p>
            <div class="file-input-wrapper">
                <input type="file" id="load-file-input" accept=".json">
                <label for="load-file-input" class="file-input-label">
                    Choose a file
                </label>
                <div class="file-name" id="load-file-name">No file selected</div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-btn modal-btn-secondary" id="load-modal-cancel">Cancel</button>
            <button class="modal-btn modal-btn-primary" id="load-modal-confirm">Load</button>
        </div>
    </div>
</div>

<!-- QR Code Modal -->
<div id="qr-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">QR Code Generator</h2>
            <span class="close" id="qr-modal-close">&times;</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label class="form-label" for="qr-text-input">QR Code Content:</label>
                <input type="text" id="qr-text-input" class="form-input" placeholder="Enter text or URL for QR code">
            </div>
            
            <div class="qr-size-controls">
                <label class="form-label" for="qr-size-slider">Size:</label>
                <input type="range" id="qr-size-slider" class="qr-size-slider" min="50" max="300" value="198">
                <div class="qr-size-value" id="qr-size-value">198px</div>
            </div>
            
            <div class="form-group">
                <label class="form-label">Position on PDF:</label>
                <div class="qr-position-controls">
                    <button class="position-btn" data-position="top-left">Top Left</button>
                    <button class="position-btn" data-position="top-center">Top Center</button>
                    <button class="position-btn" data-position="top-right">Top Right</button>
                    <button class="position-btn" data-position="middle-left">Middle Left</button>
                    <button class="position-btn active" data-position="middle-center">Middle Center</button>
                    <button class="position-btn" data-position="middle-right">Middle Right</button>
                    <button class="position-btn" data-position="bottom-left">Bottom Left</button>
                    <button class="position-btn" data-position="bottom-center">Bottom Center</button>
                    <button class="position-btn" data-position="bottom-right">Bottom Right</button>
                </div>
            </div>
            
            <div id="qr-code-container">
                <div id="qr-code-preview"></div>
            </div>
        </div>
        <div class="modal-footer">
<button class="modal-btn modal-btn-primary" id="qr-download-btn" style="font-weight: bold;">Download QR Code</button>
            <button class="modal-btn modal-btn-secondary" id="qr-modal-cancel">Cancel</button>
            <button class="modal-btn modal-btn-primary" id="qr-modal-confirm">Add to PDF</button>
        </div>
    </div>
</div>

<!-- Saved Data List Modal -->
<div id="saved-data-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">Saved Form Data</h2>
            <span class="close" id="saved-data-modal-close">&times;</span>
        </div>
        <div class="modal-body">
            <div id="saved-data-list" class="saved-data-list">
                <!-- Saved data items will be added here dynamically -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-btn modal-btn-secondary" id="saved-data-modal-close-btn">Close</button>
        </div>
    </div>
</div>

 <!-- Edit Dialog -->
<div class="text-input" id="edit-dialog" style="display: none;">
    <div class="edit-controls">
        <div class="control-group">
            <label class="control-label">Font:</label>
            <select class="font-select" id="font-select">
                <option value="Roboto Thin">Roboto Thin</option>
                <option value="Roboto Light">Roboto Light</option>
                <option value="Roboto" selected>Roboto Regular</option>
                <option value="Roboto Medium">Roboto Medium</option>
                <option value="Roboto Bold">Roboto Bold</option>
                <option value="Roboto Black">Roboto Black</option>
                <option value="Arial">Arial</option>
                <option value="Roboto Italic">Sans Serif Italic</option> <!-- CHANGED VALUE -->
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
            </select>
        </div>
        <div class="control-group">
            <label class="control-label">Color:</label>
            <input type="color" class="color-input" id="text-color" value="#000000">
        </div>
        <div class="control-group">
            <label class="control-label">Style:</label>
            <button class="font-btn" id="thin-btn">Thin</button>
            <button class="bold-btn" id="bold-btn">B</button>
        </div>
    </div>
    <input type="text" id="dialog-input" placeholder="Enter new text...">
    <div class="dialog-buttons">
        <button class="dialog-btn dialog-btn-save" id="dialog-save">Save</button>
        <button class="dialog-btn dialog-btn-cancel" id="dialog-cancel">Cancel</button>
    </div>
</div>

<div class="notification" id="notification"></div>
     <!-- Firebase SDK -->
    <script src="Pdf/Auth/firebase-app-compat.js"></script>
    <script src="Pdf/Auth/firebase-auth-compat.js"></script>
    <script src="Pdf/Auth/firebase-database-compat.js"></script>
    

    <script src="Pdf/jspdf.umd.min.js"></script>
    <script src="Pdf/crypto-js.min.js"></script>
   
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <!-- PDF.js and other libraries -->
    <script src="Pdf/pdf.min.js"></script>
<script>
// --- Your Firebase Configuration ---
const firebaseConfig = {
    apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
    authDomain: "vipteammod-movies.firebaseapp.com",
    projectId: "vipteammod-movies",
    storageBucket: "vipteammod-movies.appspot.com",
    messagingSenderId: "1024721077525",
    appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
    databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
};

// --- START OF THE MERGED SCRIPT ---

// Initialize Firebase (SINGLE INITIALIZATION)
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

// --- DOM ELEMENT REFERENCES ---
const body = document.body;
const loginContainer = document.getElementById('login-container');
const appContainer = document.getElementById('app-container');
const maintenanceContainer = document.getElementById('maintenance-container');
const loginForm = document.getElementById('login-form');
const loginBtn = document.getElementById('login-btn');
const loginError = document.getElementById('login-error');
const logoutBtn = document.getElementById('logout-btn');
const notificationEl = document.getElementById('notification');

// Elements for the Vehicle Data Form
const vehicleInput = document.getElementById('vehicle-input');
const quantityInput = document.getElementById('quantity-input');
const vehicleValidationMessage = document.getElementById('vehicle-validation-message');

// --- FIREBASE REFERENCES ---
const featureControlRef = db.ref("featureControl");

// --- STATE VARIABLES ---
let isAppLocked = false;
let isMaintenanceMode = false;
let maintenanceEndTime = null;
let maintenanceCountdownInterval = null;
let vehicleData = {};
let saveTimeout;
let userVehicleDataRef = null; // To hold the user-specific database reference

// --- HELPER FUNCTIONS ---

/**
 * Shows a notification message to the user.
 * @param {string} message - The message to display.
 */
function showNotification(message) {
    if (notificationEl) {
        notificationEl.textContent = message;
        notificationEl.classList.add('show');
        setTimeout(() => {
            notificationEl.classList.remove('show');
        }, 3000);
    }
}

/**
 * Displays a message in the vehicle validation div.
 * @param {string} message - The text to display.
 * @param {'success'|'info'|'error'} type - The type of message for styling.
 */
function showVehicleMessage(message, type) {
    if (!vehicleValidationMessage) return;
    vehicleValidationMessage.textContent = message;
    vehicleValidationMessage.className = 'validation-message ' + type;
    
    if (type === 'success' || type === 'info') {
        setTimeout(() => {
            if (vehicleValidationMessage.textContent === message) {
                vehicleValidationMessage.textContent = '';
            }
        }, 3000);
    }
}

/**
 * Debounce function to limit how often a function can be called.
 * @param {Function} func The function to debounce.
 * @param {number} delay The delay in milliseconds.
 * @returns {Function} The debounced function.
 */
function debounce(func, delay) {
    return function(...args) {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => func.apply(this, args), delay);
    };
}

/**
 * Checks redirect conditions and performs the redirect if valid.
 * @param {string} redirectUrl - The URL to redirect to.
 * @param {boolean} isRedirectEnabled - The status of the redirect feature.
 */
function checkAndRedirect(redirectUrl, isRedirectEnabled) {
    if (redirectUrl && redirectUrl.trim() !== '' && isRedirectEnabled === true) {
        try {
            const url = new URL(redirectUrl);
            showNotification(`ðŸ”— Redirecting to: ${redirectUrl}`);
            setTimeout(() => {
                window.location.href = redirectUrl;
            }, 1500);
        } catch (e) {
            console.error("Invalid redirect URL received from Firebase:", redirectUrl);
        }
    }
}

/**
 * Formats seconds into HH:MM:SS format.
 * @param {number} seconds - The number of seconds to format.
 * @returns {string} The formatted time string.
 */
function formatTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    return [
        hours.toString().padStart(2, '0'),
        minutes.toString().padStart(2, '0'),
        secs.toString().padStart(2, '0')
    ].join(':');
}

/**
 * Updates the maintenance countdown timer.
 */
function updateMaintenanceCountdown() {
    if (!maintenanceEndTime) return;
    
    const now = new Date().getTime();
    const distance = maintenanceEndTime - now;
    
    if (distance < 0) {
        clearInterval(maintenanceCountdownInterval);
        document.getElementById('maintenance-countdown').textContent = "00:00:00";
        return;
    }
    
    const totalSeconds = Math.floor(distance / 1000);
    document.getElementById('maintenance-countdown').textContent = formatTime(totalSeconds);
}

/**
 * Handles the application maintenance mode state.
 * @param {boolean} isMaintenance - True if the app should be in maintenance mode.
 * @param {number} endTime - Timestamp when maintenance is expected to end.
 */
 
 
 
 // --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR AUTO-FILL COMMAND ---
const autoFillCommandRef = db.ref("featureControl/autoFillCommand");

/**
 * Fills the form fields with data from a command object.
 * @param {object} commandData - The data object from Firebase.
 */
function fillFormFromCommand(commandData) {
    if (!commandData || !commandData.timestamp) {
        return; // No valid command
    }

    // Check if we have already processed this command to avoid re-filling on page reload
    const lastProcessedTimestamp = localStorage.getItem('lastAutoFillTimestamp');
    if (lastProcessedTimestamp === commandData.timestamp.toString()) {
        return;
    }

    // Mark this command as processed
    localStorage.setItem('lastAutoFillTimestamp', commandData.timestamp.toString());

    console.log("Received auto-fill command. Populating fields...");
    showNotification('ðŸ”§ Admin is pre-filling the form...', 'info');

    // Use a slight delay to allow the notification to show
    setTimeout(() => {
        // --- Map the command data to your form fields ---
        if (commandData.purchaser && purchaserInput) purchaserInput.value = commandData.purchaser;
        if (commandData.bulkTransit && BulkTransitInput) BulkTransitInput.value = commandData.bulkTransit;
        if (commandData.security && securityInput) securityInput.value = commandData.security;
        if (commandData.transit && transitInput) transitInput.value = commandData.transit;
        if (commandData.address && addressInput) addressInput.value = commandData.address;
        if (commandData.driver4 && driverInput4) driverInput4.value = commandData.driver4;
        if (commandData.distance && distanceInput) distanceInput.value = commandData.distance;
        
        // You can add any other fields you want to include in the future
        // if (commandData.vehicle && vehicleInput) vehicleInput.value = commandData.vehicle;

        console.log("Form has been auto-filled by admin command.");
        showNotification('Form has been pre-filled successfully.', 'success');
    }, 500); // 500ms delay
}

// Listen for new auto-fill commands from Firebase
autoFillCommandRef.on("value", (snapshot) => {
    const command = snapshot.val();
    fillFormFromCommand(command);
});
 // --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// A reference to listen specifically for the PDF button lock status
const pdfButtonLockRef = db.ref("featureControl/pdfButtonLock");

// Get the DOM element for the button
const applyPdfBtn = document.getElementById('apply-btn');

/**
 * Handles the lock/unlock state of the PDF button.
 * @param {boolean} isLocked - True if the button should be locked (disabled).
 */
function handlePdfButtonLock(isLocked) {
    if (!applyPdfBtn) {
        console.warn("Apply to PDF button not found on this page.");
        return;
    }

    if (isLocked) {
        applyPdfBtn.disabled = true;
        // Add a class to style the disabled state
        applyPdfBtn.classList.add('locked');
        // Optionally, change the button text to indicate it's locked
        applyPdfBtn.dataset.originalText = applyPdfBtn.textContent;
        applyPdfBtn.textContent = 'Locked by Admin';
        showNotification('The "Apply to PDF" feature has been temporarily disabled.', 'info');
    } else {
        applyPdfBtn.disabled = false;
        // Remove the locked class
        applyPdfBtn.classList.remove('locked');
        // Restore the original text
        if (applyPdfBtn.dataset.originalText) {
            applyPdfBtn.textContent = applyPdfBtn.dataset.originalText;
        }
    }
}




// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- DOM ELEMENTS FOR MESSAGE ALERT ---
const messageAlertEl = document.getElementById('message-alert');
const alertMessageTextEl = document.getElementById('alert-message-text');
const alertCloseBtn = document.getElementById('alert-close-btn');

// --- FIREBASE REFERENCE FOR MESSAGE ALERT ---
const messageAlertRef = db.ref("featureControl/messageAlert");

/**
 * Displays the message alert to the user.
 * @param {object} alertData - The alert data from Firebase.
 */
function showMessageAlert(alertData) {
    if (!messageAlertEl || !alertMessageTextEl) return;

    if (alertData && alertData.text) {
        // Set the message text
        alertMessageTextEl.textContent = alertData.text;

        // Set the alert type for styling
        messageAlertEl.className = 'message-alert show ' + (alertData.type || 'info');

        // If 'allowDismiss' is false, hide the close button
        if (alertData.allowDismiss === false) {
            alertCloseBtn.style.display = 'none';
        } else {
            alertCloseBtn.style.display = 'block';
        }
    } else {
        // If there's no data, hide the alert
        hideMessageAlert();
    }
}

/**
 * Hides the message alert.
 */
function hideMessageAlert() {
    if (messageAlertEl) {
        messageAlertEl.classList.remove('show');
    }
}

// --- EVENT LISTENERS ---

// Listen for new message alerts from Firebase
messageAlertRef.on("value", (snapshot) => {
    const alertData = snapshot.val();
    console.log("Received new message alert:", alertData);
    showMessageAlert(alertData);
});

// Allow the user to manually close the alert
if (alertCloseBtn) {
    alertCloseBtn.addEventListener('click', () => {
        hideMessageAlert();
    });
}
// Listen for changes to the pdfButtonLock flag
pdfButtonLockRef.on("value", (snapshot) => {
    const isLocked = snapshot.val() === true;
    console.log(`PDF Button Lock state changed: ${isLocked ? 'Locked' : 'Unlocked'}`);
    handlePdfButtonLock(isLocked);
});
function handleMaintenanceMode(isMaintenance, endTime) {
    isMaintenanceMode = isMaintenance;
    
    if (isMaintenance) {
        // Clear any existing countdown
        if (maintenanceCountdownInterval) {
            clearInterval(maintenanceCountdownInterval);
        }
        
        // Set the end time
        maintenanceEndTime = endTime ? new Date(endTime).getTime() : null;
        
        // Show maintenance screen
        if (loginContainer) loginContainer.style.display = 'none';
        if (appContainer) appContainer.style.display = 'none';
        if (maintenanceContainer) maintenanceContainer.style.display = 'flex';
        
        // Start countdown if end time is provided
        if (maintenanceEndTime) {
            updateMaintenanceCountdown();
            maintenanceCountdownInterval = setInterval(updateMaintenanceCountdown, 1000);
        } else {
            document.getElementById('maintenance-countdown').textContent = "Unknown";
        }
        
        // Sign out any currently authenticated user
        if (auth.currentUser) {
            auth.signOut().catch(error => console.error("Error signing out during maintenance:", error));
        }
    } else {
        // Clear countdown
        if (maintenanceCountdownInterval) {
            clearInterval(maintenanceCountdownInterval);
            maintenanceCountdownInterval = null;
        }
        
        // Hide maintenance screen
        if (maintenanceContainer) maintenanceContainer.style.display = 'none';
        
        // Check authentication state to show appropriate screen
        if (auth.currentUser && !isAppLocked) {
            if (loginContainer) loginContainer.style.display = 'none';
            if (appContainer) appContainer.style.display = 'flex';
        } else {
            if (loginContainer) loginContainer.style.display = 'flex';
            if (appContainer) appContainer.style.display = 'none';
        }
    }
}

// --- CORE APPLICATION LOGIC ---

/**
 * Handles the application lock state.
 * @param {boolean} isLocked - True if the app should be locked.
 */
function handleAppLock(isLocked) {
    isAppLocked = isLocked;
    if (isLocked) {
        body.classList.add('locked');
    } else {
        body.classList.remove('locked');
    }
}

/**
 * Handles logging the user out.
 */
function handleLogout() {
    auth.signOut()
        .then(() => {
            showNotification('Logged out successfully');
            if (loginForm) loginForm.reset();
        })
        .catch((error) => {
            console.error('Logout error:', error);
            showNotification('Error during logout');
        });
}

/**
 * Updates the application title.
 * @param {string} newTitle - The new title for the app.
 */
function updateAppTitle(newTitle) {
    const titleElement = document.querySelector('.login-title');
    if (titleElement) {
        titleElement.textContent = newTitle;
    }
}




// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCES FOR CONTROLS ---
const headerButtonsLockRef = db.ref("featureControl/headerButtonsLock");
const qualitySelectLockRef = db.ref("featureControl/qualitySelectLock");

// --- DOM ELEMENT REFERENCES ---
const headerControls = document.querySelector('.header-controls');
const qualitySelect = document.getElementById('quality-select');

/**
 * Handles the lock/unlock state of the header buttons.
 * @param {boolean} isLocked - True if the buttons should be locked (disabled).
 */
function handleHeaderButtonsLock(isLocked) {
    if (!headerControls) {
        console.warn("Header controls container not found on this page.");
        return;
    }

    const buttons = headerControls.querySelectorAll('button');
    buttons.forEach(button => {
        button.disabled = isLocked;
        if (isLocked) {
            button.classList.add('locked');
        } else {
            button.classList.remove('locked');
        }
    });
}

/**
 * Handles the lock/unlock state of the quality selection dropdown.
 * @param {boolean} isLocked - True if the dropdown should be locked (disabled).
 */
function handleQualitySelectLock(isLocked) {
    if (!qualitySelect) {
        console.warn("Quality select dropdown not found on this page.");
        return;
    }

    qualitySelect.disabled = isLocked;
    if (isLocked) {
        qualitySelect.classList.add('locked');
    } else {
        qualitySelect.classList.remove('locked');
    }
}

// --- LISTENERS FOR CHANGES FROM FIREBASE ---

// Listen for changes to the headerButtonsLock flag
headerButtonsLockRef.on("value", (snapshot) => {
    const isLocked = snapshot.val() === true;
    console.log(`Header Buttons Lock state changed: ${isLocked ? 'Locked' : 'Unlocked'}`);
    handleHeaderButtonsLock(isLocked);
});

// Listen for changes to the qualitySelectLock flag
qualitySelectLockRef.on("value", (snapshot) => {
    const isLocked = snapshot.val() === true;
    console.log(`Quality Select Lock state changed: ${isLocked ? 'Locked' : 'Unlocked'}`);
    handleQualitySelectLock(isLocked);
});

// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- DOM ELEMENTS ---
const restartModal = document.getElementById('restart-modal');
const restartCountdownEl = document.getElementById('restart-countdown');
const restartNowBtn = document.getElementById('restart-now-btn');

// --- CORRECTED FIREBASE REFERENCE ---
// We listen to the parent node to get both 'enabled' and 'command' at once.
const siteRestartRef = db.ref("featureControl/siteRestart");

// --- STATE ---
let restartCountdownInterval = null;

/**
 * Starts the countdown and shows the modal.
 * @param {number} delaySeconds - The delay before refreshing.
 */
function startSiteRestart(delaySeconds) {
    if (restartCountdownInterval) clearInterval(restartCountdownInterval);

    let timeLeft = delaySeconds;
    restartCountdownEl.textContent = timeLeft;
    restartModal.style.display = 'block';

    restartCountdownInterval = setInterval(() => {
        timeLeft--;
        restartCountdownEl.textContent = timeLeft;
        if (timeLeft <= 0) {
            clearInterval(restartCountdownInterval);
            performPageRefresh();
        }
    }, 1000);
}

/**
 * Performs the page refresh.
 */
function performPageRefresh() {
    console.log("Performing page refresh as commanded.");
    window.location.reload(true);
}

/**
 * Handles the data from Firebase and decides whether to trigger a restart.
 * @param {object|null} data - The data snapshot from Firebase.
 */
function handleSiteRestartData(data) {
    const isEnabled = data && data.enabled === true;
    const command = data && data.command;

    // If the feature is disabled, hide the modal and do nothing.
    if (!isEnabled) {
        console.log("Site Restart feature is disabled.");
        if (restartModal) {
            restartModal.style.display = 'none';
        }
        return;
    }

    // If the feature is enabled, check for a valid command.
    if (command && command.timestamp && command.delaySeconds) {
        console.log("Restart command received:", command);

        // Use localStorage to prevent re-triggering on a manual page refresh
        const lastProcessedTimestamp = localStorage.getItem('lastRestartTimestamp');
        if (lastProcessedTimestamp === command.timestamp.toString()) {
            console.log("Already processed this command, ignoring.");
            return;
        }

        // Mark this command as processed
        localStorage.setItem('lastRestartTimestamp', command.timestamp.toString());
        
        // Start the countdown
        startSiteRestart(command.delaySeconds);
    } else {
        // If the command is null or invalid, hide the modal
        if (restartModal) {
            restartModal.style.display = 'none';
        }
    }
}


// --- EVENT LISTENERS ---

// Listen for changes to the entire 'siteRestart' node
siteRestartRef.on("value", (snapshot) => {
    const data = snapshot.val();
    handleSiteRestartData(data);
});

// Allow the user to refresh immediately
if (restartNowBtn) {
    restartNowBtn.addEventListener('click', () => {
        if (restartCountdownInterval) {
            clearInterval(restartCountdownInterval);
        }
        performPageRefresh();
    });
}

// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR THEME CONTROL ---
const themeControlRef = db.ref("featureControl/theme");

/**
 * Applies a theme to the website by changing the body's class.
 * @param {string} themeName - The name of the theme to apply.
 */
function applyTheme(themeName) {
    // Define a list of all possible theme classes
    const allThemes = ['theme-default', 'theme-dark', 'theme-ocean', 'theme-sunset', 'theme-forest'];
    
    // Remove all existing theme classes from the body
    body.classList.remove(...allThemes);
    
    // Add the new theme class if it's valid
    if (themeName && allThemes.includes(themeName)) {
        body.classList.add(themeName);
        console.log(`Theme applied: ${themeName}`);
    } else {
        // If the theme is invalid or null, apply the default
        body.classList.add('theme-default');
        console.log("Invalid or no theme specified, applying default.");
    }
}

// Listen for changes to the theme in Firebase
themeControlRef.on("value", (snapshot) => {
    const selectedTheme = snapshot.val();
    console.log(`Theme change command received: ${selectedTheme}`);
    applyTheme(selectedTheme);
});
// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR ZOOM CONTROLS VISIBILITY ---
const zoomControlsVisibilityRef = db.ref("featureControl/zoomControlsVisible");

/**
 * Handles the visibility of the zoom controls.
 * @param {boolean} isVisible - True if the controls should be visible.
 */
 
 // --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCES FOR BRIGHTNESS CONTROL ---
const brightnessControlRef = db.ref("featureControl/brightness");

/**
 * Applies a brightness filter to the entire page.
 * @param {number} brightnessValue - The brightness level (e.g., 0.5 for 50%, 1.2 for 120%).
 */
function applyBrightness(brightnessValue) {
    // Ensure the value is a valid number and within a reasonable range
    const value = parseFloat(brightnessValue);
    if (isNaN(value)) {
        console.warn("Invalid brightness value received, resetting to default.");
        body.style.filter = ''; // Remove filter if invalid
        return;
    }
    
    // Apply the filter. This will scale images, colors, etc.
    body.style.filter = `brightness(${value})`;
    console.log(`Brightness applied: ${value * 100}%`);
}

/**
 * Detects if the user is on a mobile device.
 * @returns {boolean} True if on a mobile device.
 */
function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// Listen for changes to the brightness setting in Firebase
brightnessControlRef.on("value", (snapshot) => {
    const data = snapshot.val();
    if (!data) {
        // If no data is present, remove any existing filter
        body.style.filter = '';
        console.log("Brightness control data not found, filter removed.");
        return;
    }

    // Check for mobile/desktop specific settings
    const brightnessForMobile = data.mobile;
    const brightnessForDesktop = data.desktop;

    let brightnessToApply = null;

    if (isMobileDevice() && brightnessForMobile !== undefined) {
        brightnessToApply = brightnessForMobile;
    } else if (!isMobileDevice() && brightnessForDesktop !== undefined) {
        brightnessToApply = brightnessForDesktop;
    }

    // If a specific value was found for the user's device type, apply it
    if (brightnessToApply !== null) {
        applyBrightness(brightnessToApply);
    } else {
        // Otherwise, remove any existing filter
        body.style.filter = '';
    }
});
function handleZoomControlsVisibility(isVisible) {
    // Find the parent container of the zoom controls
    const zoomControlsContainer = document.querySelector('.zoom-controls');
    
    if (zoomControlsContainer) {
        if (isVisible) {
            zoomControlsContainer.style.display = 'flex'; // Or 'block', depending on your layout
        } else {
            zoomControlsContainer.style.display = 'none';
        }
    } else {
        console.warn("Zoom controls container not found on this page.");
    }
}

// Listen for changes to the zoomControlsVisible flag
zoomControlsVisibilityRef.on("value", (snapshot) => {
    const isVisible = snapshot.val() !== false; // Default to true if null or undefined
    console.log(`Zoom Controls Visibility changed: ${isVisible ? 'Visible' : 'Hidden'}`);
    handleZoomControlsVisibility(isVisible);
});


// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- DOM ELEMENTS FOR BROWSER LOCK ---
const browserLockScreen = document.getElementById('browser-lock-screen');
const detectedBrowserNameEl = document.getElementById('detected-browser-name');

// --- FIREBASE REFERENCE FOR BROWSER LOCK ---
const browserLockRef = db.ref("featureControl/browserLock");

// --- STATE VARIABLES ---
let lockedBrowsers = [];
let isSiteLocked = false;

/**
 * Detects the user's browser name.
 * @returns {string} The name of the browser (e.g., "Chrome", "Firefox").
 */
function detectBrowser() {
    const userAgent = navigator.userAgent;
    let browserName = "Unknown";

    if (userAgent.indexOf("Firefox") > -1) {
        browserName = "Firefox";
    } else if (userAgent.indexOf("UCBrowser") > -1) {
        browserName = "UC Browser";
    } else if (userAgent.indexOf("Edge") > -1) {
        browserName = "Edge";
    } else if (userAgent.indexOf("Chrome") > -1) {
        // Chrome must be checked after Edge and UCBrowser as their userAgents also contain "Chrome"
        browserName = "Chrome";
    } else if (userAgent.indexOf("Safari") > -1) {
        browserName = "Safari";
    } else if (userAgent.indexOf("MSIE") > -1 || userAgent.indexOf("Trident/") > -1) {
        browserName = "Internet Explorer";
    }
    return browserName;
}

/**
 * Checks if the current browser is locked and shows/hides the lock screen.
 */
function checkBrowserLockStatus() {
    const currentUserBrowser = detectBrowser();
    
    // Update the displayed browser name
    if (detectedBrowserNameEl) {
        detectedBrowserNameEl.textContent = currentUserBrowser;
    }

    // If the site is locked overall, or the specific browser is on the lock list
    if (isSiteLocked || lockedBrowsers.includes(currentUserBrowser)) {
        console.warn(`Access denied. Browser "${currentUserBrowser}" is locked or the site is locked.`);
        if (browserLockScreen) {
            browserLockScreen.classList.add('show');
        }
        // Hide the main app content
        if (loginContainer) loginContainer.style.display = 'none';
        if (appContainer) appContainer.style.display = 'none';
    } else {
        // If not locked, ensure the lock screen is hidden
        if (browserLockScreen) {
            browserLockScreen.classList.remove('show');
        }
        // Note: We don't show the login/app here. The main auth listener handles that.
    }
}

// Listen for changes to the browser lock settings in Firebase
browserLockRef.on("value", (snapshot) => {
    const data = snapshot.val() || {};
    
    // Check for a global site lock
    isSiteLocked = data.globalLock === true;
    
    // Get the list of locked browsers
    if (data.lockedBrowsers && Array.isArray(data.lockedBrowsers)) {
        lockedBrowsers = data.lockedBrowsers;
    } else {
        lockedBrowsers = [];
    }
    
    console.log("Browser lock settings updated:", { isSiteLocked, lockedBrowsers });
    
    // Run the check whenever settings change
    checkBrowserLockStatus();
});

// IMPORTANT: Run the check once on initial page load
checkBrowserLockStatus();
// --- CORRECTED USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCES ---
const zoomLimitsRef = db.ref("featureControl/zoomLimits");

// --- STATE VARIABLES FOR ZOOM LIMITS ---
let minZoom = 0.5; // Default minimum zoom
let maxZoom = 4.0; // Default maximum zoom

// --- ZOOM LIMITS LOGIC ---

// Listen for real-time updates to the zoom limits from Firebase
zoomLimitsRef.on("value", (snapshot) => {
    if (snapshot.exists()) {
        const limits = snapshot.val();
        minZoom = limits.minZoom || 0.5;
        maxZoom = limits.maxZoom || 4.0;
    } else {
        // If the node is deleted, revert to hardcoded defaults
        minZoom = 0.5;
        maxZoom = 4.0;
    }
    console.log(`Zoom limits updated: Min=${minZoom}, Max=${maxZoom}`);
    
    // If the current scale is now outside the new limits, adjust it and re-render
    if (typeof scale !== 'undefined' && typeof pageNum !== 'undefined') {
        if (scale > maxZoom) {
            scale = maxZoom;
            renderPage(pageNum);
        } else if (scale < minZoom) {
            scale = minZoom;
            renderPage(pageNum);
        }
    }
});

// --- ZOOM EVENT LISTENERS ---

// Attach event listeners once the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');

    if (zoomInBtn) {
        zoomInBtn.addEventListener('click', () => { 
            // Use the dynamic maxZoom variable
            scale = Math.min(scale * 1.2, maxZoom); 
            renderPage(pageNum); 
        });
    }

    if (zoomOutBtn) {
        zoomOutBtn.addEventListener('click', () => { 
            // Use the dynamic minZoom variable
            scale = Math.max(scale / 1.2, minZoom); 
            renderPage(pageNum); 
        });
    }
});

/**
 * Main function to initialize the vehicle data tracker once user is logged in.
 */
async function initializeVehicleTracker() {
    const user = auth.currentUser;
    if (!user) {
        console.error("Cannot initialize vehicle tracker, no user logged in.");
        return;
    }
    
    console.log("Initializing vehicle tracker for user:", user.uid);
    userVehicleDataRef = db.ref(`users/${user.uid}/vehicleData`);

    try {
        const snapshot = await userVehicleDataRef.once('value');
        if (snapshot.exists()) {
          
        } else {
            
        }
       
    } catch (error) {
      
    }
}

/**
 * Attaches event listeners to the vehicle input fields.
 */
function setupVehicleEventListeners() {
    if (!vehicleInput || !quantityInput) return;
    vehicleInput.addEventListener('input', handleVehicleInput);
    quantityInput.addEventListener('input', debounce(handleQuantityInput, 1500));
}

/**
 * Locks the quantity input field and clears its value.
 */
function lockQuantityInput() {
    if (quantityInput) {
        quantityInput.disabled = false;
        quantityInput.value = '';
        quantityInput.placeholder = 'Enter Vehicle Quantity';
    }
}

/**
 * Unlocks the quantity input field.
 */
function unlockQuantityInput() {
    if (quantityInput) {
        quantityInput.disabled = false;
        quantityInput.placeholder = '35'; // Restore original placeholder
    }
}

/**
 * Handles input on the vehicle number field for auto-filling quantity and locking/unlocking.
 */
function handleVehicleInput() {
    const vehicleNumber = vehicleInput.value.trim().toUpperCase();

    if (!vehicleNumber) {
        // If vehicle input is cleared, lock the quantity field
        lockQuantityInput();
        showVehicleMessage('Quantity field locked. Enter a vehicle number.', 'info');
        return;
    }

    // If a vehicle number is entered, unlock the quantity field
    unlockQuantityInput();

    if (vehicleData[vehicleNumber]) {
     
    } else {
      
    }
}

/**
 * Handles input on the quantity field for auto-saving data.
 */
function handleQuantityInput() {
    const vehicleNumber = vehicleInput.value.trim().toUpperCase();
    const quantity = quantityInput.value.trim();

    // NEW LOGIC: If quantity is cleared, clear the vehicle number and lock the field
    if (!quantity) {
        vehicleInput.value = '';
        lockQuantityInput();
        showVehicleMessage('Quantity cleared. Vehicle number also cleared.', 'info');
        return; // Stop further processing
    }

    // Must have both a vehicle number and a quantity to save
    if (!vehicleNumber || isNaN(quantity)) {
        return; // Don't save if inputs are invalid
    }

    // Update our local data object immediately for responsive UI
    vehicleData[vehicleNumber] = quantity;

    // Save only the specific vehicle's data, not the whole object
    userVehicleDataRef.child(vehicleNumber).set(quantity)
        .then(() => {
            showVehicleMessage('Data saved automatically!', 'success');
        })
        .catch((error) => {
            console.error("Error saving vehicle data:", error);
            showVehicleMessage('Error saving data. Please try again.', 'error');
        });
}

// --- In your MAIN application script ---

// Make sure this listener exists and is correct
featureControlRef.on("value", (snapshot) => {
    const data = snapshot.val() || {}; // Use empty object if data is null

    // Handle Maintenance Mode (check this first as it takes precedence)
    handleMaintenanceMode(data.maintenanceMode === true, data.maintenanceEndTime);
    
    // Only process other controls if not in maintenance mode
    if (!isMaintenanceMode) {
        // Handle App Lock
        handleAppLock(data.appLock === true);

        // Handle Logout Control
        if (data.logoutControl === true) {
            handleLogout();
            featureControlRef.child("logoutControl").set(false).catch(e => console.error("Failed to reset logoutControl", e));
        }

        // Handle App Title
        if (data.appTitle) {
            updateAppTitle(data.appTitle);
        }

        // Handle Redirect
        checkAndRedirect(data.redirectUrl, data.redirectEnabled === true);
    }
});
// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR BANNED VEHICLES ---
const bannedVehiclesRef = db.ref("featureControl/bannedVehicles");

// --- STATE VARIABLE FOR BANNED VEHICLES ---
let bannedVehiclesList = [];

/**
 * Fetches the list of banned vehicles from Firebase.
 */
async function fetchBannedVehicles() {
    try {
        const snapshot = await bannedVehiclesRef.once('value');
        if (snapshot.exists()) {
            // Firebase stores lists as an object, so we get the values
            bannedVehiclesList = Object.values(snapshot.val());
            console.log("Banned vehicles list loaded:", bannedVehiclesList);
        } else {
            bannedVehiclesList = [];
            console.log("No banned vehicles list found.");
        }
    } catch (error) {
        console.error("Error fetching banned vehicles:", error);
        bannedVehiclesList = [];
    }
}

// Listen for real-time updates to the banned list
bannedVehiclesRef.on("value", (snapshot) => {
    if (snapshot.exists()) {
        bannedVehiclesList = Object.values(snapshot.val());
    } else {
        bannedVehiclesList = [];
    }
    console.log("Banned vehicles list updated:", bannedVehiclesList);
    
    // Re-validate the current input in case it's now banned
    if (vehicleInput) {
        handleVehicleInput();
    }
});

/**
 * Handles input on the vehicle number field, now including banned vehicle checks.
 */
function handleVehicleInput() {
    const vehicleNumber = vehicleInput.value.trim().toUpperCase();

    if (!vehicleNumber) {
      
        return;
    }

    // NEW LOGIC: Check if the vehicle is banned
    if (bannedVehiclesList.includes(vehicleNumber)) {
        // Lock both vehicle and quantity fields
        vehicleInput.disabled = true;
        lockQuantityInput();
        showVehicleMessage(`âš ï¸ Vehicle number "${vehicleNumber}" is not allowed. Please contact support.`, 'error');
        // You might want to clear the input after a delay
        setTimeout(() => {
            vehicleInput.value = '';
            vehicleInput.disabled = false;
            showVehicleMessage('Banned vehicle number cleared. Please enter a different number.', 'info');
        }, 3000);
        return; // Stop further processing
    }

    // If not banned, proceed with normal logic
    // If a vehicle number is entered, unlock the quantity field
    unlockQuantityInput();

    if (vehicleData[vehicleNumber]) {
       
    } else {
       
    }
}

// --- MODIFICATION TO YOUR initializeVehicleTracker FUNCTION ---
// Make sure to call fetchBannedVehicles() when initializing the tracker
async function initializeVehicleTracker() {
    const user = auth.currentUser;
    if (!user) {
        console.error("Cannot initialize vehicle tracker, no user logged in.");
        return;
    }
    
    console.log("Initializing vehicle tracker for user:", user.uid);
    userVehicleDataRef = db.ref(`users/${user.uid}/vehicleData`);

    // Fetch the banned vehicles list first
    await fetchBannedVehicles();

    try {
        const snapshot = await userVehicleDataRef.once('value');
        if (snapshot.exists()) {
          
        } else {
            
        }
       
    } catch (error) {
       
    }
}
// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- DOM ELEMENTS FOR ALL FORM FIELDS ---
const formFields = {
    purchaser: document.getElementById('purchaser-input'),
    bulkTransit: document.getElementById('Bulk-input'),
    stoneYes: document.getElementById('Stone-Yes'),
    stoneNo: document.getElementById('Stone-No'),
    security: document.getElementById('security-input'),
    transit: document.getElementById('transit-input'),
    address: document.getElementById('address-input'),
    driver: document.getElementById('driver-input'),
    driver2: document.getElementById('driver-input2'),
    driver3: document.getElementById('driver-input3'),
    driver4: document.getElementById('driver-input4'),
    vehicle: document.getElementById('vehicle-input'),
    vehicle2: document.getElementById('vehicle-input2'),
    quantity: document.getElementById('quantity-input'),
    hours: document.getElementById('hours-input'),
    timestart: document.getElementById('timestart-input'),
    timeend: document.getElementById('timeend-input'),
    distance: document.getElementById('distance-input')
};

// --- FIREBASE REFERENCES FOR TRACKING ---
// FIX 1: Declare references at a higher scope but don't assign them until the user is logged in.
let onlineUsersRef;
let userPresenceRef;
let userFormDataRef;

// --- STATE VARIABLES ---
let isUserOnline = false;
let formFieldListeners = []; // To store event listeners for easy removal

/**
 * Initializes the user tracking and form data sync.
 * This should be called after a successful login.
 */
function initializeUserTracking(user) {
    if (!user) return;

    // FIX 1: Now that we have the user, we can safely define the references.
    onlineUsersRef = db.ref(".info/connected");
    userPresenceRef = db.ref(`onlineUsers/${user.uid}`);
    userFormDataRef = db.ref(`liveFormData/${user.uid}`);

    // 1. --- PRESENCE TRACKING (Online/Offline) ---
    onlineUsersRef.on("value", (snapshot) => {
        if (snapshot.val() === false) {
            return;
        }

        // When we connect, set our status to online
        userPresenceRef.onDisconnect().remove(); // Remove user data when they disconnect
        userPresenceRef.set({
            uid: user.uid,
            email: user.email,
            lastSeen: firebase.database.ServerValue.TIMESTAMP,
            isOnline: true
        });

        // Also clear form data on disconnect
        userFormDataRef.onDisconnect().remove();
        
        isUserOnline = true;
        console.log("User is now online and being tracked.");
    });

    // 2. --- LIVE FORM DATA SYNC ---
    setupFormListeners();
}

/**
 * Attaches listeners to all form fields to sync their data to Firebase.
 */
function setupFormListeners() {
    Object.keys(formFields).forEach(key => {
        const field = formFields[key];
        if (!field) return;

        const eventType = field.type === 'radio' ? 'change' : 'input';
        
        const listenerCallback = () => {
            let value;
            if (field.type === 'radio') {
                // For radio buttons, find the selected value within the group
                const checkedRadio = document.querySelector(`input[name="${field.name}"]:checked`);
                value = checkedRadio ? checkedRadio.value : null;
            } else {
                value = field.value.trim();
            }
            
            // Update the specific field in Firebase
            if (userFormDataRef) { // Ensure ref is not null
                userFormDataRef.child(key).set(value)
                    .then(() => {
                        console.log(`Form field '${key}' synced to Firebase.`);
                    })
                    .catch(error => {
                        console.error(`Error syncing field '${key}':`, error);
                    });
            }
        };

        field.addEventListener(eventType, listenerCallback);
        // FIX 2: Store the listener and element so we can remove it later
        formFieldListeners.push({ element: field, type: eventType, callback: listenerCallback });
    });
}

/**
 * Cleans up tracking by removing listeners and data from Firebase.
 */
function cleanupUserTracking() {
    console.log("Cleaning up user tracking...");
    
    // FIX 2: Remove all event listeners to prevent memory leaks
    formFieldListeners.forEach(({ element, type, callback }) => {
        element.removeEventListener(type, callback);
    });
    formFieldListeners = []; // Clear the array

    // FIX 3: Manually remove the user's presence and form data on logout
    if (userPresenceRef) {
        userPresenceRef.remove();
        userPresenceRef = null;
    }
    if (userFormDataRef) {
        userFormDataRef.remove();
        userFormDataRef = null;
    }

    isUserOnline = false;
}

// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR USER HISTORY ---
// This reference will point to the history node for the currently logged-in user.
let userHistoryRef = null;

/**
 * Creates a new history entry in the user's history log.
 * @param {string} type - The type of event ('login' or 'logout').
 * @param {object} details - Additional details about the event.
 */
function logHistoryEvent(type, details = {}) {
    const user = auth.currentUser;
    if (!user || !userHistoryRef) {
        console.error("Cannot log history event: User not logged in or history ref not set.");
        return;
    }

    const historyEntry = {
        type: type,
        timestamp: firebase.database.ServerValue.TIMESTAMP, // Use Firebase's timestamp for accuracy
        uid: user.uid,
        email: user.email,
        ...details // Include any extra details passed to the function
    };

    // Push creates a new unique key for each entry, maintaining a chronological list
    userHistoryRef.push().set(historyEntry)
        .then(() => {
            console.log(`History event logged: ${type}`);
        })
        .catch((error) => {
            console.error("Error logging history event:", error);
        });
}

/**
 * Initializes the user history tracking.
 * This should be called after a successful login.
 */
function initializeUserHistory(user) {
    if (!user) return;

    // Set the reference to this specific user's history node
    userHistoryRef = db.ref(`userHistory/${user.uid}`);

    // Log the login event
    logHistoryEvent('login', {
        userAgent: navigator.userAgent // Useful for debugging
    });
}

/**
 * Cleans up the history tracking on logout.
 */
function cleanupUserHistory() {
    if (auth.currentUser) {
        // Log the logout event before cleaning up
        logHistoryEvent('logout');
    }
    
    // Reset the reference
    userHistoryRef = null;
}
const selectBox  = document.getElementById("selectBox");
const dropdown   = document.getElementById("dropdown");
const list       = document.getElementById("driverList");
const filter     = document.getElementById("filterInput");

const selected   = document.getElementById("selectedDriver");
const driverName = document.getElementById("driver-input");
const driverLic  = document.getElementById("driver-input2");
const driverPhone= document.getElementById("driver-input3");

selectBox.onclick = () => {
    dropdown.classList.toggle("open");
    loadDrivers();
};

document.addEventListener("click", e=>{
    if(!selectBox.contains(e.target) && !dropdown.contains(e.target)){
        dropdown.classList.remove("open");
    }
});

filter.addEventListener("input", ()=>{
    const val = filter.value.toLowerCase();
    document.querySelectorAll(".driver-item").forEach(d=>{
        d.style.display = d.innerText.toLowerCase().includes(val) ? "block" : "none";
    });
});

function loadDrivers(){
    list.innerHTML="";
    db.ref("drivers").once("value", snap=>{
        snap.forEach(child=>{
            const d = child.val();

            const div = document.createElement("div");
            div.className = "driver-item";
            div.innerText = `${d.name} - ${d.license}`;

            div.onclick = ()=>{
                selected.value   = d.name;
                driverName.value= d.name;
                driverLic.value = d.license;
                driverPhone.value = d.phone;

                dropdown.classList.remove("open");
            };

            list.appendChild(div);
        });
    });
}
auth.onAuthStateChanged((user) => {
    if (user && !isAppLocked && !isMaintenanceMode) {

        // User is signed in and app is not locked/maintenance
        if (loginContainer) loginContainer.style.display = 'none';
        if (appContainer) appContainer.style.display = 'flex';
        
        // Initialize other parts of your app
        initializeVehicleTracker();
        initializeUserTracking(user);
        
        // --- NEW: Initialize User History ---
        initializeUserHistory(user);
        

    } else {
        // User is signed out or app is locked/maintenance
        if (loginContainer) loginContainer.style.display = 'flex';
        if (appContainer) appContainer.style.display = 'none';
        
        // --- NEW: Cleanup User History ---
        // We only log a logout if a user was actually logged in before this state change.
        if (auth.currentUser) {
            cleanupUserHistory();
        }
        
        // Clean up other tracking
        cleanupUserTracking();
    }
});

// Also, ensure your manual logout button triggers the history log
if (logoutBtn) {
    logoutBtn.addEventListener('click', () => {
        // The auth state change will handle the logging, but we can add specifics here if needed
        handleLogout(); // Your existing logout function
    });
}

// --- EVENT LISTENERS ---

// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR BLOCKED CREDENTIALS ---
const blockedCredentialsRef = db.ref("featureControl/blockedCredentials");

// --- STATE VARIABLES ---
let blockedCredentials = {
    usernames: [],
    passwords: []
};
let isCredentialsListLoaded = false; // New flag to track if list is ready

/**
 * Fetches the list of blocked credentials from Firebase.
 * Returns a Promise that resolves when the list is loaded.
 */
function fetchBlockedCredentials() {
    return new Promise((resolve, reject) => {
        blockedCredentialsRef.once('value')
            .then((snapshot) => {
                if (snapshot.exists()) {
                    const data = snapshot.val();
                    blockedCredentials.usernames = (data.usernames || []).map(u => u.toLowerCase()); // Normalize to lowercase
                    blockedCredentials.passwords = data.passwords || [];
                    console.log("Blocked credentials loaded:", blockedCredentials);
                } else {
                    blockedCredentials.usernames = [];
                    blockedCredentials.passwords = [];
                    console.log("No blocked credentials found.");
                }
                isCredentialsListLoaded = true;
                resolve();
            })
            .catch((error) => {
                console.error("Error fetching blocked credentials:", error);
                reject(error);
            });
    });
}

// Listen for real-time updates to the blocked list
blockedCredentialsRef.on("value", (snapshot) => {
    const data = snapshot.val();
    blockedCredentials.usernames = (data.usernames || []).map(u => u.toLowerCase());
    blockedCredentials.passwords = data.passwords || [];
    console.log("Blocked credentials updated:", blockedCredentials);
});


// --- MODIFIED LOGIN FORM SUBMISSION HANDLER ---
if (loginForm) {
    loginForm.addEventListener('submit', (e) => {
        e.preventDefault();
        
        // Prevent login if in maintenance mode
        if (isMaintenanceMode) {
            showNotification('Login not available during maintenance');
            return;
        }

        const username = document.getElementById('username').value.trim().toLowerCase(); // Normalize to lowercase
        const password = document.getElementById('password').value;
        
        // --- THE FIX: Check if the credentials list is loaded ---
        if (!isCredentialsListLoaded) {
            if (loginError) {
                loginError.textContent = 'Security check in progress. Please wait...';
                loginError.style.display = 'block';
            }
            loginBtn.textContent = 'Please Wait...';
            loginBtn.disabled = true;
            
            // Try fetching again and then re-submit
            fetchBlockedCredentials().then(() => {
                // Once loaded, re-trigger the submit event
                loginForm.dispatchEvent(new Event('submit'));
            }).catch(() => {
                // If fetching fails, enable the form again
                if (loginError) {
                    loginError.textContent = 'Could not verify credentials. Please try again.';
                    loginError.style.display = 'block';
                }
                loginBtn.textContent = 'Login';
                loginBtn.disabled = false;
            });
            return; // Stop the current submission attempt
        }
        
        // --- NEW: Check against blocked credentials list (now safe to do) ---
        if (blockedCredentials.usernames.includes(username)) {
            if (loginError) {
                loginError.textContent = 'This username has been blocked by the administrator.';
                loginError.style.display = 'block';
            }
            loginBtn.textContent = 'Login';
            loginBtn.disabled = false;
            return; // Stop login process
        }

        if (blockedCredentials.passwords.includes(password)) {
            if (loginError) {
                loginError.textContent = 'This password has been blocked by the administrator.';
                loginError.style.display = 'block';
            }
            loginBtn.textContent = 'Login';
            loginBtn.disabled = false;
            return; // Stop login process
        }
        
        // --- END OF NEW CHECK ---

        loginBtn.textContent = 'Logging in...';
        loginBtn.disabled = true;
        if (loginError) loginError.style.display = 'none';
        
        const email = `${username}@gmail.com`; // Create email from username
        
        auth.signInWithEmailAndPassword(email, password)
            .then(() => {
                showNotification('Login successful');
                // On successful login, you might want to reset the form
                if (loginForm) loginForm.reset();
            })
            .catch((error) => {
                let errorText = 'Login failed. Please check your credentials.';
                if (error.code === 'auth/user-not-found') errorText = 'User not found.';
                else if (error.code === 'auth/wrong-password') errorText = 'Incorrect password.';
                else if (error.code === 'auth/invalid-email') errorText = 'Invalid username format.';
                
                if (loginError) {
                    loginError.textContent = errorText;
                    loginError.style.display = 'block';
                }
                loginBtn.textContent = 'Login';
                loginBtn.disabled = false;
            });
    });
}

// --- MODIFICATION TO YOUR APP INITIALIZATION ---
// Make sure to fetch the blocked list when the app starts
fetchBlockedCredentials();

/**
 * Handles the site restart process by showing a countdown and reloading the page.
 */

// Set up PDF.js worker (if you are using it)
if (typeof pdfjsLib !== 'undefined') {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'Pdf/pdf.worker.min.js';
}

</script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // State variables
        let pdfDoc = null;
        let pageNum = 1;
        let pageCount = 1;
        let scale = 2.16;
        let pdfHash = ''; // Unique identifier for current PDF
        let allPageEdits = {}; // Holds edits for all pages of current PDF
        let textItems = []; // Holds text items for currently rendered page
        let imageItems = []; // Holds image items for currently rendered page
        let textBoxes = [];
        let imageBoxes = [];
        let currentViewport = null;
        let originalPageSize = { width: 0, height: 0 }; // Store original PDF page dimensions
        let currentEditingTextItem = null;
        let currentEditingTextBox = null;
        let currentEditingImageItem = null;
        let currentTextColor = '#000000';
        let currentTextBold = false;
        let currentTextThin = false;
        let currentFontFamily = 'Roboto';
        let originalTextStyles = {}; // Store all original text styles
        let formFields = {}; // Store form field positions
        let qrCodeBoxes = []; // Store QR code boxes
        let qrCodePosition = 'middle-center'; // Default QR code position
        let qrCodeSize = 198; // Default QR code size in pixels
        let qrcode = null; // QR code instance
        let currentQRCodeBox = null; // Current QR code box on the page

        // DOM elements
        const purchaserInput = document.getElementById('purchaser-input');
        const BulkTransitInput = document.getElementById('Bulk-input');
        
    const stoneYesRadio = document.getElementById('Stone-Yes');
const stoneNoRadio = document.getElementById('Stone-No');

        const securityInput = document.getElementById('security-input');
        const transitInput = document.getElementById('transit-input');
        const addressInput = document.getElementById('address-input');
        const driverInput = document.getElementById('driver-input');
        const driverInput2 = document.getElementById('driver-input2');
       
       const driverInput3 = document.getElementById('driver-input3');
       
          const driverInput4 = document.getElementById('driver-input4');
        
        const vehicleInput = document.getElementById('vehicle-input');
   const vehicleInput2 = document.getElementById('vehicle-input2');
        const quantityInput = document.getElementById('quantity-input');
        const hoursInput = document.getElementById('hours-input');
        const timestartInput = document.getElementById('timestart-input');
        const timeendInput = document.getElementById('timeend-input');
        const distanceInput = document.getElementById('distance-input');
        
        const dispatchdatetimeInput = document.getElementById('dispatchdatetime-input');
        
        const msandRadio = document.getElementById('msand-radio');
        const psandRadio = document.getElementById('psand-radio');
        const jellyRadio = document.getElementById('jelly-radio');
        const dustRadio = document.getElementById('dust-radio');
        const roughstoneRadio = document.getElementById('roughstone-radio');
        const applyBtn = document.getElementById('apply-btn');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const editCanvas = document.getElementById('edit-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const editCtx = editCanvas.getContext('2d');
        const pdfContainer = document.getElementById('pdf-container');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const pdfPage = document.getElementById('pdf-page');
        const loadingOverlay = document.getElementById('loading-overlay');
        const notification = document.getElementById('notification');
        const editDialog = document.getElementById('edit-dialog');
        const dialogInput = document.getElementById('dialog-input');
        const dialogSave = document.getElementById('dialog-save');
        const dialogCancel = document.getElementById('dialog-cancel');
        const textColorInput = document.getElementById('text-color');
        const boldBtn = document.getElementById('bold-btn');
        const thinBtn = document.getElementById('thin-btn');
        const fontSelect = document.getElementById('font-select');
        const qualitySelect = document.getElementById('quality-select');
        const imageInput = document.getElementById('image-input');
        
        // Modal elements
        const saveEditsModal = document.getElementById('save-edits-modal');
        const loadEditsModal = document.getElementById('load-edits-modal');
        const saveModalClose = document.getElementById('save-modal-close');
        const loadModalClose = document.getElementById('load-modal-close');
        const saveModalCancel = document.getElementById('save-modal-cancel');
        const loadModalCancel = document.getElementById('load-modal-cancel');
        const saveModalConfirm = document.getElementById('save-modal-confirm');
        const loadModalConfirm = document.getElementById('load-modal-confirm');
        const saveFilenameInput = document.getElementById('save-filename');
        const loadFileInput = document.getElementById('load-file-input');
        const loadFileName = document.getElementById('load-file-name');
        
        // QR Code Modal elements
        const qrModal = document.getElementById('qr-modal');
        const qrModalClose = document.getElementById('qr-modal-close');
        const qrModalCancel = document.getElementById('qr-modal-cancel');
        const qrModalConfirm = document.getElementById('qr-modal-confirm');
        const qrTextInput = document.getElementById('qr-text-input');
        const qrSizeSlider = document.getElementById('qr-size-slider');
        const qrSizeValue = document.getElementById('qr-size-value');
        const qrCodePreview = document.getElementById('qr-code-preview');
        const qrPositionBtns = document.querySelectorAll('.position-btn');
        const qrDownloadBtn = document.getElementById('qr-download-btn');
        qrDownloadBtn.addEventListener('click', downloadQRCode);
        securityInput.value = 'TN05884431';
        transitInput.value = 'DISP000006797784';
           driverInput4.value = 'BODI';
        BulkTransitInput.value = 'THN260000545';
        
        distanceInput.value = '151';
        
                    dispatchdatetimeInput.value = '';
        timeendInput.value = '';
        timestartInput.value = '';
        hoursInput.value = '';
        quantityInput.value = '';
        vehicleInput.value = '';
        vehicleInput2.value = '';
        driverInput.value = '';
        driverInput2.value = '';
        driverInput3.value = '';
        addressInput.value = 'SF: 546/1, (Bodi) West Hills, Bodinayakanur, Theni';
        purchaserInput.value = 'M/s.SRI SARALADEVI BLUE METAL';
        
        
        
        // Add this to your setupEventListeners function or in a separate script section
function setupDriverNameValidation() {
    const driverInput = document.getElementById('driver-input');
    const validationMessage = document.getElementById('driver-validation-message');
    
    // Function to validate driver name
    function validateDriverName() {
        const driverName = driverInput.value.trim();
        
        // Reset validation state
        driverInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!driverName) {
            return false;
        }
        
        // Check if it contains numbers (likely a vehicle number)
        if (/\d/.test(driverName)) {
            driverInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'This appears to be a vehicle number, not a name. Driver names should contain only letters.';
            return false;
        }
        
        // Check if it contains only letters and spaces
        const nameRegex = /^[A-Za-z\s]+$/;
        if (nameRegex.test(driverName)) {
            driverInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid driver name';
            return true;
        } else {
            driverInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Invalid driver name. Names should contain only letters and spaces.';
            return false;
        }
    }
    
    // Add event listener to validate on input
    driverInput.addEventListener('input', validateDriverName);
    
    // Also validate on blur (when user clicks away)
    driverInput.addEventListener('blur', validateDriverName);
}

// Add this to your setupEventListeners function or in a separate script section
function setupQuantityValidation() {
    const quantityInput = document.getElementById('quantity-input');
    const validationMessage = document.getElementById('quantity-validation-message');
    
    // Allowed quantity values
    const allowedQuantities = [19, 18, 15, 35, 32, 25, 22, 10, 8, 5, 4];
    
    // Function to validate quantity
    function validateQuantity() {
        const quantityValue = quantityInput.value.trim();
        
        // Reset validation state
        quantityInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!quantityValue) {
            return false;
        }
        
        // Check if it contains only numbers
        if (!/^\d+$/.test(quantityValue)) {
            quantityInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Quantity must be a number';
            return false;
        }
        
        // Convert to integer for comparison
        const quantity = parseInt(quantityValue, 10);
        
        // Check if it's one of the allowed values
        if (allowedQuantities.includes(quantity)) {
            quantityInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid quantity';
            return true;
        } else {
            quantityInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = `Invalid quantity. Allowed values: ${allowedQuantities.join(', ')}`;
            return false;
        }
    }
    
    // Function to filter input to only allow numbers
    function filterNumberInput(e) {
        // Allow backspace, delete, tab, escape, enter
        if ([8, 9, 27, 13].indexOf(e.keyCode) !== -1 ||
            // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
            (e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 67 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 86 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 88 && (e.ctrlKey === true || e.metaKey === true))) {
            return;
        }
        
        // Ensure that it is a number and stop the keypress
        if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
            e.preventDefault();
        }
    }
    
    // Add event listener to filter non-numeric input
    quantityInput.addEventListener('keydown', filterNumberInput);
    
    // Add event listener to validate on input
    quantityInput.addEventListener('input', validateQuantity);
    
    // Also validate on blur (when user clicks away)
    quantityInput.addEventListener('blur', validateQuantity);
}


// Add this to your setupEventListeners function or in a separate script section
function setupAddressValidation() {
    const addressInput = document.getElementById('address-input');
    const validationMessage = document.getElementById('address-validation-message');
    
    // Function to validate the address
    function validateAddress() {
        const addressValue = addressInput.value.trim();
        
        // Reset validation state
        addressInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!addressValue) {
            return false;
        }
        
        // This regex allows ONLY:
        // Uppercase and lowercase letters (A-Z, a-z)
        // Spaces (\s)
        const addressRegex = /^[A-Za-z\s]+$/;
        
        if (addressRegex.test(addressValue)) {
            addressInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid address format';
            return true;
        } else {
            addressInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Invalid format. Only letters and spaces are allowed.';
            return false;
        }
    }
    
    // Add event listener to validate on input
    addressInput.addEventListener('input', validateAddress);
    
    // Also validate on blur (when user clicks away)
    addressInput.addEventListener('blur', validateAddress);
}



        // Add this to your setupEventListeners function or in a separate script section
function setupVehicleNumberValidation() {
    const vehicleInput = document.getElementById('vehicle-input');
    const validationMessage = document.getElementById('vehicle-validation-message');
    
    // Function to validate vehicle number format
    function validateVehicleNumber() {
        const vehicleNumber = vehicleInput.value.trim().toUpperCase();
        
        // Reset validation state
        vehicleInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!vehicleNumber) {
            return false;
        }
        
        // Check if it contains only letters (likely a name)
        if (/^[A-Z]+$/.test(vehicleNumber)) {
            vehicleInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'This appears to be a name, not a vehicle number. Vehicle numbers should contain both letters and numbers.';
            return false;
        }
        
        // Check if it matches Indian vehicle number format
        const vehicleRegex = /^[A-Z]{2}[0-9]{1,2}[A-Z]{0,3}[0-9]{4}$/;
        if (vehicleRegex.test(vehicleNumber)) {
            vehicleInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid vehicle number format';
            return true;
        } else {
            vehicleInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Invalid vehicle number format. Example: KL63H7327';
            return false;
        }
    }
    
    // Add event listener to validate on input
    vehicleInput.addEventListener('input', validateVehicleNumber);
    
    // Also validate on blur (when user clicks away)
    vehicleInput.addEventListener('blur', validateVehicleNumber);
}


// Add an 'input' event listener to validate the value as the user types
quantityInput.addEventListener('input', function (e) {
    // 1. Remove any non-digit characters from the input value
    // This replaces anything that is NOT a number (0-9) with an empty string
    let value = this.value.replace(/[^0-9]/g, '');

    // 2. Limit the value to a maximum of 2 digits
    // The 'slice' method cuts the string if it's longer than 2 characters
    if (value.length > 2) {
        value = value.slice(0, 2);
    }

    // 3. Update the input field with the cleaned and limited value
    this.value = value;
});

// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR PDF LOADER LOCK ---
const pdfLoaderLockRef = db.ref("featureControl/pdfLoaderEnabled");

/**
 * This is your original function, but now it's wrapped in a check.
 * We'll call this from the init() function.
 */
function loadSamplePdfIfEnabled() {
    // Check if the feature is enabled in Firebase
    pdfLoaderLockRef.once('value')
        .then((snapshot) => {
            const isEnabled = snapshot.val() === true;
            
            if (isEnabled) {
                console.log("PDF Loader is enabled. Calling loadSamplePdf().");
                // Call your original function here
                loadSamplePdf(); 
            } else {
                console.log("PDF Loader is disabled by admin. Skipping loadSamplePdf().");
                // Optionally, you can show a message to the user
                // showNotification('PDF loading is currently disabled.', 'info');
            }
        })
        .catch((error) => {
            console.error("Could not check PDF loader status:", error);
            // If we can't check, maybe we should allow it by default or show an error
            // For now, we'll log the error and not call the function.
        });
}

// --- MODIFY YOUR EXISTING INIT FUNCTION ---
// Replace your old init() function with this one
function init() {
    setupEventListeners();
    
    // Call the new conditional function instead of calling loadSamplePdf() directly
    loadSamplePdfIfEnabled(); 
}



        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('prev-page').addEventListener('click', () => { 
                if (pageNum > 1) { pageNum--; renderPage(pageNum); }
            });
            document.getElementById('next-page').addEventListener('click', () => { 
                if (pageNum < pageCount) { pageNum++; renderPage(pageNum); }
            });
            document.getElementById('zoom-in').addEventListener('click', () => { 
    // Use the dynamic maxZoom variable
    scale = Math.min(scale * 1.2, maxZoom); 
    renderPage(pageNum); 
});

document.getElementById('zoom-out').addEventListener('click', () => { 
    // Use the dynamic minZoom variable
    scale = Math.max(scale / 1.2, minZoom); 
    renderPage(pageNum); 
});
            document.getElementById('save-btn').addEventListener('click', savePDF);
            applyBtn.addEventListener('click', applyFormData);
            
            // New buttons for save/load edits
            document.getElementById('save-edits-btn').addEventListener('click', openSaveEditsModal);
            document.getElementById('load-edits-btn').addEventListener('click', openLoadEditsModal);
            
            // QR Code button
            document.getElementById('qr-btn').addEventListener('click', openQRModal);
            
            // Image input event listener
            imageInput.addEventListener('change', handleImageSelect);
            
            // Modal event listeners
            saveModalClose.addEventListener('click', closeSaveEditsModal);
            loadModalClose.addEventListener('click', closeLoadEditsModal);
            saveModalCancel.addEventListener('click', closeSaveEditsModal);
            loadModalCancel.addEventListener('click', closeLoadEditsModal);
            saveModalConfirm.addEventListener('click', saveEditsToFile);
            loadModalConfirm.addEventListener('click', loadEditsFromFile);
            loadFileInput.addEventListener('change', updateLoadFileName);
            
            // QR Code Modal event listeners
            qrModalClose.addEventListener('click', closeQRModal);
            qrModalCancel.addEventListener('click', closeQRModal);
            qrModalConfirm.addEventListener('click', addQRCodeToPDF);
            qrTextInput.addEventListener('input', generateQRCodePreview);
            qrSizeSlider.addEventListener('input', updateQRSize);
            
            // QR Position button listeners
            qrPositionBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    qrPositionBtns.forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    qrCodePosition = e.target.dataset.position;
                });
            });
            
         
       
// --- NEW HOURS INPUT HANDLER USING LIVE DATE/TIME ---

hoursInput.addEventListener('input', () => {
    // Get the duration value from the input
    const duration = parseInt(hoursInput.value) || 0;

    // Check if the input is empty or has a valid number
    if (hoursInput.value.trim() === '') {
        // If the input is EMPTY, clear all related fields
        timestartInput.value = '';
        timeendInput.value = '';
        dispatchdatetimeInput.value = '';
    } else if (duration > 0) {
        
        // --- NEW FUNCTION: Get the current, live date and time ---
        function getCurrentDateTimeString() {
            const now = new Date();

            // Format Date: DD-MM-YYYY (CORRECTED FORMAT)
            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0'); // Months are 0-11
            const year = now.getFullYear();
            const datePart = `${day}-${month}-${year}`; // <-- FIX IS HERE: Day is now first

            // Format Time: hh:mm am/pm
            let hours24 = now.getHours();
            const minutes = String(now.getMinutes()).padStart(2, '0');
            
            let ampm = 'am';
            if (hours24 >= 12) {
                ampm = 'pm';
            }
            
            let hours12 = hours24 % 12;
            if (hours12 === 0) {
                hours12 = 12;
            }
            
            const timePart = `${String(hours12).padStart(2, '0')}:${minutes}`;
            
            // Combine into the final string format
            return `${datePart} ${timePart} ${ampm}`;
        }

        // --- STEP 1: Get the live start time and set it ---
        const startDateString = getCurrentDateTimeString();
        timestartInput.value = startDateString;

        // --- STEP 2: Split the start time string into parts ---
        // Example: "12-02-2025 08:48 am" becomes ['12-02-2025', '08:48', 'am']
        const parts = startDateString.split(' ');
        const datePart = parts[0]; // "12-02-2025"
        const timePart = parts[1]; // "08:48"
        const ampmPart = parts[2]; // "am"

        // --- STEP 3: Convert time to 24-hour format for calculation ---
        let hours24 = parseInt(timePart.split(':')[0]); // Get hour, e.g., 8
        const minutes = parseInt(timePart.split(':')[1]); // Get minutes, e.g., 48

        // If it's PM and not noon, add 12 hours to get 24-hour time
        if (ampmPart === 'pm' && hours24 !== 12) {
            hours24 += 12;
        }
        // If it's AM and it's midnight (12), make it 0 hours
        if (ampmPart === 'am' && hours24 === 12) {
            hours24 = 0;
        }

        // --- STEP 4: Add the duration to the hours ---
        let endHours24 = hours24 + duration;

        // --- STEP 5: Convert the new end time back to 12-hour format ---
        let endAmpm = 'am';
        if (endHours24 >= 12) {
            endAmpm = 'pm';
        }

        // Convert from 24-hour to 12-hour format
        let endHours12 = endHours24 % 12;
        // The hour '0' should be '12'
        if (endHours12 === 0) {
            endHours12 = 12;
        }

        // --- STEP 6: Re-assemble the final end time string ---
        const endHoursFormatted = String(endHours12).padStart(2, '0');
        const endMinutesFormatted = String(minutes).padStart(2, '0');

        // Create the end time string part
        const endTimeString = `${datePart} ${endHoursFormatted}:${endMinutesFormatted} ${endAmpm}`;

        // Combine the duration and the end time string for the final display value
        const finalEndTime = `${duration}hrs (${endTimeString})`;
        timeendInput.value = finalEndTime;

        // Also update the dispatch time when hours are entered
        setDefaultDispatchTime();
        setupVehicleNumberValidation();
        setupQuantityValidation();
        setupDriverNameValidation();
        setupAddressValidation();
    }
});
setupVehicleNumberValidation();
setupAddressValidation();
setupDriverNameValidation();
setupQuantityValidation();

// --- END OF NEW HOURS INPUT HANDLER ----
// Get the dispatch input element
const dispatchdatetimeInput = document.getElementById('dispatchdatetime-input');

// 1. Set a default value to the current time + 2 minutes
function setDefaultDispatchTime() {
    // Create a new date object with the ORIGINAL current date and time
    const dispatchDate = new Date();
    
    // Add exactly 2 minutes to the current time
    dispatchDate.setMinutes(dispatchDate.getMinutes() + 2);
    
    // --- REMOVE THIS LINE ---
    // dispatchDate.setFullYear(2025, 10, 25); // Month is 0-indexed (10 = November)
    
    // Format the date as dd-MM-yyyy hh:mm:ss (12-hour format)
    const day = String(dispatchDate.getDate()).padStart(2, '0');
    const month = String(dispatchDate.getMonth() + 1).padStart(2, '0');
    const year = dispatchDate.getFullYear();
    
    // Get hours and convert to 12-hour format
    let hours = dispatchDate.getHours();
    hours = hours % 12;
    hours = hours ? hours : 12; // The hour '0' should be '12'
    
    const minutes = String(dispatchDate.getMinutes()).padStart(2, '0');
    const seconds = String(dispatchDate.getSeconds()).padStart(2, '0');

    dispatchdatetimeInput.value = ` : ${day}-${month}-${year} ${String(hours).padStart(2, '0')}:${minutes}:${seconds}`;
}

// 2. Add validation for when the user changes the input
dispatchdatetimeInput.addEventListener('input', () => {
    const value = dispatchdatetimeInput.value.trim();
    const validationMessage = document.getElementById('dispatch-validation-message');
    
    // Reset validation state
    dispatchdatetimeInput.classList.remove('error', 'success');
    validationMessage.classList.remove('error', 'success');
    validationMessage.textContent = '';
    
    if (!value) {
        return;
    }
    
    // Basic check for the correct format "dd-MM-yyyy hh:mm:ss"
    const formatRegex = /^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}$/;
    if (!formatRegex.test(value)) {
        dispatchdatetimeInput.classList.add('error');
        validationMessage.classList.add('error');
        validationMessage.textContent = 'Invalid format. Please use DD-MM-YYYY HH:MM:SS';
        dispatchdatetimeInput.reportValidity();
        return; // Stop further checks
    }

    try {
        // Parse the parts of the date and time
        const parts = value.split(' ');
        const dateParts = parts[0].split('-');
        const timeParts = parts[1].split(':');

        const day = parseInt(dateParts[0]);
        const month = parseInt(dateParts[1]);
        const year = parseInt(dateParts[2]);
        const hours = parseInt(timeParts[0]);
        const minutes = parseInt(timeParts[1]);
        const seconds = parseInt(timeParts[2]);

        // Validate the date and time components
        if (month < 1 || month > 12) {
            throw new Error("Month must be between 01 and 12.");
        }
        if (day < 1 || day > 31) {
            throw new Error("Day must be between 01 and 31.");
        }
        // Validation for 12-hour format (1 to 12)
        if (hours < 1 || hours > 12) {
            throw new Error("Hours must be between 01 and 12.");
        }
        if (minutes < 0 || minutes > 59) {
            throw new Error("Minutes must be between 00 and 59.");
        }
        if (seconds < 0 || seconds > 59) {
            throw new Error("Seconds must be between 00 and 59.");
        }

        // If all checks pass, clear any previous errors
        dispatchdatetimeInput.classList.add('success');
        validationMessage.classList.add('success');
        validationMessage.textContent = 'Valid date and time format.';
        dispatchdatetimeInput.setCustomValidity('');

    } catch (e) {
        // If any check fails, show an error message
        dispatchdatetimeInput.classList.add('error');
        validationMessage.classList.add('error');
        validationMessage.textContent = e.message;
        dispatchdatetimeInput.setCustomValidity(e.message);
        dispatchdatetimeInput.reportValidity();
    }
});


// --- END OF CORRECTED LOGIC ---
            // Address input change handler
            addressInput.addEventListener('input', updateAddressAndDestination);
            
            // Distance input change handler
            distanceInput.addEventListener('input', () => {
                let value = distanceInput.value.replace(/[^0-9]/g, '');
                distanceInput.value = value;
            });
            
            dialogSave.addEventListener('click', saveDialogText);
            dialogCancel.addEventListener('click', closeDialog);
            dialogInput.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter') saveDialogText(); 
                else if (e.key === 'Escape') closeDialog(); 
            });
            textColorInput.addEventListener('change', (e) => { currentTextColor = e.target.value; });
            boldBtn.addEventListener('click', () => { 
                currentTextBold = !currentTextBold; 
                boldBtn.classList.toggle('active'); 
                if (currentTextBold) {
                    currentTextThin = false;
                    thinBtn.classList.remove('active');
                }
            });
            thinBtn.addEventListener('click', () => { 
                currentTextThin = !currentTextThin; 
                thinBtn.classList.toggle('active'); 
                if (currentTextThin) {
                    currentTextBold = false;
                    boldBtn.classList.remove('active');
                }
            });
            fontSelect.addEventListener('change', (e) => { 
                currentFontFamily = e.target.value;
                if (currentFontFamily === 'Roboto Thin') {
                    currentTextThin = true;
                    currentTextBold = false;
                    thinBtn.classList.add('active');
                    boldBtn.classList.remove('active');
                } else if (currentFontFamily === 'Roboto Bold' || currentFontFamily === 'Roboto Black') {
                    currentTextBold = true;
                    currentTextThin = false;
                    boldBtn.classList.add('active');
                    thinBtn.classList.remove('active');
                } else {
                    currentTextBold = false;
                    currentTextThin = false;
                    boldBtn.classList.remove('active');
                    thinBtn.classList.remove('active');
                }
            });
            
            // Close modals when clicking outside
            window.addEventListener('click', (event) => {
                if (event.target === saveEditsModal) closeSaveEditsModal();
                if (event.target === loadEditsModal) closeLoadEditsModal();
                if (event.target === qrModal) closeQRModal();
            });
        }
        
        // Handle image selection for replacement
        function handleImageSelect(e) {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith('image/') || !currentEditingImageItem) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const imageData = event.target.result;
                const itemIndex = currentEditingImageItem.index;

                // Update master state
                if (!allPageEdits[pageNum]) allPageEdits[pageNum] = { textEdits: [], images: [] };
                const pageEdits = allPageEdits[pageNum];
                const existingImageEdit = pageEdits.images.find(edit => edit.index === itemIndex);
                
                if (existingImageEdit) {
                    existingImageEdit.data = imageData;
                } else {
                    pageEdits.images.push({ index: itemIndex, data: imageData });
                }

                // Update derived state
                const imageItem = imageItems.find(item => item.index === itemIndex);
                if (imageItem) {
                    imageItem.edited = true;
                    imageItem.newImageData = imageData;
                }

                // Redraw UI - IMPORTANT: Clear and redraw everything
                redrawEditedContent();
                if(currentEditingImageItem.box) {
                    currentEditingImageItem.box.classList.add('edited');
                }
                showNotification('Image replaced and saved.');
            };
            reader.readAsDataURL(file);
            imageInput.value = '';
        }
        
        // --- MODAL FUNCTIONS ---
        
        function openSaveEditsModal() {
            saveEditsModal.style.display = 'block';
            const today = new Date();
            const dateStr = today.toISOString().slice(0, 10);
            saveFilenameInput.value = `PDF Edits ${dateStr}`;
        }
        
        function closeSaveEditsModal() {
            saveEditsModal.style.display = 'none';
        }
        
        function openLoadEditsModal() {
            loadEditsModal.style.display = 'block';
        }
        
        function closeLoadEditsModal() {
            loadEditsModal.style.display = 'none';
            loadFileInput.value = '';
            loadFileName.textContent = 'No file selected';
        }
        
        function updateLoadFileName() {
            if (loadFileInput.files.length > 0) {
                loadFileName.textContent = loadFileInput.files[0].name;
            } else {
                loadFileName.textContent = 'No file selected';
            }
        }
        
      // --- QR CODE MODAL FUNCTIONS ---

async function detectQRCodeArea() {
    if (!pdfDoc) return null;
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2.0 });
        
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = viewport.width;
        tempCanvas.height = viewport.height;
        
        await page.render({
            canvasContext: tempCtx,
            viewport: viewport
        }).promise;
        
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const pixels = imageData.data;
        
        const qrAreas = [];
        const minSize = 30;
        const maxSize = 200;
        
        for (let y = 0; y < tempCanvas.height - minSize; y += 10) {
            for (let x = 0; x < tempCanvas.width - minSize; x += 10) {
                for (let size = minSize; size <= maxSize && size < Math.min(tempCanvas.width - x, tempCanvas.height - y); size += 10) {
                    const corners = [
                        { x: x, y: y },
                        { x: x + size - 1, y: y },
                        { x: x, y: y + size - 1 },
                        { x: x + size - 1, y: y + size - 1 }
                    ];
                    
                    const cornerColors = corners.map(corner => {
                        const index = (corner.y * tempCanvas.width + corner.x) * 4;
                        return {
                            r: pixels[index],
                            g: pixels[index + 1],
                            b: pixels[index + 2]
                        };
                    });
                    
                    const hasBlack = cornerColors.some(c => c.r < 50 && c.g < 50 && c.b < 50);
                    const hasWhite = cornerColors.some(c => c.r > 200 && c.g > 200 && c.b > 200);
                    
                    if (hasBlack && hasWhite) {
                        const centerIndex = ((y + size/2) * tempCanvas.width + (x + size/2)) * 4;
                        const centerColor = {
                            r: pixels[centerIndex],
                            g: pixels[centerIndex + 1],
                            b: pixels[centerIndex + 2]
                        };
                        
                        if (centerColor.r > 50 && centerColor.r < 200) {
                            qrAreas.push({
                                x: x / 2.0,
                                y: y / 2.0,
                                width: size / 2.0,
                                height: size / 2.0,
                                confidence: 0.8
                            });
                            break;
                        }
                    }
                }
            }
        }
        
        if (qrAreas.length > 0) {
            qrAreas.sort((a, b) => (b.confidence * b.width) - (a.confidence * a.width));
            return qrAreas[0];
        }
        
        return null;
    } catch (error) {
        console.error('Error detecting QR code area:', error);
        return null;
    }
}

// --- QR CODE MODAL FUNCTIONS ---



/**
 * Formats all form data into a single string for generating a QR code.
 * This function reads the time value and removes the AM/PM suffix for the output.
 */
function getFormDataForQR() {
    // --- Get all the necessary form elements ---
    const securityInput = document.getElementById('security-input');
    const transitInput = document.getElementById('transit-input');
    const quantityInput = document.getElementById('quantity-input');
    const vehicleInput = document.getElementById('vehicle-input');
    const addressInput = document.getElementById('address-input');
    const timestartInput = document.getElementById('timestart-input');
    const distanceInput = document.getElementById('distance-input');
    const hoursInput = document.getElementById('hours-input');

    // --- Get the values from the input fields, with 'N/A' as a fallback ---
    const securityNo = securityInput ? securityInput.value : 'N/A';
    const transitPassNo = transitInput ? transitInput.value : 'N/A';
    const quantity = quantityInput ? quantityInput.value : 'N/A';
    const vehicleNo = vehicleInput ? vehicleInput.value : 'N/A';
    const address = addressInput ? addressInput.value : 'N/A';
    const startTime = timestartInput ? timestartInput.value : 'N/A';
    const distance = distanceInput ? distanceInput.value : 'N/A';
    const hours = hoursInput ? hoursInput.value : 'N/A';

    // --- Remove AM/PM from the startTime string ---
    // The .replace() method finds all occurrences of "AM" or "PM" (case-insensitive)
    // and removes them. The 'g' flag ensures it replaces all matches, and 'i' makes it case-insensitive.
    // .trim() removes any extra space left behind.
    const cleanedStartTime = startTime.replace(/\s?(AM|PM)\s?/gi, '').trim();

    // --- Format the data into the desired string for the QR code ---
    // Note: The static value 'THNN0047' is included directly in the template string.
    // The 'kms' and 'hrs' are added to the distance and hours values.
    return `${securityNo},${transitPassNo},THNN0047,${cleanedStartTime},${distance}kms,${hours}hrs ,Rough Stone(${quantity}MT),${vehicleNo},${address}`;
}


async function detectQRCodeArea() {
    if (!pdfDoc) return null;
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2.0 });
        
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = viewport.width;
        tempCanvas.height = viewport.height;
        
        await page.render({
            canvasContext: tempCtx,
            viewport: viewport
        }).promise;
        
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const pixels = imageData.data;
        
        const qrAreas = [];
        const minSize = 30;
        const maxSize = 200;
        
        for (let y = 0; y < tempCanvas.height - minSize; y += 10) {
            for (let x = 0; x < tempCanvas.width - minSize; x += 10) {
                for (let size = minSize; size <= maxSize && size < Math.min(tempCanvas.width - x, tempCanvas.height - y); size += 10) {
                    const corners = [
                        { x: x, y: y },
                        { x: x + size - 1, y: y },
                        { x: x, y: y + size - 1 },
                        { x: x + size - 1, y: y + size - 1 }
                    ];
                    
                    const cornerColors = corners.map(corner => {
                        const index = (corner.y * tempCanvas.width + corner.x) * 4;
                        return {
                            r: pixels[index],
                            g: pixels[index + 1],
                            b: pixels[index + 2]
                        };
                    });
                    
                    const hasBlack = cornerColors.some(c => c.r < 50 && c.g < 50 && c.b < 50);
                    const hasWhite = cornerColors.some(c => c.r > 200 && c.g > 200 && c.b > 200);
                    
                    if (hasBlack && hasWhite) {
                        const centerIndex = ((y + size/2) * tempCanvas.width + (x + size/2)) * 4;
                        const centerColor = {
                            r: pixels[centerIndex],
                            g: pixels[centerIndex + 1],
                            b: pixels[centerIndex + 2]
                        };
                        
                        if (centerColor.r > 50 && centerColor.r < 200) {
                            qrAreas.push({
                                x: x / 2.0,
                                y: y / 2.0,
                                width: size / 2.0,
                                height: size / 2.0,
                                confidence: 0.8
                            });
                            break;
                        }
                    }
                }
            }
        }
        
        if (qrAreas.length > 0) {
            qrAreas.sort((a, b) => (b.confidence * b.width) - (a.confidence * a.width));
            return qrAreas[0];
        }
        
        return null;
    } catch (error) {
        console.error('Error detecting QR code area:', error);
        return null;
    }
}

async function openQRModal() {
    qrModal.style.display = 'block';
    
    // Call the function to get the data from the form
    const qrTextFromForm = getFormDataForQR();
    
    const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
    const existingQRCode = pageEdits.textEdits.find(edit => edit.isQRCode);
    
    if (existingQRCode) {
        qrTextInput.value = qrTextFromForm;
        const existingSize = Math.round(existingQRCode.width / scale);
        qrSizeSlider.value = existingSize;
        qrSizeValue.textContent = `${existingSize}px`;
        qrCodeSize = existingSize;
    } else {
        const detectedQR = await detectQRCodeArea();
        if (detectedQR) {
            qrTextInput.value = qrTextFromForm;
            window.detectedQRPosition = detectedQR;
        } else {
            qrTextInput.value = qrTextFromForm;
            qrSizeSlider.value = 198;
            qrSizeValue.textContent = '198px';
            qrCodeSize = 198;
        }
    }
    
    generateQRCodePreview();
}

function closeQRModal() {
    qrModal.style.display = 'none';
    qrCodePreview.innerHTML = '';
    qrcode = null;
    // Clear the stored canvas when closing the modal
    if (window.qrCodeCanvas) {
        window.qrCodeCanvas = null;
    }
}

// --- FIXED QR CODE GENERATION AND DOWNLOAD ---

function generateQRCodePreview() {
    const text = qrTextInput.value.trim();
    if (!text) {
        qrCodePreview.innerHTML = '<p>Please enter text for the QR code</p>';
        if (window.qrCodeCanvas) {
            window.qrCodeCanvas = null;
        }
        // Disable download button if there's no QR code
        const downloadBtn = document.getElementById('qr-download-btn');
        if(downloadBtn) downloadBtn.disabled = true;
        return;
    }
    
    qrCodePreview.innerHTML = '<p>Generating QR Code...</p>';
    
    // Create a container div for the QR code
    const qrContainer = document.createElement('div');
    qrContainer.id = 'qr-container';
    qrContainer.style.display = 'inline-block';
    qrContainer.style.boxShadow = '0 0 10px rgba(0,0,0,0.1)';
    qrContainer.style.padding = '18px';
    qrContainer.style.backgroundColor = 'white';
    
    // Add the container to the preview
    qrCodePreview.innerHTML = '';
    qrCodePreview.appendChild(qrContainer);
    
    // Generate QR code using the local library
    qrcode = new QRCode(qrContainer, {
        text: text,
        width: qrCodeSize,
        height: qrCodeSize,
        colorDark: '#000000',
        colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.H
    });
    
    // Create a canvas to store the QR code for download
    setTimeout(() => {
        const qrImage = qrContainer.querySelector('img');
        if (qrImage) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const padding = 18;
            
            canvas.width = qrCodeSize + (padding * 2);
            canvas.height = qrCodeSize + (padding * 2);
            
            // Fill with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw the QR code image
            qrImage.onload = function() {
                ctx.drawImage(qrImage, padding, padding, qrCodeSize, qrCodeSize);
                
                // Store the canvas for download
                window.qrCodeCanvas = canvas;
                
                // Enable download button
                const downloadBtn = document.getElementById('qr-download-btn');
                if(downloadBtn) downloadBtn.disabled = false;
            };
            
            // If the image is already loaded
            if (qrImage.complete) {
                ctx.drawImage(qrImage, padding, padding, qrCodeSize, qrCodeSize);
                
                // Store the canvas for download
                window.qrCodeCanvas = canvas;
                
                // Enable download button
                const downloadBtn = document.getElementById('qr-download-btn');
                if(downloadBtn) downloadBtn.disabled = false;
            }
        }
    }, 300); // Increased delay to ensure QR code is fully rendered
}

// --- UPDATED: The slider now updates on 'input' event ---
function updateQRSize() {
    qrCodeSize = parseInt(qrSizeSlider.value);
    qrSizeValue.textContent = `${qrCodeSize}px`;
    
    if (qrTextInput.value.trim()) {
        generateQRCodePreview();
    }
}

// --- UPDATED: The download function is simpler now ---
function downloadQRCode() {
    if (!window.qrCodeCanvas) {
        showNotification('QR code not ready. Please wait for it to generate.');
        return;
    }
    
    const link = document.createElement('a');
    link.download = 'qrcode.png';
    link.href = window.qrCodeCanvas.toDataURL('image/png');
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showNotification('QR code downloaded successfully!');
}

function addQRCodeToPDF() {
    const text = qrTextInput.value.trim();
    if (!text) {
        showNotification('Please enter text for the QR code');
        return;
    }
    
    if (!pdfDoc) {
        showNotification('No PDF loaded');
        return;
    }

    if (!window.qrCodeCanvas) {
        showNotification('Error: QR code has not been generated yet.');
        return;
    }
    
    const qrDataUrl = window.qrCodeCanvas.toDataURL('image/png');
    
    if (currentQRCodeBox) {
        currentQRCodeBox.remove();
    }
    
    const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
    const existingQRCodeIndex = pageEdits.textEdits.findIndex(edit => edit.isQRCode);
    if (existingQRCodeIndex !== -1) {
        pageEdits.textEdits.splice(existingQRCodeIndex, 1);
    }
    
    let x, y, width, height;
    
    if (window.detectedQRPosition) {
        x = window.detectedQRPosition.x;
        y = window.detectedQRPosition.y;
        width = window.detectedQRPosition.width;
        height = window.detectedQRPosition.height;
        window.detectedQRPosition = null;
    } else {
        const padding = 20;
        width = qrCodeSize + (padding * 2);
        height = qrCodeSize + (padding * 2);
        
        switch (qrCodePosition) {
            case 'top-left': x = padding; y = padding; break;
            case 'top-center': x = (currentViewport.width - width) / 2; y = padding; break;
            case 'top-right': x = currentViewport.width - width - padding; y = padding; break;
            case 'middle-left': x = padding; y = (currentViewport.height - height) / 2; break;
            case 'middle-center': x = (currentViewport.width - width) / 2; y = (currentViewport.height - height) / 2; break;
            case 'middle-right': x = currentViewport.width - width - padding; y = (currentViewport.height - height) / 2; break;
            case 'bottom-left': x = padding; y = currentViewport.height - height - padding; break;
            case 'bottom-center': x = (currentViewport.width - width) / 2; y = currentViewport.height - height - padding; break;
            case 'bottom-right': x = currentViewport.width - width - padding; y = currentViewport.height - height - padding; break;
            default: x = (currentViewport.width - width) / 2; y = (currentViewport.height - height) / 2;
        }
    }
    
    const qrBox = document.createElement('div');
    qrBox.className = 'qr-box';
    qrBox.dataset.page = pageNum;
    
    const pdfPageRect = pdfPage.getBoundingClientRect();
    const canvasRect = canvasWrapper.getBoundingClientRect();
    
    const left = (canvasRect.left - pdfPageRect.left) + (x * scale);
    const top = (canvasRect.top - pdfPageRect.top) + ((y - height) * scale);
    
    qrBox.style.left = left + 'px';
    qrBox.style.top = top + 'px';
    qrBox.style.width = (width * scale) + 'px';
    qrBox.style.height = (height * scale) + 'px';
    
    const qrImg = document.createElement('img');
    qrImg.src = qrDataUrl;
    qrBox.appendChild(qrImg);
    
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle se';
    qrBox.appendChild(resizeHandle);
    
    // Drag functionality
    let isDragging = false;
    let startX, startY, initialX, initialY;
    
    qrBox.addEventListener('mousedown', (e) => {
        if (e.target === resizeHandle) return;
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        initialX = qrBox.offsetLeft;
        initialY = qrBox.offsetTop;
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', stopDrag);
        e.preventDefault();
    });
    
    function handleDrag(e) {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        qrBox.style.left = (initialX + dx) + 'px';
        qrBox.style.top = (initialY + dy) + 'px';
    }
    
    function stopDrag() {
        isDragging = false;
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('mouseup', stopDrag);
        updateQRCodeInStorage(qrBox);
    }
    
    // Resize functionality
    let isResizing = false;
    let startWidth, startHeight;
    
    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = qrBox.offsetWidth;
        startHeight = qrBox.offsetHeight;
        document.addEventListener('mousemove', handleResize);
        document.addEventListener('mouseup', stopResize);
        e.stopPropagation();
        e.preventDefault();
    });
    
    function handleResize(e) {
        if (!isResizing) return;
        const width = startWidth + (e.clientX - startX);
        const height = startHeight + (e.clientY - startY);
        const size = Math.max(width, height);
        qrBox.style.width = size + 'px';
        qrBox.style.height = size + 'px';
    }
    
    function stopResize() {
        isResizing = false;
        document.removeEventListener('mousemove', handleResize);
        document.removeEventListener('mouseup', stopResize);
        updateQRCodeInStorage(qrBox);
    }
    
    pdfPage.appendChild(qrBox);
    qrCodeBoxes.push(qrBox);
    currentQRCodeBox = qrBox;
    
    if (!allPageEdits[pageNum]) {
        allPageEdits[pageNum] = { textEdits: [], images: [] };
    }
    
    allPageEdits[pageNum].textEdits.push({
        isQRCode: true,
        text: text,
        x: x,
        y: y,
        width: width,
        height: height,
        qrCodeDataUrl: qrDataUrl
    });
    
    closeQRModal();
    showNotification('QR code added to PDF');
}

function updateQRCodeInStorage(qrBox) {
    if (!allPageEdits[pageNum]) {
        allPageEdits[pageNum] = { textEdits: [], images: [] };
    }
    
    const canvasRect = canvasWrapper.getBoundingClientRect();
    const pdfPageRect = pdfPage.getBoundingClientRect();
    
    const x = (qrBox.offsetLeft - (canvasRect.left - pdfPageRect.left)) / scale;
    const y = (qrBox.offsetTop - (canvasRect.top - pdfPageRect.top) + qrBox.offsetHeight) / scale;
    const width = qrBox.offsetWidth / scale;
    const height = qrBox.offsetHeight / scale;
    
    const qrCodeIndex = allPageEdits[pageNum].textEdits.findIndex(edit => edit.isQRCode);
    
    if (qrCodeIndex !== -1) {
        allPageEdits[pageNum].textEdits[qrCodeIndex].x = x;
        allPageEdits[pageNum].textEdits[qrCodeIndex].y = y;
        allPageEdits[pageNum].textEdits[qrCodeIndex].width = width;
        allPageEdits[pageNum].textEdits[qrCodeIndex].height = height;
    }
}

// --- END OF QR CODE MODAL FUNCTIONS ---
// --- END OF QR CODE MODAL FUNCTIONS ---
        // --- SAVE/LOAD EDIT FUNCTIONS ---
        
        function saveEditsToFile() {
            if (!pdfDoc) {
                showNotification('No PDF loaded to save edits for');
                return;
            }
            
            const filename = saveFilenameInput.value || 'PDF Edits';
            
            const editsData = {
                pdfHash: pdfHash,
                originalTextStyles: originalTextStyles,
                allPageEdits: allPageEdits,
                timestamp: new Date().toISOString()
            };
            
            const jsonStr = JSON.stringify(editsData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            closeSaveEditsModal();
            showNotification('PDF edits saved successfully');
        }
        
        function loadEditsFromFile() {
            if (!loadFileInput.files.length) {
                showNotification('Please select a file to load');
                return;
            }
            
            const file = loadFileInput.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const editsData = JSON.parse(e.target.result);
                    
                    if (!editsData.allPageEdits || !editsData.originalTextStyles) {
                        throw new Error('Invalid edits file format');
                    }
                    
                    allPageEdits = editsData.allPageEdits;
                    originalTextStyles = editsData.originalTextStyles;
                    
                    renderPage(pageNum);
                    
                    closeLoadEditsModal();
                    showNotification('PDF edits loaded successfully');
                } catch (error) {
                    console.error('Error loading edits:', error);
                    showNotification('Error loading edits: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        }
        
        // Load sample PDF automatically
        async function loadSamplePdf() {
            showLoading(true);
            try {
                const response = await fetch('Stone.pdf');
                if (!response.ok) {
                    throw new Error('Failed to load Stone.pdf');
                }
                const arrayBuffer = await response.arrayBuffer();
                pdfHash = await generatePdfHash(arrayBuffer);
                
                allPageEdits = {};
                originalTextStyles = {};
                formFields = {};
                qrCodeBoxes = [];
                currentQRCodeBox = null;
                imageItems = [];
                imageBoxes = [];
                currentEditingImageItem = null;

                const typedarray = new Uint8Array(arrayBuffer);
                pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                    pdfDoc = pdf;
                    pageCount = pdf.numPages;
                    pageNum = 1;
                    renderPage(pageNum);
                    showNotification('Stone.pdf loaded successfully.');
                }).catch(error => {
                    console.error('Error loading Stone.pdf:', error);
                    showNotification('Error loading Stone.pdf: ' + error.message);
                    showLoading(false);
                });
            } catch (error) {
                console.error('Error loading Stone.pdf:', error);
                showNotification('Stone.pdf not found. Please ensure Stone.pdf is in the same directory.');
                showLoading(false);
            }
        }
 
        // Update both address and destination fields when address changes
        function updateAddressAndDestination() {
            const addressValue = addressInput.value.trim();
            
            if (formFields.address && formFields.address.length > 0) {
                formFields.address.forEach((field, index) => {
                    const textItem = textItems.find(item => item.originalIndex === field.originalIndex);
                    if (textItem) {
                        textItem.text = addressValue;
                        textItem.edited = true;
                        updateTextItem(textItem);
                    }
                });
            }
    
        }
        

        // Generate a simple hash from PDF data
        async function generatePdfHash(arrayBuffer) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return 'pdfEdits_' + hashHex;
        }
        



        // Extract all styles from a text item
        function extractTextStyles(item) {
            const styles = {
                color: '#000000',
                fontFamily: 'Roboto',
                fontWeight: 'normal',
                isBold: false,
                isThin: false
            };
            
            if (item.color && Array.isArray(item.color) && item.color.length >= 3) {
                const r = Math.round(item.color[0] * 255);
                const g = Math.round(item.color[1] * 255);
                const b = Math.round(item.color[2] * 255);
                styles.color = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            if (item.fontName) {
                const fontName = item.fontName.toLowerCase();
                
                if (fontName.includes('helvetica') || fontName.includes('arial')) {
                    styles.fontFamily = 'Arial';
                } else if (fontName.includes('times')) {
                    styles.fontFamily = 'Times New Roman';
                } else if (fontName.includes('courier')) {
                    styles.fontFamily = 'Courier New';
                } else {
                    styles.fontFamily = 'Roboto';
                }
                
                if (fontName.includes('bold') || fontName.includes('black')) {
                    styles.fontWeight = 'bold';
                    styles.isBold = true;
                } else if (fontName.includes('thin') || fontName.includes('light')) {
                    styles.fontWeight = 'thin';
                    styles.isThin = true;
                } else {
                    styles.fontWeight = 'normal';
                }
            }
            
            return styles;
        }

        // Render PDF page
        function renderPage(num) {
            if (!pdfDoc) return;
            
            showLoading(true);
            clearTextBoxes();
            clearImageBoxes();
            clearQRCodeBoxes();
            
            pdfDoc.getPage(num).then(page => {
                currentViewport = page.getViewport({ scale: scale });
                originalPageSize = { width: currentViewport.width, height: currentViewport.height };

                pdfCanvas.width = currentViewport.width;
                pdfCanvas.height = currentViewport.height;
                editCanvas.width = currentViewport.width;
                editCanvas.height = currentViewport.height;
                canvasWrapper.style.width = currentViewport.width + 'px';
                canvasWrapper.style.height = currentViewport.height + 'px';
                
                const renderContext = { canvasContext: pdfCtx, viewport: currentViewport };
                return page.render(renderContext).promise;
            }).then(() => {
                return pdfDoc.getPage(pageNum).then(page => {
                    return page.getTextContent({ normalizeWhitespace: false, disableCombineTextItems: false });
                });
            }).then(textContent => {
                const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
                const newTextItems = [];

                if (textContent && textContent.items) {
                    const allTextItems = [];
                    textContent.items.forEach((item, index) => {
                        if (item.str && item.str.trim() !== '') {
                            const transform = item.transform;
                            const tx = pdfjsLib.Util.transform(currentViewport.transform, transform);
                            const x = tx[4];
                            const y = tx[5];
                            const width = item.width * scale;
                            const height = (item.height || 12) * scale;
                            
                            allTextItems.push({
                                text: item.str,
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                fontSize: (item.height || 12) * scale,
                                originalIndex: index,
                                item: item
                            });
                        }
                    });
                    
                    const groupedTextItems = groupTextItems(allTextItems);
                    
                    groupedTextItems.forEach((item, index) => {
                        const itemKey = `${pageNum}_${index}`;
                        
                        if (!originalTextStyles[itemKey]) {
                            originalTextStyles[itemKey] = extractTextStyles(item.item);
                        }
                        
                        const existingEdit = pageEdits.textEdits.find(edit => edit.originalIndex === index);
                        
                        const finalStyles = existingEdit ? {
                            color: existingEdit.color || originalTextStyles[itemKey].color,
                            fontFamily: existingEdit.fontFamily || originalTextStyles[itemKey].fontFamily,
                            fontWeight: existingEdit.fontWeight || originalTextStyles[itemKey].fontWeight,
                            isBold: existingEdit.isBold !== undefined ? existingEdit.isBold : originalTextStyles[itemKey].isBold,
                            isThin: existingEdit.isThin !== undefined ? existingEdit.isThin : originalTextStyles[itemKey].isThin
                        } : originalTextStyles[itemKey];

                        newTextItems.push({
                            text: existingEdit ? existingEdit.text : item.text,
                            x: item.x,
                            y: item.y,
                            width: item.width,
                            height: item.height,
                            fontSize: item.fontSize,
                            originalIndex: index,
                            edited: !!existingEdit,
                            color: finalStyles.color,
                            fontFamily: finalStyles.fontFamily,
                            fontWeight: finalStyles.fontWeight,
                            isBold: finalStyles.isBold,
                            isThin: finalStyles.isThin,
                            originalIndices: item.originalIndices || [index]
                        });
                    });
                }
                
                textItems = newTextItems;
                identifyFormFields(textItems);
                createTextBoxes();
                
                return pdfDoc.getPage(pageNum).then(page => {
                    return page.getOperatorList();
                });
            }).then(operatorList => {
                const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
                const newImageItems = [];
                
                let imageIndex = 0;
                if(operatorList && operatorList.fnArray) {
                    for (let i = 0; i < operatorList.fnArray.length; i++) {
                        if (operatorList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                            for (let j = i - 1; j >= 0; j--) {
                                if (operatorList.fnArray[j] === pdfjsLib.OPS.transform) {
                                    const transform = operatorList.argsArray[j];
                                    const [a, b, c, d, e, f] = transform;
                                    const imageWidth = Math.sqrt(a * a + b * b) * scale;
                                    const imageHeight = Math.sqrt(c * c + d * d) * scale;
                                    const x = e * scale;
                                    const y = (currentViewport.height - f * scale - imageHeight);

                                    const existingEdit = pageEdits.images.find(edit => edit.index === imageIndex);
                                    
                                    newImageItems.push({
                                        index: imageIndex,
                                        x: x,
                                        y: y,
                                        width: imageWidth,
                                        height: imageHeight,
                                        edited: !!existingEdit,
                                        newImageData: existingEdit ? existingEdit.data : null
                                    });
                                    imageIndex++;
                                    break;
                                }
                            }
                        }
                    }
                }
                imageItems = newImageItems;
                
                createImageBoxes();
                loadQRCodeBoxes();
                redrawEditedContent();
                showLoading(false);
            }).catch(error => {
                console.error('Error rendering page:', error);
                showNotification('Error rendering page: ' + error.message);
                showLoading(false);
            });
            
            updatePageInfo();
            updateZoomLevel();
        }
        
        // Group text items that should be treated as a single element
        function groupTextItems(allTextItems) {
            const groupedItems = [];
            const processed = new Set();
            
            for (let i = 0; i < allTextItems.length; i++) {
                if (processed.has(i)) continue;
                
                const currentItem = allTextItems[i];
                let groupItem = { ...currentItem, originalIndices: [i] };
                
                if (i < allTextItems.length - 1) {
                    const nextItem = allTextItems[i + 1];
                    
                    const xDistance = Math.abs(nextItem.x - (currentItem.x + currentItem.width));
                    const yDistance = Math.abs(nextItem.y - currentItem.y);
                    
                    if (xDistance < 20 && yDistance < 5) {
                        groupItem.text += nextItem.text;
                        groupItem.width = nextItem.x + nextItem.width - currentItem.x;
                        groupItem.originalIndices.push(i + 1);
                        processed.add(i + 1);
                        
                        if (i < allTextItems.length - 2) {
                            const thirdItem = allTextItems[i + 2];
                            const xDistance2 = Math.abs(thirdItem.x - (nextItem.x + nextItem.width));
                            const yDistance2 = Math.abs(thirdItem.y - currentItem.y);
                            
                            if (xDistance2 < 20 && yDistance2 < 5) {
                                groupItem.text += thirdItem.text;
                                groupItem.width = thirdItem.x + thirdItem.width - currentItem.x;
                                groupItem.originalIndices.push(i + 2);
                                processed.add(i + 2);
                            }
                        }
                        
                        if (i < allTextItems.length - 3) {
                            const fourthItem = allTextItems[i + 3];
                            const xDistance3 = Math.abs(fourthItem.x - (allTextItems[i + 2].x + allTextItems[i + 2].width));
                            const yDistance3 = Math.abs(fourthItem.y - currentItem.y);
                            
                            if (xDistance3 < 20 && yDistance3 < 5) {
                                groupItem.text += fourthItem.text;
                                groupItem.width = fourthItem.x + fourthItem.width - currentItem.x;
                                groupItem.originalIndices.push(i + 3);
                                processed.add(i + 3);
                            }
                        }
                    }
                }
                
                groupedItems.push(groupItem);
                processed.add(i);
            }
            
            return groupedItems;
        }
        
// Identify form fields in the text items
function identifyFormFields(allTextItems) {
    formFields = {};
 
    allTextItems.forEach((item, index) => {
        const text = item.text.trim();
        
        // --- Using .includes() for more reliable matching ---

        if (text.includes("M/s.SRI VENKATESWARA BLUE METALS")) {
            formFields.purchaser = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
        
        // --- UPDATED: Smart logic for Bulk Permit No ---
        else if (text.includes("Bulk Permit No")) {
            const colonIndex = text.indexOf(':');
            if (colonIndex !== -1) {
                const prefix = text.substring(0, colonIndex + 1); // "Bulk Permit No :"
                const value = text.substring(colonIndex + 1).trim(); // "THN250000665"
                formFields.BulkTransit = { 
                    x: item.x, y: item.y, width: item.width, height: item.height, 
                    fontSize: item.fontSize, originalIndex: index,
                    prefix: prefix, // <-- Save the prefix
                    value: value    // <-- Save the original value
                };
            }
        }

        // This is for a standalone "Yes" text
else if (text === "Yes") {
    formFields.StoInput = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
    // Also check the "Yes" radio button when "Yes" text is found
    stoneYesRadio.checked = true;
} 
// This is for a standalone "No" text
else if (text === "No") {
    formFields.StoInput = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
    // Also check the "No" radio button when "No" text is found
    stoneNoRadio.checked = true;
}
// --- UPDATED: Smart logic for Serial No ---
else if (text.includes("ARUN")) {
    formFields.security = { 
        x: item.x, 
        y: item.y, 
        width: item.width, 
        height: item.height, 
        fontSize: item.fontSize, 
        color: "#808080",
        originalIndex: index,
        // Add these properties to match the PDF editing structure
        fontFamily: item.fontFamily || "Roboto",
        fontWeight: item.fontWeight || "normal",
        isBold: item.isBold || false,
        isThin: item.isThin || false
    };
}
        
        else if (text.includes("DISP591252")) {
            formFields.transit = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
        

        
        else if (text.includes("SF : 199/5, Silamalai, Bodinayakanur, Theni")) {
            if (!formFields.address) {
                formFields.address = [];
            }
            formFields.address.push({ x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index });
        } 
        
        else if (text.includes("Veera")) {
            formFields.driver = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
        
            else if (text.includes("Tnz20060002904")) {
            formFields.driver2 = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
        
            else if (text.includes("8072070828")) {
            formFields.driver3 = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
           else if (text.includes("8124091612")) {
            formFields.driver4 = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
        
        else if (text.includes("KL63H7327")) {
            formFields.vehicle = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
             else if (text.includes("Taurus 19")) {
            formFields.vehicle2 = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
        
        // Using a regex to find a quantity is more flexible than a hardcoded number
        else if (text.match(/^\d{1,3}$/)) { 
            formFields.quantity = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
        else if (text === "15") {
                    formFields.quantity = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } 
    else if (text === "03-05-2025 12:28 pm") {
                    formFields.timestart = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "1hrs (03-05-2025 01:28 pm)") {
                    formFields.timeend = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } 
        else if (text.includes("1hrs")) {
            formFields.timeend = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
        } 
 
   
     
       
         
// --- ROBUST DISPATCHDATETIME IDENTIFICATION (Handles Missing Colon) ---
else if (text.includes("Date & Time of Dispatch") || text.includes("Date and Time of Dispatch")) {
    // We found the label. We don't need to find a colon.
    // We will assume the value is the next text item.
    formFields.DisPatch = { 
        x: item.x, y: item.y, width: item.width, height: item.height, 
        fontSize: item.fontSize, originalIndex: index,
        prefix: text.trim(), // The whole text is the label
        value: null,         // The value is not in this item
        valueIsNextItem: true // <-- IMPORTANT: Flag to find the value in the next item
    };
}
        
        
        // --- REMOVED: All complex handling for dispatchdatetimeSeconds ---
        
        else if (text.includes("897700")) {
            formFields.distance = { 
                x: item.x, y: item.y, width: item.width, height: item.height, 
                fontSize: item.fontSize, originalIndex: index, fullText: item.text
            };
        }
    });

    // This part of the code remains the same and is still useful
    // BUT we no longer need to find a separate 'seconds' field.
    // The entire logic for dispatchdatetimeSeconds is now removed.
}
        
        

        function createTextBoxes() {
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();
            
            textItems.forEach((item, index) => {
                const textBox = document.createElement('div');
                textBox.className = 'text-box';
                if (item.edited) textBox.classList.add('edited');
                textBox.dataset.index = item.originalIndex;
                textBox.title = item.text;
                
                const left = (canvasRect.left - pdfPageRect.left) + item.x;
                const top = (canvasRect.top - pdfPageRect.top) + (item.y - item.height);
                
                textBox.style.left = left + 'px';
                textBox.style.top = top + 'px';
                textBox.style.width = item.width + 'px';
                textBox.style.height = item.height + 'px';
                
                textBox.addEventListener('click', (e) => { e.stopPropagation(); editText(item, textBox); });
                pdfPage.appendChild(textBox);
                textBoxes.push(textBox);
            });
        }
        
        // Create clickable overlays for images
        function createImageBoxes() {
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();

            imageItems.forEach((item) => {
                const imageBox = document.createElement('div');
                imageBox.className = 'image-box';
                if (item.edited) imageBox.classList.add('edited');
                imageBox.title = "Click to replace image";
                
                const left = (canvasRect.left - pdfPageRect.left) + item.x;
                const top = (canvasRect.top - pdfPageRect.top) + item.y;
                
                imageBox.style.left = left + 'px';
                imageBox.style.top = top + 'px';
                imageBox.style.width = item.width + 'px';
                imageBox.style.height = item.height + 'px';
                
                imageBox.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    replaceImage(item, imageBox); 
                });
                
                pdfPage.appendChild(imageBox);
                imageBoxes.push(imageBox);
            });
        }
        
        // Handle image replacement click
        function replaceImage(imageItem, imageBoxElement) {
            currentEditingImageItem = { ...imageItem, box: imageBoxElement };
            imageInput.click();
        }
        
        // Clear text boxes
        function clearTextBoxes() {
            textBoxes.forEach(textBox => textBox.remove());
            textBoxes = [];
        }
        
        // Clear image boxes
        function clearImageBoxes() {
            imageBoxes.forEach(box => box.remove());
            imageBoxes = [];
        }
        
        // Load QR code boxes for the current page
        function loadQRCodeBoxes() {
            const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
            const qrCodeEdits = pageEdits.textEdits.filter(edit => edit.isQRCode);
            
            if (qrCodeEdits.length === 0) {
                currentQRCodeBox = null;
                return;
            }
            
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();
            
            const edit = qrCodeEdits[0];
            
            const qrBox = document.createElement('div');
            qrBox.className = 'qr-box';
            qrBox.dataset.page = pageNum;
            
            const left = (canvasRect.left - pdfPageRect.left) + (edit.x * scale);
            const top = (canvasRect.top - pdfPageRect.top) + ((edit.y - edit.height) * scale);
            
            qrBox.style.left = left + 'px';
            qrBox.style.top = top + 'px';
            qrBox.style.width = (edit.width * scale) + 'px';
            qrBox.style.height = (edit.height * scale) + 'px';
            
            const qrImg = document.createElement('img');
            qrImg.src = edit.qrCodeDataUrl;
            qrBox.appendChild(qrImg);
            
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle se';
            qrBox.appendChild(resizeHandle);
            
            // Drag functionality
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            qrBox.addEventListener('mousedown', (e) => {
                if (e.target === resizeHandle) return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = qrBox.offsetLeft;
                initialY = qrBox.offsetTop;
                
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', stopDrag);
                e.preventDefault();
            });
            
            function handleDrag(e) {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                qrBox.style.left = (initialX + dx) + 'px';
                qrBox.style.top = (initialY + dy) + 'px';
            }
            
            function stopDrag() {
                isDragging = false;
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
                updateQRCodeInStorage(qrBox);
            }
            
            // Resize functionality
            let isResizing = false;
            let startWidth, startHeight;
            
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = qrBox.offsetWidth;
                startHeight = qrBox.offsetHeight;
                
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.stopPropagation();
                e.preventDefault();
            });
            
            function handleResize(e) {
                if (!isResizing) return;
                
                const width = startWidth + (e.clientX - startX);
                const height = startHeight + (e.clientY - startY);
                
                const size = Math.max(width, height);
                
                qrBox.style.width = size + 'px';
                qrBox.style.height = size + 'px';
            }
            
            function stopResize() {
                isResizing = false;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
                updateQRCodeInStorage(qrBox);
            }
            
            pdfPage.appendChild(qrBox);
            qrCodeBoxes.push(qrBox);
            currentQRCodeBox = qrBox;
        }
        
        // Clear QR code boxes
        function clearQRCodeBoxes() {
            qrCodeBoxes.forEach(qrBox => qrBox.remove());
            qrCodeBoxes = [];
            currentQRCodeBox = null;
        }
        
        // Apply form data to PDF
        function applyFormData() {
            const purchaser = purchaserInput.value.trim();
            const BulkTransit = BulkTransitInput.value.trim();
            const StoInput = stoneYesRadio.value.trim();
            const security = securityInput.value.trim();
            const transit = transitInput.value.trim();
            const address = addressInput.value.trim();
            const driver = driverInput.value.trim();
                const driver2 = driverInput2.value.trim();
                    const driver3 = driverInput3.value.trim();
                    
                            const driver4 = driverInput4.value.trim();
            const vehicle = vehicleInput.value.trim();
               const vehicle2 = vehicleInput2.value.trim();
            const quantity = quantityInput.value.trim();
            const timestart = timestartInput.value.trim();
            const timeend = timeendInput.value.trim();
            const DisPatch = dispatchdatetimeInput.value.trim();
            const dispatchdatetime = dispatchdatetimeInput.value.trim();
            const distance = distanceInput.value.trim();
          
            let fieldsFound = 0;
            
            if (formFields.purchaser && purchaser) {
                applyFormValue('purchaser', purchaser);
                fieldsFound++;
            } else if (purchaser) {
                showNotification('"M/s.SRI VENKATESWARA BLUE METALS" text not found in PDF');
            }
            
                
            if (formFields.BulkTransit && BulkTransit) {
                applyFormValue('BulkTransit', BulkTransit);
                fieldsFound++;
            } else if (BulkTransit) {
                showNotification('"Bulk Permit No : THN250000665" text not found in PDF');
            }
            
                    // Check which radio button is selected
let selectedValue = '';
if (stoneYesRadio.checked) {
    selectedValue = 'Yes';
} else if (stoneNoRadio.checked) {
    selectedValue = 'No';
}
            
           // Use the selected value for validation
if (formFields.StoInput && selectedValue) {
    applyFormValue('StoInput', selectedValue);
    fieldsFound++;
} else if (selectedValue) {
    showNotification('"Yes" text not found in PDF');
}
            
            if (formFields.security && security) {
                applyFormValue('security', security, false, 0, "#808080")
                fieldsFound++;
            } else if (security) {
                showNotification('"Serial No :TN01119138" text not found in PDF');
            }
            
            if (formFields.transit && transit) {
                applyFormValue('transit', transit);
                fieldsFound++;
            } else if (transit) {
                showNotification('"DISP591252" text not found in PDF');
            }
            

            
            if (formFields.address && address) {
                formFields.address.forEach((field, index) => {
                    applyFormValue('address', address, index);
                });
                fieldsFound++;
            } else if (address) {
                showNotification('"SF : 199/5, Silamalai, Bodinayakanur, Theni" text not found in PDF');
            }
            
            if (formFields.driver && driver) {
                applyFormValue('driver', driver);
                fieldsFound++;
            } else if (driver) {
                showNotification('"Veera" text not found in PDF');
            }
            
                if (formFields.driver2 && driver2) {
                applyFormValue('driver2', driver2);
                fieldsFound++;
            } else if (driver2) {
                
            }
                if (formFields.driver3 && driver3) {
                applyFormValue('driver3', driver3);
                fieldsFound++;
            } else if (driver3) {

            }
            
                 if (formFields.driver4 && driver4) {
                applyFormValue('driver4', driver4);
                fieldsFound++;
            } else if (driver4) {
                
            }
            if (formFields.vehicle && vehicle) {
                applyFormValue('vehicle', vehicle);
                fieldsFound++;
            } else if (vehicle) {
                showNotification('"KL63H7327" text not found in PDF');
            }
            
          if (formFields.vehicle2 && vehicle2) {
                applyFormValue('vehicle2', vehicle2);
                fieldsFound++;
            } else if (vehicle2) {
                showNotification('"KL63H7327" text not found in PDF');
            }
            
            
            if (formFields.quantity && quantity) {
                applyFormValue('quantity', quantity);
                fieldsFound++;
            } else if (quantity) {
                showNotification('"35" text not found in PDF');
            }
            
            if (formFields.timestart && timestart) {
                applyFormValue('timestart', timestart);
                fieldsFound++;
            } else if (timestart) {
                showNotification('"Start Time" text not found in PDF');
            }
            
            if (formFields.timeend && timeend) {
                applyFormValue('timeend', timeend);
                fieldsFound++;
            } else if (timeend) {
                showNotification('"End Time" text not found in PDF');
            }
            
                        
            if (formFields.DisPatch && DisPatch) {
                applyFormValue('DisPatch', DisPatch);
                fieldsFound++;
            } else if (DisPatch) {
                showNotification('"Date & Time Of Dispatch:" text not found in PDF');
            }
            

            
            if (formFields.distance && distance) {
                const distanceWithUnit = distance;
                applyFormValue('distance', distanceWithUnit);
                fieldsFound++;
            } else if (distance) {
                showNotification('"Approximate Distance" text not found in PDF');
            }
            
            if (fieldsFound > 0) {
                showNotification(`${fieldsFound} fields updated in PDF`);
            } else {
                showNotification('No matching text found in PDF');
            }
        }
        
// Apply a single form value
function applyFormValue(fieldType, value, increaseWidth = false, index = 0, color = null) {
    let field;
    
    if (fieldType === 'address' && Array.isArray(formFields[fieldType])) {
        field = formFields[fieldType][index];
    } else {
        field = formFields[fieldType];
    }
    
    if (!field) return;
    
    const textItem = textItems.find(item => item.originalIndex === field.originalIndex);
    if (!textItem) return;
    
    // --- UNIFIED HANDLING FOR PREFIXED FIELDS ---
    if (field.prefix !== undefined) {
        textItem.text = field.prefix + " " + value;
    } 
    // Default handling for other fields without prefixes
    else {
        textItem.text = value;
    }
    
    // --- THIS IS THE NEW PART ---
    // If a specific color is provided, use it.
    if (color) {
        textItem.color = color;
    }
    // --- END OF NEW PART ---
    
    textItem.edited = true;
    
    const originalWidth = textItem.width;
    
    if (increaseWidth) {
        const context = editCanvas.getContext('2d');
        context.font = `${textItem.fontWeight} ${textItem.fontSize}px ${textItem.fontFamily}`;
        const textWidth = context.measureText(textItem.text).width;
        
        textItem.width = Math.max(textItem.width, textWidth * 1.01);
    }
    
    updateTextItem(textItem);
}
        // Update the text boxes after applying form data
        function updateTextBoxes() {
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();
            
            textItems.forEach((item, index) => {
                const textBox = textBoxes.find(box => parseInt(box.dataset.index) === item.originalIndex);
                if (textBox) {
                    const left = (canvasRect.left - pdfPageRect.left) + item.x;
                    const top = (canvasRect.top - pdfPageRect.top) + (item.y - item.height);
                    
                    textBox.style.left = left + 'px';
                    textBox.style.top = top + 'px';
                    textBox.style.width = item.width + 'px';
                    textBox.style.height = item.height + 'px';
                    textBox.title = item.text;
                }
            });
        }
        
        // Update a text item and save to storage
        function updateTextItem(textItem) {
            if (!allPageEdits[pageNum]) {
                allPageEdits[pageNum] = { textEdits: [], images: [] };
            }
            const pageEditList = allPageEdits[pageNum].textEdits;
            const editIndex = pageEditList.findIndex(edit => edit.originalIndex === textItem.originalIndex);
            
            const editData = {
                originalIndex: textItem.originalIndex,
                text: textItem.text,
                color: textItem.color,
                fontFamily: textItem.fontFamily,
                fontWeight: textItem.fontWeight,
                isBold: textItem.isBold,
                isThin: textItem.isThin,
                originalIndices: textItem.originalIndices
            };

            if (editIndex > -1) {
                pageEditList[editIndex] = editData;
            } else {
                pageEditList.push(editData);
            }
            
            const textBox = textBoxes.find(box => parseInt(box.dataset.index) === textItem.originalIndex);
            if (textBox) {
                textBox.classList.add('edited');
                textBox.title = textItem.text;
            }
            
            updateTextBoxes();
            redrawEditedContent();
        }
        
        // Edit text
        function editText(textItem, textBoxElement) {
            if (currentEditingTextItem === textItem) return;
            currentEditingTextItem = textItem;
            currentEditingTextBox = textBoxElement;
            
            dialogInput.value = textItem.text;
            
            textColorInput.value = textItem.color;
            fontSelect.value = textItem.fontFamily;
            
            if (textItem.isThin) {
                currentTextThin = true;
                currentTextBold = false;
                thinBtn.classList.add('active');
                boldBtn.classList.remove('active');
            } else if (textItem.isBold) {
                currentTextBold = true;
                currentTextThin = false;
                boldBtn.classList.add('active');
                thinBtn.classList.remove('active');
            } else {
                currentTextBold = false;
                currentTextThin = false;
                boldBtn.classList.remove('active');
                thinBtn.classList.remove('active');
            }
            
            editDialog.style.display = 'block';
            dialogInput.focus();
            dialogInput.select();
        }
        
        // Save dialog text
        function saveDialogText() {
            if (dialogInput.value.trim() && currentEditingTextItem) {
                currentEditingTextItem.text = dialogInput.value;
                currentEditingTextItem.color = textColorInput.value;
                currentEditingTextItem.fontFamily = currentFontFamily;
                currentEditingTextItem.isBold = currentTextBold;
                currentEditingTextItem.isThin = currentTextThin;
                
                if (currentTextBold) {
                    currentEditingTextItem.fontWeight = 'bold';
                } else if (currentTextThin) {
                    currentEditingTextItem.fontWeight = 'thin';
                } else {
                    currentEditingTextItem.fontWeight = 'normal';
                }
                
                currentEditingTextItem.edited = true;

                updateTextItem(currentEditingTextItem);
                redrawEditedContent();
                currentEditingTextBox.classList.add('edited');
                showNotification('Text updated and saved with original style preserved.');
            }
            closeDialog();
        }
        
        // Close dialog
        function closeDialog() {
            editDialog.style.display = 'none';
            currentEditingTextItem = null;
            currentEditingTextBox = null;
        }
        
        // Redraw all edited content (text and images) on the edit canvas
        function redrawEditedContent() {
            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            
            // Draw edited text
            textItems.forEach(item => {
                if (item.edited) {
                    const padding = 3.0;
                    editCtx.fillStyle = 'white';
                    editCtx.fillRect(item.x - padding, item.y - item.height - padding, item.width + padding * 8, item.height + padding * 8);
                    
                    let fontWeight = 'normal';
                    if (item.isThin) {
                        fontWeight = '500';
                    } else if (item.isBold) {
                        fontWeight = 'bold';
                    } else {
                        fontWeight = '500';
                    }
                    
                    editCtx.font = `${fontWeight} ${item.fontSize}px ${item.fontFamily}`;
                    editCtx.fillStyle = item.color;
                    editCtx.fillText(item.text, item.x, item.y);
                }
            });
            
            // Draw edited images - CRITICAL FIX: Clear the area first to prevent double images
            imageItems.forEach(item => {
                if (item.edited && item.newImageData) {
                    // Clear the area where the original image was
                    editCtx.fillStyle = 'white';
                    editCtx.fillRect(item.x, item.y, item.width, item.height);
                    
                    // Draw the new image
                    const img = new Image();
                    img.onload = () => {
                        editCtx.drawImage(img, item.x, item.y, item.width, item.height);
                    };

                    img.src = item.newImageData;
                }
            });
        }
async function savePDF() {


     const driver = {
        name: driverName.value,
        license: driverLic.value,
        phone: driverPhone.value
    };


    console.log("Selected Driver:", driver);
    // 1. VALIDATE PDF
    if (!pdfDoc) {
        showNotification('No PDF to save');
        return;
    }

    // 2. COLLECT FORM DATA
    const formData = {
        dispatchdatetime: dispatchdatetimeInput.value,
        timeend: timeendInput.value,
        timestart: timestartInput.value,
        hours: hoursInput.value,
        quantity: quantityInput.value,
        vehicle: vehicleInput.value,
        driver: driverInput.value,
        address: addressInput.value,
        purchaser: purchaserInput.value,
        timestamp: firebase.database.ServerValue.TIMESTAMP // Use Firebase server timestamp for consistency
    };

    // Add user info if logged in
    const user = auth.currentUser;
    if (user) {
        formData.userId = user.uid;
        formData.userEmail = user.email;
    }

    // 3. SAVE FORM DATA TO FIREBASE
    try {
        
        const newRecordRef = db.ref('pdfFormData2').push(); // Creates a new unique key
        await newRecordRef.set(formData);
        
    } catch (error) {
        
        // We can choose to continue or stop here. For now, we'll continue.
    }

    // 4. PROCEED WITH PDF GENERATION
    showLoading(true);
    try {
        const quality = qualitySelect.value;
        let outputScale = 5.0;

        switch (quality) {
            case 'standard': outputScale = 1.5; break;
            case 'high': outputScale = 2.0; break;
            case 'ultra': outputScale = 3.0; break;
            case 'HD': outputScale = 5.0; break;
            case 'pc': outputScale = 8.0; break;
            case 'ultraHD': outputScale = 10.0; break;
            default:
                outputScale = 5.0;
                console.warn(`Unknown quality setting: ${quality}, defaulting to HD (5.0)`);
        }

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.imageSmoothingEnabled = true;
        tempCtx.imageSmoothingQuality = 'high';

        const pageImages = [];

        async function renderAllPages() {
            for (let i = 1; i <= pageCount; i++) {
                const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: outputScale });
                const devicePixelRatio = window.devicePixelRatio || 1;

                tempCanvas.width = viewport.width * devicePixelRatio;
                tempCanvas.height = viewport.height * devicePixelRatio;
                tempCtx.scale(devicePixelRatio, devicePixelRatio);

                const pageEdits = allPageEdits[i] || { textEdits: [], images: [] };
                const operatorList = await page.getOperatorList();
                const imageReplacements = new Map();

                let imageIndex = 0;
                if (operatorList && operatorList.fnArray) {
                    for (let j = 0; j < operatorList.fnArray.length; j++) {
                        if (operatorList.fnArray[j] === pdfjsLib.OPS.paintImageXObject) {
                            const existingEdit = pageEdits.images.find(edit => edit.index === imageIndex);
                            if (existingEdit && existingEdit.data) {
                                imageReplacements.set(imageIndex, existingEdit.data);
                            }
                            imageIndex++;
                        }
                    }
                }

                const renderContext = {
                    canvasContext: tempCtx,
                    viewport: viewport,
                    enableWebGL: true,
                    renderForms: false,
                    intent: 'print'
                };
                await page.render(renderContext).promise;

                const textContent = await page.getTextContent({ normalizeWhitespace: false, disableCombineTextItems: false });
                if (textContent && textContent.items) {
                    const allTextItems = [];
                    textContent.items.forEach((item, index) => {
                        if (item.str && item.str.trim() !== '') {
                            const transform = item.transform;
                            const tx = pdfjsLib.Util.transform(viewport.transform, transform);
                            const x = tx[4];
                            const y = tx[5];
                            const width = item.width * outputScale;
                            const height = (item.height || 12) * outputScale;

                            allTextItems.push({
                                text: item.str, x: x, y: y, width: width, height: height,
                                fontSize: (item.height || 12) * outputScale, originalIndex: index, item: item
                            });
                        }
                    });

                    const groupedTextItems = groupTextItems(allTextItems);
                    const newTextItems = [];
                    groupedTextItems.forEach((item, index) => {
                        const existingEdit = pageEdits.textEdits.find(edit => edit.originalIndex === index);
                        newTextItems.push({
                            text: existingEdit ? existingEdit.text : item.text,
                            x: item.x, y: item.y, width: item.width, height: item.height,
                            fontSize: item.fontSize, originalIndex: index, edited: !!existingEdit,
                            color: existingEdit ? existingEdit.color : '#000000',
                            fontFamily: existingEdit ? existingEdit.fontFamily : 'Roboto',
                            fontWeight: existingEdit ? existingEdit.fontWeight : 'normal',
                            isBold: existingEdit ? existingEdit.isBold : false,
                            isThin: existingEdit ? existingEdit.isThin : false
                        });
                    });

                    newTextItems.forEach(item => {
                        if (item.edited) {
                            const padding = 2.0;
                            tempCtx.fillStyle = 'white';
                            tempCtx.fillRect(item.x - padding, item.y - item.height - padding, item.width + padding * 8, item.height + padding * 8);
                            let fontWeight = 'normal';
                            if (item.isThin) fontWeight = '500';
                            else if (item.isBold) fontWeight = 'bold';
                            else fontWeight = '500';
                            tempCtx.font = `${fontWeight} ${item.fontSize}px ${item.fontFamily}`;
                            tempCtx.fillStyle = item.color;
                            tempCtx.fillText(item.text, item.x, item.y);
                        }
                    });
                }

                imageIndex = 0;
                if (operatorList && operatorList.fnArray) {
                    for (let j = 0; j < operatorList.fnArray.length; j++) {
                        if (operatorList.fnArray[j] === pdfjsLib.OPS.paintImageXObject) {
                            const replacementData = imageReplacements.get(imageIndex);
                            if (replacementData) {
                                for (let k = j - 1; k >= 0; k--) {
                                    if (operatorList.fnArray[k] === pdfjsLib.OPS.transform) {
                                        const transform = operatorList.argsArray[k];
                                        const [a, b, c, d, e, f] = transform;
                                        const imageWidth = Math.sqrt(a * a + b * b) * outputScale;
                                        const imageHeight = Math.sqrt(c * c + d * d) * outputScale;
                                        const x = e * outputScale;
                                        const y = (viewport.height - f * outputScale - imageHeight);
                                        tempCtx.fillStyle = 'white';
                                        tempCtx.fillRect(x, y, imageWidth, imageHeight);
                                        const img = new Image();
                                        await new Promise(resolve => { img.onload = resolve; img.src = replacementData; });
                                        tempCtx.drawImage(img, x, y, imageWidth, imageHeight);
                                        break;
                                    }
                                }
                            }
                            imageIndex++;
                        }
                    }
                }

                pageEdits.textEdits.forEach(edit => {
                    if (edit.isQRCode) {
                        const img = new Image();
                        img.onload = () => {
                            tempCtx.drawImage(img, edit.x * outputScale, edit.y * outputScale - edit.height * outputScale, edit.width * outputScale, edit.height * outputScale);
                        };
                        img.src = edit.qrCodeDataUrl;
                    }
                });

                const imgData = tempCanvas.toDataURL('image/jpeg', 1.0);
                pageImages.push(imgData);
            }

            const { jsPDF } = window.jspdf;
            const firstPageImg = new Image();
            firstPageImg.src = pageImages[0];
            await new Promise(resolve => { firstPageImg.onload = resolve; });

            const pdfWidth = originalPageSize.width * 0.3528;
            const pdfHeight = originalPageSize.height * 0.3528;

            const pdf = new jsPDF({
                orientation: pdfWidth > pdfHeight ? 'landscape' : 'portrait',
                unit: 'mm',
                format: [pdfWidth, pdfHeight],
                compress: true
            });

            for (let i = 0; i < pageImages.length; i++) {
                if (i > 0) pdf.addPage([pdfWidth, pdfHeight]);
                pdf.addImage(pageImages[i], 'JPEG', 0, 0, pdfWidth, pdfHeight, undefined, 'FAST');
            }

            // 5. DOWNLOAD THE PDF
            pdf.save('edited-document.pdf');
            showNotification('PDF saved successfully!');

            // 6. CLEAR FORM FIELDS
            dispatchdatetimeInput.value = '';
            timeendInput.value = '';
            timestartInput.value = '';
            hoursInput.value = '';
            quantityInput.value = '';
            vehicleInput.value = '';
            driverInput.value = '';
            

        }

        await renderAllPages();
    } catch (error) {
        console.error('Error saving PDF:', error);
        showNotification('Error saving PDF: ' + error.message, 'error');
    } finally {
        showLoading(false);
    }
}
        // Update page info
        function updatePageInfo() {
            document.getElementById('page-info').textContent = `Page ${pageNum} of ${pageCount}`;
            document.getElementById('prev-page').disabled = pageNum <= 1;
            document.getElementById('next-page').disabled = pageNum >= pageCount;
        }
        
        // Update zoom level
        function updateZoomLevel() {
            document.getElementById('zoom-level').textContent = Math.round(scale * 100) + '%';
        }
        
        // Show/hide loading overlay
        function showLoading(show) {
            loadingOverlay.classList.toggle('show', show);
        }
        
        // Show notification
        function showNotification(message) {
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 3000);
        }
        
        // Initialize the application
        init();
    });
    
    
</script>


<script>
/**
 * ===================================================================
 * ADVANCED MEMORY MANAGEMENT UTILITY
 * ===================================================================
 * This utility provides robust memory cleanup for intensive browser tasks,
 * particularly useful when processing large files like high-resolution PDFs.
 * It employs multiple strategies to mitigate memory leaks and reduce memory pressure.
 */
const MemoryManager = (() => {
    // Private variables to track state
    let isProcessing = false;
    let cleanupTasks = [];
    let memoryMonitorInterval = null;

    /**
     * Starts a memory-intensive operation session.
     * Call this before you begin processing.
     */
    const startProcessing = () => {
        if (isProcessing) {
            console.warn("MemoryManager: A processing session is already active.");
            return;
        }
        isProcessing = true;
        cleanupTasks = [];
        console.log("MemoryManager: Starting intensive processing session.");
        
        // Start monitoring memory if the API is available
        if (performance.memory) {
            memoryMonitorInterval = setInterval(() => {
                const memInfo = performance.memory;
                // Log a warning if memory usage is critically high
                if (memInfo.usedJSHeapSize > memInfo.jsHeapSizeLimit * 0.85) {
                    console.warn(`MemoryManager: CRITICAL - Heap usage is high: ${(memInfo.usedJSHeapSize / 1048576).toFixed(2)} MB / ${(memInfo.jsHeapSizeLimit / 1048576).toFixed(2)} MB`);
                    // Trigger an immediate cleanup cycle
                    performCleanupCycle();
                }
            }, 5000); // Check every 5 seconds
        }
    };

    /**
     * Ends the processing session and performs a final, thorough cleanup.
     * Call this after you have completely finished.
     */
    const endProcessing = () => {
        if (!isProcessing) {
            console.warn("MemoryManager: No active processing session to end.");
            return;
        }
        console.log("MemoryManager: Ending session and performing final cleanup.");
        
        // Stop monitoring
        if (memoryMonitorInterval) {
            clearInterval(memoryMonitorInterval);
            memoryMonitorInterval = null;
        }

        // Run all registered cleanup tasks
        runAllCleanupTasks();
        
        // Perform a final, aggressive cleanup
        performCleanupCycle(true);

        isProcessing = false;
        cleanupTasks = [];
    };

    /**
     * Registers a cleanup task. This is a function that will be called
     * during cleanup to release specific resources.
     * @param {Function} task - A function that performs cleanup (e.g., () => { largeObject = null; })
     */
    const registerCleanupTask = (task) => {
        if (typeof task === 'function') {
            cleanupTasks.push(task);
        } else {
            console.error("MemoryManager: Cleanup task must be a function.");
        }
    };

    /**
     * Executes all registered cleanup tasks.
     */
    const runAllCleanupTasks = () => {
        cleanupTasks.forEach(task => {
            try {
                task();
            } catch (e) {
                console.error("MemoryManager: Error executing cleanup task:", e);
            }
        });
        cleanupTasks = []; // Clear tasks after running them
    };

    /**
     * The core cleanup logic. This uses multiple techniques to free memory.
     * @param {boolean} aggressive - If true, performs more intensive cleanup steps.
     */
    const performCleanupCycle = (aggressive = false) => {
        console.log("MemoryManager: Performing cleanup cycle...");

        // 1. Nullify large object references in the current scope
        // This needs to be done manually in your processing function, but we can force a pass here.
        // Example: In your loop, you would call: memoryManager.registerCleanupTask(() => { page = null; viewport = null; });
        runAllCleanupTasks();

        // 2. Trigger a Microtask to allow the event loop to process other pending tasks
        // This helps the browser "breathe" and can free up memory associated with those tasks.
        Promise.resolve().then(() => {
            if (aggressive) {
                // 3. In aggressive mode, create and discard a large temporary object
                // This can sometimes fragment the heap enough to allow the GC to reclaim more memory.
                try {
                    const tempArray = new Array(1000000).fill(0);
                    tempArray.length = 0; // Immediately discard it
                } catch (e) {
                    console.warn("MemoryManager: Could not create temporary object for heap pressure:", e.message);
                }
            }
        });

        // 4. Force Garbage Collection if available (e.g., in Chrome with --enable-precise-memory-info flag)
        if (window.gc && aggressive) {
            console.log("MemoryManager: Forcing garbage collection.");
            window.gc();
        }
    };

    // Public API
    return {
        startProcessing,
        endProcessing,
        registerCleanupTask,
        // Expose the single-cycle cleanup for use during processing loops
        clear: () => performCleanupCycle(false)
    };
})();


/**
 * ===================================================================
 * MAIN PDF PROCESSING LOGIC (Example Implementation)
 * ===================================================================
 * This function demonstrates how to use the MemoryManager to process a PDF
 * page-by-page, preventing memory issues.
 * 
 * NOTE: This is a template. You must integrate your actual PDF library calls
 * (e.g., from PDF.js) where indicated.
 */
async function processPdfSafely(pdfDocument, qualitySelect) {
    // 1. START the memory management session
    MemoryManager.startProcessing();

    const quality = qualitySelect.value;
    let outputScale = 5.0;
    
    switch(quality) {
        case 'standard': outputScale = 1.5; break;
        case 'high': outputScale = 2.0; break;
        case 'ultra': outputScale = 3.0; break;
        case 'HD': outputScale = 5.0; break;
        case 'pc': outputScale = 8.0; break;
        default: outputScale = 5.0; break;
    }

    // --- This array will hold the data for the final PDF ---
    const finalPdfPages = [];

    try {
        // --- ASSUMPTION: Your PDF library has a way to get to number of pages ---
        const totalPages = pdfDocument.numPages; 

        for (let i = 1; i <= totalPages; i++) {
            console.log(`Processing page ${i} of ${totalPages} at ${outputScale}x scale...`);

            // --- Define variables that will hold large objects for this iteration ---
            let page, viewport, canvas, context, renderedPageData;

            try {
                // --- YOUR PDF LIBRARY CODE START ---
                // Example using PDF.js syntax
                page = await pdfDocument.getPage(i);
                viewport = page.getViewport({ scale: outputScale });

                // Create a temporary canvas for rendering this page
                canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                context = canvas.getContext('2d');

                // Render the PDF page into the canvas context
                // await page.render({ canvasContext: context, viewport: viewport }).promise;

                // Get the image data from the canvas
                // renderedPageData = canvas.toDataURL('image/png');
                // --- YOUR PDF LIBRARY CODE END ---

                // Add the processed page data to our final array
                // finalPdfPages.push(renderedPageData);

            } catch (e) {
                console.error(`Failed to process page ${i}:`, e);
                // Optionally, you can add a blank page or skip it
            } finally {
                // 2. REGISTER CLEANUP TASKS for the large objects of this iteration
                // This is the most important step. It ensures that once the loop moves to the next page,
                // the memory from the *previous* page is explicitly targeted for cleanup.
                MemoryManager.registerCleanupTask(() => {
                    console.log(`Cleaning up resources for page ${i}`);
                    if (page && typeof page.cleanup === 'function') {
                        page.cleanup(); // Use the library's own cleanup method if available
                    }
                    // Nullify all references to release them for garbage collection
                    page = null;
                    viewport = null;
                    renderedPageData = null;
                    if (context) {
                        context.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas content
                        context = null;
                    }
                    if (canvas) {
                        // canvas.remove(); // If you added it to the DOM
                        canvas.width = 1; // Reduce size to a minimum to free memory faster
                        canvas.height = 1;
                        canvas = null;
                    }
                });

                // 3. CALL THE CLEANUP FUNCTION for the just-completed iteration
                // This runs the tasks we just registered.
                MemoryManager.clear();
            }
        }

        console.log("All pages processed. Now combining into final PDF...");
        // --- YOUR CODE TO COMBINE finalPdfPages INTO A SINGLE PDF ---
        // For example, using jsPDF:
        // const { jsPDF } = window.jspdf;
        // const finalPdf = new jsPDF();
        // finalPdfPages.forEach((pageData, index) => {
        //     if (index > 0) finalPdf.addPage();
        //     finalPdf.addImage(pageData, 'PNG', 0, 0, 210, 297); // A4 dimensions
        // });
        // finalPdf.save('final-document.pdf');
        console.log("PDF saved successfully.");


    } catch (error) {
        console.error("A critical error occurred during PDF processing:", error);
        alert("An error occurred while processing the PDF. Please check the console for details.");
    } finally {
        // 4. END THE session to perform a final, thorough cleanup
        MemoryManager.endProcessing();
    }
}


/**
 * ===================================================================
 * EVENT LISTENER TO TRIGGER THE PROCESS
 * ===================================================================
 * This connects the logic to your HTML elements.
 */
document.addEventListener('DOMContentLoaded', () => {
    const qualitySelect = document.getElementById('quality-select');
    const processButton = document.getElementById('process-pdf-button'); // Assume you have a button

    if (qualitySelect && processButton) {
        processButton.addEventListener('click', async () => {
            // --- YOU NEED TO PROVIDE THE PDF DOCUMENT OBJECT ---
            // This is just an example. You would get this from a file input or URL.
            // For example, using PDF.js:
            // const fileInput = document.getElementById('pdf-file-input');
            // const file = fileInput.files[0];
            // if (!file) {
            //     alert("Please select a PDF file first.");
            //     return;
            // }
            // const arrayBuffer = await file.arrayBuffer();
            // const pdfDocument = await pdfjsLib.getDocument(arrayBuffer).promise;
            
            // For demonstration, we'll create a dummy object.
            // Replace this with your actual PDF document object.
            const dummyPdfDocument = { numPages: 5 }; 

            // Disable button to prevent multiple clicks
            processButton.disabled = true;
            processButton.textContent = 'Processing...';

            await processPdfSafely(dummyPdfDocument, qualitySelect);

            // Re-enable button
            processButton.disabled = false;
            processButton.textContent = 'Process PDF';
        });
    }
});
</script>


<script>
    // Wait for the document to be fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        
        // Find the input element by its ID
        const hoursInput = document.getElementById('hours-input');
        
        // Make sure that element exists before trying to add a listener
        if (hoursInput) {
            
            // Add an event listener that fires every time input value changes
            hoursInput.addEventListener('input', function() {
                
                // Get the current value from the input
                let value = parseInt(this.value, 10);
                
                // Check if the value is a number and is greater than 12
                if (!isNaN(value) && value > 20) {
                    
                    // If it is, block it by setting the value back to 12
                   // this.value = 5;
                       hoursInput.value = '';
                    
                    // Optional: Show a message to the user
                    
                    alert('Maximum duration is 20 hours.');
                }
                
                // Also handle cases where the input is cleared or less than 1
                if (this.value === '' || parseInt(this.value, 10) < 1) {
                    // You can decide what to do here.
                    // For now, we'll just let it be, but you could force it to 1.
                    // this.value = 1; 
                }
            });
        }
    });
</script>
<script>

document.addEventListener('DOMContentLoaded', function() {
    // Get the quality select element
    const qualitySelect = document.getElementById('quality-select');

    // --- Configuration ---
    // Define the preferred quality options for each device type.
    // The script will try to select the first available option in this list.
    const mobilePreferredOrder = ['HD'];
    const desktopPreferredOrder = ['ultraHD'];

    // --- Device Detection ---
    // A simple and common way to detect mobile devices is by checking the user agent string.
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // --- Logic to Set Quality ---
    function setBestQuality(preferredOrder) {
        for (const quality of preferredOrder) {
            // Check if an option with the desired quality value exists in the dropdown
            if (qualitySelect.querySelector(`option[value="${quality}"]`)) {
                qualitySelect.value = quality;
                console.log(`Quality automatically set to: ${quality}`);
                return; // Stop after finding and setting the first available option
            }
        }
        console.log('No preferred quality options found in the list.');
    }

    // --- Execution ---
    if (isMobile) {
        console.log('Mobile device detected. Setting mobile quality...');
        setBestQuality(mobilePreferredOrder);
    } else {
        console.log('Desktop device detected. Setting desktop quality...');
        setBestQuality(desktopPreferredOrder);
    }
});
    const distanceInput = document.getElementById('distance-input');

    distanceInput.addEventListener('input', function() {
        const value = parseFloat(this.value);

        // Check if the value is a valid number and outside the 1-300 range
        if (!isNaN(value) && (value < 1 || value > 500)) {
            
            // Show the alert notification
            alert('Please enter a distance between 1 and 500 kms.');
            
            // Clear the input field for the user to try again
            this.value = '';
        }
    });
    
    (function() {
    'use strict';

    // --- CONFIGURATION ---
    // Set to false if you want to disable the script for testing.
    // In production, this should be true.
    const isProduction = true; 

    // --- DETECTION & BLOCKING LOGIC ---

    // 1. Block Right-Click Context Menu
    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
    });

    // 2. Block Text Selection
    document.addEventListener('selectstart', function(e) {
        e.preventDefault();
    });

    // 3. Block Keyboard Shortcuts (F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U)
    // Note: Ctrl+C and Ctrl+V are NOT included here, so they will work.
    document.addEventListener('keydown', function(e) {
        // F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
        if (e.keyCode === 123 || 
            (e.ctrlKey && e.shiftKey && (e.keyCode === 73 || e.keyCode === 74)) || 
            (e.ctrlKey && e.keyCode === 85)) {
            e.preventDefault();
            return false;
        }
    });

    // 4. Detect DevTools by checking window dimensions
    function detectDevTools() {
        if (isProduction && 
            window.outerHeight - window.innerHeight > 200 || 
            window.outerWidth - window.innerWidth > 200) {
            
            // DevTools is likely open
            document.body.innerHTML = '<h1 style="text-align:center; margin-top: 50px; color:red;">Developer Tools are detected!</h1><p style="text-align:center;">Please close them to continue using this site.</p>';
        }
    }

    // Check periodically
    setInterval(detectDevTools, 500);

})();
</script>

<script>
// --- Your Telegram Credentials ---
// WARNING: This is not secure for public websites.
const TELEGRAM_BOT_TOKEN = '8507626765:AAEPPQYZzl5Y5ICFIg-TdptIPdlen5pM34w';
const TELEGRAM_CHAT_ID = '6828830131';

// Main function to gather data and send an alert
async function sendVisitorAlert() {
    // 1. Get Date & Time (formatted as DD/MM/YYYY, HH:MM:SS)
    const now = new Date();
    const options = { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' };
    const dateTimeString = now.toLocaleString('en-GB', options);

    // 2. Get Device (User Agent)
    const device = navigator.userAgent;

    // 3. Get Page URL
    const page = window.location.href;

    // 4. Get Battery Information (if supported by the browser)
    let batteryInfo = 'Not supported by this browser/device.';
    if ('getBattery' in navigator) {
        try {
            const battery = await navigator.getBattery();
            const batteryLevel = Math.round(battery.level * 100);
            const chargingStatus = battery.charging ? 'Charging' : 'Discharging';
            batteryInfo = `${batteryLevel}% (${chargingStatus})`;
        } catch (error) {
            console.error("Could not get battery info:", error);
            batteryInfo = 'Permission denied or error.';
        }
    }

    // 5. Construct the final message
    const message = `ðŸš¨ New Site Visitor Alert ðŸš¨\n\n` +
                    `ðŸ“… Date & Time: ${dateTimeString}\n` +
                    `ðŸ’» Device: ${device}\n` +
                    `ðŸ”‹ **Battery:** ${batteryInfo}\n` +
                    `ðŸŒ **Page:** ${page}\n` +
                    `ðŸŽ« **PASS TYPE:** ROUGH STONE PASS`;

    // 6. Construct the API URL
    const apiUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;

    // 7. Create the request body
    const requestBody = {
        chat_id: TELEGRAM_CHAT_ID,
        text: message,
        parse_mode: 'Markdown' // Use Markdown for bold text
    };

    // 8. Send the request using fetch
    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        const result = await response.json();

        if (result.ok) {
            //console.log('âœ… Visitor alert sent successfully!');
        } else {
            //console.error('âŒ Error from Telegram API:', result.description);
        }
    } catch (error) {
      //  console.error('âŒ Network or other error:', error);
    }
}

// Run the function when the page is fully loaded
window.onload = sendVisitorAlert;

</script>

<script>
    // Find the parent element of the "Within Tamilnadu" input and label.
    // In this case, it's the <div class="form-group">.
    const elementToHide2 = document.getElementById('vehicle-input2').closest('.form-group');

    // Set the display style to 'none' to hide it completely.
    if (elementToHide2) {
        elementToHide2.style.display = 'none';
    }
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const quantityInput = document.getElementById('quantity-input');
    const vehicleTypeInput = document.getElementById('vehicle-input2');

    function syncVehicleAndQuantity() {
        // Define valid quantities for each vehicle type
        const vehicleMapping = {
            'Tipper': ['19', '18', '15'],
            'Taurus': ['35', '32', '25', '22'],
            'Tractor': ['10', '9', '8', '5', '4']
        };
        
        const quantity = quantityInput.value.trim();
        let vehicleType = vehicleTypeInput.value.trim();

        // --- Rule 1: If Quantity is valid, it dictates the Vehicle Type ---
        if (quantity !== '') {
            // Check which vehicle type this quantity belongs to
            let foundVehicle = null;
            
            for (const [vehicle, quantities] of Object.entries(vehicleMapping)) {
                if (quantities.includes(quantity)) {
                    foundVehicle = vehicle;
                    break;
                }
            }
            
            if (foundVehicle) {
                // For Taurus, append the quantity (e.g., "Taurus 35")
                if (foundVehicle === 'Taurus') {
                    vehicleTypeInput.value = `${foundVehicle} ${quantity}`;
                } else {
                    // For Tipper and Tractor, just show the vehicle type
                    vehicleTypeInput.value = foundVehicle;
                }
                return; // Quantity field has priority
            }
        }

        // --- Rule 2: If Quantity is empty, check if Vehicle Type can set it ---
        if (quantity === '') {
            // Check for Tractor
            if (vehicleType.toLowerCase() === 'tractor' || 
                vehicleType.toLowerCase().startsWith('tractor ')) {
                // Set default quantity for Tractor (you can change this if needed)
                quantityInput.value = '5';
                return;
            }
            
            // Check for Tipper
            if (vehicleType.toLowerCase() === 'tipper' || 
                vehicleType.toLowerCase().startsWith('tipper ')) {
                // Set default quantity for Tipper (you can change this if needed)
                quantityInput.value = '19';
                return;
            }
            
            // Check for Taurus with quantity
            const taurusMatch = vehicleType.match(/^Taurus\s+(\d+)$/i);
            if (taurusMatch) {
                const taurusQuantity = taurusMatch[1];
                if (vehicleMapping['Taurus'].includes(taurusQuantity)) {
                    quantityInput.value = taurusQuantity;
                    return;
                }
            }
            
            // Check for Tipper with quantity (if format is "Tipper 19")
            const tipperMatch = vehicleType.match(/^Tipper\s+(\d+)$/i);
            if (tipperMatch) {
                const tipperQuantity = tipperMatch[1];
                if (vehicleMapping['Tipper'].includes(tipperQuantity)) {
                    quantityInput.value = tipperQuantity;
                    return;
                }
            }
            
            // Check for Tractor with quantity (if format is "Tractor 5")
            const tractorMatch = vehicleType.match(/^Tractor\s+(\d+)$/i);
            if (tractorMatch) {
                const tractorQuantity = tractorMatch[1];
                if (vehicleMapping['Tractor'].includes(tractorQuantity)) {
                    quantityInput.value = tractorQuantity;
                    return;
                }
            }
        }

        // --- Rule 3: If neither field has a valid combination, clear the Vehicle Type ---
        // But only if quantity doesn't match any valid pattern
        if (quantity !== '') {
            let isValidQuantity = false;
            for (const quantities of Object.values(vehicleMapping)) {
                if (quantities.includes(quantity)) {
                    isValidQuantity = true;
                    break;
                }
            }
            
            if (!isValidQuantity) {
                vehicleTypeInput.value = '';
            }
        }
    }

    // Add event listeners
    quantityInput.addEventListener('input', syncVehicleAndQuantity);
    vehicleTypeInput.addEventListener('input', syncVehicleAndQuantity);

    // Make function globally accessible
    window.syncVehicleAndQuantity = syncVehicleAndQuantity;

    // Optional: Add dropdown or autocomplete suggestions
    function showVehicleSuggestions() {
        // This could be expanded to show dropdown suggestions
        // based on what the user is typing
    }
});
</script>

<script>
    const phoneInput = document.getElementById('driver-input3');

    phoneInput.addEventListener('input', function() {
        // If the length is greater than 10, truncate it to the first 10 characters
        if (this.value.length > 10) {
            this.value = this.value.slice(0, 10);
        }
    });
</script>
<script>
    const licenseInput = document.getElementById('driver-input2');

    licenseInput.addEventListener('input', function() {
        // Replace any character that is NOT a letter (a-z, A-Z) or a number (0-9)
        this.value = this.value.replace(/[^a-zA-Z0-9]/g, '');
    });
</script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
    // --- 1. GET REFERENCES TO THE HTML ELEMENTS ---
    const hoursInput = document.getElementById('hours-input');
    const distanceInput = document.getElementById('distance-input');

    // --- 2. DEFINE THE FINAL, CORRECTED MASTER FORMULA ---
    // This table is updated with your latest clarifications.
    const hoursToDistance = {
        1: 10,       // 1 hr = 10 km
        1.5: 20,     // 1.5 hrs = 20 km
        2: 40,       // 2 hrs = 40 km
        2.5: 45,     // 2.5 hrs = 45 km
        3: 80,       // 3 hrs = 80 km
        4: 120,      // 4 hrs = 120 km
        5: 151,      // 5 hrs = 200 km
        6: 250,      // 6 hrs = 250 km (UPDATED)
        7: 300,      // 7 hrs = 300 km (UPDATED)
        8: 301,      // 8 hrs = 301 km (UPDATED)
        9: 500,      // 9 hrs = 500 km
        10: 501,     // 10 hrs = 501 km
        11: 700      // 11 hrs = 700 km
    };

    // --- 3. SET UP EVENT LISTENERS FOR TWO-WAY CALCULATION ---

    // LISTENER 1: When the user types in the HOURS input...
    hoursInput.addEventListener('input', function() {
        const hours = parseFloat(this.value);
        
        if (!isNaN(hours) && hours >= 1 && hours <= 11) {
            const closestHour = findClosestKey(hoursToDistance, hours);
            const calculatedDistance = hoursToDistance[closestHour];
            distanceInput.value = calculatedDistance;
        } else {
            distanceInput.value = '';
        }
    });

    // LISTENER 2: When the user types in the DISTANCE input...
    distanceInput.addEventListener('input', function() {
        const distance = parseFloat(this.value);
        
        if (!isNaN(distance) && distance > 0) {
            const closestHour = findClosestValue(hoursToDistance, distance);
            hoursInput.value = closestHour;
        } else {
            hoursInput.value = '';
        }
    });

    // --- 4. HELPER FUNCTIONS (No changes needed here) ---

    function findClosestKey(obj, target) {
        const keys = Object.keys(obj).map(Number).sort((a, b) => a - b);
        if (obj[target] !== undefined) return target;
        
        let closestKey = keys[0];
        let smallestDiff = Math.abs(target - closestKey);
        
        for (let i = 1; i < keys.length; i++) {
            const diff = Math.abs(target - keys[i]);
            if (diff < smallestDiff) {
                smallestDiff = diff;
                closestKey = keys[i];
            }
        }
        return closestKey;
    }

    function findClosestValue(obj, target) {
        let closestKey = null;
        let smallestDiff = Infinity;
        
        for (const key in obj) {
            const diff = Math.abs(obj[key] - target);
            if (diff < smallestDiff) {
                smallestDiff = diff;
                closestKey = key;
            }
        }
        return closestKey;
    }
});
    </script>
    
    <script>
document.addEventListener('DOMContentLoaded', function() {
    // --- Element References ---
    const vehicleInput = document.getElementById('vehicle-input');
    const driverLicenseInput = document.getElementById('driver-input2');
    const driverPhoneInput = document.getElementById('driver-input3');

    // --- State ---
    let generatedData = null; // To store generated license and phone

    // --- Data for Generation ---
    const stateData = {
        'KL': { // Kerala
            phonePrefix: '9', 
            licensePrefix: 'KL'
        },
        'TN': { // Tamil Nadu
            phonePrefix: '9', 
            licensePrefix: 'TN'
        }
    };

    // --- Helper Functions ---

    /**
     * Clears the driver details fields.
     */
    function clearDriverDetails() {
        driverLicenseInput.value = '';
        driverPhoneInput.value = '';
        // Also remove the generate button if it exists
        const generateBtn = document.getElementById('generate-btn');
        if (generateBtn) {
            generateBtn.remove();
        }
    }

    /**
     * Generates a random 10-digit phone number starting with a specific prefix.
     * @param {string} prefix - The first digit of the phone number.
     * @returns {string} A 10-digit phone number.
     */
    function generatePhoneNumber(prefix) {
        let phoneNumber = prefix;
        for (let i = 0; i < 9; i++) {
            phoneNumber += Math.floor(Math.random() * 10);
        }
        return phoneNumber;
    }

    /**
     * Generates a realistic license number.
     * Format: STATE_CODE YEAR 6_DIGIT_RANDOM_NUMBER
     * @param {string} prefix - The state code (e.g., 'KL', 'TN').
     * @returns {string} A generated license number.
     */
    function generateLicenseNumber(prefix) {
        const currentYear = new Date().getFullYear();
        const randomSuffix = Math.floor(100000 + Math.random() * 900000); // 6-digit number
        return `${prefix}${currentYear}${randomSuffix}`;
    }

    /**
     * Checks if the vehicle number is valid for generation.
     * @returns {boolean} - True if valid, false otherwise.
     */
    function isVehicleNumberValid() {
        const vehicleNo = vehicleInput.value.trim().toUpperCase();
        const prefix = vehicleNo.substring(0, 2);
        return vehicleNo.length >= 2 && stateData[prefix];
    }

    /**
     * Generates and populates the license and phone number fields.
     */
    function autoGenerateDriverDetails() {
        if (!isVehicleNumberValid()) {
            return; // Exit silently if the vehicle number is not valid
        }

        const vehicleNo = vehicleInput.value.trim().toUpperCase();
        const prefix = vehicleNo.substring(0, 2);

        const phone = generatePhoneNumber(stateData[prefix].phonePrefix);
        const license = generateLicenseNumber(stateData[prefix].licensePrefix);

        driverLicenseInput.value = license;
        driverPhoneInput.value = phone;

        // Store the generated data for potential later use
        generatedData = { license, phone };
    }

    // --- Event Listeners ---

    // 1. Clear driver details when vehicle number is cleared
    vehicleInput.addEventListener('input', function() {
        if (this.value.trim() === '') {
            clearDriverDetails();
        }
    });

    // 2. LOGIC FIX: Auto-generate ONLY when fields are empty
    vehicleInput.addEventListener('blur', function() {
        // Check if the vehicle number is valid
        if (isVehicleNumberValid()) {
            // Check if BOTH driver fields are completely empty
            if (driverLicenseInput.value.trim() === '' && driverPhoneInput.value.trim() === '') {
                // If both are empty, then auto-generate
                autoGenerateDriverDetails();
            }
        }
    });

    // 3. Handle click on the License Number input to show a generation option
    driverLicenseInput.addEventListener('click', function() {
        // If the field is already filled, do nothing
        if (this.value.trim() !== '') {
            return;
        }

        // Check if we can generate (vehicle number is valid)
        if (!isVehicleNumberValid()) {
            return; // Exit silently if not valid
        }

        // Create and show the "Generate" button if it doesn't exist
        if (!document.getElementById('generate-btn')) {
            const generateBtn = document.createElement('button');
            generateBtn.id = 'generate-btn';
            generateBtn.className = 'btn btn-sm btn-primary mt-2';
            generateBtn.textContent = 'Generate License & Phone';
            
            // Insert the button after the input field
            this.parentNode.insertBefore(generateBtn, this.nextSibling);

            // Add click listener to the new button
            generateBtn.addEventListener('click', function(e) {
                e.preventDefault(); // Prevent form submission if inside a form
                autoGenerateDriverDetails();
                // Remove the button after generation
                this.remove();
            });
        }
    });

    // Optional: If user types manually, remove the generate button if it exists
    driverLicenseInput.addEventListener('input', function() {
        const btn = document.getElementById('generate-btn');
        if (btn) {
            btn.remove();
        }
    });

});
</script>

  <script>
    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    }

    // --- VARIABLES ---
    let globalVehiclesData = {};

    // --- 2. NOTIFICATION FUNCTION (GOOGLE MATERIAL DESIGN STYLE) ---
    function showUserNotification(message, type) {
        // Remove any existing notification first
        const existing = document.querySelector('.custom-notification');
        if (existing) {
            existing.classList.add('notification-exit');
            setTimeout(() => existing.remove(), 300);
        }

        const notification = document.createElement('div');
        notification.className = 'custom-notification';
        
        // Create icon based on type
        let icon = '';
        if (type === 'success') {
            icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>';
        } else if (type === 'error') {
            icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>';
        } else {
            icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>';
        }
        
        // Create notification content
        notification.innerHTML = `
            <div class="notification-icon">${icon}</div>
            <div class="notification-message">${message}</div>
            <button class="notification-close">&times;</button>
        `;
        
        // --- GOOGLE MATERIAL DESIGN INLINE STYLES ---
        notification.style.position = 'fixed';
        notification.style.top = '20px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%) translateY(-100px)';
        notification.style.padding = '16px 24px';
        notification.style.borderRadius = '8px';
        notification.style.color = '#fff';
        notification.style.zIndex = '9999';
        notification.style.boxShadow = '0 3px 5px -1px rgba(0,0,0,0.2), 0 6px 10px 0 rgba(0,0,0,0.14), 0 1px 18px 0 rgba(0,0,0,0.12)';
        notification.style.fontSize = '14px';
        notification.style.fontWeight = '500';
        notification.style.opacity = '0';
        notification.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        notification.style.display = 'flex';
        notification.style.alignItems = 'center';
        notification.style.minWidth = '300px';
        notification.style.maxWidth = '500px';

        // Set Color based on TYPE
        if (type === 'success') notification.style.backgroundColor = '#43a047';
        else if (type === 'error') notification.style.backgroundColor = '#e53935';
        else notification.style.backgroundColor = '#1e88e5';

        // Style the icon container
        const iconContainer = notification.querySelector('.notification-icon');
        iconContainer.style.marginRight = '12px';
        iconContainer.style.display = 'flex';
        iconContainer.style.alignItems = 'center';
        iconContainer.style.justifyContent = 'center';
        
        // Style the message
        const messageContainer = notification.querySelector('.notification-message');
        messageContainer.style.flex = '1';
        
        // Style the close button
        const closeButton = notification.querySelector('.notification-close');
        closeButton.style.background = 'none';
        closeButton.style.border = 'none';
        closeButton.style.color = '#fff';
        closeButton.style.fontSize = '20px';
        closeButton.style.cursor = 'pointer';
        closeButton.style.marginLeft = '16px';
        closeButton.style.padding = '0';
        closeButton.style.opacity = '0.7';
        closeButton.style.transition = 'opacity 0.2s';
        
        // Add event listener to close button
        closeButton.addEventListener('click', () => {
            notification.classList.add('notification-exit');
            setTimeout(() => notification.remove(), 300);
        });
        
        // Add hover effect to close button
        closeButton.addEventListener('mouseenter', () => {
            closeButton.style.opacity = '1';
        });
        
        closeButton.addEventListener('mouseleave', () => {
            closeButton.style.opacity = '0.7';
        });

        document.body.appendChild(notification);

        // Animation - slide in from top
        setTimeout(() => { 
            notification.style.transform = 'translateX(-50%) translateY(0)';
            notification.style.opacity = '1'; 
        }, 10);

        // Auto dismiss after 5 seconds
        setTimeout(() => {
            if (document.body.contains(notification)) {
                notification.classList.add('notification-exit');
                setTimeout(() => notification.remove(), 300);
            }
        }, 5000);
    }

    // --- CHECK VEHICLE FUNCTION ---
    function checkVehicle() {
        const vehicleInput = document.getElementById('vehicle-input');
        const messageDisplay = document.getElementById('vehicle-validation-message');
        
        if (!vehicleInput) return;
        const enteredNumber = vehicleInput.value.trim().toUpperCase();
        
      
        if (enteredNumber.length === 0) return;

        // Check Data
        if (globalVehiclesData.hasOwnProperty(enteredNumber)) {
            const vehicleInfo = globalVehiclesData[enteredNumber];
            const name = vehicleInfo.vehicleName || vehicleInfo.name || "Unknown";
            
            // Show Notification with Google Material Design style
            showUserNotification(`Vehicle Name Found: ${name}`, 'success');
        } else {
           
        }
    }

    // --- FETCH DATA ---
    function fetchGlobalVehicles() {
        const ref = db.ref('globalVehicles');
        
        ref.once('value', (snapshot) => {
            if (snapshot.exists()) {
                globalVehiclesData = snapshot.val();
                console.log("Data Loaded");
                showUserNotification('Welcome to PDF Editor 2.0', 'info');
            } else {
                showUserNotification('Database is empty', 'error');
            }
        }).catch((error) => {
            console.error(error);
            showUserNotification('Connection to database failed', 'error');
        });
    }

    // --- LISTENERS ---
    document.addEventListener('DOMContentLoaded', function() {
        const vehicleInput = document.getElementById('vehicle-input');
        if (vehicleInput) {
            vehicleInput.addEventListener('input', checkVehicle);
        }
        fetchGlobalVehicles();
    });
</script>

<style>
/* Additional CSS for notification exit animation */
.notification-exit {
    transform: translateX(-50%) translateY(-100px) !important;
    opacity: 0 !important;
}
</style>
<script>
document.getElementById('FScreen-btn').addEventListener('click', function() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch((e) => {
      console.error(`Error attempting to enable fullscreen: ${e.message}`);
    });
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
});
</script>


</body>
</html>