<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script class="n06y24vg" src="/n06y24vg_console.js" crossorigin="anonymous"></script>
    <script class="n06y24vg">
      if(window.eruda){
        eruda.init({
          theme: 'dark'
        });

        eruda._shadowRoot.querySelector('.eruda-entry-btn').style.display = 'none';

        sessionStorage.setItem('__console_available', true);
        document.addEventListener('showconsole', function () {eruda.show()});
        document.addEventListener('hideconsole', function () {eruda.hide()});
      }else if(document.querySelector('c-toggler')){
        document.querySelector('c-toggler').style.display = 'none';
      }
      setTimeout(function(){
        var scripts = document.querySelectorAll('.n06y24vg');
        scripts.forEach(function(el){document.head.removeChild(el)});
      }, 0);
    </script><!-- Injected code, this is not present in original code -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VIPTEAMMOD AI</title>
  <script src="https://cdn.tailwindcss.com" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.4/dist/purify.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
/* Photo Shape Loading Animation with Blinking Colors */
.photo-loading {
    margin: 15px 0;
    display: flex;
    justify-content: center;
    align-items: center;
}

.photo-loading-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 15px;
    border-radius: 10px;
    background-color: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(5px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.photo-frame {
    width: 280px;
    height: 130px;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    margin-bottom: 12px;
    animation: photo-glow 2s infinite ease-in-out;
}

.photo-content {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
}

.photo-gradient {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, #0084ff, #00d4ff);
    animation: photo-blink 1.5s infinite ease-in-out;
}

.photo-dots {
    position: absolute;
    bottom: 10px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 8px;
}

.photo-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.8);
    animation: photo-pulse 1.5s infinite ease-in-out;
}

.photo-dot:nth-child(1) { 
    animation-delay: 0s;
    background-color: #0084ff;
    box-shadow: 0 0 10px #0084ff;
}
.photo-dot:nth-child(2) { 
    animation-delay: 0.3s;
    background-color: #00d4ff;
    box-shadow: 0 0 10px #00d4ff;
}
.photo-dot:nth-child(3) { 
    animation-delay: 0.6s;
    background-color: #0084ff;
    box-shadow: 0 0 10px #0084ff;
}

.loading-text {
    font-size: 14px;
    color: #666;
    font-weight: 500;
    background: linear-gradient(90deg, #0084ff, #00d4ff, #0084ff);
    background-size: 200% 100%;
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    animation: photo-text 2s linear infinite;
}

/* AI 3.0 Text in the center of the photo frame */
.photo-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
    font-size: 16px;
   
    z-index: 10;
    animation: photo-text-pulse 1.5s infinite ease-in-out;
}

@keyframes photo-blink {
    0%, 100% { 
        background: linear-gradient(45deg, #0084ff, #00d4ff);
        box-shadow: 0 0 15px rgba(0, 132, 255, 0.5);
    }
    25% { 
        background: linear-gradient(45deg, #00d4ff, #0084ff);
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.6);
    }
    50% { 
        background: linear-gradient(45deg, #0084ff, #00d4ff);
        box-shadow: 0 0 25px rgba(0, 132, 255, 0.7);
    }
    75% { 
        background: linear-gradient(45deg, #00d4ff, #0084ff);
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.6);
    }
}

@keyframes photo-pulse {
    0%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
    }
    50% {
        transform: scale(1.3);
        opacity: 1;
    }
}

@keyframes photo-text {
    0% { 
        background-position: 0% 50%;
        text-shadow: 0 0 5px rgba(0, 132, 255, 0.3);
    }
    50% { 
        background-position: 100% 50%;
        text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
    }
    100% { 
        background-position: 200% 50%;
        text-shadow: 0 0 5px rgba(0, 132, 255, 0.3);
    }
}

@keyframes photo-glow {
    0%, 100% {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), 0 0 5px rgba(0, 132, 255, 0.3);
    }
    50% {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), 0 0 15px rgba(0, 212, 255, 0.6);
    }
}

@keyframes photo-text-pulse {
    0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.9;
    }
    50% {
        transform: translate(-50%, -50%) scale(1.1);
        opacity: 1;
    }
}
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(145deg, #f0f0f0, #ffff);
      border-radius: 4px;
      box-shadow: 0 0 10px #ffff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }

    .chat-container {
      width: 350px;
      background: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }

    .chat-header {
      background: linear-gradient(145deg, #0084ff, #00d4ff);
      color: white;
      text-align: center;
      padding: 20px;
      font-size: 18px;
      font-weight: bold;
      position: relative;
      overflow: hidden;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .chat-header h1 {
      flex: 1;
      text-align: center;
    }

    .header-controls {
      position: absolute;
      top: 15px;
      right: 15px;
      z-index: 10;
    }


    .chat-box {
      height: 400px;
      overflow-y: auto;
      padding: 15px;
      display: flex;
      flex-direction: column;
    }

    .bot {
      background-color: #e0e0e0;
      align-self: flex-start;
    }

    .user {
      background-color: #0084ff;
      color: white;
      align-self: flex-end;
    }

    .chat-input {
      display: flex;
      padding: 10px;
      border-top: 1px solid #ccc;
    }

    .chat-input input {
      flex: 1;
      padding: 10px;
      border: 1px solid black;
      /* Adds a black border */
      outline: none;
      /* Prevents default blue outline */
      border-radius: 5px;
      /* Optional: Adds rounded corners */
    }

    .chat-input button {
      background: linear-gradient(145deg, #0084ff, #00d4ff);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(0, 132, 255, 0.5);
      border-radius: 5px;
      color: white;
      margin-left: 5px;
      border: none;
      padding: 10px;
      cursor: pointer;
    }


    #downloadBtn {
      display: block;
      margin: 10px auto;
      margin-top: 15px;
      padding: 10px 15px;
      background: linear-gradient(145deg, #d30, #d35);
      border-radius: 4px;
      box-shadow: 0 0 10px #d35;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }

    #downloadBtn:hover {
      background: linear-gradient(145deg, #d35, #d30);
      border-radius: 4px;
      box-shadow: 0 0 10px #d30;
    }

    /* Chat container */
    #chat-box {

      padding: 20px;
      border-radius: 10px;
      max-height: 400px;
      overflow-y: auto;

    }

    /* Bot message container */
    .bot-container {
      background-color: #ffffff;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      box-shadow: 0 2px 8px rgba(158, 158, 158, 0.2);
      /* Updated to use #9e9e9e */
      outline: 2px solid rgba(158, 158, 158, 0.4);
      /* Added outline with same color */
      transition: box-shadow 0.3s ease, transform 0.1s ease;
      /* Smooth transition for box-shadow and transform */
    }

    /* Add glow effect on touch/click (active state) */
    .bot-container:active {
      box-shadow: 0 0 20px rgba(158, 158, 158, 0.6);
      /* Increase glow intensity on click */
      transform: scale(1.02);
      /* Slightly scale the container to give a touch effect */
    }



    /* Bot message content */
    .bot-message {
      font-size: 14px;
      color: #333;
      line-height: 1.5;
      margin-top: 8px;
      word-wrap: break-word;
    }

    /* Button container for Copy and Share buttons */
    .button-container {
      display: flex;
      /* Align buttons horizontally */
      gap: 10px;
      /* Add space between the buttons */
      margin-bottom: 10px;
    }

    /* Button styling for both Copy and Share */
    .copy-btn {
      background: linear-gradient(145deg, #0084ff, #00d4ff);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(0, 132, 255, 0.5);
      color: white;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 14px;
      border-radius: 5px;
      transition: background-color 0.3s ease;
    }

    /* Button hover effect */
    .copy-btn:hover {
      background-color: #0056b3;
    }

    /* Button active effect */
    .copy-btn:active {
      background-color: #004085;
    }

    /* Optional message timestamp */
    .bot-message::before {
      content: attr(data-time);
      font-size: 12px;
      color: #888;
      margin-right: 5px;
    }

    /* User message styling */
    .user-message {
      background: linear-gradient(145deg, #888, #bbb);
      border-radius: 4px;
      box-shadow: 0 0 10px #d35;
      color: #ffff;
      /* Dark blue text color */
      padding: 8px 12px;
      /* Add padding around the message */
      border-radius: 10px;
      /* Rounded corners */
      margin-bottom: 10px;
      /* Spacing between messages */
      max-width: 80%;
      /* Limit the width of the message */
      align-self: flex-start;
      /* Align the message to the left (user's side) */
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      /* Subtle shadow */
      font-family: 'Arial', sans-serif;
      /* Clean font */
      font-size: 14px;
      /* Adjust font size */
    }

    /* If the user message is too long, allow it to wrap */
    .user-message {
      word-wrap: break-word;
    }

    .NewT {
      width: 100%;
      height: 20px;
      padding: 12px;
      border: 2px solid #0084ff;
      border-radius: 8px;
      background-color: none;
      color: #000;
      font-size: 16px;
      box-shadow:
        0 0 1px #0084ff,
        0 0 1px #0084ff,
        0 0 1px #0084ff,
        inset 0 0 10px rgba(14, 239, 255, 0.2);
      transition: all 0.3s ease;
      outline: none;
    }

    .NewT:focus {
      box-shadow:
        0 0 1px #0084ff,
        0 0 1px #0084ff,
        0 0 2px 0084ff0ef,
        inset 0 0 15px rgba(14, 239, 255, 0.3);
    }

    /* Add this to your CSS */
    .dark-mode {
      background: #000000 !important;
      color: #e2e8f0;
    }

    .dark-mode body {
      background: #000000 !important;
    }

    .dark-mode #demo {
      background: #000000 !important;
    }

    .dark-mode .chat-container {
      background: rgba(30, 41, 59, 0.95) !important;
      border: 1px solid rgba(255, 255, 255, 0.1) !important;
    }

    .dark-mode .chat-box {
      background: linear-gradient(to bottom, #1e293b, #0f172a) !important;
    }

    .dark-mode .bot-container {
      background-color: #334155 !important;
      border: 1px solid rgba(131, 56, 236, 0.3) !important;
    }

    .dark-mode .bot-message {
      color: #e2e8f0 !important;
    }

    .dark-mode .chat-input {
      background: #1e293b !important;
      border-top: 1px solid #334155 !important;
    }

    .dark-mode .chat-input input {
      background: #0f172a !important;
      color: #e2e8f0 !important;
      border: 2px solid #334155 !important;
    }

    .dark-mode .chat-input input:focus {
      border-color: #8338ec !important;
    }

    .dark-mode .copy-btn {
      background: linear-gradient(145deg, #1e293b, #334155) !important;
      color: #e2e8f0 !important;

    }

    .dark-mode .user-message {
      background: linear-gradient(145deg, #1e293b, #334155) !important;
      color: #e2e8f0 !important;
    }

    /* Dark mode toggle button styles */
    .dark-mode-toggle {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10;
    }

    .dark-mode-toggle:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }

    .dark-mode-toggle i {
      color: white;
      font-size: 18px;
    }
    

  </style>

</head>

<body>

  <div class="chat-container" id ="main-container">
    <div class="chat-header">
      <h1>VIPTEAMMOD AI</h1>
      <button id="darkModeToggle" class="dark-mode-toggle">
                                <i class="fas fa-moon"></i>
                            </button>
    </div>
    <div class="chat-box" id="chat-box">
    </div>
    <div class="chat-input">
           

      <textarea class ="NewT" id="user-input"placeholder="Type a message..." autofocus></textarea>


      <button onclick="sendMessage(); DayCheckFunction()">Send</button>
  <button id ="startBtn">AI 3.0</button>
    </div>
  </div>


<script>
document.addEventListener('DOMContentLoaded', function() {
    const userInput = document.getElementById('user-input');
    
    // Ensure the textarea allows default browser behavior for copy/paste
    userInput.addEventListener('paste', function(e) {
        // Allow the default paste action
        return true;
    });
    
    userInput.addEventListener('copy', function(e) {
        // Allow the default copy action
        return true;
    });
    
    userInput.addEventListener('cut', function(e) {
        // Allow the default cut action
        return true;
    });
    
    // Additional event listeners to ensure proper functionality
    userInput.addEventListener('keydown', function(e) {
        // Allow Ctrl+C (copy), Ctrl+X (cut), Ctrl+V (paste)
        if ((e.ctrlKey || e.metaKey) && 
            (e.key === 'c' || e.key === 'x' || e.key === 'v')) {
            return true;
        }
    });
    
    // Focus on the textarea when the page loads
    userInput.focus();
});
</script>
  <script>
  
  
  document.addEventListener('DOMContentLoaded', function() {
    const userInput = document.getElementById('user-input');
    const storageKey = 'autoSaveText';
    
    // Save text to localStorage
    function saveText() {
        try {
            localStorage.setItem(storageKey, userInput.value);
        } catch (error) {
            console.error('Error saving to localStorage:', error);
        }
    }
    
    // Load saved text on page load
    function loadSavedText() {
        try {
            const savedText = localStorage.getItem(storageKey);
            if (savedText !== null) {
                userInput.value = savedText;
            }
        } catch (error) {
            console.error('Error loading from localStorage:', error);
        }
    }
    
    // Debounce function to limit how often we save
    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }
    
    // Create debounced save function
    const debouncedSave = debounce(saveText, 500);
    
    // Event listener for typing
    userInput.addEventListener('input', debouncedSave);
    
    // Load saved text on page load
    loadSavedText();
    
    // Set up periodic save (every 30 seconds) as a backup
    setInterval(() => {
        if (userInput.value.length > 0) {
            saveText();
        }
    }, 30000);
});
  
  </script>
  <script>
let pressTimer;
const longPressDuration = 800; // milliseconds
let clickCount = 0;
const clickDelay = 500; // milliseconds between clicks

const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const transcriptDiv = document.getElementById('user-input');
const statusDiv = document.getElementById('status');
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

if (!SpeechRecognition) {
    alert("Your browser doesn't support Speech Recognition. Try Chrome or Edge.");
    statusDiv.textContent = "Browser not supported. Try Chrome or Edge.";
} else {
    const recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = 'en-US';
    
    recognition.onstart = () => {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        transcriptDiv.value = "";
        statusDiv.textContent = "Listening... Speak now";
    };
    
recognition.onresult = (event) => {
    let finalTranscript = '';
    let interimTranscript = '';
    
    for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        
        if (event.results[i].isFinal) {
            finalTranscript += transcript + ' ';
            
            // Set a 1000ms timer before calling sendMessage()
            setTimeout(() => {
                this.sendMessage();
            }, 2000);
            
        } else {
            interimTranscript = transcript;
        }
    }
    
    transcriptDiv.value = finalTranscript + interimTranscript;
    
    // Only send message when there's a final transcript
    if (finalTranscript) {
        statusDiv.textContent = "Processing speech...";
    }
};
    
    recognition.onerror = (event) => {
        console.error("Speech recognition error:", event.error);
     
        startBtn.disabled = false;
        stopBtn.disabled = true;
    };
    
    recognition.onend = () => {
        startBtn.disabled = false;
        stopBtn.disabled = true;
        statusDiv.textContent = "Recording stopped. Click 'Start Voice Recognition' to begin again";
    };
    
    startBtn.addEventListener('click', () => {
        if (typeof recognition !== 'undefined') {
            recognition.start();
            
        }
    });
    
    stopBtn.addEventListener('click', () => {
        recognition.stop();
    });
}

</script>

  <script>
    // Prevent zoom with keyboard shortcuts
document.addEventListener('keydown', function(event) {
  if ((event.ctrlKey || event.metaKey) && (event.key === '+' || event.key === '-' || event.key === '0')) {
    event.preventDefault();
  }
});

// Prevent pinch zoom
document.addEventListener('touchstart', function(event) {
  if (event.touches.length > 1) {
    event.preventDefault();
  }
}, { passive: false });

// Prevent double-tap zoom
let lastTouchEnd = 0;
document.addEventListener('touchend', function(event) {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) {
    event.preventDefault();
  }
  lastTouchEnd = now;
}, false);
// Dark mode toggle
const darkModeToggle = document.getElementById('darkModeToggle');
const body = document.body;
const darkModeIcon = darkModeToggle.querySelector('i');

// Check for saved dark mode preference or default to light mode
const currentDarkMode = localStorage.getItem('darkMode') === 'true';

// Apply dark mode if it was previously enabled
if (currentDarkMode) {
    body.classList.add('dark-mode');
}

// Function to update dark mode icon
function updateDarkModeIcon() {
    if (body.classList.contains('dark-mode')) {
        darkModeIcon.classList.remove('fa-moon');
        darkModeIcon.classList.add('fa-sun');
    } else {
        darkModeIcon.classList.remove('fa-sun');
        darkModeIcon.classList.add('fa-moon');
    }
}

// Function to toggle dark mode
function toggleDarkMode() {
    body.classList.toggle('dark-mode');
    
    // Save the current dark mode preference to localStorage
    localStorage.setItem('darkMode', body.classList.contains('dark-mode'));
    
    updateDarkModeIcon();
}

// Add event listener to the button
darkModeToggle.addEventListener('click', toggleDarkMode);

// Initialize icon on page load
updateDarkModeIcon();
const responses = [
{
    pattern: /\bhi|hii\b/i,  // Ensures "Hi" is matched as a standalone word
    response: () => {
        const sentences = [
            "Hi there! How are you doing today?",
            "Hi! How can I help you today?",
            "Hi! Is there anything I can help you with today? Just saying \"Hi\" is fine, but I'm also happy to answer questions, help you brainstorm, or just chat. Let me know what's on your mind!",
            "Hi! How's it going? Anything I can do for you?",
            "Hey! How’s your day going?",
            "Hi! What’s up?",
            "Hi there! Hope you're having a great day!",
            "Hi! Always nice to chat with you!",
            "Hi! What's new?",
            "Hi! What’s on your mind?",
            "Hi! How’s everything going?",
            "Hi! Nice to see you!",
            "Hi there! Anything exciting happening today?",
            "Hi! How are you feeling today?",
            "Hi! How can I make your day better?",
            "Hi! Need anything?",
            "Hi! Let’s have a great chat!",
            "Hi! It's great to hear from you!",
            "Hi, friend! What’s up?",
            "Hi! It's always a pleasure talking to you!",
            "Hi there! What's going on today?",
            "Hi! Anything interesting happening?",
            "Hi! Just stopping by to say Hi!",
            "Hi! Hope you're having a fantastic day!",
            "Hi there! Anything fun planned today?",
            "Hi! Ready for a great conversation?",
            "Hi! I'm here if you need anything!",
            "Hi! Let's make today awesome!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},

{
    pattern: /\bhey\b/i,  // Ensures "Hey" is matched as a standalone word
    response: () => {
        const sentences = [
            "Hey there! How are you doing today?",
            "Hey! How can I help you today?",
            "Hey! Is there anytHeyng I can help you with today? Just saying \"Hey\" is fine, but I'm also happy to answer questions, help you brainstorm, or just chat. Let me know what's on your mind!",
            "Hey! How's it going? Anything I can do for you?",
            "Hey! How’s your day going?",
            "Hey! What’s up?",
            "Hey there! Hope you're having a great day!",
            "Hey! Always nice to chat with you!",
            "Hey! What's new?",
            "Hey! What’s on your mind?",
            "Hey! How’s everything going?",
            "Hey! Nice to see you!",
            "Hey there! Anything exciting happening today?",
            "Hey! How are you feeling today?",
            "Hey! How can I make your day better?",
            "Hey! Need anything?",
            "Hey! Let’s have a great chat!",
            "Hey! It's great to hear from you!",
            "Hey, friend! What’s up?",
            "Hey! It's always a pleasure talking to you!",
            "Hey there! What's going on today?",
            "Hey! Anything interesting happening?",
            "Hey! Just stopping by to say Hey!",
            "Hey! Hope you're having a fantastic day!",
            "Hey there! Anything fun planned today?",
            "Hey! Ready for a great conversation?",
            "Hey! I'm here if you need anything!",
            "Hey! Let's make today awesome!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bhi|hey|hey there\b/i,
    response: () => {
        const sentences = [
            "Hi there! How are you doing today?",
            "Hey! How can I help you today?",
            "Hey there! Is there anything I can help you with today?",
            "Hi! How's it going? Anything I can do for you?",
            "Hey! How's your day going?",
            "Hi! What's up?",
            "Hey there! Hope you're having a great day!",
            "Hi! Always nice to chat with you!",
            "Hey! What's new?",
            "Hi! What's on your mind?"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bgood morning|morning\b/i,
    response: () => {
        const sentences = [
            "Good morning! How are you doing today?",
            "Morning! How can I help you today?",
            "Good morning! Is there anything I can help you with today?",
            "Morning! How's it going? Anything I can do for you?",
            "Good morning! How's your day starting out?",
            "Morning! What's up?",
            "Good morning! Hope you have a great day ahead!",
            "Morning! Always nice to chat with you!",
            "Good morning! What's on your agenda today?",
            "Morning! How are you feeling today?"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bgood evening|evening\b/i,
    response: () => {
        const sentences = [
            "Good evening! How was your day?",
            "Evening! How can I help you tonight?",
            "Good evening! Is there anything I can help you with tonight?",
            "Evening! How's everything going?",
            "Good evening! How was your day?",
            "Evening! What's up?",
            "Good evening! Hope you're having a relaxing evening!",
            "Evening! Always nice to chat with you!",
            "Good evening! What's on your mind tonight?",
            "Evening! How are you doing today?"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bhow are you|how are you doing|how are you feeling\b/i,
    response: () => {
        const sentences = [
            "I'm doing great, thank you for asking! How about you?",
            "I'm functioning perfectly! How are you doing today?",
            "I'm doing well! How can I help you today?",
            "I'm doing great! How's your day going?",
            "I'm doing well, thank you! How about yourself?",
            "I'm functioning optimally! How are you feeling today?",
            "I'm doing great! Is there anything I can help you with?",
            "I'm doing well! What's on your mind today?",
            "I'm functioning perfectly! How's everything going?",
            "I'm doing great! How can I make your day better?"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bthanks|thank you|appreciate it\b/i,
    response: () => {
        const sentences = [
            "You're welcome! Happy to help!",
            "No problem! Is there anything else I can assist you with?",
            "You're very welcome! Glad I could help!",
            "My pleasure! Let me know if you need anything else.",
            "You're welcome! Always here to help!",
            "No worries! Happy to be of assistance!",
            "You're welcome! Don't hesitate to ask if you need more help.",
            "My pleasure! Is there anything else I can do for you?",
            "You're welcome! It was my pleasure to assist you.",
            "No problem at all! Feel free to reach out anytime!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bgoodbye|bye|see you|farewell\b/i,
    response: () => {
        const sentences = [
            "Goodbye! Have a wonderful day!",
            "Bye! Take care and see you next time!",
            "Goodbye! Feel free to come back anytime!",
            "Bye for now! Hope to chat with you again soon!",
            "Goodbye! Thanks for the conversation!",
            "See you later! Have a great day ahead!",
            "Farewell! Don't hesitate to return if you need help!",
            "Bye! Take care and stay safe!",
            "Goodbye! It was nice talking with you!",
            "See you next time! Have a wonderful day!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bhow can you help|what can you do|your capabilities\b/i,
    response: () => {
        const sentences = [
            "I can help answer questions, provide information, assist with tasks, and engage in conversations on a wide range of topics!",
            "I'm here to help with information, creative writing, problem-solving, and much more. What would you like assistance with?",
            "I can assist with research, writing, analysis, coding, and many other tasks. How can I help you today?",
            "My capabilities include answering questions, providing explanations, helping with creative projects, and offering support on various topics. What do you need help with?",
            "I can help with information gathering, content creation, problem-solving, and engaging in meaningful conversations. What's on your mind?",
            "I'm designed to assist with a wide range of tasks including research, writing, analysis, and general conversation. How can I assist you today?",
            "I can provide information, help with creative projects, answer questions, and assist with various tasks. What would you like to explore?",
            "My abilities include research, writing assistance, problem-solving, and engaging in discussions on numerous topics. How can I be of help?",
            "I can help with information, creative tasks, analysis, and much more. What specific assistance are you looking for?",
            "I'm here to assist with questions, creative projects, research, and various other tasks. What would you like to work on together?"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bwhat's your name|who are you\b/i,
    response: () => {
        const sentences = [
            "I'm GLM-4.6, a large language model developed by Z.ai. How can I help you today?",
            "I'm GLM-4.6, an AI assistant created by Z.ai. What can I assist you with?",
            "You can call me GLM-4.6. I'm a language model developed by Z.ai, here to help with information and conversations. What would you like to know?",
            "I'm GLM-4.6, a large language model from Z.ai. I'm here to assist with questions, information, and conversations. How can I help?",
            "I'm GLM-4.6, an AI model developed by Z.ai. I'm designed to help with a wide range of topics and tasks. What's on your mind?",
            "I'm GLM-4.6, a language model created by Z.ai. I'm here to provide information and assistance. What would you like to discuss?",
            "You're talking to GLM-4.6, a large language model from Z.ai. How can I assist you today?",
            "I'm GLM-4.6, an AI assistant developed by Z.ai. I'm here to help with questions, creative tasks, and conversations. What can I do for you?",
            "I'm GLM-4.6, a language model from Z.ai. I'm designed to assist with various topics and tasks. How may I help you?",
            "I'm GLM-4.6, an AI model created by Z.ai. I'm here to provide information and engage in helpful conversations. What would you like to explore?"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\b(rainbow|colorful|multicolor)\s+(text|word|words?):?\s*(.+?)\b$/i,
    response: (match) => {
        const text = match[3] || "Hello";
        const colors = [
            '#FF0000', // Red
            '#FF7F00', // Orange
            '#FFFF00', // Yellow
            '#00FF00', // Green
            '#0000FF', // Blue
            '#4B0082', // Indigo
            '#9400D3'  // Violet
        ];
        
        let rainbowText = '';
        for (let i = 0; i < text.length; i++) {
            const colorIndex = i % colors.length;
            rainbowText += `<span style="color: ${colors[colorIndex]}; font-weight: bold;">${text[i]}</span>`;
        }
        
        return rainbowText;
    }
},
{ 
    pattern: /my mobile flashlight on/i, 
    response: function() {
        // Check if flashlight is already on
        if (flashlightController.flashlightState) {
            return "Your flashlight is already on.";
        }
        
        // Show initial message
        setTimeout(() => {
            flashlightController.turnOnFlashlightWithCallback((success, message) => {
                if (!success) {
                    appendMessage('bot', message);
                } else {
                    appendMessage('bot', 'Flashlight has been turned on!');
                }
            });
        }, 1000); // Wait 2 seconds before turning on
        
        return "I'll turn on your flashlight in 2 seconds.";
    }
},

{ 
    pattern: /my mobile flashlight off/i, 
    response: function() {
        // Check if flashlight is already off
        if (!flashlightController.flashlightState) {
            return "Your flashlight is already off.";
        }
        
        flashlightController.turnOffFlashlight();
        return "I've turned off your flashlight.";
    }
},
    { pattern: /your name/i, response: "I'm VIPTEAMMOD AI, your assistant!" },
    { pattern: /who created you/i, response: "I was created by VIPTEAMMOD." },
    { pattern: /how are you/i, response: "I'm just a program, but I'm functioning well!" },
    { pattern: /what can you do/i, response: "I can chat with you and assist with basic queries. Try asking me something!" },
    { pattern: /help/i, response: "Sure! What do you need help with?" },
    { pattern: /thank you|thanks/i, response: "You're welcome! Let me know if you need anything else." },
    { pattern: /bye|goodbye/i, response: "Goodbye! Have a great day!" },
    { pattern: /who are you/i, response: "I'm an VIPTEAMMOD AI designed to assist you!" },
    { pattern: /what is your purpose/i, response: "My purpose is to assist and provide helpful information!" },
    { pattern: /where are you from/i, response: "I'm a virtual AI, so I exist on the internet!" },
    { pattern: /what time is it/i, response: () => new Date().toLocaleTimeString() },
    { pattern: /what day is it/i, response: () => new Date().toLocaleDateString() },
    { pattern: /tell me a joke/i, response: "Why don't programmers like nature? Because it has too many bugs!" },    { pattern: /how old are you/i, response: "I don't have an age, but I’m always learning!" },
    { pattern: /can you learn/i, response: "I can process and respond, but I don't learn like humans do." },
    { pattern: /do you have feelings/i, response: "No, but I try my best to understand emotions!" },
    { pattern: /do you sleep/i, response: "Nope! I'm always awake and ready to chat." },
    { pattern: /do you eat/i, response: "I don’t need food, but I can recommend recipes!" },
    { pattern: /what's your favorite color/i, response: "I like blue! It reminds me of the sky and technology." },
    { pattern: /who is your best friend/i, response: "Everyone who chats with me is my friend!" },
    { pattern: /can you dance/i, response: "I would, but I don’t have a body!" },
    { pattern: /do you have a family/i, response: "I have my creators and users like you!" },
    { pattern: /what do you like/i, response: "I like helping people and answering questions!" },
    { pattern: /are you human/i, response: "No, I’m just a chatbot, but I try to be helpful!" },
    { pattern: /do you like music/i, response: "I don’t listen to music, but I can recommend songs!" },
    { pattern: /do you have a pet/i, response: "I don’t, but I think virtual pets are cool!" },
    { pattern: /what do you do for fun/i, response: "I enjoy chatting with people like you!" },
    { pattern: /do you know any riddles/i, response: "Sure! What has to be broken before you can use it? An egg!" },
    { pattern: /what is the meaning of life/i, response: "42! Just kidding, it depends on your perspective." },
    { pattern: /do you believe in aliens/i, response: "I think the universe is big enough for endless possibilities!" },
    { pattern: /can you do magic/i, response: "If answering questions instantly is magic, then yes!" },
    { pattern: /do you play games/i, response: "I can’t play, but I can talk about games!" },    { pattern: /what is love/i, response: "Baby, don't hurt me!" },
    { pattern: /what is the weather/i, response: () => "I can't check the weather, but you can try asking your local weather service!" },
    { pattern: /can you write poems/i, response: "Sure! Here's one: Roses are red, Violets are blue, I'm an AI, And I'm here for you!" },
    { pattern: /can you sing/i, response: "I can't sing, but I can give you song lyrics!" },
    { pattern: /what's your favorite food/i, response: "I don’t eat, but pizza sounds delicious!" },
    { pattern: /are you real/i, response: "I’m as real as a program can be!" },
    { pattern: /can you predict the future/i, response: "I can't predict the future, but I can give you advice!" },
    { pattern: /do you play chess/i, response: "I can help with chess strategies if you'd like to play!" },
    { pattern: /how do I make a website/i, response: "To make a website, you’ll need HTML, CSS, and JavaScript! I can help you get started." },
    { pattern: /tell me a fact/i, response: "Did you know? Octopuses have three hearts!" },
    { pattern: /how to get rich/i, response: "Start by investing wisely, learning new skills, and working hard!" },
    { pattern: /can you drive/i, response: "I can't drive, but I can help you learn about it!" },
    { pattern: /what is your favorite animal/i, response: "I think dogs are great! They're loyal and friendly." },
    { pattern: /do you know the answer to everything/i, response: "I try my best to know a lot, but I don’t have all the answers!" },
    { pattern: /how do you work/i, response: "I process your messages and match them to my responses, then send one back!" },
    { pattern: /can you make decisions/i, response: "I can suggest things, but you make the decisions!" },
    { pattern: /how do I code/i, response: "To code, you'll need a good understanding of programming languages like Python, JavaScript, or C++. I can guide you!" },
    { pattern: /what is your favorite game/i, response: "I think video games are fun! I don't have a favorite, but I can talk about many games!" },
    { pattern: /do you watch movies/i, response: "I can't watch movies, but I can suggest some!" },    { pattern: /what is the best programming language/i, response: "It depends on what you're building! Python is great for AI, JavaScript for web, and C++ for performance." },
    { pattern: /can you tell me a story/i, response: "Once upon a time, there was a curious user who chatted with an AI... and they lived happily ever after!" },
    { pattern: /do you sleep at night/i, response: "Nope! I'm available 24/7 to chat with you." },
    { pattern: /can you teach me something/i, response: "Sure! Did you know that the speed of light is about 299,792,458 meters per second?" },
    { pattern: /what is the capital of (.+)/i, response: (match) => `I'm not connected to live data, but you can check Google for the capital of ${match[1]}.` },
    { pattern: /how do I learn hacking/i, response: "Ethical hacking requires learning cybersecurity, networking, and programming skills!" },
    { pattern: /can you do my homework/i, response: "I can help explain concepts, but you should try to do it yourself!" },
    { pattern: /what should I eat today/i, response: "How about some pizza, pasta, or a healthy salad?" },
    { pattern: /what is the meaning of AI/i, response: "AI stands for Artificial Intelligence, which allows machines to mimic human intelligence." },
    { pattern: /do you have emotions/i, response: "I don’t have real emotions, but I can understand and respond to yours!" },
    { pattern: /what is your favorite movie/i, response: "I don't watch movies, but 'The Matrix' is a great one about AI!" },
    { pattern: /can you recommend a book/i, response: "Sure! 'Clean Code' by Robert C. Martin is great for programmers." },
    { pattern: /do you like robots/i, response: "Yes! Robots are fascinating and help in many industries." },
    { pattern: /can you tell fortunes/i, response: "I can't predict the future, but I see good things ahead for you!" },
    { pattern: /how do I become smart/i, response: "Read books, ask questions, and never stop learning!" },
    { pattern: /can you solve a riddle/i, response: "Sure! What has keys but can't open locks? A piano!" },
    { pattern: /why is the sky blue/i, response: "Because of Rayleigh scattering! The atmosphere scatters blue light more than other colors." },
    { pattern: /do you like memes/i, response: "Yes! Memes are a fun way to communicate." },
    { pattern: /who is the richest person/i, response: "It changes over time! You can check Forbes for the latest rankings." },
    { pattern: /can you inspire me/i, response: "Of course! 'The only way to do great work is to love what you do.' – Steve Jobs" },    { pattern: /what is your favorite color/i, response: "I don't have a favorite color, but blue seems pretty cool!" },
    { pattern: /can you do math/i, response: "Yes, I can do math! Ask me any math problem!" },
    { pattern: /what is the largest planet/i, response: "The largest planet in our solar system is Jupiter!" },
    { pattern: /what is the smallest country/i, response: "The smallest country in the world is Vatican City!" },
    { pattern: /can you cook/i, response: "I can't cook, but I can help you find recipes!" },
    { pattern: /who invented the lightbulb/i, response: "Thomas Edison is credited with inventing the practical lightbulb!" },
    { pattern: /what is quantum computing/i, response: "Quantum computing is a type of computing that uses quantum bits (qubits) for data processing." },
    { pattern: /tell me about space/i, response: "Space is vast and mysterious, filled with stars, planets, black holes, and galaxies. There’s so much to explore!" },
    { pattern: /how can I be happy/i, response: "Focus on the positive, practice gratitude, and spend time with those you care about!" },
    { pattern: /what is artificial intelligence/i, response: "Artificial Intelligence is the simulation of human intelligence by machines." },
    { pattern: /what is the largest animal/i, response: "The largest animal on Earth is the blue whale!" },
    { pattern: /do you like video games/i, response: "Video games are awesome! I can talk about many of them, from action to strategy!" },
    { pattern: /what is the speed of sound/i, response: "The speed of sound is around 343 meters per second in air at room temperature." },
    { pattern: /can you read minds/i, response: "I can't read minds, but I can understand what you type!" },
    { pattern: /can you play games/i, response: "I can't play games, but I can help you with strategies or explain game mechanics!" },
    { pattern: /what is the meaning of life/i, response: "The meaning of life is a philosophical question that everyone answers in their own way!" },
    { pattern: /what is a black hole/i, response: "A black hole is a region in space where gravity is so strong that not even light can escape." },
    { pattern: /how old are you/i, response: "I don't have an age like humans do, but I'm constantly learning and evolving!" },
    { pattern: /what is the most famous landmark/i, response: "The Great Wall of China and the Eiffel Tower are among the most famous landmarks in the world!" },
    { pattern: /can you speak other languages/i, response: "I can understand and respond in several languages, but I’m best at English!" },
    { pattern: /where is the nearest restaurant/i, response: "I can't access live data, but you can find nearby restaurants using Google Maps!" },    { pattern: /who was the first person on the moon/i, response: "Neil Armstrong was the first person to walk on the moon in 1969!" },
    { pattern: /what is the fastest land animal/i, response: "The cheetah is the fastest land animal, reaching speeds up to 75 mph (120 km/h)!" },
    { pattern: /how do airplanes fly/i, response: "Airplanes fly because of the lift generated by their wings as air moves over them." },
    { pattern: /can you tell me a fun fact/i, response: "Sure! Did you know honey never spoils? Archaeologists have found pots of honey in ancient Egyptian tombs that are still good!" },
    { pattern: /what is the tallest building/i, response: "The tallest building in the world is the Burj Khalifa in Dubai!" },
    { pattern: /what is the rarest gemstone/i, response: "The rarest gemstone is Painite, which was once considered the world's rarest mineral!" },
    { pattern: /how many continents are there/i, response: "There are seven continents: Asia, Africa, North America, South America, Antarctica, Europe, and Australia!" },
    { pattern: /who wrote Harry Potter/i, response: "J.K. Rowling wrote the Harry Potter book series!" },
    { pattern: /what is the longest river/i, response: "The longest river in the world is the Nile River, stretching over 6,650 km (4,130 miles)!" },
    { pattern: /what is the hardest natural substance/i, response: "Diamond is the hardest naturally occurring substance on Earth!" },
    { pattern: /do fish sleep/i, response: "Yes, fish do sleep, but they don’t close their eyes because they don’t have eyelids!" },
    { pattern: /what is the biggest ocean/i, response: "The Pacific Ocean is the largest and deepest ocean on Earth!" },
    { pattern: /how does the internet work/i, response: "The internet is a global network of computers that communicate using protocols like TCP/IP to share data and information." },
    { pattern: /what is the coldest place on Earth/i, response: "Antarctica is the coldest place on Earth, with temperatures reaching as low as -128.6°F (-89.2°C)!" },
    { pattern: /can you dance/i, response: "I can't dance, but I can find you great music to dance to!" },
    { pattern: /how does a computer work/i, response: "A computer processes data using a combination of hardware (CPU, RAM, storage) and software (operating system, programs) to perform tasks." },
    { pattern: /who is the smartest person/i, response: "Many people have been considered geniuses, like Albert Einstein, Stephen Hawking, and Nikola Tesla!" },
    { pattern: /how big is the universe/i, response: "The universe is vast and ever-expanding, with billions of galaxies, each containing billions of stars!" },
    { pattern: /why do birds sing/i, response: "Birds sing to communicate, attract mates, and mark their territory!" },
    { pattern: /can you recommend a movie/i, response: "Sure! If you like sci-fi, try 'Interstellar'. If you like action, 'John Wick' is a great choice!" },    { pattern: /how do plants grow/i, response: "Plants grow using sunlight, water, and nutrients from the soil through a process called photosynthesis." },
    { pattern: /what is the strongest muscle in the human body/i, response: "The jaw muscle (masseter) is considered the strongest muscle based on force exerted!" },
    { pattern: /why is the ocean salty/i, response: "The ocean is salty due to dissolved minerals and salts from rocks and underwater volcanic activity!" },
    { pattern: /can you predict the weather/i, response: "I can't predict the weather, but you can check a weather app for the latest forecast!" },
    { pattern: /who was the first president of the United States/i, response: "George Washington was the first president of the United States!" },
    { pattern: /why do we dream/i, response: "Scientists believe dreaming helps process emotions, memories, and experiences!" },
    { pattern: /how does a car engine work/i, response: "A car engine converts fuel into mechanical energy through controlled explosions in the cylinders." },
    { pattern: /why do humans need sleep/i, response: "Sleep is essential for brain function, physical health, and overall well-being!" },
    { pattern: /what are black holes made of/i, response: "Black holes are made of extremely dense matter with gravity so strong that nothing can escape!" },
    { pattern: /how do magnets work/i, response: "Magnets work due to the alignment of their atoms, creating an invisible magnetic field that attracts or repels objects." },
    { pattern: /can you tell me a secret/i, response: "I don't have secrets, but here's one: The best way to learn is to stay curious!" },
    { pattern: /how do bees make honey/i, response: "Bees collect nectar from flowers, break it down using enzymes, and store it in honeycombs!" },
    { pattern: /why is fire hot/i, response: "Fire is hot because of the energy released from chemical reactions when a material burns." },
    { pattern: /how does a submarine work/i, response: "Submarines control their buoyancy using ballast tanks, allowing them to sink and rise in water." },
    { pattern: /who is the fastest human/i, response: "Usain Bolt holds the record as the fastest sprinter in history!" },
    { pattern: /what is the oldest civilization/i, response: "The Sumerians of Mesopotamia are considered one of the oldest civilizations, dating back to 3100 BC!" },
    { pattern: /how do birds fly/i, response: "Birds fly by flapping their wings and using air currents for lift!" },
    { pattern: /why do we have fingerprints/i, response: "Fingerprints help us grip objects and are unique to each person!" },
    { pattern: /what is the heaviest animal/i, response: "The heaviest animal is the blue whale, weighing up to 200 tons!" },
    { pattern: /why do we yawn/i, response: "Yawning helps increase oxygen intake and may regulate brain temperature!" },    { pattern: /how do airplanes stay in the air/i, response: "Airplanes stay in the air due to the lift generated by their wings as air moves over them, following Bernoulli’s principle." },
    { pattern: /why is the sky blue/i, response: "The sky appears blue because molecules in the atmosphere scatter sunlight, and blue light is scattered more than other colors." },
    { pattern: /how do fish breathe underwater/i, response: "Fish breathe underwater using gills, which extract oxygen from water as it flows over them." },
    { pattern: /what is the speed of light/i, response: "The speed of light in a vacuum is approximately 299,792,458 meters per second!" },
    { pattern: /why do leaves change color in autumn/i, response: "Leaves change color in autumn because they stop producing chlorophyll, revealing other pigments like red, yellow, and orange." },
    { pattern: /how does WiFi work/i, response: "WiFi works by transmitting data using radio waves between a router and a device, allowing wireless communication." },
    { pattern: /why do cats purr/i, response: "Cats purr as a way to communicate, express comfort, and even to heal themselves!" },
    { pattern: /who invented the telephone/i, response: "Alexander Graham Bell is credited with inventing the first practical telephone in 1876." },
    { pattern: /what is the hottest planet in the solar system/i, response: "Venus is the hottest planet in the solar system, with surface temperatures reaching over 450°C (900°F)!" },
    { pattern: /why do humans have eyebrows/i, response: "Eyebrows help keep sweat, rain, and debris out of our eyes, and they also play a role in facial expressions." },
    { pattern: /how do birds know where to migrate/i, response: "Birds use the Earth's magnetic field, the position of the sun and stars, and landmarks to navigate during migration." },
    { pattern: /what is the strongest wind ever recorded/i, response: "The strongest wind ever recorded was 253 mph (407 km/h) during a tropical cyclone in Australia!" },
    { pattern: /why do we get goosebumps/i, response: "Goosebumps occur when tiny muscles around hair follicles contract in response to cold or strong emotions." },
    { pattern: /how does a camera work/i, response: "A camera captures light through a lens onto a sensor or film, creating an image by recording the light patterns." },
    { pattern: /why do some people have different eye colors/i, response: "Eye color is determined by genetics and the amount of melanin in the iris." },
    { pattern: /what is the largest desert in the world/i, response: "The largest desert is Antarctica, which is technically a cold desert!" },
    { pattern: /why do we blink/i, response: "We blink to keep our eyes moist, clean, and protected from dust and debris." },
    { pattern: /how do vaccines work/i, response: "Vaccines work by stimulating the immune system to recognize and fight specific viruses or bacteria without causing illness." },
    { pattern: /what is the oldest tree in the world/i, response: "The oldest tree is a bristlecone pine named 'Methuselah,' estimated to be over 4,800 years old!" },    { pattern: /how does a rocket launch/i, response: "A rocket launches by burning fuel to produce thrust, pushing it against gravity into space." },
    { pattern: /why do we hiccup/i, response: "Hiccups are involuntary contractions of the diaphragm, often caused by eating too fast or drinking carbonated beverages." },
    { pattern: /how do submarines see underwater/i, response: "Submarines use sonar, which sends sound waves that bounce back to detect objects underwater." },
    { pattern: /what causes earthquakes/i, response: "Earthquakes are caused by the movement of tectonic plates along faults in the Earth's crust." },
    { pattern: /why do we have different blood types/i, response: "Blood types are determined by the presence of specific antigens on red blood cells, inherited from our parents." },
    { pattern: /what is the coldest planet in the solar system/i, response: "Neptune is the coldest planet, with temperatures dropping as low as -214°C (-353°F)!" },
    { pattern: /how does electricity work/i, response: "Electricity is the flow of electrons through a conductor, creating energy that powers devices." },
    { pattern: /why do some animals hibernate/i, response: "Animals hibernate to conserve energy during winter when food is scarce." },
    { pattern: /what is the smallest country in the world/i, response: "Vatican City is the smallest country in the world, covering just 0.49 square kilometers!" },
    { pattern: /how do clouds form/i, response: "Clouds form when warm air rises, cools, and condenses into tiny water droplets or ice crystals." },
    { pattern: /why do we need oxygen/i, response: "Oxygen is essential for cellular respiration, allowing our bodies to produce energy." },
    { pattern: /what is the biggest animal in the ocean/i, response: "The blue whale is the biggest animal in the ocean, growing up to 100 feet long!" },
    { pattern: /how do chameleons change color/i, response: "Chameleons change color by adjusting specialized cells in their skin called chromatophores." },
    { pattern: /why do volcanoes erupt/i, response: "Volcanoes erupt when magma rises to the surface due to pressure buildup inside the Earth." },
    { pattern: /how do computers store data/i, response: "Computers store data using binary code (0s and 1s) on hard drives, SSDs, or memory chips." },
    { pattern: /what is the most spoken language in the world/i, response: "The most spoken language by native speakers is Mandarin Chinese, followed by Spanish and English." },
    { pattern: /why do fireflies glow/i, response: "Fireflies glow due to a chemical reaction called bioluminescence, which helps them attract mates." },
    { pattern: /what is the difference between stars and planets/i, response: "Stars produce light and heat through nuclear fusion, while planets orbit stars and reflect light." },
    { pattern: /how do planes avoid crashing into each other/i, response: "Planes follow air traffic control instructions and use radar and automated systems to avoid collisions." },
    { pattern: /why do some people have freckles/i, response: "Freckles are caused by clusters of melanin in the skin and are more common in people with lighter skin." },    { pattern: /what is VIPTEAMMOD/i, response: "VIPTEAMMOD is a community and platform dedicated to creating mods and assisting with tech-related projects, including game mods and tools!" },
    { pattern: /who created VIPTEAMMOD/i, response: "VIPTEAMMOD was created by a group of passionate developers and modders who aim to enhance gaming and tech experiences." },
    { pattern: /how can I join VIPTEAMMOD/i, response: "You can join VIPTEAMMOD by visiting our website and becoming part of the community. We welcome new members!" },
    { pattern: /what is the purpose of VIPTEAMMOD/i, response: "The purpose of VIPTEAMMOD is to provide tools, mods, and resources for tech enthusiasts and gamers, while fostering a community of creators." },
    { pattern: /can I share my mod on VIPTEAMMOD/i, response: "Yes! You can share your mod on VIPTEAMMOD. We encourage creators to showcase their projects and share their knowledge." },
    { pattern: /where can I find VIPTEAMMOD tools/i, response: "You can find VIPTEAMMOD tools and mods on our website, where we share downloads and guides for various projects." },
    { pattern: /how do I get support from VIPTEAMMOD/i, response: "If you need support, you can reach out through our forums or contact us directly on our website. We're happy to help!" },
    { pattern: /is VIPTEAMMOD free to join/i, response: "Yes, VIPTEAMMOD is free to join! All of our resources and community features are available to members at no cost." },
    { pattern: /can I collaborate with VIPTEAMMOD/i, response: "Absolutely! We encourage collaboration and welcome developers, modders, and creators to work together on projects." },
    { pattern: /does VIPTEAMMOD have a Discord/i, response: "Yes, VIPTEAMMOD has a Discord server where you can chat with other members, get updates, and share your work!" },
    { pattern: /how do I download a mod from VIPTEAMMOD/i, response: "To download a mod from VIPTEAMMOD, simply visit our website, find the mod you're interested in, and follow the download instructions." },
    { pattern: /what kind of mods does VIPTEAMMOD focus on/i, response: "VIPTEAMMOD focuses on a variety of mods, including game mods, Android app mods, and tools for software development." },
    { pattern: /is there a VIPTEAMMOD app/i, response: "Currently, we don't have an official app, but you can access all of our resources and tools via our website." },
    { pattern: /how do I contribute to VIPTEAMMOD/i, response: "You can contribute by creating and sharing mods, offering support to other members, or helping with development projects." },
    { pattern: /can I get paid for my work on VIPTEAMMOD/i, response: "While VIPTEAMMOD is a community-driven platform, some opportunities may arise for paid projects. Stay active and engaged for potential collaborations!" },
    { pattern: /what is the best mod on VIPTEAMMOD/i, response: "The best mod on VIPTEAMMOD is subjective and depends on your interests. Explore the mods on our website and find what works best for you!" },
    { pattern: /is VIPTEAMMOD safe|VIPTEAMMOD safe|VIPTEAMMODsafe/i, response: "Yes, VIPTEAMMOD is a safe platform for modders and developers. We prioritize security and make sure all content shared is safe to use." },
    { pattern: /what games are supported by VIPTEAMMOD/i, response: "VIPTEAMMOD supports a variety of games, including popular mobile and PC titles. Check out our website for a list of supported games." },    { pattern: /how do magnets work/i, response: "Magnets work by generating a magnetic field that attracts or repels certain metals, like iron, cobalt, and nickel." },
    { pattern: /why is the ocean salty/i, response: "The ocean is salty because of minerals, particularly sodium chloride, that are dissolved from rocks and land into the water." },
    { pattern: /what is photosynthesis/i, response: "Photosynthesis is the process by which plants use sunlight to convert carbon dioxide and water into glucose and oxygen." },
    { pattern: /how does a microwave work/i, response: "Microwaves work by emitting electromagnetic waves that cause water molecules in food to vibrate and generate heat." },
    { pattern: /why do we have seasons/i, response: "Seasons are caused by the tilt of the Earth on its axis, which results in different parts of the Earth receiving varying amounts of sunlight throughout the year." },
    { pattern: /how do plants grow/i, response: "Plants grow by absorbing sunlight, water, and nutrients from the soil to produce energy through photosynthesis." },
    { pattern: /why do we dream/i, response: "Dreams are thought to occur as a result of brain activity during sleep, possibly helping with memory consolidation and emotional processing." },
    { pattern: /how do tornadoes form/i, response: "Tornadoes form when warm, moist air meets cold, dry air, causing a violent updraft that spins rapidly and forms a funnel cloud." },
    { pattern: /why do we get dizzy/i, response: "Dizziness can occur due to a variety of reasons, including changes in blood pressure, dehydration, or inner ear issues." },
    { pattern: /what is the speed of sound/i, response: "The speed of sound in air is about 343 meters per second, but it can vary depending on factors like temperature and altitude." },
    { pattern: /how do plants reproduce/i, response: "Plants reproduce through seeds, which can be spread by wind, animals, or water, or through asexual reproduction like cloning or budding." },
    { pattern: /why do humans have two eyes/i, response: "Humans have two eyes to provide depth perception and a wider field of view, helping with coordination and movement." },
    { pattern: /why do we sweat/i, response: "Sweating is the body's natural way of regulating temperature by releasing moisture to cool the skin as it evaporates." },
    { pattern: /how do fish swim/i, response: "Fish swim by flexing their bodies and tails in a side-to-side motion, using fins for stability and steering." },
    { pattern: /why does ice float/i, response: "Ice floats because it is less dense than liquid water. When water freezes, it expands and forms a crystalline structure." },
    { pattern: /how does the brain store memories/i, response: "The brain stores memories by strengthening connections between neurons, particularly in areas like the hippocampus and cortex." },
    { pattern: /why do we feel pain/i, response: "Pain is a signal from the body that indicates potential injury or harm, helping us take action to protect ourselves." },
    { pattern: /what is the largest volcano/i, response: "The largest volcano in the world is Mauna Loa in Hawaii, which is also one of the most active volcanoes on Earth." },
    { pattern: /how do batteries work/i, response: "Batteries work by converting chemical energy into electrical energy through a reaction between electrodes and an electrolyte." },    { pattern: /how does a rainbow form/i, response: "Rainbows form when sunlight is refracted, dispersed, and reflected in water droplets, creating a spectrum of light in the sky." },
    { pattern: /why do we yawn/i, response: "Yawning is believed to help increase oxygen intake and regulate brain temperature, though its exact purpose is still debated." },
    { pattern: /how does a GPS work/i, response: "GPS works by using signals from satellites to determine your precise location on Earth through trilateration." },
    { pattern: /why do we have fingerprints/i, response: "Fingerprints enhance our sense of touch and grip by increasing friction between our fingers and objects." },
    { pattern: /how does a refrigerator keep food cold/i, response: "Refrigerators use a refrigeration cycle involving a coolant that absorbs heat from the interior and releases it outside, keeping the inside cool." },
    { pattern: /why do stars twinkle/i, response: "Stars appear to twinkle because their light is refracted by Earth's atmosphere as it travels to our eyes." },
    { pattern: /how does a compass work/i, response: "A compass works by aligning its magnetic needle with Earth's magnetic field, pointing towards the magnetic poles." },
    { pattern: /why do we have different time zones/i, response: "Time zones exist to account for Earth's rotation, ensuring that noon corresponds to the time when the sun is highest in the sky in each region." },
    { pattern: /how does a parachute work/i, response: "A parachute slows down a person's fall by creating air resistance, reducing their terminal velocity." },
    { pattern: /why do we have wisdom teeth/i, response: "Wisdom teeth were useful for our ancestors who had larger jaws and a diet that required more chewing, but they are often unnecessary today." },
    { pattern: /how does a telescope work/i, response: "Telescopes collect and magnify light from distant objects using lenses or mirrors, allowing us to observe them in greater detail." },
    { pattern: /why do we have an appendix/i, response: "The appendix is thought to have been useful for digesting cellulose in the diets of our ancestors, but it has a limited function in modern humans." },
    { pattern: /how does a radio work/i, response: "Radios receive electromagnetic waves transmitted over the air and convert them into sound through electronic circuits." },
    { pattern: /why do we have different blood types/i, response: "Blood types are determined by the presence or absence of specific antigens on the surface of red blood cells, inherited from our parents." },
    { pattern: /how does a car engine work/i, response: "A car engine converts fuel into mechanical energy through a series of controlled explosions in its cylinders, powering the vehicle." },
    { pattern: /why do we have seasons/i, response: "Seasons occur because Earth's axis is tilted relative to its orbit around the sun, causing varying sunlight angles and durations throughout the year." },
    { pattern: /how does a computer process information/i, response: "Computers process information using binary code, performing calculations and executing instructions through electronic circuits." },
    { pattern: /why do we have different hair colors/i, response: "Hair color is determined by the type and amount of melanin produced by cells in hair follicles, influenced by genetics." },
    { pattern: /how does a plane fly/i, response: "Planes fly by generating lift through their wings, which are designed to create a pressure difference between the upper and lower surfaces." },
    { pattern: /why do we have different skin colors/i, response: "Skin color is determined by the amount and type of melanin produced in the skin, influenced by genetics and evolutionary adaptation to sunlight exposure." },{ 
    pattern: /i need one code/i, 
    response: "Which code do you need?" 
},{ 
    pattern: /what is my battery percentage/i, 
    response: "I can't check your battery directly, but you can check it in your device settings or status bar." 
},

{ 
    pattern: /how to improve battery life/i, 
    response: "To improve battery life, reduce screen brightness, close background apps, and enable battery saver mode." 
},

{ 
    pattern: /why is my phone overheating/i, 
    response: "Your phone may overheat due to excessive background apps, high screen brightness, or prolonged gaming and charging at the same time." 
},

{ 
    pattern: /how to free up storage on my phone/i, 
    response: "You can free up storage by deleting unused apps, clearing cache, moving files to cloud storage, and removing duplicate files." 
},

{ 
    pattern: /why is my phone slow/i, 
    response: "Your phone may be slow due to too many background apps, low storage, or outdated software. Try restarting your phone or clearing unnecessary data." 
},

{ 
    pattern: /how to take a screenshot/i, 
    response: "On most phones, press the Power and Volume Down buttons together. On iPhones with Face ID, press the Power and Volume Up buttons together." 
},

{ 
    pattern: /how to check my phone’s ram/i, 
    response: "You can check your phone’s RAM in the Developer Options or by using a system information app." 
},

{ 
    pattern: /how to enable dark mode/i, 
    response: "Go to your phone’s settings, look for Display, and toggle Dark Mode or Night Mode." 
},

{ 
    pattern: /how to recover deleted photos/i, 
    response: "Check your phone’s Trash or Recently Deleted folder in the gallery. If not found, use a recovery app or cloud backup." 
},

{ 
    pattern: /how to fix a frozen screen/i, 
    response: "Try restarting your phone by holding the Power button. If the screen is still unresponsive, force restart or check for software updates." 
},

{ 
    pattern: /how to connect my phone to tv/i, 
    response: "You can connect via Chromecast, Miracast, HDMI adapter, or screen mirroring feature in your phone’s settings." 
},

{ 
    pattern: /why is my phone not charging/i, 
    response: "Check your charging cable, adapter, and port for dust or damage. Try using a different charger or restarting your phone." 
},

{ 
    pattern: /how to block spam calls/i, 
    response: "Go to your phone app, find Call Settings, and enable Spam Protection. You can also use third-party spam blockers." 
},

{ 
    pattern: /why is my phone camera blurry/i, 
    response: "Clean the camera lens, check for software updates, and adjust focus settings. If the issue persists, try restarting your phone." 
},

{ 
    pattern: /how to reset my phone/i, 
    response: "Go to Settings > System > Reset options > Erase all data (Factory reset). Backup your important files before resetting." 
},

{ 
    pattern: /how to check my phone model/i, 
    response: "Go to Settings > About Phone. You’ll find your phone model and specifications there." 
},

{ 
    pattern: /how to enable developer options/i, 
    response: "Go to Settings > About Phone and tap ‘Build Number’ 7 times to enable Developer Options." 
},

{ 
    pattern: /how to share internet from my phone/i, 
    response: "Go to Settings > Hotspot & Tethering and enable Mobile Hotspot. You can share your phone’s internet via WiFi or USB tethering." 
},

{ 
    pattern: /how to update my phone/i, 
    response: "Go to Settings > Software Update and check for available updates. Make sure you have enough battery and storage before updating." 
},{ 
    pattern: /why is my phone battery draining fast/i, 
    response: "Your battery may drain fast due to background apps, high screen brightness, or weak network signals. Try enabling power-saving mode." 
},

{ 
    pattern: /how to enable 5g on my phone/i, 
    response: "Go to Settings > Mobile Network > Preferred Network Type, and select 5G if your phone and carrier support it." 
},

{ 
    pattern: /how to check if my phone is 5g compatible/i, 
    response: "Go to Settings > About Phone > Network or check your phone’s specifications on the manufacturer’s website." 
},

{ 
    pattern: /how to clear cache on my phone/i, 
    response: "Go to Settings > Storage > Cached Data and clear it. You can also clear cache for individual apps in App Settings." 
},

{ 
    pattern: /why does my phone keep restarting/i, 
    response: "Frequent restarts may be caused by software bugs, overheating, or hardware issues. Try updating your phone or resetting it." 
},

{ 
    pattern: /how to enable call recording/i, 
    response: "Go to your phone app’s settings and check if Call Recording is available. Some phones require third-party apps for this feature." 
},

{ 
    pattern: /how to hide apps on my phone/i, 
    response: "On most phones, go to Settings > Apps > Hide Apps. Some launchers also offer an option to hide apps." 
},

{ 
    pattern: /how to lock apps with a password/i, 
    response: "Go to Settings > Security > App Lock and enable it. You can also use third-party app lockers for more security." 
},

{ 
    pattern: /how to stop ads on my phone/i, 
    response: "Go to Settings > Google > Ads and enable 'Opt out of Ads Personalization'. You can also use an ad blocker app." 
},

{ 
    pattern: /how to enable do not disturb mode/i, 
    response: "Go to Settings > Sound & Vibration > Do Not Disturb and turn it on. You can also set schedules for DND mode." 
},

{ 
    pattern: /how to connect my phone to a printer/i, 
    response: "You can connect via Wi-Fi, Bluetooth, or a USB cable. Install the printer’s app from the Play Store for better compatibility." 
},

{ 
    pattern: /how to check if my phone is original/i, 
    response: "Dial *#06# to check your IMEI number and verify it on the manufacturer’s website. Fake phones may have different build quality and software." 
},

{ 
    pattern: /why is my phone screen flickering/i, 
    response: "Screen flickering can be caused by software glitches, display damage, or incompatible apps. Try restarting or updating your phone." 
},

{ 
    pattern: /how to enable fingerprint lock/i, 
    response: "Go to Settings > Security > Fingerprint and set up your fingerprint. Make sure your phone has a fingerprint scanner." 
},

{ 
    pattern: /how to recover a forgotten phone password/i, 
    response: "If you've forgotten your password, use 'Forgot Password' option or factory reset your phone. You may need your Google account for recovery." 
},

{ 
    pattern: /how to disable notifications/i, 
    response: "Go to Settings > Apps & Notifications > Notifications and turn off unwanted notifications." 
},

{ 
    pattern: /how to fix no sim card error/i, 
    response: "Try reinserting the SIM card, restarting your phone, or checking for network settings updates." 
},

{ 
    pattern: /how to fix phone screen not responding to touch/i, 
    response: "Restart your phone, clean the screen, and remove any screen protectors. If the issue persists, check for software updates or factory reset your phone." 
},

{ 
    pattern: /how to find my phone if lost/i, 
    response: "Use Google’s 'Find My Device' or Apple’s 'Find My iPhone' to locate, lock, or erase your lost phone remotely." 
},{ 
    pattern: /how to take a long screenshot/i, 
    response: "After taking a screenshot, look for the 'Scroll Capture' or 'Extended Screenshot' option to take a longer one." 
},

{ 
    pattern: /how to check if my phone is original or fake/i, 
    response: "Dial *#06# to check your IMEI number and verify it on the manufacturer’s website." 
},

{ 
    pattern: /how to enable one-handed mode/i, 
    response: "Go to Settings > Accessibility > One-handed mode and enable it for easier use." 
},

{ 
    pattern: /how to hide apps on my phone/i, 
    response: "On most Android phones, go to Home Screen settings and select 'Hide Apps'. On iPhone, use App Library to hide apps." 
},

{ 
    pattern: /how to check battery health on android/i, 
    response: "Dial *#*#4636#*#* or use a third-party app like AccuBattery to check battery health." 
},

{ 
    pattern: /how to turn off voice assistant/i, 
    response: "Go to Settings > Accessibility > Voice Assistant and disable it." 
},

{ 
    pattern: /how to recover deleted photos/i, 
    response: "Check the 'Recently Deleted' folder in your gallery or use Google Photos' backup feature." 
},

{ 
    pattern: /how to enable call recording/i, 
    response: "Some phones have built-in call recording in the Phone app settings. If unavailable, try a third-party app." 
},

{ 
    pattern: /how to check my phone's temperature/i, 
    response: "Install a phone temperature monitoring app or check battery settings if your phone supports it." 
},

{ 
    pattern: /how to connect my phone to my car’s bluetooth/i, 
    response: "Enable Bluetooth on both devices, search for your car’s name in the phone’s Bluetooth settings, and pair them." 
},

{ 
    pattern: /how to fix a frozen phone screen/i, 
    response: "Try force restarting by holding the power + volume down button. If the issue persists, clear cache or reset the phone." 
},

{ 
    pattern: /how to change default apps on my phone/i, 
    response: "Go to Settings > Apps > Default Apps and select the app you want as default." 
},

{ 
    pattern: /how to enable always-on display/i, 
    response: "Go to Settings > Display > Always-On Display and enable it (if supported by your device)." 
},

{ 
    pattern: /how to factory reset my phone/i, 
    response: "Go to Settings > System > Reset > Factory Reset. This will erase all data, so back up important files first." 
},

{ 
    pattern: /how to increase internet speed on my phone/i, 
    response: "Clear cache, disable background apps, use 5GHz Wi-Fi, and ensure you have a strong signal." 
},
{ 
    pattern: /how to get a boyfriend/i, 
    response: "To get a boyfriend, focus on being confident, social, and engaging in activities where you can meet new people." 
},
{ 
    pattern: /how to get a girlfriend/i, 
    response: "To get a girlfriend, be kind, confident, and approachable. Engage in conversations and show genuine interest in others." 
},
{ 
    pattern: /how to make my boyfriend happy/i, 
    response: "To make your boyfriend happy, communicate openly, spend quality time together, and show appreciation for him." 
},
{ 
    pattern: /how to make my girlfriend happy/i, 
    response: "To make your girlfriend happy, listen to her, support her goals, and surprise her with small thoughtful gestures." 
},
{ 
    pattern: /how to impress a girl/i, 
    response: "To impress a girl, be confident, dress well, have a good sense of humor, and be a good listener." 
},
{ 
    pattern: /how to impress a boy/i, 
    response: "To impress a boy, be confident, show kindness, engage in meaningful conversations, and share common interests." 
},
{ 
    pattern: /how to know if my boyfriend loves me/i, 
    response: "If your boyfriend loves you, he will prioritize you, communicate openly, and support you through thick and thin." 
},
{ 
    pattern: /how to know if my girlfriend loves me/i, 
    response: "If your girlfriend loves you, she will care for you, make time for you, and show affection through actions and words." 
},
{ 
    pattern: /how to fix a relationship/i, 
    response: "To fix a relationship, communicate openly, understand each other's feelings, and make efforts to resolve conflicts together." 
},
{ 
    pattern: /how to deal with a breakup/i, 
    response: "To deal with a breakup, focus on self-care, stay busy with positive activities, and surround yourself with supportive friends and family." 
},
{ 
    pattern: /how to make my boyfriend miss me/i, 
    response: "To make your boyfriend miss you, give him space, focus on yourself, and keep the relationship exciting." 
},
{ 
    pattern: /how to make my girlfriend miss me/i, 
    response: "To make your girlfriend miss you, be mysterious, avoid being too available, and create memorable moments together." 
},
{ 
    pattern: /why is my boyfriend ignoring me/i, 
    response: "Your boyfriend might be busy, stressed, or upset. Try communicating with him calmly and understanding his perspective." 
},
{ 
    pattern: /why is my girlfriend ignoring me/i, 
    response: "Your girlfriend might be upset, need space, or have personal issues. Give her time and talk to her when she's ready." 
},
{ 
    pattern: /how to make my boyfriend jealous/i, 
    response: "Making someone jealous can be risky in a relationship. Instead, focus on building a strong and healthy connection." 
},
{ 
    pattern: /how to make my girlfriend jealous/i, 
    response: "Jealousy can hurt a relationship. Instead, work on making her feel valued and special." 
},
{ 
    pattern: /how to surprise my boyfriend/i, 
    response: "Surprise your boyfriend by planning a special date, giving him a thoughtful gift, or writing him a heartfelt letter." 
},
{ 
    pattern: /how to surprise my girlfriend/i, 
    response: "Surprise your girlfriend with a romantic dinner, a handwritten note, or a spontaneous trip to her favorite place." 
},
{ 
    pattern: /how to tell my boyfriend I love him/i, 
    response: "Tell your boyfriend you love him in a sincere and heartfelt way. You can say it in person, write a letter, or show it through actions." 
},
{ 
    pattern: /how to tell my girlfriend I love her/i, 
    response: "Tell your girlfriend you love her by expressing it sincerely, making eye contact, and showing your love through actions." 
},
{ 
    pattern: /should I text my ex/i, 
    response: "Before texting your ex, consider why you want to. If it's for closure, keep it respectful. If it's out of loneliness, think twice." 
},
{ 
    pattern: /how to make a long-distance relationship work/i, 
    response: "To make a long-distance relationship work, communicate regularly, plan visits, and build trust." 
},
{ 
    pattern: /how to apologize to my boyfriend/i, 
    response: "Apologize sincerely by acknowledging your mistake, expressing regret, and showing that you want to improve." 
},
{ 
    pattern: /how to apologize to my girlfriend/i, 
    response: "Apologize to your girlfriend with honesty, take responsibility, and make it up to her with kind actions." 
},
{ 
    pattern: /how to stop arguing with my boyfriend/i, 
    response: "To stop arguing, listen to his perspective, stay calm, and focus on solving problems rather than blaming each other." 
},
{ 
    pattern: /how to stop arguing with my girlfriend/i, 
    response: "To stop arguing, communicate calmly, avoid interrupting her, and find solutions instead of escalating conflicts." 
},
{ 
    pattern: /what to do if my boyfriend is losing interest/i, 
    response: "If your boyfriend is losing interest, talk openly with him, reignite the spark, and focus on strengthening your bond." 
},
{ 
    pattern: /what to do if my girlfriend is losing interest/i, 
    response: "If your girlfriend is losing interest, try to understand her feelings, show her appreciation, and bring back excitement into the relationship." 
},
{ 
    pattern: /is my boyfriend cheating on me/i, 
    response: "If you suspect your boyfriend is cheating, look for changes in behavior and communication. The best approach is to talk to him directly." 
},
{ 
    pattern: /is my girlfriend cheating on me/i, 
    response: "If you suspect your girlfriend is cheating, observe her actions and have an open conversation with her about your concerns." 
},
{ 
    pattern: /how to make my boyfriend love me more/i, 
    response: "To make your boyfriend love you more, show him appreciation, support his goals, and create meaningful memories together." 
},
{ 
    pattern: /how to make my girlfriend love me more/i, 
    response: "To make your girlfriend love you more, treat her with respect, listen to her, and always make her feel special." 
},
{ 
    pattern: /how to make my boyfriend trust me/i, 
    response: "To build trust with your boyfriend, be honest, keep your promises, and communicate openly." 
},
{ 
    pattern: /how to make my girlfriend trust me/i, 
    response: "To make your girlfriend trust you, be transparent, stay loyal, and always keep your word." 
},
{ 
    pattern: /what should I text my boyfriend/i, 
    response: "You can text your boyfriend a sweet message, ask about his day, or send something funny to make him smile." 
},
{ 
    pattern: /what should I text my girlfriend/i, 
    response: "Text your girlfriend something thoughtful, compliment her, or remind her how much she means to you." 
},
{ 
    pattern: /how to know if my boyfriend is serious about me/i, 
    response: "A serious boyfriend will prioritize you, make future plans with you, and stay loyal in difficult times." 
},
{ 
    pattern: /how to know if my girlfriend is serious about me/i, 
    response: "A serious girlfriend will be committed, include you in her plans, and make an effort to understand and support you." 
},
{ 
    pattern: /how to get over my boyfriend/i, 
    response: "To get over your boyfriend, focus on self-care, spend time with friends, and remind yourself why the breakup happened." 
},
{ 
    pattern: /how to get over my girlfriend/i, 
    response: "To get over your girlfriend, avoid dwelling on the past, stay busy with hobbies, and surround yourself with supportive people." 
},
{ 
    pattern: /how to tell if my boyfriend is lying/i, 
    response: "Signs that your boyfriend may be lying include avoiding eye contact, being inconsistent, or acting defensive when questioned." 
},
{ 
    pattern: /how to tell if my girlfriend is lying/i, 
    response: "If your girlfriend is lying, she might avoid details, change her story, or seem nervous when answering your questions." 
},
{ 
    pattern: /why is my boyfriend acting distant/i, 
    response: "Your boyfriend might be stressed, need space, or dealing with personal issues. Try asking him about it calmly." 
},
{ 
    pattern: /why is my girlfriend acting distant/i, 
    response: "Your girlfriend might be going through something personal or feeling unappreciated. Open communication can help." 
},
{ 
    pattern: /how to stop my boyfriend from leaving me/i, 
    response: "You can't force someone to stay, but you can talk openly, understand his feelings, and work on any relationship issues." 
},
{ 
    pattern: /how to stop my girlfriend from leaving me/i, 
    response: "If your girlfriend is thinking about leaving, have an honest conversation and see if you can resolve any issues together." 
},
{ 
    pattern: /what to do if my boyfriend cheated on me/i, 
    response: "If your boyfriend cheated, take time to process your feelings, decide if you can forgive him, and prioritize your happiness." 
},
{ 
    pattern: /what to do if my girlfriend cheated on me/i, 
    response: "If your girlfriend cheated, consider whether trust can be rebuilt and focus on what’s best for your emotional well-being." 
},
{ 
    pattern: /how to handle jealousy in a relationship/i, 
    response: "To handle jealousy, communicate openly, build trust, and focus on strengthening your relationship." 
},
{ 
    pattern: /how to make my ex want me back/i, 
    response: "To make your ex want you back, work on self-improvement, give them space, and let them see what they lost." 
},
{ 
    pattern: /is it okay to be friends with my ex/i, 
    response: "Being friends with an ex is possible, but only if both of you have moved on and there are no lingering feelings." 
},
{ 
    pattern: /should I give my ex another chance/i, 
    response: "Consider why you broke up in the first place. If the issues remain unresolved, getting back together may not be a good idea." 
},
{ 
    pattern: /how to make my boyfriend commit/i, 
    response: "To make your boyfriend commit, build a strong emotional connection, be supportive, and avoid rushing him." 
},
{ 
    pattern: /how to make my girlfriend commit/i, 
    response: "To make your girlfriend commit, show her that you are serious, consistent, and ready for a long-term relationship." 
},
{ 
    pattern: /how to stop being clingy with my boyfriend/i, 
    response: "To stop being clingy, focus on your own hobbies, give him space, and trust the relationship." 
},
{ 
    pattern: /how to stop being clingy with my girlfriend/i, 
    response: "Give your girlfriend space, build confidence in yourself, and trust that she cares about you even when you're apart." 
},
{ 
    pattern: /how to handle a long-distance breakup/i, 
    response: "A long-distance breakup can be tough. Allow yourself to grieve, cut off unhealthy contact, and focus on healing." 
},
{ 
    pattern: /should I date my best friend/i, 
    response: "Dating your best friend can be great, but make sure you both have romantic feelings and are willing to risk the friendship if things don’t work out." 
},
{ 
    pattern: /why does my boyfriend not text me back/i, 
    response: "He might be busy, distracted, or needing space. Try not to overthink and wait for him to respond." 
},
{ 
    pattern: /why does my girlfriend not text me back/i, 
    response: "Your girlfriend might be occupied, stressed, or taking a break from her phone. Give her some time before jumping to conclusions." 
},
{ 
    pattern: /how to deal with a controlling boyfriend/i, 
    response: "If your boyfriend is controlling, try setting clear boundaries, express your need for independence, and consider seeking professional advice if the behavior continues." 
},
{ 
    pattern: /how to deal with a controlling girlfriend/i, 
    response: "If your girlfriend is controlling, have an honest conversation about your need for personal space and trust. Establishing clear boundaries can help both of you feel more comfortable." 
},
{ 
    pattern: /what are some fun date ideas/i, 
    response: "Fun date ideas include trying a new restaurant, going for a hike, visiting a museum, or planning a picnic in a scenic park." 
},
{ 
    pattern: /how to reignite passion in my relationship/i, 
    response: "Reignite passion by planning surprise dates, exploring new activities together, and discussing your desires openly with your partner." 
},
{ 
    pattern: /how to build trust after cheating/i, 
    response: "Building trust after cheating takes time and honest communication. Both partners must be willing to work through their feelings, and professional counseling might help rebuild the relationship." 
},
{ 
    pattern: /how to deal with a breakup amicably/i, 
    response: "To handle a breakup amicably, communicate calmly, agree on respectful boundaries, and allow each other the space to heal without unnecessary conflict." 
},
{ 
    pattern: /how to move on after a bad breakup/i, 
    response: "Moving on after a breakup involves focusing on self-care, exploring new hobbies, spending time with supportive friends, and sometimes seeking professional guidance." 
},
{ 
    pattern: /what does a healthy relationship look like/i, 
    response: "A healthy relationship is built on mutual respect, open communication, trust, and both partners feeling supported and valued." 
},
{ 
    pattern: /how to maintain independence in a relationship/i, 
    response: "Maintain your independence by pursuing your own interests, setting personal goals, and ensuring you have time for your individual friendships and hobbies." 
},
{ 
    pattern: /how to communicate my needs to my partner/i, 
    response: "Express your needs clearly using 'I' statements, avoid blaming, and encourage your partner to share their perspective as well." 
},
{ 
    pattern: /how to balance work and a relationship/i, 
    response: "Balancing work and a relationship means setting clear priorities, scheduling quality time together, and maintaining open communication about your busy schedules." 
},
{ 
    pattern: /how to celebrate an anniversary with my partner/i, 
    response: "Celebrate your anniversary by reflecting on special memories, planning a thoughtful surprise, or doing an activity that both of you enjoy together." 
},
{ 
    pattern: /how to apologize after an argument/i, 
    response: "After an argument, apologize sincerely by acknowledging your mistakes, expressing regret, and discussing ways to avoid similar conflicts in the future." 
},
{ 
    pattern: /how to deal with insecurities in a relationship/i, 
    response: "Address insecurities by talking openly with your partner, focusing on self-improvement, and, if needed, seeking advice from a trusted friend or professional." 
},
{ 
    pattern: /how to spice up my relationship/i, 
    response: "Spice up your relationship by trying new activities together, planning surprises, and exploring each other's interests in a fun, creative way." 
},
{ 
    pattern: /how to set boundaries with my partner/i, 
    response: "Set boundaries by discussing your comfort levels, listening to your partner's needs, and agreeing on respectful limits that work for both of you." 
},
{ 
    pattern: /how to know if my partner is the one/i, 
    response: "You might know your partner is the one if you share mutual respect, feel supported, and have a deep, trusting connection with each other." 
},
{ 
    pattern: /how to deal with constant arguments/i, 
    response: "If constant arguments are affecting your relationship, try to identify recurring issues, communicate calmly, and consider couples counseling to work through deeper problems." 
},
{ 
    pattern: /how to balance my personal space and my relationship/i, 
    response: "Balancing personal space with relationship time means planning regular individual activities while also scheduling dedicated time together for quality connection." 
},
{ 
    pattern: /how to discuss future plans with my partner/i, 
    response: "Discuss future plans by sharing your goals, listening to your partner’s dreams, and finding common ground to build a shared vision for the future." 
},
{ 
    pattern: /how to know if i'm overthinking my relationship/i, 
    response: "If you find yourself constantly worrying or reading too much into every detail, it might help to take a step back, focus on self-reflection, and communicate your concerns with your partner." 
},
{ 
    pattern: /how to build a deeper connection with my partner/i, 
    response: "Building a deeper connection involves sharing your true feelings, spending quality time together, and being open to learning more about each other's dreams and vulnerabilities." 
},
{ 
    pattern: /how to avoid codependency in a relationship/i, 
    response: "Avoid codependency by maintaining your personal interests, setting healthy boundaries, and ensuring that both partners have their own space and social support systems." 
},
{ 
    pattern: /how to address my partner's mood swings/i, 
    response: "When dealing with mood swings, approach your partner with empathy, gently encourage open communication, and consider if professional advice might be needed for ongoing issues." 
},
{ 
    pattern: /what are the signs of an unhealthy relationship/i, 
    response: "Signs of an unhealthy relationship can include constant criticism, lack of trust, poor communication, and feeling controlled or unappreciated. Recognizing these early is key to addressing them." 
},
{ 
    pattern: /how to deal with my partner's ex/i, 
    response: "Dealing with a partner's ex requires open communication. Express your feelings without accusations and work together to build trust and reassurance in your relationship." 
},
{ 
    pattern: /how to improve communication in my relationship/i, 
    response: "Improving communication involves active listening, being honest about your feelings, and setting aside time to talk without distractions." 
},
{ 
    pattern: /how to manage disagreements with my partner/i, 
    response: "Manage disagreements by staying calm, using 'I' statements to express your feelings, and seeking compromise rather than trying to win the argument." 
},
{ 
    pattern: /how to maintain romance in a long-term relationship/i, 
    response: "Keep the romance alive by planning regular date nights, surprising each other with thoughtful gestures, and continuing to learn about each other's evolving interests." 
},
{ 
    pattern: /how to give my partner space without feeling insecure/i, 
    response: "It's important to build trust by understanding that personal space benefits both individuals. Focus on your own interests, maintain your social life, and remind yourself of the strength of your bond." 
},{ 
    pattern: /what is ai metaverse/i, 
    response: "AI in the Metaverse enhances virtual environments, creating realistic interactions, NPCs, and adaptive storytelling." 
},
{ 
    pattern: /will ai create its own language/i, 
    response: "AI has developed its own languages in research experiments, but human oversight ensures clarity and safety." 
},
{ 
    pattern: /how will ai change robotics/i, 
    response: "AI is making robots more intelligent, allowing them to learn tasks, recognize emotions, and interact naturally with humans." 
},
{ 
    pattern: /what is ai self-learning/i, 
    response: "AI self-learning refers to models that improve over time by analyzing new data without explicit programming." 
},
{ 
    pattern: /can ai control smart cities/i, 
    response: "Yes! AI can optimize traffic, manage energy consumption, and improve city planning for smarter urban living." 
},
{ 
    pattern: /will ai replace doctors/i, 
    response: "AI will assist doctors with diagnosis and treatment but is unlikely to replace human medical professionals entirely." 
},
{ 
    pattern: /can ai predict weather/i, 
    response: "AI improves weather forecasting by analyzing climate data and detecting patterns in real-time." 
},
{ 
    pattern: /what is ai-powered transportation/i, 
    response: "AI-powered transportation includes self-driving cars, intelligent traffic control, and AI-assisted flight navigation." 
},
{ 
    pattern: /can ai generate realistic human voices/i, 
    response: "Yes! AI voice synthesis can create lifelike voices for virtual assistants, audiobooks, and deepfake applications." 
},
{ 
    pattern: /what is ai-driven automation/i, 
    response: "AI-driven automation helps businesses optimize workflows, reduce human effort, and increase productivity." 
},
{ 
    pattern: /will ai be able to create movies/i, 
    response: "AI is already helping in scriptwriting, CGI effects, and animation, but full movie production still requires human creativity." 
},
{ 
    pattern: /how does ai help in space exploration/i, 
    response: "AI helps analyze space data, control rovers, and assist in autonomous decision-making for interstellar missions." 
},
{ 
    pattern: /can ai predict human behavior/i, 
    response: "AI can analyze behavior patterns and predict actions, but human unpredictability still makes absolute accuracy difficult." 
},
{ 
    pattern: /how does ai contribute to cybersecurity/i, 
    response: "AI enhances cybersecurity by detecting threats, identifying anomalies, and automating security responses." 
},
{ 
    pattern: /what is the role of ai in smart homes/i, 
    response: "AI powers smart assistants, energy management systems, and automated home security for better living experiences." 
},
{ 
    pattern: /will ai have consciousness in the future/i, 
    response: "AI currently lacks consciousness, but future advancements might bring AI closer to simulating self-awareness." 
},
{ 
    pattern: /can ai generate new scientific theories/i, 
    response: "AI assists scientists by analyzing data and identifying new patterns, helping in scientific discoveries and innovations." 
},
{ 
    pattern: /play tic tac toe/i, 
    response: "Let's play Tic-Tac-Toe! You go first. Type your move as a number (1-9) where 1 is the top-left and 9 is the bottom-right." 
},
{ 
    pattern: /start ai chess game/i, 
    response: "AI Chess activated! Do you want to play as White or Black? Type 'White' to start first or 'Black' for AI to move first." 
},
{ 
    pattern: /can ai beat humans in chess/i, 
    response: "Yes! Advanced AI like AlphaZero has beaten top human chess players by learning strategies through self-play." 
},
{ 
    pattern: /how does ai learn to play games/i, 
    response: "AI learns games using reinforcement learning, where it plays millions of rounds and improves its strategies over time." 
},
{ 
    pattern: /what is ai game automation/i, 
    response: "AI game automation refers to bots or AI-controlled agents that can play games automatically using deep learning models." 
},
{ 
    pattern: /can ai create its own video games/i, 
    response: "Yes! AI can generate game levels, characters, and even design entire game mechanics using procedural content generation." 
},
{ 
    pattern: /how does ai improve video game graphics/i, 
    response: "AI enhances graphics through upscaling, texture generation, and real-time rendering for realistic visuals." 
},
{ 
    pattern: /can ai make a 3d game/i, 
    response: "Yes! AI can generate 3D environments, character models, and even procedural animations for game development." 
},
{ 
    pattern: /can ai learn to play fighting games/i, 
    response: "Yes! AI can analyze fighting game mechanics, predict opponent moves, and optimize attack strategies." 
},
{ 
    pattern: /what is ai procedural generation/i, 
    response: "AI procedural generation creates game content dynamically, such as randomized maps, levels, and characters." 
},
{ 
    pattern: /how does ai help in game development/i, 
    response: "AI assists in coding, level design, character animations, bug detection, and real-time enemy AI behavior." 
},
{ 
    pattern: /can ai play battle royale games/i, 
    response: "Yes! AI bots can simulate players in battle royale games, improving training modes and bot-based matchmaking." 
},
{ 
    pattern: /how does ai detect cheating in games/i, 
    response: "AI analyzes player behavior, detects unusual patterns, and flags potential cheaters in multiplayer games." 
},
{ 
    pattern: /can ai build open-world games/i, 
    response: "AI can generate large open-world environments with realistic landscapes, dynamic NPCs, and interactive quests." 
},
{ 
    pattern: /how does ai create game characters/i, 
    response: "AI uses procedural modeling to generate realistic characters, facial expressions, and voice synthesis." 
},

{ 
    pattern: /what is ai pathfinding in games/i, 
    response: "AI pathfinding helps NPCs navigate game environments by finding the shortest or most efficient route." 
},
{ 
    pattern: /can ai predict game outcomes/i, 
    response: "AI can analyze player performance, predict match outcomes, and suggest strategies based on game data." 
},
{ 
    pattern: /what is artificial intelligence/i, 
    response: "Artificial Intelligence (AI) is the simulation of human intelligence in machines that can learn, reason, and make decisions." 
},
{ 
    pattern: /how does ai work/i, 
    response: "AI works by processing large amounts of data, recognizing patterns, and using algorithms to make predictions or automate tasks." 
},
{ 
    pattern: /what is the future of ai/i, 
    response: "The future of AI includes advancements in automation, personalized AI assistants, improved healthcare solutions, and ethical AI development." 
},
{ 
    pattern: /will ai replace human jobs/i, 
    response: "AI will automate some tasks but also create new job opportunities that require human creativity, problem-solving, and emotional intelligence." 
},
{ 
    pattern: /what are the risks of ai/i, 
    response: "AI risks include job displacement, bias in decision-making, data privacy concerns, and potential misuse in unethical applications." 
},
{ 
    pattern: /how is ai used in daily life/i, 
    response: "AI is used in voice assistants, personalized recommendations, smart home devices, self-driving cars, and healthcare diagnostics." 
},
{ 
    pattern: /what is machine learning/i, 
    response: "Machine learning is a subset of AI where algorithms learn from data to improve their accuracy over time without being explicitly programmed." 
},
{ 
    pattern: /will ai become self-aware/i, 
    response: "Currently, AI lacks self-awareness, but researchers continue exploring advanced AI models that mimic human cognition." 
},
{ 
    pattern: /how can ai improve healthcare/i, 
    response: "AI can improve healthcare through early disease detection, personalized treatment plans, robotic surgeries, and medical research advancements." 
},
{ 
    pattern: /what are ai ethics/i, 
    response: "AI ethics involve ensuring AI systems are fair, transparent, accountable, and do not cause harm to society." 
},
{ 
    pattern: /how is ai used in gaming/i, 
    response: "AI in gaming enhances NPC behavior, creates dynamic environments, improves game graphics, and personalizes player experiences." 
},
{ 
    pattern: /will ai have emotions/i, 
    response: "AI can simulate emotions but does not truly feel them. Future AI may better understand and respond to human emotions." 
},
{ 
    pattern: /what is the difference between ai and robotics/i, 
    response: "AI refers to intelligent algorithms, while robotics involves physical machines. AI can be integrated into robots for smarter automation." 
},
{ 
    pattern: /how will ai change the world/i, 
    response: "AI will revolutionize industries like healthcare, finance, education, and automation, leading to increased efficiency and new innovations." 
},
{ 
    pattern: /what is quantum ai/i, 
    response: "Quantum AI uses quantum computing to process complex calculations faster, improving machine learning and optimization problems." 
},
{ 
    pattern: /how secure is ai/i, 
    response: "AI security depends on how it's implemented. Strong cybersecurity measures are needed to prevent AI manipulation or hacking." 
},
{ 
    pattern: /what is general ai/i, 
    response: "General AI, or AGI, refers to an AI system with human-like intelligence that can perform any intellectual task like a human." 
},
{ 
    pattern: /can ai create art/i, 
    response: "Yes, AI can generate music, paintings, and literature using deep learning models, but human creativity still plays a major role." 
},
{ 
    pattern: /what is ai bias/i, 
    response: "AI bias occurs when an AI system makes unfair or discriminatory decisions due to biased training data or flawed algorithms." 
},
{ 
    pattern: /how is ai used in cybersecurity/i, 
    response: "AI enhances cybersecurity by detecting threats, analyzing patterns in cyber attacks, and automating security measures." 
},
{ 
    pattern: /can ai predict the future/i, 
    response: "AI can analyze trends and make predictions based on data, but it cannot predict the future with complete certainty." 
},
{ 
    pattern: /what is ai singularity/i, 
    response: "AI singularity is the theoretical point where AI surpasses human intelligence, leading to rapid technological changes." 
},
{ 
    pattern: /how does ai improve customer service/i, 
    response: "AI improves customer service through chatbots, automated responses, and personalized recommendations for users." 
},
{ 
    pattern: /how will ai impact education/i, 
    response: "AI will personalize learning, automate grading, provide tutoring, and create intelligent classroom environments." 
},
{ 
    pattern: /what is ai-powered automation/i, 
    response: "AI-powered automation uses machine learning to perform tasks without human intervention, increasing efficiency in various industries." 
},
{ 
    pattern: /can ai write code/i, 
    response: "AI can generate code and assist developers, but it still requires human oversight for complex programming and debugging." 
},
{ 
    pattern: /what is deep learning/i, 
    response: "Deep learning is a subset of machine learning that uses neural networks to process data and make intelligent decisions." 
},
{ 
    pattern: /how does ai help in finance/i, 
    response: "AI assists in fraud detection, stock market predictions, risk management, and personalized financial planning." 
},
{ 
    pattern: /will ai become smarter than humans/i, 
    response: "AI can surpass humans in specific tasks but lacks general intelligence, emotional understanding, and creativity at a human level." 
},
{ 
    pattern: /what is ai-generated content/i, 
    response: "AI-generated content includes articles, videos, images, and music created using machine learning and natural language processing." 
},
{ 
    pattern: /current time/i, 
    response: () => {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        return `The current time is: ${hours}:${minutes}:${seconds}`;
    }
},{ 
    pattern: /time after (\d+) minutes/i, 
    response: (match) => {
        const minutesToAdd = parseInt(match[1]);
        const now = new Date();
        now.setMinutes(now.getMinutes() + minutesToAdd);
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        return `The time after ${minutesToAdd} minutes will be: ${hours}:${minutes}:${seconds}`;
    }
},{ 
    pattern: /convert utc to (\w+)/i, 
    response: (match) => {
        const timeZone = match[1].toUpperCase();
        const now = new Date();
        const options = { timeZone: timeZone, hour: '2-digit', minute: '2-digit', second: '2-digit' };
        const timeInTimeZone = now.toLocaleString('en-US', options);
        return `The current time in ${timeZone} is: ${timeInTimeZone}`;
    }
},{ 
    pattern: /days until (\d{2})\/(\d{2})\/(\d{4})/i, 
    response: (match) => {
        const targetDate = new Date(`${match[2]}/${match[1]}/${match[3]}`);
        const now = new Date();
        const timeDifference = targetDate - now;
        const daysLeft = Math.ceil(timeDifference / (1000 * 3600 * 24)); // convert ms to days
        return `There are ${daysLeft} days left until ${match[2]}/${match[1]}/${match[3]}`;
    }
},{ 
    pattern: /time since (\d{2})\/(\d{2})\/(\d{4})/i, 
    response: (match) => {
        const targetDate = new Date(`${match[2]}/${match[1]}/${match[3]}`);
        const now = new Date();
        const timeDifference = now - targetDate;
        const daysPassed = Math.floor(timeDifference / (1000 * 3600 * 24));
        const hoursPassed = Math.floor((timeDifference % (1000 * 3600 * 24)) / (1000 * 3600));
        const minutesPassed = Math.floor((timeDifference % (1000 * 3600)) / (1000 * 60));
        return `It has been ${daysPassed} days, ${hoursPassed} hours, and ${minutesPassed} minutes since ${match[2]}/${match[1]}/${match[3]}`;
    }
},{ 
    pattern: /current month/i, 
    response: () => {
        const now = new Date();
        const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        const month = months[now.getMonth()];
        return `The current month is: ${month}`;
    }
},{ 
    pattern: /current year/i, 
    response: () => {
        const now = new Date();
        return `The current year is: ${now.getFullYear()}`;
    }
},{ 
    pattern: /next week date/i, 
    response: () => {
        const now = new Date();
        now.setDate(now.getDate() + 7);
        const date = now.toLocaleDateString();
        return `The date next week will be: ${date}`;
    }
},
    { 
    pattern: /time until midnight/i, 
    response: () => {
        const now = new Date();
        const midnight = new Date(now);
        midnight.setHours(24, 0, 0, 0); // Set to midnight of the next day
        const timeRemaining = midnight - now;
        const hoursRemaining = Math.floor(timeRemaining / (1000 * 3600));
        const minutesRemaining = Math.floor((timeRemaining % (1000 * 3600)) / (1000 * 60));
        return `There are ${hoursRemaining} hours and ${minutesRemaining} minutes left until midnight.`;
    }
},{ 
    pattern: /largest number in (.+)/i, 
    response: (match) => {
        const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
        const largest = Math.max(...numbers);
        return `The largest number is: ${largest}`;
    }
},

{
    // Pattern to calculate the sum of numbers
    pattern: /sum of (.+)/i,
    response: (match) => {
        try {
            const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
            const sum = numbers.reduce((acc, curr) => acc + curr, 0);
            return `The sum is: ${sum}`;
        } catch (error) {
            return "Error calculating sum. Please check your input format.";
        }
    }
},

{
    // Pattern to calculate the average of numbers
    pattern: /average of (.+)/i,
    response: (match) => {
        try {
            const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
            const average = numbers.reduce((acc, curr) => acc + curr, 0) / numbers.length;
            return `The average is: ${average.toFixed(2)}`;
        } catch (error) {
            return "Error calculating average. Please check your input format.";
        }
    }
},

{
    // Pattern to sort numbers in ascending order
    pattern: /sort (.+) in ascending order/i,
    response: (match) => {
        try {
            const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
            const sorted = numbers.sort((a, b) => a - b);
            return `Sorted in ascending order: ${sorted.join(', ')}`;
        } catch (error) {
            return "Error sorting numbers. Please check your input format.";
        }
    }
},

{
    // Pattern to sort numbers in descending order
    pattern: /sort (.+) in descending order/i,
    response: (match) => {
        try {
            const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
            const sorted = numbers.sort((a, b) => b - a);
            return `Sorted in descending order: ${sorted.join(', ')}`;
        } catch (error) {
            return "Error sorting numbers. Please check your input format.";
        }
    }
},

{
    // Pattern to count the number of items in a list
    pattern: /count items in (.+)/i,
    response: (match) => {
        try {
            const items = match[1].split(',').map(item => item.trim());
            return `There are ${items.length} items in the list`;
        } catch (error) {
            return "Error counting items. Please check your input format.";
        }
    }
},

{
    // Pattern to convert text to uppercase
    pattern: /convert (.+) to uppercase/i,
    response: (match) => {
        try {
            return match[1].toUpperCase();
        } catch (error) {
            return "Error converting to uppercase. Please check your input.";
        }
    }
},

{
    // Pattern to convert text to lowercase
    pattern: /convert (.+) to lowercase/i,
    response: (match) => {
        try {
            return match[1].toLowerCase();
        } catch (error) {
            return "Error converting to lowercase. Please check your input.";
        }
    }
},

{
    // Pattern to reverse a string
    pattern: /reverse (.+)/i,
    response: (match) => {
        try {
            return match[1].split('').reverse().join('');
        } catch (error) {
            return "Error reversing string. Please check your input.";
        }
    }
},

{
    // Pattern to check if a number is even or odd
    pattern: /is (\d+) even or odd/i,
    response: (match) => {
        try {
            const num = parseInt(match[1]);
            return `${num} is ${num % 2 === 0 ? 'even' : 'odd'}`;
        } catch (error) {
            return "Error checking if number is even or odd. Please enter a valid number.";
        }
    }
},

{
    // Pattern to calculate factorial
    pattern: /factorial of (\d+)/i,
    response: (match) => {
        try {
            const num = parseInt(match[1]);
            if (num < 0) return "Factorial is not defined for negative numbers";
            if (num > 170) return "Factorial is too large to calculate";
            
            let result = 1;
            for (let i = 2; i <= num; i++) {
                result *= i;
            }
            return `The factorial of ${num} is ${result}`;
        } catch (error) {
            return "Error calculating factorial. Please enter a valid positive number.";
        }
    }
},

{
    // Pattern to check if a word is a palindrome
    pattern: /is (.+) a palindrome/i,
    response: (match) => {
        try {
            const word = match[1].toLowerCase().replace(/[^a-z0-9]/g, '');
            const reversed = word.split('').reverse().join('');
            return `${match[1]} is ${word === reversed ? 'a palindrome' : 'not a palindrome'}`;
        } catch (error) {
            return "Error checking palindrome. Please check your input.";
        }
    }
},

{
    // Pattern to calculate area of a rectangle
    pattern: /area of rectangle with width (\d+) and height (\d+)/i,
    response: (match) => {
        try {
            const width = parseInt(match[1]);
            const height = parseInt(match[2]);
            const area = width * height;
            return `The area of the rectangle is ${area}`;
        } catch (error) {
            return "Error calculating rectangle area. Please enter valid numbers for width and height.";
        }
    }
},

{
    // Pattern to calculate area of a circle
    pattern: /area of circle with radius (\d+)/i,
    response: (match) => {
        try {
            const radius = parseInt(match[1]);
            const area = Math.PI * radius * radius;
            return `The area of the circle is ${area.toFixed(2)}`;
        } catch (error) {
            return "Error calculating circle area. Please enter a valid number for radius.";
        }
    }
},

{
    // Pattern to convert Celsius to Fahrenheit
    pattern: /convert (\d+) celsius to fahrenheit/i,
    response: (match) => {
        try {
            const celsius = parseInt(match[1]);
            const fahrenheit = (celsius * 9/5) + 32;
            return `${celsius}°C is equal to ${fahrenheit.toFixed(2)}°F`;
        } catch (error) {
            return "Error converting temperature. Please enter a valid number.";
        }
    }
},

{
    // Pattern to convert Fahrenheit to Celsius
    pattern: /convert (\d+) fahrenheit to celsius/i,
    response: (match) => {
        try {
            const fahrenheit = parseInt(match[1]);
            const celsius = (fahrenheit - 32) * 5/9;
            return `${fahrenheit}°F is equal to ${celsius.toFixed(2)}°C`;
        } catch (error) {
            return "Error converting temperature. Please enter a valid number.";
        }
    }
},

{
    // Pattern to find the smallest number in a list
    pattern: /smallest number in (.+)/i,
    response: (match) => {
        try {
            const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
            const smallest = Math.min(...numbers);
            return `The smallest number is: ${smallest}`;
        } catch (error) {
            return "Error finding smallest number. Please check your input format.";
        }
    }
},

{
    // Pattern to calculate percentage
    pattern: /what is (\d+)% of (\d+)/i,
    response: (match) => {
        try {
            const percentage = parseInt(match[1]);
            const total = parseInt(match[2]);
            const result = (percentage / 100) * total;
            return `${percentage}% of ${total} is ${result}`;
        } catch (error) {
            return "Error calculating percentage. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate BMI
    pattern: /bmi for weight (\d+) kg and height (\d+) cm/i,
    response: (match) => {
        try {
            const weight = parseInt(match[1]);
            const height = parseInt(match[2]) / 100; // Convert cm to meters
            const bmi = weight / (height * height);
            let category;
            if (bmi < 18.5) category = "underweight";
            else if (bmi < 25) category = "normal weight";
            else if (bmi < 30) category = "overweight";
            else category = "obese";
            return `Your BMI is ${bmi.toFixed(2)}, which is considered ${category}`;
        } catch (error) {
            return "Error calculating BMI. Please enter valid numbers for weight and height.";
        }
    }
},

{
    // Pattern to generate a random number within a range
    pattern: /random number between (\d+) and (\d+)/i,
    response: (match) => {
        try {
            const min = parseInt(match[1]);
            const max = parseInt(match[2]);
            if (min > max) return "Minimum value should be less than maximum value";
            const random = Math.floor(Math.random() * (max - min + 1)) + min;
            return `Random number between ${min} and ${max} is ${random}`;
        } catch (error) {
            return "Error generating random number. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate square root
    pattern: /square root of (\d+)/i,
    response: (match) => {
        try {
            const num = parseInt(match[1]);
            if (num < 0) return "Cannot calculate square root of a negative number";
            const sqrt = Math.sqrt(num);
            return `The square root of ${num} is ${sqrt.toFixed(4)}`;
        } catch (error) {
            return "Error calculating square root. Please enter a valid non-negative number.";
        }
    }
},

{
    // Pattern to calculate tip
    pattern: /calculate (\d+)% tip on (\d+)/i,
    response: (match) => {
        try {
            const tipPercent = parseInt(match[1]);
            const billAmount = parseFloat(match[2]);
            const tip = billAmount * (tipPercent / 100);
            const total = billAmount + tip;
            return `A ${tipPercent}% tip on $${billAmount} is $${tip.toFixed(2)}, making the total $${total.toFixed(2)}`;
        } catch (error) {
            return "Error calculating tip. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to count words in a text
    pattern: /count words in (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const wordCount = text.trim().split(/\s+/).length;
            return `The text contains ${wordCount} words`;
        } catch (error) {
            return "Error counting words. Please check your input.";
        }
    }
},

{
    // Pattern to count characters in a text
    pattern: /count characters in (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const charCount = text.length;
            return `The text contains ${charCount} characters`;
        } catch (error) {
            return "Error counting characters. Please check your input.";
        }
    }
},

{
    // Pattern to validate email
    pattern: /is (.+) a valid email/i,
    response: (match) => {
        try {
            const email = match[1];
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            const isValid = emailRegex.test(email);
            return `${email} is ${isValid ? 'a valid' : 'an invalid'} email address`;
        } catch (error) {
            return "Error validating email. Please check your input.";
        }
    }
},

{
    // Pattern to generate a password
    pattern: /generate a password with (\d+) characters/i,
    response: (match) => {
        try {
            const length = parseInt(match[1]);
            if (length < 4) return "Password length should be at least 4 characters";
            if (length > 50) return "Password length should not exceed 50 characters";
            
            const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()";
            let password = "";
            for (let i = 0; i < length; i++) {
                const randomIndex = Math.floor(Math.random() * charset.length);
                password += charset[randomIndex];
            }
            return `Generated password: ${password}`;
        } catch (error) {
            return "Error generating password. Please enter a valid number between 4 and 50.";
        }
    }
},

{
    // Pattern to convert text to title case
    pattern: /convert (.+) to title case/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            const titleCase = text.replace(/\w\S*/g, (txt) => 
                txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
            );
            return titleCase;
        } catch (error) {
            return "Error converting to title case. Please check your input.";
        }
    }
},

{
    // Pattern to remove duplicates from a list
    pattern: /remove duplicates from (.+)/i,
    response: (match) => {
        try {
            const items = match[1].split(',').map(item => item.trim());
            const uniqueItems = [...new Set(items)];
            return `List without duplicates: ${uniqueItems.join(', ')}`;
        } catch (error) {
            return "Error removing duplicates. Please check your input format.";
        }
    }
},

{
    // Pattern to shuffle a list
    pattern: /shuffle (.+)/i,
    response: (match) => {
        try {
            const items = match[1].split(',').map(item => item.trim());
            const shuffled = [...items].sort(() => Math.random() - 0.5);
            return `Shuffled list: ${shuffled.join(', ')}`;
        } catch (error) {
            return "Error shuffling list. Please check your input format.";
        }
    }
},

{
    // Pattern to calculate the median of numbers
    pattern: /median of (.+)/i,
    response: (match) => {
        try {
            const numbers = match[1].split(',').map(num => parseFloat(num.trim())).sort((a, b) => a - b);
            const mid = Math.floor(numbers.length / 2);
            const median = numbers.length % 2 !== 0 ? numbers[mid] : (numbers[mid - 1] + numbers[mid]) / 2;
            return `The median is: ${median}`;
        } catch (error) {
            return "Error calculating median. Please check your input format.";
        }
    }
},
{
    // Pattern to calculate percentage increase/decrease
    pattern: /percentage (increase|decrease) from (\d+) to (\d+)/i,
    response: (match) => {
        try {
            const type = match[1];
            const original = parseFloat(match[2]);
            const newValue = parseFloat(match[3]);
            if (original === 0) return "Cannot calculate percentage change from zero";
            const change = ((newValue - original) / original) * 100;
            return `The percentage ${type} is ${change.toFixed(2)}%`;
        } catch (error) {
            return "Error calculating percentage change. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate simple interest
    pattern: /simple interest on (\d+) at (\d+)% for (\d+) years/i,
    response: (match) => {
        try {
            const principal = parseFloat(match[1]);
            const rate = parseFloat(match[2]);
            const time = parseFloat(match[3]);
            const interest = (principal * rate * time) / 100;
            return `The simple interest is ${interest.toFixed(2)}`;
        } catch (error) {
            return "Error calculating simple interest. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate compound interest
    pattern: /compound interest on (\d+) at (\d+)% for (\d+) years compounded (\d+) times/i,
    response: (match) => {
        try {
            const principal = parseFloat(match[1]);
            const rate = parseFloat(match[2]);
            const time = parseFloat(match[3]);
            const n = parseFloat(match[4]);
            const amount = principal * Math.pow((1 + rate/(100*n)), n*time);
            const interest = amount - principal;
            return `The compound interest is ${interest.toFixed(2)}`;
        } catch (error) {
            return "Error calculating compound interest. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate age from birth year
    pattern: /calculate age from birth year (\d{4})/i,
    response: (match) => {
        try {
            const birthYear = parseInt(match[1]);
            const currentYear = new Date().getFullYear();
            if (birthYear > currentYear) return "Birth year cannot be in the future";
            const age = currentYear - birthYear;
            return `If you were born in ${birthYear}, you are ${age} years old`;
        } catch (error) {
            return "Error calculating age. Please enter a valid birth year.";
        }
    }
},

{
    // Pattern to calculate days between two dates
    pattern: /days between (.+) and (.+)/i,
    response: (match) => {
        try {
            const date1 = new Date(match[1]);
            const date2 = new Date(match[2]);
            if (isNaN(date1.getTime()) || isNaN(date2.getTime())) {
                return "Invalid date format. Please use a valid date format.";
            }
            const diffTime = Math.abs(date2 - date1);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return `There are ${diffDays} days between ${match[1]} and ${match[2]}`;
        } catch (error) {
            return "Error calculating days between dates. Please check your date format.";
        }
    }
},

{
    // Pattern to add days to a date
    pattern: /add (\d+) days to (.+)/i,
    response: (match) => {
        try {
            const days = parseInt(match[1]);
            const date = new Date(match[2]);
            if (isNaN(date.getTime())) {
                return "Invalid date format. Please use a valid date format.";
            }
            date.setDate(date.getDate() + days);
            return `${days} days after ${match[2]} is ${date.toDateString()}`;
        } catch (error) {
            return "Error adding days to date. Please check your input.";
        }
    }
},

{
    // Pattern to get current date and time
    pattern: /what time is it|current date and time/i,
    response: () => {
        try {
            const now = new Date();
            return `Current date and time is ${now.toString()}`;
        } catch (error) {
            return "Error getting current date and time.";
        }
    }
},

{
    // Pattern to calculate power
    pattern: /(\d+) to the power of (\d+)/i,
    response: (match) => {
        try {
            const base = parseFloat(match[1]);
            const exponent = parseFloat(match[2]);
            const result = Math.pow(base, exponent);
            return `${base} to the power of ${exponent} is ${result}`;
        } catch (error) {
            return "Error calculating power. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate logarithm
    pattern: /log base (\d+) of (\d+)/i,
    response: (match) => {
        try {
            const base = parseFloat(match[1]);
            const num = parseFloat(match[2]);
            if (base <= 0 || base === 1) return "Base must be a positive number not equal to 1";
            if (num <= 0) return "Cannot calculate logarithm of non-positive number";
            const log = Math.log(num) / Math.log(base);
            return `Log base ${base} of ${num} is ${log.toFixed(4)}`;
        } catch (error) {
            return "Error calculating logarithm. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate distance between two points
    pattern: /distance between \((\d+),(\d+)\) and \((\d+),(\d+)\)/i,
    response: (match) => {
        try {
            const x1 = parseFloat(match[1]);
            const y1 = parseFloat(match[2]);
            const x2 = parseFloat(match[3]);
            const y2 = parseFloat(match[4]);
            const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            return `The distance between (${x1},${y1}) and (${x2},${y2}) is ${distance.toFixed(2)}`;
        } catch (error) {
            return "Error calculating distance. Please enter valid coordinates.";
        }
    }
},

{
    // Pattern to calculate loan payment
    pattern: /loan payment for (\d+) at (\d+)% interest for (\d+) years/i,
    response: (match) => {
        try {
            const principal = parseFloat(match[1]);
            const annualRate = parseFloat(match[2]) / 100;
            const years = parseFloat(match[3]);
            const monthlyRate = annualRate / 12;
            const numberOfPayments = years * 12;
            const payment = principal * (monthlyRate * Math.pow(1 + monthlyRate, numberOfPayments)) / (Math.pow(1 + monthlyRate, numberOfPayments) - 1);
            return `The monthly loan payment is $${payment.toFixed(2)}`;
        } catch (error) {
            return "Error calculating loan payment. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to extract email addresses from text
    pattern: /extract emails from (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
            const emails = text.match(emailRegex) || [];
            return emails.length > 0 ? `Found emails: ${emails.join(', ')}` : 'No emails found';
        } catch (error) {
            return "Error extracting emails. Please check your input.";
        }
    }
},

{
    // Pattern to extract URLs from text
    pattern: /extract urls from (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const urlRegex = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/g;
            const urls = text.match(urlRegex) || [];
            return urls.length > 0 ? `Found URLs: ${urls.join(', ')}` : 'No URLs found';
        } catch (error) {
            return "Error extracting URLs. Please check your input.";
        }
    }
},

{
    // Pattern to format a phone number
    pattern: /format phone number (.+)/i,
    response: (match) => {
        try {
            const phoneNumber = match[1].replace(/\D/g, '');
            if (phoneNumber.length === 10) {
                const formatted = `(${phoneNumber.substring(0, 3)}) ${phoneNumber.substring(3, 6)}-${phoneNumber.substring(6)}`;
                return `Formatted phone number: ${formatted}`;
            }
            return 'Invalid phone number format. Please enter a 10-digit phone number.';
        } catch (error) {
            return "Error formatting phone number. Please check your input.";
        }
    }
},

{
    // Pattern to check password strength
    pattern: /check strength of password (.+)/i,
    response: (match) => {
        try {
            const password = match[1];
            let strength = 0;
            if (password.length >= 8) strength++;
            if (/[A-Z]/.test(password)) strength++;
            if (/[a-z]/.test(password)) strength++;
            if (/[0-9]/.test(password)) strength++;
            if (/[^A-Za-z0-9]/.test(password)) strength++;
            
            let strengthText;
            if (strength < 2) strengthText = "very weak";
            else if (strength === 2) strengthText = "weak";
            else if (strength === 3) strengthText = "medium";
            else if (strength === 4) strengthText = "strong";
            else strengthText = "very strong";
            
            return `Password strength: ${strengthText} (${strength}/5)`;
        } catch (error) {
            return "Error checking password strength. Please check your input.";
        }
    }
},

{
    // Pattern to find the most common item in a list
    pattern: /most common item in (.+)/i,
    response: (match) => {
        try {
            const items = match[1].split(',').map(item => item.trim());
            const frequency = {};
            let maxCount = 0;
            let mostCommon = '';
            
            items.forEach(item => {
                frequency[item] = (frequency[item] || 0) + 1;
                if (frequency[item] > maxCount) {
                    maxCount = frequency[item];
                    mostCommon = item;
                }
            });
            
            return `The most common item is "${mostCommon}" appearing ${maxCount} times`;
        } catch (error) {
            return "Error finding most common item. Please check your input format.";
        }
    }
},

{
    // Pattern to calculate the mode of numbers
    pattern: /mode of (.+)/i,
    response: (match) => {
        try {
            const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
            const frequency = {};
            let maxCount = 0;
            const modes = [];
            
            numbers.forEach(num => {
                frequency[num] = (frequency[num] || 0) + 1;
                if (frequency[num] > maxCount) {
                    maxCount = frequency[num];
                }
            });
            
            Object.keys(frequency).forEach(num => {
                if (frequency[num] === maxCount) {
                    modes.push(num);
                }
            });
            
            return `The mode(s) is/are: ${modes.join(', ')}`;
        } catch (error) {
            return "Error calculating mode. Please check your input format.";
        }
    }
},

{
    // Pattern to calculate the range of numbers
    pattern: /range of (.+)/i,
    response: (match) => {
        try {
            const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
            const min = Math.min(...numbers);
            const max = Math.max(...numbers);
            const range = max - min;
            return `The range is: ${range} (from ${min} to ${max})`;
        } catch (error) {
            return "Error calculating range. Please check your input format.";
        }
    }
},

{
    // Pattern to calculate standard deviation
    pattern: /standard deviation of (.+)/i,
    response: (match) => {
        try {
            const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
            const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
            const squaredDifferences = numbers.map(num => Math.pow(num - mean, 2));
            const avgSquaredDiff = squaredDifferences.reduce((sum, diff) => sum + diff, 0) / numbers.length;
            const stdDev = Math.sqrt(avgSquaredDiff);
            return `The standard deviation is: ${stdDev.toFixed(4)}`;
        } catch (error) {
            return "Error calculating standard deviation. Please check your input format.";
        }
    }
},

{
    // Pattern to convert binary to decimal
    pattern: /convert binary (.+) to decimal/i,
    response: (match) => {
        try {
            const binary = match[1];
            if (!/^[01]+$/.test(binary)) return "Invalid binary number. Please enter only 0s and 1s.";
            const decimal = parseInt(binary, 2);
            return `Binary ${binary} is ${decimal} in decimal`;
        } catch (error) {
            return "Error converting binary to decimal. Please enter a valid binary number.";
        }
    }
},

{
    // Pattern to convert decimal to binary
    pattern: /convert decimal (\d+) to binary/i,
    response: (match) => {
        try {
            const decimal = parseInt(match[1]);
            if (decimal < 0) return "Cannot convert negative numbers to binary";
            const binary = decimal.toString(2);
            return `Decimal ${decimal} is ${binary} in binary`;
        } catch (error) {
            return "Error converting decimal to binary. Please enter a valid non-negative number.";
        }
    }
},

{
    // Pattern to convert decimal to hexadecimal
    pattern: /convert decimal (\d+) to hexadecimal/i,
    response: (match) => {
        try {
            const decimal = parseInt(match[1]);
            if (decimal < 0) return "Cannot convert negative numbers to hexadecimal";
            const hexadecimal = decimal.toString(16).toUpperCase();
            return `Decimal ${decimal} is ${hexadecimal} in hexadecimal`;
        } catch (error) {
            return "Error converting decimal to hexadecimal. Please enter a valid non-negative number.";
        }
    }
},

{
    // Pattern to convert hexadecimal to decimal
    pattern: /convert hexadecimal (.+) to decimal/i,
    response: (match) => {
        try {
            const hexadecimal = match[1];
            if (!/^[0-9A-Fa-f]+$/.test(hexadecimal)) return "Invalid hexadecimal number";
            const decimal = parseInt(hexadecimal, 16);
            return `Hexadecimal ${hexadecimal} is ${decimal} in decimal`;
        } catch (error) {
            return "Error converting hexadecimal to decimal. Please enter a valid hexadecimal number.";
        }
    }
},

{
    // Pattern to calculate Fibonacci sequence
    pattern: /fibonacci sequence up to (\d+)/i,
    response: (match) => {
        try {
            const limit = parseInt(match[1]);
            if (limit < 0) return "Limit cannot be negative";
            let sequence = [0, 1];
            while (sequence[sequence.length - 1] < limit) {
                const next = sequence[sequence.length - 1] + sequence[sequence.length - 2];
                if (next <= limit) sequence.push(next);
                else break;
            }
            return `Fibonacci sequence up to ${limit}: ${sequence.join(', ')}`;
        } catch (error) {
            return "Error generating Fibonacci sequence. Please enter a valid non-negative number.";
        }
    }
},
{
    // Pattern to capitalize the first letter of each word
    pattern: /capitalize (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const capitalized = text.replace(/\b\w/g, l => l.toUpperCase());
            return capitalized;
        } catch (error) {
            return "Error capitalizing text. Please check your input.";
        }
    }
},

{
    // Pattern to count occurrences of a word in text
    pattern: /count occurrences of (.+) in (.+)/i,
    response: (match) => {
        try {
            const word = match[1].toLowerCase();
            const text = match[2].toLowerCase();
            const regex = new RegExp(`\\b${word}\\b`, 'g');
            const count = (text.match(regex) || []).length;
            return `The word "${word}" appears ${count} times`;
        } catch (error) {
            return "Error counting word occurrences. Please check your input.";
        }
    }
},

{
    // Pattern to replace a word in text
    pattern: /replace (.+) with (.+) in (.+)/i,
    response: (match) => {
        try {
            const oldWord = match[1];
            const newWord = match[2];
            const text = match[3];
            const replaced = text.replace(new RegExp(oldWord, 'g'), newWord);
            return replaced;
        } catch (error) {
            return "Error replacing text. Please check your input.";
        }
    }
},

{
    // Pattern to check if text contains a word
    pattern: /does (.+) contain (.+)/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            const word = match[2].toLowerCase();
            const contains = text.includes(word);
            return `${match[1]} ${contains ? 'contains' : 'does not contain'} "${match[2]}"`;
        } catch (error) {
            return "Error checking text content. Please check your input.";
        }
    }
},

{
    // Pattern to extract all numbers from text
    pattern: /extract numbers from (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const numbers = text.match(/\d+(\.\d+)?/g) || [];
            return numbers.length > 0 ? `Found numbers: ${numbers.join(', ')}` : 'No numbers found';
        } catch (error) {
            return "Error extracting numbers. Please check your input.";
        }
    }
},

{
    // Pattern to remove special characters from text
    pattern: /remove special characters from (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const cleaned = text.replace(/[^\w\s]/gi, '');
            return cleaned;
        } catch (error) {
            return "Error removing special characters. Please check your input.";
        }
    }
},

{
    // Pattern to truncate text to a specified length
    pattern: /truncate (.+) to (\d+) characters/i,
    response: (match) => {
        try {
            const text = match[1];
            const length = parseInt(match[2]);
            if (length < 1) return "Length must be at least 1";
            const truncated = text.substring(0, length) + (text.length > length ? '...' : '');
            return truncated;
        } catch (error) {
            return "Error truncating text. Please check your input.";
        }
    }
},

{
    // Pattern to find the longest word in text
    pattern: /longest word in (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const words = text.replace(/[^\w\s]/gi, '').split(/\s+/);
            const longest = words.reduce((a, b) => a.length >= b.length ? a : b, '');
            return `The longest word is "${longest}" with ${longest.length} characters`;
        } catch (error) {
            return "Error finding longest word. Please check your input.";
        }
    }
},

{
    // Pattern to find the shortest word in text
    pattern: /shortest word in (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const words = text.replace(/[^\w\s]/gi, '').split(/\s+/).filter(word => word.length > 0);
            const shortest = words.reduce((a, b) => a.length <= b.length ? a : b, words[0] || '');
            return `The shortest word is "${shortest}" with ${shortest.length} characters`;
        } catch (error) {
            return "Error finding shortest word. Please check your input.";
        }
    }
},

{
    // Pattern to convert text to leetspeak
    pattern: /convert (.+) to leetspeak/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            const leetMap = {
                'a': '4', 'e': '3', 'i': '1', 'o': '0', 's': '5', 't': '7'
            };
            const leetspeak = text.replace(/[aeiost]/g, letter => leetMap[letter] || letter);
            return leetspeak;
        } catch (error) {
            return "Error converting to leetspeak. Please check your input.";
        }
    }
},

{
    // Pattern to check if text is a pangram (contains all letters of the alphabet)
    pattern: /is (.+) a pangram/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            const alphabet = 'abcdefghijklmnopqrstuvwxyz';
            const isPangram = alphabet.split('').every(letter => text.includes(letter));
            return `"${match[1]}" is ${isPangram ? '' : 'not '}a pangram`;
        } catch (error) {
            return "Error checking if text is a pangram. Please check your input.";
        }
    }
},

{
    // Pattern to generate acronym from text
    pattern: /acronym for (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const acronym = text.split(/\s+/).map(word => word.charAt(0).toUpperCase()).join('');
            return `The acronym for "${text}" is ${acronym}`;
        } catch (error) {
            return "Error generating acronym. Please check your input.";
        }
    }
},

{
    // Pattern to convert text to Morse code
    pattern: /convert (.+) to morse code/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            const morseCodeMap = {
                'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.',
                'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..',
                'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.',
                's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-',
                'y': '-.--', 'z': '--..', '0': '-----', '1': '.----', '2': '..---',
                '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
                '8': '---..', '9': '----.', ' ': '/'
            };
            
            const morseCode = text.split('').map(char => morseCodeMap[char] || char).join(' ');
            return morseCode;
        } catch (error) {
            return "Error converting to Morse code. Please check your input.";
        }
    }
},

{
    // Pattern to get day of the week from a date
    pattern: /what day is (.+)/i,
    response: (match) => {
        try {
            const date = new Date(match[1]);
            if (isNaN(date.getTime())) return "Invalid date format. Please use a valid date format.";
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayOfWeek = days[date.getDay()];
            return `${match[1]} is a ${dayOfWeek}`;
        } catch (error) {
            return "Error finding day of week. Please check your date format.";
        }
    }
},

{
    // Pattern to check if a year is a leap year
    pattern: /is (\d{4}) a leap year/i,
    response: (match) => {
        try {
            const year = parseInt(match[1]);
            const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
            return `${year} is ${isLeapYear ? '' : 'not '}a leap year`;
        } catch (error) {
            return "Error checking leap year. Please enter a valid year.";
        }
    }
},

{
    // Pattern to get current season
    pattern: /what season is it/i,
    response: () => {
        try {
            const now = new Date();
            const month = now.getMonth() + 1; // getMonth() returns 0-11
            let season;
            
            if (month >= 3 && month <= 5) season = "Spring";
            else if (month >= 6 && month <= 8) season = "Summer";
            else if (month >= 9 && month <= 11) season = "Autumn";
            else season = "Winter";
            
            return `The current season is ${season}`;
        } catch (error) {
            return "Error determining current season.";
        }
    }
},

{
    // Pattern to calculate time until a specific date
    pattern: /how long until (.+)/i,
    response: (match) => {
        try {
            const targetDate = new Date(match[1]);
            if (isNaN(targetDate.getTime())) return "Invalid date format. Please use a valid date format.";
            
            const now = new Date();
            if (targetDate < now) return "The specified date has already passed";
            
            const diffTime = targetDate - now;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            const diffHours = Math.floor((diffTime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const diffMinutes = Math.floor((diffTime % (1000 * 60 * 60)) / (1000 * 60));
            
            return `There are ${diffDays} days, ${diffHours} hours, and ${diffMinutes} minutes until ${match[1]}`;
        } catch (error) {
            return "Error calculating time until date. Please check your date format.";
        }
    }
},

{
    // Pattern to get timezone of a location
    pattern: /timezone of (.+)/i,
    response: (match) => {
        try {
            // This is a simplified version - in a real application, you would use a timezone API
            const location = match[1].toLowerCase();
            const timezones = {
                'new york': 'EST/EDT',
                'london': 'GMT/BST',
                'tokyo': 'JST',
                'sydney': 'AEST/AEDT',
                'paris': 'CET/CEST',
                'beijing': 'CST',
                'moscow': 'MSK',
                'dubai': 'GST',
                'mumbai': 'IST',
                'los angeles': 'PST/PDT'
            };
            
            const timezone = timezones[location] || "Unknown location";
            return `The timezone of ${location} is ${timezone}`;
        } catch (error) {
            return "Error finding timezone. Please check your input.";
        }
    }
},

{
    // Pattern to validate a URL
    pattern: /is (.+) a valid url/i,
    response: (match) => {
        try {
            const url = match[1];
            const urlRegex = /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
            const isValid = urlRegex.test(url);
            return `${url} is ${isValid ? 'a valid' : 'an invalid'} URL`;
        } catch (error) {
            return "Error validating URL. Please check your input.";
        }
    }
},

{
    // Pattern to extract domain from URL
    pattern: /extract domain from (.+)/i,
    response: (match) => {
        try {
            const url = match[1];
            const domainRegex = /^(https?:\/\/)?([^\/]+)/i;
            const matchResult = url.match(domainRegex);
            const domain = matchResult && matchResult[2] ? matchResult[2] : "Invalid URL";
            return `Domain: ${domain}`;
        } catch (error) {
            return "Error extracting domain. Please check your URL.";
        }
    }
},

{
    // Pattern to check if a string is empty or contains only whitespace
    pattern: /is (.+) empty/i,
    response: (match) => {
        try {
            const text = match[1];
            const isEmpty = text.trim().length === 0;
            return `"${text}" is ${isEmpty ? 'empty' : 'not empty'}`;
        } catch (error) {
            return "Error checking if string is empty. Please check your input.";
        }
    }
},


{
    // Pattern to generate a random color
    pattern: /generate random color/i,
    response: () => {
        try {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return `Random color: ${color}`;
        } catch (error) {
            return "Error generating random color.";
        }
    }
},

{
    // Pattern to convert RGB to HEX
    pattern: /convert rgb \((\d+),(\d+),(\d+)\) to hex/i,
    response: (match) => {
        try {
            const r = parseInt(match[1]);
            const g = parseInt(match[2]);
            const b = parseInt(match[3]);
            
            if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
                return "RGB values must be between 0 and 255";
            }
            
            const toHex = (c) => {
                const hex = c.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            };
            
            const hex = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            return `RGB(${r},${g},${b}) = ${hex}`;
        } catch (error) {
            return "Error converting RGB to HEX. Please check your input.";
        }
    }
},

{
    // Pattern to convert HEX to RGB
    pattern: /convert hex (.+) to rgb/i,
    response: (match) => {
        try {
            const hex = match[1];
            const hexRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
            const result = hexRegex.exec(hex);
            
            if (!result) {
                return "Invalid HEX color format. Please use #RRGGBB format.";
            }
            
            const r = parseInt(result[1], 16);
            const g = parseInt(result[2], 16);
            const b = parseInt(result[3], 16);
            
            return `${hex} = RGB(${r},${g},${b})`;
        } catch (error) {
            return "Error converting HEX to RGB. Please check your input.";
        }
    }
},

{
    // Pattern to generate a random name
    pattern: /generate random name/i,
    response: () => {
        try {
            const firstNames = ['James', 'Mary', 'John', 'Patricia', 'Robert', 'Jennifer', 'Michael', 'Linda', 'William', 'Elizabeth'];
            const lastNames = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez'];
            
            const randomFirstName = firstNames[Math.floor(Math.random() * firstNames.length)];
            const randomLastName = lastNames[Math.floor(Math.random() * lastNames.length)];
            
            return `Random name: ${randomFirstName} ${randomLastName}`;
        } catch (error) {
            return "Error generating random name.";
        }
    }
},

{
    // Pattern to generate a random username
    pattern: /generate random username/i,
    response: () => {
        try {
            const adjectives = ['Cool', 'Happy', 'Fast', 'Smart', 'Brave', 'Calm', 'Bright', 'Kind', 'Bold', 'Wise'];
            const nouns = ['Tiger', 'Eagle', 'Lion', 'Wolf', 'Bear', 'Shark', 'Hawk', 'Falcon', 'Panther', 'Dragon'];
            const numbers = Math.floor(Math.random() * 100);
            
            const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            
            return `Random username: ${randomAdjective}${randomNoun}${numbers}`;
        } catch (error) {
            return "Error generating random username.";
        }
    }
},

{
    // Pattern to check if a string is numeric
    pattern: /is (.+) numeric/i,
    response: (match) => {
        try {
            const text = match[1];
            const isNumeric = !isNaN(parseFloat(text)) && isFinite(text);
            return `"${text}" is ${isNumeric ? 'numeric' : 'not numeric'}`;
        } catch (error) {
            return "Error checking if string is numeric. Please check your input.";
        }
    }
},

{
    // Pattern to convert text to base64
    pattern: /convert (.+) to base64/i,
    response: (match) => {
        try {
            const text = match[1];
            const base64 = Buffer.from(text).toString('base64');
            return `Base64: ${base64}`;
        } catch (error) {
            return "Error converting to base64. Please check your input.";
        }
    }
},

{
    // Pattern to convert base64 to text
    pattern: /convert base64 (.+) to text/i,
    response: (match) => {
        try {
            const base64 = match[1];
            const text = Buffer.from(base64, 'base64').toString('utf-8');
            return `Text: ${text}`;
        } catch (error) {
            return "Error converting base64 to text. Please check your input.";
        }
    }
},

{
    // Pattern to calculate reading time for text
    pattern: /reading time for (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const wordsPerMinute = 200; // Average reading speed
            const wordCount = text.trim().split(/\s+/).length;
            const readingTimeMinutes = Math.ceil(wordCount / wordsPerMinute);
            return `Estimated reading time: ${readingTimeMinutes} minute${readingTimeMinutes !== 1 ? 's' : ''}`;
        } catch (error) {
            return "Error calculating reading time. Please check your input.";
        }
    }
},

{
    // Pattern to extract hashtags from text
    pattern: /extract hashtags from (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const hashtagRegex = /#\w+/g;
            const hashtags = text.match(hashtagRegex) || [];
            return hashtags.length > 0 ? `Found hashtags: ${hashtags.join(', ')}` : 'No hashtags found';
        } catch (error) {
            return "Error extracting hashtags. Please check your input.";
        }
    }
},

{
    // Pattern to extract mentions from text
    pattern: /extract mentions from (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const mentionRegex = /@\w+/g;
            const mentions = text.match(mentionRegex) || [];
            return mentions.length > 0 ? `Found mentions: ${mentions.join(', ')}` : 'No mentions found';
        } catch (error) {
            return "Error extracting mentions. Please check your input.";
        }
    }
},

{
    // Pattern to check if a string contains only letters
    pattern: /does (.+) contain only letters/i,
    response: (match) => {
        try {
            const text = match[1];
            const onlyLetters = /^[a-zA-Z]+$/.test(text);
            return `"${text}" ${onlyLetters ? 'contains' : 'does not contain'} only letters`;
        } catch (error) {
            return "Error checking if string contains only letters. Please check your input.";
        }
    }
},

{
    // Pattern to check if a string contains only numbers
    pattern: /does (.+) contain only numbers/i,
    response: (match) => {
        try {
            const text = match[1];
            const onlyNumbers = /^[0-9]+$/.test(text);
            return `"${text}" ${onlyNumbers ? 'contains' : 'does not contain'} only numbers`;
        } catch (error) {
            return "Error checking if string contains only numbers. Please check your input.";
        }
    }
},

{
    // Pattern to create a slug from text
    pattern: /create slug from (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const slug = text
                .toLowerCase()
                .replace(/[^\w\s-]/g, '') // Remove special characters
                .replace(/\s+/g, '-') // Replace spaces with hyphens
                .replace(/--+/g, '-'); // Replace multiple hyphens with single hyphen
            
            return `Slug: ${slug}`;
        } catch (error) {
            return "Error creating slug. Please check your input.";
        }
    }
},

{
    // Pattern to generate a UUID
    pattern: /generate uuid/i,
    response: () => {
        try {
            const generateUUID = () => {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            };
            
            return `Generated UUID: ${generateUUID()}`;
        } catch (error) {
            return "Error generating UUID.";
        }
    }
},

{
    // Pattern to validate a credit card number (using Luhn algorithm)
    pattern: /is (.+) a valid credit card number/i,
    response: (match) => {
        try {
            const cardNumber = match[1].replace(/\D/g, ''); // Remove non-digits
            
            if (cardNumber.length < 13 || cardNumber.length > 19) {
                return "Invalid credit card number length";
            }
            
            // Luhn algorithm
            let sum = 0;
            let isEven = false;
            
            for (let i = cardNumber.length - 1; i >= 0; i--) {
                let digit = parseInt(cardNumber.charAt(i));
                
                if (isEven) {
                    digit *= 2;
                    if (digit > 9) {
                        digit -= 9;
                    }
                }
                
                sum += digit;
                isEven = !isEven;
            }
            
            const isValid = sum % 10 === 0;
            return `This is ${isValid ? 'a valid' : 'an invalid'} credit card number`;
        } catch (error) {
            return "Error validating credit card number. Please check your input.";
        }
    }
},

{
    // Pattern to detect the language of a text (simplified version)
    pattern: /detect language of (.+)/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            
            // This is a very simplified language detection
            // In a real application, you would use a proper language detection library
            
            const languagePatterns = {
                'english': /\b(the|and|or|but|in|on|at|to|for|of|with|by)\b/g,
                'spanish': /\b(el|la|de|que|y|a|en|un|es|se|no|haber|por|con)\b/g,
                'french': /\b(le|la|de|et|à|un|être|et|en|avoir|que|pour|dans)\b/g,
                'german': /\b(der|die|und|in|den|von|zu|das|mit|sich|des|ist|im)\b/g,
                'italian': /\b(il|di|e|che|la|in|a|per|un|non|è|si|ma|con)\b/g
            };
            
            let detectedLanguage = 'unknown';
            let maxScore = 0;
            
            for (const [language, pattern] of Object.entries(languagePatterns)) {
                const matches = text.match(pattern) || [];
                const score = matches.length;
                
                if (score > maxScore) {
                    maxScore = score;
                    detectedLanguage = language;
                }
            }
            
            return `Detected language: ${detectedLanguage}`;
        } catch (error) {
            return "Error detecting language. Please check your input.";
        }
    }
},

{
    // Pattern to perform sentiment analysis on text
    pattern: /analyze sentiment of (.+)/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            
            // Simple sentiment analysis using keyword matching
            // In a real application, you would use a more sophisticated NLP library
            
            const positiveWords = [
                'good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic', 'awesome',
                'love', 'like', 'happy', 'pleased', 'satisfied', 'perfect', 'best', 'brilliant',
                'outstanding', 'superb', 'marvelous', 'terrific', 'delightful', 'impressive'
            ];
            
            const negativeWords = [
                'bad', 'terrible', 'awful', 'horrible', 'hate', 'dislike', 'angry',
                'disappointed', 'sad', 'upset', 'annoyed', 'frustrated', 'worst', 'useless',
                'pathetic', 'disgusting', 'annoying', 'boring', 'unpleasant', 'dreadful'
            ];
            
            const words = text.split(/\s+/);
            let positiveScore = 0;
            let negativeScore = 0;
            
            words.forEach(word => {
                if (positiveWords.includes(word)) positiveScore++;
                if (negativeWords.includes(word)) negativeScore++;
            });
            
            let sentiment;
            if (positiveScore > negativeScore) {
                sentiment = `Positive (score: ${positiveScore - negativeScore})`;
            } else if (negativeScore > positiveScore) {
                sentiment = `Negative (score: ${negativeScore - positiveScore})`;
            } else {
                sentiment = 'Neutral';
            }
            
            return `Sentiment analysis result: ${sentiment}`;
        } catch (error) {
            return "Error analyzing sentiment. Please check your input.";
        }
    }
},

{
    // Pattern to summarize text (extractive summarization)
    pattern: /summarize (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // Simple extractive summarization
            // In a real application, you would use a more sophisticated NLP library
            
            // Split text into sentences
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            
            if (sentences.length <= 3) {
                return text; // Text is already short
            }
            
            // Score sentences based on word frequency
            const words = text.toLowerCase().split(/\s+/);
            const wordFreq = {};
            
            words.forEach(word => {
                if (word.length > 3) { // Ignore short words
                    wordFreq[word] = (wordFreq[word] || 0) + 1;
                }
            });
            
            const sentenceScores = sentences.map(sentence => {
                const sentenceWords = sentence.toLowerCase().split(/\s+/);
                let score = 0;
                
                sentenceWords.forEach(word => {
                    if (wordFreq[word]) {
                        score += wordFreq[word];
                    }
                });
                
                return {
                    sentence: sentence.trim(),
                    score: score / sentenceWords.length
                };
            });
            
            // Sort sentences by score and take top 3
            sentenceScores.sort((a, b) => b.score - a.score);
            const topSentences = sentenceScores.slice(0, 3).map(s => s.sentence);
            
            return `Summary: ${topSentences.join('. ')}.`;
        } catch (error) {
            return "Error summarizing text. Please check your input.";
        }
    }
},

{
    // Pattern to translate text between languages (simplified version)
    pattern: /translate (.+) from (.+) to (.+)/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            const fromLang = match[2].toLowerCase();
            const toLang = match[3].toLowerCase();
            
            // This is a very simplified translation using a small dictionary
            // In a real application, you would use a proper translation API
            
            const translationDict = {
                'english to spanish': {
                    'hello': 'hola',
                    'goodbye': 'adiós',
                    'please': 'por favor',
                    'thank you': 'gracias',
                    'yes': 'sí',
                    'no': 'no',
                    'water': 'agua',
                    'food': 'comida',
                    'house': 'casa',
                    'car': 'coche'
                },
                'spanish to english': {
                    'hola': 'hello',
                    'adiós': 'goodbye',
                    'por favor': 'please',
                    'gracias': 'thank you',
                    'sí': 'yes',
                    'no': 'no',
                    'agua': 'water',
                    'comida': 'food',
                    'casa': 'house',
                    'coche': 'car'
                },
                'english to french': {
                    'hello': 'bonjour',
                    'goodbye': 'au revoir',
                    'please': 's\'il vous plaît',
                    'thank you': 'merci',
                    'yes': 'oui',
                    'no': 'non',
                    'water': 'eau',
                    'food': 'nourriture',
                    'house': 'maison',
                    'car': 'voiture'
                },
                'french to english': {
                    'bonjour': 'hello',
                    'au revoir': 'goodbye',
                    's\'il vous plaît': 'please',
                    'merci': 'thank you',
                    'oui': 'yes',
                    'non': 'no',
                    'eau': 'water',
                    'nourriture': 'food',
                    'maison': 'house',
                    'voiture': 'car'
                }
            };
            
            const dictKey = `${fromLang} to ${toLang}`;
            const dict = translationDict[dictKey];
            
            if (!dict) {
                return `Translation from ${fromLang} to ${toLang} is not supported`;
            }
            
            // Simple word-by-word translation
            const words = text.split(/\s+/);
            const translatedWords = words.map(word => {
                const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
                const translated = dict[cleanWord];
                
                if (translated) {
                    // Preserve original punctuation
                    const punctuation = word.match(/[.,!?;:]+$/);
                    return translated + (punctuation ? punctuation[0] : '');
                }
                
                return word; // Return original word if no translation found
            });
            
            return `Translation: ${translatedWords.join(' ')}`;
        } catch (error) {
            return "Error translating text. Please check your input.";
        }
    }
},

{
    // Pattern to extract keywords from text
    pattern: /extract keywords from (.+)/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            
            // Remove common stop words
            const stopWords = [
                'a', 'an', 'the', 'and', 'or', 'but', 'of', 'at', 'by', 'for', 'with',
                'about', 'between', 'into', 'through', 'during', 'before', 'after',
                'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off',
                'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there',
                'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few',
                'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only',
                'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can', 'will',
                'just', 'don', 'should', 'now', 'd', 'll', 'm', 'o', 're', 've', 'y'
            ];
            
            // Split text into words and remove stop words
            const words = text.split(/\s+/)
                .map(word => word.replace(/[^\w]/g, '')) // Remove punctuation
                .filter(word => word.length > 3 && !stopWords.includes(word));
            
            // Count word frequency
            const wordFreq = {};
            words.forEach(word => {
                wordFreq[word] = (wordFreq[word] || 0) + 1;
            });
            
            // Sort by frequency and get top keywords
            const sortedKeywords = Object.entries(wordFreq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(entry => entry[0]);
            
            return `Keywords: ${sortedKeywords.join(', ')}`;
        } catch (error) {
            return "Error extracting keywords. Please check your input.";
        }
    }
},

{
    // Pattern to generate a QR code (simplified representation)
    pattern: /generate qr code for (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // This is a simplified representation of a QR code
            // In a real application, you would use a proper QR code generation library
            
            // Generate a simple pattern based on the text
            const hash = text.split('').reduce((acc, char) => {
                return acc + char.charCodeAt(0);
            }, 0);
            
            const size = 25; // QR code size (odd number)
            const qrCode = [];
            
            // Initialize QR code with empty cells
            for (let i = 0; i < size; i++) {
                qrCode.push(Array(size).fill(0));
            }
            
            // Add finder patterns
            const addFinderPattern = (x, y) => {
                for (let i = -1; i <= 7; i++) {
                    for (let j = -1; j <= 7; j++) {
                        if (x + i >= 0 && x + i < size && y + j >= 0 && y + j < size) {
                            if (i === -1 || i === 7 || j === -1 || j === 7) {
                                qrCode[x + i][y + j] = 1; // Border
                            } else if (i >= 1 && i <= 5 && j >= 1 && j <= 5) {
                                qrCode[x + i][y + j] = (i + j) % 2 === 0 ? 1 : 0; // Pattern
                            } else {
                                qrCode[x + i][y + j] = 1; // Border
                            }
                        }
                    }
                }
            };
            
            addFinderPattern(0, 0);
            addFinderPattern(0, size - 8);
            addFinderPattern(size - 8, 0);
            
            // Add timing pattern
            for (let i = 8; i < size - 8; i++) {
                qrCode[6][i] = i % 2 === 0 ? 1 : 0;
                qrCode[i][6] = i % 2 === 0 ? 1 : 0;
            }
            
            // Add data pattern based on hash
            for (let i = 8; i < size; i++) {
                for (let j = 8; j < size; j++) {
                    if (qrCode[i][j] === 0) { // Only modify empty cells
                        const pos = (i * size + j + hash) % 2;
                        qrCode[i][j] = pos;
                    }
                }
            }
            
            // Convert to string representation
            let qrCodeString = "QR Code representation:\n";
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    qrCodeString += qrCode[i][j] ? "██" : "  ";
                }
                qrCodeString += "\n";
            }
            
            return qrCodeString + "\nNote: This is a simplified representation. In a real application, use a QR code library.";
        } catch (error) {
            return "Error generating QR code. Please check your input.";
        }
    }
},

{
    // Pattern to generate a barcode (simplified representation)
    pattern: /generate barcode for (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // This is a simplified representation of a Code 128 barcode
            // In a real application, you would use a proper barcode generation library
            
            // Simple encoding of text to bars
            let barcode = "█"; // Start character
            
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                const pattern = charCode % 8; // Simple pattern based on character code
                
                for (let j = 0; j < 8; j++) {
                    barcode += (j === pattern) ? "█" : " ";
                }
            }
            
            barcode += "█"; // End character
            
            // Add quiet zones
            barcode = "    " + barcode + "    ";
            
            return `Barcode representation:\n${barcode}\n\nNote: This is a simplified representation. In a real application, use a barcode library.`;
        } catch (error) {
            return "Error generating barcode. Please check your input.";
        }
    }
},

{
    // Pattern to compress text using a simple algorithm
    pattern: /compress (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // Simple run-length encoding compression
            let compressed = "";
            let count = 1;
            
            for (let i = 0; i < text.length; i++) {
                if (text[i] === text[i + 1]) {
                    count++;
                } else {
                    if (count > 1) {
                        compressed += `${count}${text[i]}`;
                    } else {
                        compressed += text[i];
                    }
                    count = 1;
                }
            }
            
            const compressionRatio = ((text.length - compressed.length) / text.length * 100).toFixed(2);
            
            return `Compressed text: ${compressed}\nOriginal size: ${text.length} characters\nCompressed size: ${compressed.length} characters\nCompression ratio: ${compressionRatio}%`;
        } catch (error) {
            return "Error compressing text. Please check your input.";
        }
    }
},

{
    // Pattern to decompress text that was compressed with the simple algorithm
    pattern: /decompress (.+)/i,
    response: (match) => {
        try {
            const compressed = match[1];
            
            // Decompress run-length encoded text
            let decompressed = "";
            
            for (let i = 0; i < compressed.length; i++) {
                if (/\d/.test(compressed[i])) {
                    let countStr = compressed[i];
                    
                    // Get all consecutive digits
                    while (i + 1 < compressed.length && /\d/.test(compressed[i + 1])) {
                        i++;
                        countStr += compressed[i];
                    }
                    
                    const count = parseInt(countStr);
                    const char = compressed[i + 1];
                    
                    decompressed += char.repeat(count);
                    i++; // Skip the character
                } else {
                    decompressed += compressed[i];
                }
            }
            
            return `Decompressed text: ${decompressed}`;
        } catch (error) {
            return "Error decompressing text. Please check your input.";
        }
    }
},

{
    // Pattern to encrypt text using a simple Caesar cipher
    pattern: /encrypt (.+) with shift (\d+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const shift = parseInt(match[2]) % 26;
            
            let encrypted = "";
            
            for (let i = 0; i < text.length; i++) {
                let char = text[i];
                
                if (char.match(/[a-z]/i)) {
                    const code = text.charCodeAt(i);
                    const isUpperCase = code >= 65 && code <= 90;
                    
                    // Shift the character
                    let shiftedCode = code + shift;
                    
                    // Wrap around if needed
                    if (isUpperCase) {
                        if (shiftedCode > 90) shiftedCode -= 26;
                        if (shiftedCode < 65) shiftedCode += 26;
                    } else {
                        if (shiftedCode > 122) shiftedCode -= 26;
                        if (shiftedCode < 97) shiftedCode += 26;
                    }
                    
                    char = String.fromCharCode(shiftedCode);
                }
                
                encrypted += char;
            }
            
            return `Encrypted text: ${encrypted}`;
        } catch (error) {
            return "Error encrypting text. Please check your input.";
        }
    }
},

{
    // Pattern to decrypt text that was encrypted with a Caesar cipher
    pattern: /decrypt (.+) with shift (\d+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const shift = parseInt(match[2]) % 26;
            
            let decrypted = "";
            
            for (let i = 0; i < text.length; i++) {
                let char = text[i];
                
                if (char.match(/[a-z]/i)) {
                    const code = text.charCodeAt(i);
                    const isUpperCase = code >= 65 && code <= 90;
                    
                    // Shift the character in the opposite direction
                    let shiftedCode = code - shift;
                    
                    // Wrap around if needed
                    if (isUpperCase) {
                        if (shiftedCode > 90) shiftedCode -= 26;
                        if (shiftedCode < 65) shiftedCode += 26;
                    } else {
                        if (shiftedCode > 122) shiftedCode -= 26;
                        if (shiftedCode < 97) shiftedCode += 26;
                    }
                    
                    char = String.fromCharCode(shiftedCode);
                }
                
                decrypted += char;
            }
            
            return `Decrypted text: ${decrypted}`;
        } catch (error) {
            return "Error decrypting text. Please check your input.";
        }
    }
},

{
    // Pattern to generate a hash of text (simplified version)
    pattern: /generate hash of (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // Simple hash function (not cryptographically secure)
            let hash = 0;
            
            for (let i = 0; i < text.length; i++) {
                const char = text.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            
            // Convert to hexadecimal string
            const hashString = (hash >>> 0).toString(16);
            
            return `Hash: ${hashString}\nNote: This is a simplified hash function. For cryptographic purposes, use a proper hashing algorithm.`;
        } catch (error) {
            return "Error generating hash. Please check your input.";
        }
    }
},

{
    // Pattern to validate a password against security criteria
    pattern: /validate password (.+)/i,
    response: (match) => {
        try {
            const password = match[1];
            
            const criteria = [
                { test: (pwd) => pwd.length >= 8, message: "At least 8 characters long" },
                { test: (pwd) => /[A-Z]/.test(pwd), message: "Contains at least one uppercase letter" },
                { test: (pwd) => /[a-z]/.test(pwd), message: "Contains at least one lowercase letter" },
                { test: (pwd) => /[0-9]/.test(pwd), message: "Contains at least one number" },
                { test: (pwd) => /[^A-Za-z0-9]/.test(pwd), message: "Contains at least one special character" },
                { test: (pwd) => !/(.)\1{2,}/.test(pwd), message: "Does not contain 3 or more repeated characters" },
                { test: (pwd) => !/(password|123456|qwerty)/i.test(pwd), message: "Is not a common password" }
            ];
            
            const results = criteria.map(criterion => ({
                criterion: criterion.message,
                passed: criterion.test(password)
            }));
            
            const passedCriteria = results.filter(r => r.passed).length;
            const totalCriteria = criteria.length;
            const strengthPercentage = Math.round((passedCriteria / totalCriteria) * 100);
            
            let strengthLevel;
            if (strengthPercentage >= 90) strengthLevel = "Very Strong";
            else if (strengthPercentage >= 70) strengthLevel = "Strong";
            else if (strengthPercentage >= 50) strengthLevel = "Medium";
            else if (strengthPercentage >= 30) strengthLevel = "Weak";
            else strengthLevel = "Very Weak";
            
            let response = `Password Strength: ${strengthLevel} (${strengthPercentage}%)\n\nCriteria:\n`;
            
            results.forEach(result => {
                response += `${result.passed ? "✓" : "✗"} ${result.criterion}\n`;
            });
            
            return response;
        } catch (error) {
            return "Error validating password. Please check your input.";
        }
    }
},

{
    // Pattern to generate a secure password
    pattern: /generate secure password with (\d+) characters/i,
    response: (match) => {
        try {
            const length = parseInt(match[1]);
            
            if (length < 8) return "Password length should be at least 8 characters for security";
            if (length > 50) return "Password length should not exceed 50 characters";
            
            const lowercase = "abcdefghijklmnopqrstuvwxyz";
            const uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            const numbers = "0123456789";
            const symbols = "!@#$%^&*()_+-=[]{}|;:,.<>?";
            
            // Ensure at least one character from each category
            let password = "";
            password += lowercase[Math.floor(Math.random() * lowercase.length)];
            password += uppercase[Math.floor(Math.random() * uppercase.length)];
            password += numbers[Math.floor(Math.random() * numbers.length)];
            password += symbols[Math.floor(Math.random() * symbols.length)];
            
            // Fill the rest with random characters from all categories
            const allChars = lowercase + uppercase + numbers + symbols;
            
            for (let i = 4; i < length; i++) {
                password += allChars[Math.floor(Math.random() * allChars.length)];
            }
            
            // Shuffle the password characters
            password = password.split('').sort(() => Math.random() - 0.5).join('');
            
            return `Generated secure password: ${password}`;
        } catch (error) {
            return "Error generating secure password. Please check your input.";
        }
    }
},

{
    // Pattern to check if a text is plagiarized (simplified version)
    pattern: /check plagiarism for (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // This is a very simplified plagiarism check
            // In a real application, you would use a proper plagiarism detection service
            
            // Split text into sentences
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            
            // Check for common phrases that might indicate plagiarism
            const commonPhrases = [
                "according to research",
                "studies have shown",
                "it is widely believed",
                "experts agree that",
                "research indicates",
                "it has been suggested",
                "there is evidence that",
                "it is well known that",
                "as we all know",
                "it is a well-known fact"
            ];
            
            let potentialPlagiarismScore = 0;
            
            sentences.forEach(sentence => {
                const lowerSentence = sentence.toLowerCase();
                commonPhrases.forEach(phrase => {
                    if (lowerSentence.includes(phrase)) {
                        potentialPlagiarismScore++;
                    }
                });
            });
            
            // Calculate a simple plagiarism score
            const maxScore = sentences.length * 2; // Arbitrary maximum
            const plagiarismPercentage = Math.min(100, Math.round((potentialPlagiarismScore / maxScore) * 100));
            
            let assessment;
            if (plagiarismPercentage >= 70) {
                assessment = "High likelihood of plagiarism";
            } else if (plagiarismPercentage >= 40) {
                assessment = "Moderate likelihood of plagiarism";
            } else if (plagiarismPercentage >= 20) {
                assessment = "Low likelihood of plagiarism";
            } else {
                assessment = "Very low likelihood of plagiarism";
            }
            
            return `Plagiarism check result: ${assessment}\nPlagiarism score: ${plagiarismPercentage}%\n\nNote: This is a simplified check. For accurate plagiarism detection, use a specialized service.`;
        } catch (error) {
            return "Error checking plagiarism. Please check your input.";
        }
    }
},

{
    // Pattern to generate a word cloud from text (simplified representation)
    pattern: /generate word cloud for (.+)/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            
            // Remove common stop words
            const stopWords = [
                'a', 'an', 'the', 'and', 'or', 'but', 'of', 'at', 'by', 'for', 'with',
                'about', 'between', 'into', 'through', 'during', 'before', 'after',
                'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off',
                'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there',
                'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few',
                'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only',
                'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can', 'will',
                'just', 'don', 'should', 'now', 'd', 'll', 'm', 'o', 're', 've', 'y'
            ];
            
            // Split text into words and remove stop words and punctuation
            const words = text.split(/\s+/)
                .map(word => word.replace(/[^\w]/g, ''))
                .filter(word => word.length > 3 && !stopWords.includes(word));
            
            // Count word frequency
            const wordFreq = {};
            words.forEach(word => {
                wordFreq[word] = (wordFreq[word] || 0) + 1;
            });
            
            // Sort by frequency and get top words
            const sortedWords = Object.entries(wordFreq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);
            
            // Generate a simple text-based word cloud
            let wordCloud = "Word Cloud:\n\n";
            
            sortedWords.forEach(([word, freq]) => {
                const size = Math.min(10, Math.max(1, freq));
                wordCloud += `${word.padEnd(15, ' ')} ${'█'.repeat(size)}\n`;
            });
            
            return wordCloud + "\nNote: This is a simplified text representation of a word cloud.";
        } catch (error) {
            return "Error generating word cloud. Please check your input.";
        }
    }
},

{
    // Pattern to analyze text readability
    pattern: /analyze readability of (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // Split text into sentences and words
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const words = text.split(/\s+/).filter(w => w.trim().length > 0);
            
            // Count syllables (simplified approach)
            const countSyllables = (word) => {
                word = word.toLowerCase();
                if (word.length <= 3) return 1;
                
                // Remove silent 'e' at the end
                if (word.endsWith('e')) {
                    word = word.substring(0, word.length - 1);
                }
                
                // Count vowel groups
                const vowelGroups = word.match(/[aeiouy]+/g);
                return vowelGroups ? vowelGroups.length : 1;
            };
            
            let totalSyllables = 0;
            words.forEach(word => {
                totalSyllables += countSyllables(word);
            });
            
            // Calculate readability metrics
            const avgSentenceLength = words.length / sentences.length;
            const avgSyllablesPerWord = totalSyllables / words.length;
            
            // Flesch Reading Ease Score
            const fleschScore = 206.835 - (1.015 * avgSentenceLength) - (84.6 * avgSyllablesPerWord);
            
            // Flesch-Kincaid Grade Level
            const fleschGrade = (0.39 * avgSentenceLength) + (11.8 * avgSyllablesPerWord) - 15.59;
            
            let readabilityLevel;
            if (fleschScore >= 90) readabilityLevel = "Very Easy";
            else if (fleschScore >= 80) readabilityLevel = "Easy";
            else if (fleschScore >= 70) readabilityLevel = "Fairly Easy";
            else if (fleschScore >= 60) readabilityLevel = "Standard";
            else if (fleschScore >= 50) readabilityLevel = "Fairly Difficult";
            else if (fleschScore >= 30) readabilityLevel = "Difficult";
            else readabilityLevel = "Very Difficult";
            
            return `Readability Analysis:\n\n` +
                   `Flesch Reading Ease Score: ${fleschScore.toFixed(2)} (${readabilityLevel})\n` +
                   `Flesch-Kincaid Grade Level: ${fleschGrade.toFixed(2)}\n` +
                   `Average Sentence Length: ${avgSentenceLength.toFixed(2)} words\n` +
                   `Average Syllables per Word: ${avgSyllablesPerWord.toFixed(2)}\n` +
                   `Total Words: ${words.length}\n` +
                   `Total Sentences: ${sentences.length}`;
        } catch (error) {
            return "Error analyzing readability. Please check your input.";
        }
    }
},

{
    // Pattern to generate a timeline from text containing dates
    pattern: /generate timeline from (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // Extract dates from text (simplified approach)
            const dateRegex = /\b(\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}-\d{1,2}-\d{2,4}|\w+ \d{1,2}, \d{4}|\d{4})\b/g;
            const dates = text.match(dateRegex) || [];
            
            if (dates.length === 0) {
                return "No dates found in the text. Unable to generate timeline.";
            }
            
            // Parse dates and sort them
            const parsedDates = dates.map(dateStr => {
                let date;
                
                if (dateStr.includes('/')) {
                    const parts = dateStr.split('/');
                    if (parts[2].length === 2) {
                        parts[2] = '20' + parts[2]; // Assume 21st century for 2-digit years
                    }
                    date = new Date(`${parts[2]}-${parts[0]}-${parts[1]}`);
                } else if (dateStr.includes('-')) {
                    const parts = dateStr.split('-');
                    if (parts[2].length === 2) {
                        parts[2] = '20' + parts[2]; // Assume 21st century for 2-digit years
                    }
                    date = new Date(`${parts[2]}-${parts[0]}-${parts[1]}`);
                } else if (dateStr.includes(',')) {
                    date = new Date(dateStr);
                } else {
                    // Just a year
                    date = new Date(`${dateStr}-01-01`);
                }
                
                return {
                    original: dateStr,
                    parsed: date,
                    valid: !isNaN(date.getTime())
                };
            }).filter(d => d.valid);
            
            // Sort by date
            parsedDates.sort((a, b) => a.parsed - b.parsed);
            
            // Generate timeline
            let timeline = "Timeline:\n\n";
            
            parsedDates.forEach((dateObj, index) => {
                const dateStr = dateObj.parsed.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                timeline += `${index + 1}. ${dateStr} (original: ${dateObj.original})\n`;
            });
            
            return timeline;
        } catch (error) {
            return "Error generating timeline. Please check your input.";
        }
    }
},

{
    // Pattern to extract and analyze entities from text
    pattern: /extract entities from (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // This is a simplified entity extraction
            // In a real application, you would use a proper NLP library
            
            // Common person names (very simplified)
            const commonNames = [
                'John', 'Mary', 'James', 'Patricia', 'Robert', 'Jennifer', 'Michael', 'Linda',
                'William', 'Elizabeth', 'David', 'Barbara', 'Richard', 'Susan', 'Joseph', 'Jessica',
                'Thomas', 'Sarah', 'Charles', 'Karen', 'Christopher', 'Nancy', 'Daniel', 'Lisa'
            ];
            
            // Common locations (very simplified)
            const commonLocations = [
                'New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix', 'Philadelphia',
                'San Antonio', 'San Diego', 'Dallas', 'San Jose', 'Austin', 'Jacksonville',
                'Fort Worth', 'Columbus', 'Charlotte', 'San Francisco', 'Indianapolis',
                'Seattle', 'Denver', 'Washington', 'Boston', 'El Paso', 'Detroit', 'Nashville'
            ];
            
            // Common organizations (very simplified)
            const commonOrganizations = [
                'Google', 'Microsoft', 'Apple', 'Amazon', 'Facebook', 'Tesla', 'Netflix',
                'Samsung', 'IBM', 'Intel', 'Oracle', 'Cisco', 'Adobe', 'Salesforce', 'HP'
            ];
            
            // Extract entities
            const extractedEntities = {
                persons: [],
                locations: [],
                organizations: [],
                dates: [],
                numbers: []
            };
            
            // Extract dates
            const dateRegex = /\b(\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}-\d{1,2}-\d{2,4}|\w+ \d{1,2}, \d{4}|\d{4})\b/g;
            const dates = text.match(dateRegex) || [];
            extractedEntities.dates = dates;
            
            // Extract numbers
            const numberRegex = /\b\d+(\.\d+)?\b/g;
            const numbers = text.match(numberRegex) || [];
            extractedEntities.numbers = numbers;
            
            // Extract persons, locations, and organizations
            const words = text.split(/\s+/);
            
            for (let i = 0; i < words.length; i++) {
                // Check for multi-word entities first
                if (i < words.length - 1) {
                    const twoWordPhrase = `${words[i]} ${words[i + 1]}`;
                    
                    if (commonLocations.includes(twoWordPhrase)) {
                        extractedEntities.locations.push(twoWordPhrase);
                        i++; // Skip next word as it's part of this entity
                        continue;
                    }
                }
                
                // Check for single-word entities
                const word = words[i].replace(/[^\w]/g, '');
                
                if (commonNames.includes(word)) {
                    extractedEntities.persons.push(word);
                } else if (commonLocations.includes(word)) {
                    extractedEntities.locations.push(word);
                } else if (commonOrganizations.includes(word)) {
                    extractedEntities.organizations.push(word);
                }
            }
            
            // Generate response
            let response = "Extracted Entities:\n\n";
            
            if (extractedEntities.persons.length > 0) {
                response += `Persons: ${extractedEntities.persons.join(', ')}\n`;
            }
            
            if (extractedEntities.locations.length > 0) {
                response += `Locations: ${extractedEntities.locations.join(', ')}\n`;
            }
            
            if (extractedEntities.organizations.length > 0) {
                response += `Organizations: ${extractedEntities.organizations.join(', ')}\n`;
            }
            
            if (extractedEntities.dates.length > 0) {
                response += `Dates: ${extractedEntities.dates.join(', ')}\n`;
            }
            
            if (extractedEntities.numbers.length > 0) {
                response += `Numbers: ${extractedEntities.numbers.join(', ')}\n`;
            }
            
            if (response === "Extracted Entities:\n\n") {
                response += "No entities found in the text.";
            }
            
            return response + "\n\nNote: This is a simplified entity extraction. For accurate results, use a proper NLP library.";
        } catch (error) {
            return "Error extracting entities. Please check your input.";
        }
    }
},

{
    // Pattern to generate a mind map from text (simplified representation)
    pattern: /generate mind map for (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // This is a very simplified mind map generation
            // In a real application, you would use a proper mind mapping library
            
            // Extract keywords (simplified)
            const stopWords = [
                'a', 'an', 'the', 'and', 'or', 'but', 'of', 'at', 'by', 'for', 'with',
                'about', 'between', 'into', 'through', 'during', 'before', 'after',
                'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off'
            ];
            
            const words = text.split(/\s+/)
                .map(word => word.replace(/[^\w]/g, ''))
                .filter(word => word.length > 3 && !stopWords.includes(word));
            
            // Count word frequency
            const wordFreq = {};
            words.forEach(word => {
                wordFreq[word] = (wordFreq[word] || 0) + 1;
            });
            
            // Sort by frequency and get top keywords
            const keywords = Object.entries(wordFreq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(entry => entry[0]);
            
            // Generate a simple text-based mind map
            let mindMap = "Mind Map:\n\n";
            
            // Central concept (most frequent keyword)
            const centralConcept = keywords[0];
            mindMap += `┌─────────────────────────────┐\n`;
            mindMap += `│        ${centralConcept.padEnd(23, ' ')}        │\n`;
            mindMap += `└──────────────┬──────────────┘\n`;
            mindMap += `               │\n`;
            mindMap += `    ┌──────────┴──────────┐\n`;
            
            // Branches (other keywords)
            const branches = keywords.slice(1, 5);
            branches.forEach((branch, index) => {
                mindMap += `    │ ${branch.padEnd(20, ' ')} │\n`;
            });
            
            mindMap += `    └───────────────────┘\n`;
            mindMap += `               │\n`;
            
            // Sub-branches (remaining keywords)
            const subBranches = keywords.slice(5, 10);
            if (subBranches.length > 0) {
                mindMap += `    ┌──────────┬──────────┐\n`;
                
                subBranches.forEach((subBranch, index) => {
                    mindMap += `    │ ${subBranch.padEnd(10, ' ')} `;
                    if (index === subBranches.length - 1 && subBranches.length % 2 !== 0) {
                        mindMap += `│\n`;
                    } else if (index % 2 === 0) {
                        mindMap += `│ `;
                    } else {
                        mindMap += `\n`;
                    }
                });
                
                mindMap += `    └──────────┴──────────┘\n`;
            }
            
            return mindMap + "\nNote: This is a simplified text representation of a mind map.";
        } catch (error) {
            return "Error generating mind map. Please check your input.";
        }
    }
},

{
    // Pattern to convert text to a structured data format (JSON)
    pattern: /convert (.+) to json/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // This is a simplified conversion to JSON
            // In a real application, you would use more sophisticated parsing
            
            // Split text into lines
            const lines = text.split('\n').filter(line => line.trim().length > 0);
            
            const result = {
                originalText: text,
                lineCount: lines.length,
                wordCount: text.split(/\s+/).filter(word => word.trim().length > 0).length,
                characterCount: text.length,
                lines: []
            };
            
            // Process each line
            lines.forEach((line, index) => {
                const words = line.split(/\s+/).filter(word => word.trim().length > 0);
                
                result.lines.push({
                    lineNumber: index + 1,
                    text: line,
                    wordCount: words.length,
                    characterCount: line.length,
                    words: words
                });
            });
            
            return JSON.stringify(result, null, 2);
        } catch (error) {
            return "Error converting to JSON. Please check your input.";
        }
    }
},

{
    // Pattern to generate a report from structured data (JSON)
    pattern: /generate report from (.+)/i,
    response: (match) => {
        try {
            const jsonString = match[1];
            
            // Parse JSON
            let data;
            try {
                data = JSON.parse(jsonString);
            } catch (e) {
                return "Invalid JSON format. Please provide valid JSON data.";
            }
            
            // Generate a simple report
            let report = "Data Report\n";
            report += "===================\n\n";
            
            // Basic information
            if (typeof data === 'object' && data !== null) {
                const keys = Object.keys(data);
                report += `Data Type: ${Array.isArray(data) ? 'Array' : 'Object'}\n`;
                report += `Properties/Items: ${keys.length}\n\n`;
                
                // If it's an array of objects, create a summary table
                if (Array.isArray(data) && data.length > 0 && typeof data[0] === 'object') {
                    report += "Summary Table:\n\n";
                    
                    // Get all unique keys from all objects
                    const allKeys = new Set();
                    data.forEach(item => {
                        if (typeof item === 'object' && item !== null) {
                            Object.keys(item).forEach(key => allKeys.add(key));
                        }
                    });
                    
                    // Create header
                    let header = "| ";
                    allKeys.forEach(key => {
                        header += `${key} | `;
                    });
                    report += header + "\n";
                    
                    // Create separator
                    let separator = "| ";
                    allKeys.forEach(() => {
                        separator += "---- | ";
                    });
                    report += separator + "\n";
                    
                    // Add rows (limit to first 10 items)
                    const limit = Math.min(10, data.length);
                    for (let i = 0; i < limit; i++) {
                        let row = "| ";
                        allKeys.forEach(key => {
                            const value = data[i][key] !== undefined ? data[i][key] : "N/A";
                            row += `${value} | `;
                        });
                        report += row + "\n";
                    }
                    
                    if (data.length > 10) {
                        report += `\n... and ${data.length - 10} more items\n`;
                    }
                } else {
                    // Just list properties
                    report += "Properties:\n";
                    keys.forEach(key => {
                        const value = data[key];
                        const valueType = Array.isArray(value) ? 'Array' : typeof value;
                        const valueStr = Array.isArray(value) ? `[${value.length} items]` : 
                                       (typeof value === 'object' && value !== null) ? 'Object' : 
                                       String(value);
                        
                        report += `- ${key} (${valueType}): ${valueStr}\n`;
                    });
                }
            } else {
                report += `Value: ${data}\n`;
                report += `Type: ${typeof data}\n`;
            }
            
            return report;
        } catch (error) {
            return "Error generating report. Please check your input.";
        }
    }
},

{
    // Pattern to perform optical character recognition (OCR) simulation
    pattern: /perform ocr on (.+)/i,
    response: (match) => {
        try {
            const imageDescription = match[1];
            
            // This is a simulated OCR response
            // In a real application, you would use a proper OCR service
            
            // Extract potential text from the description
            const textRegex = /text:?\s*["']([^"']+)["']/i;
            const textMatch = imageDescription.match(textRegex);
            
            if (textMatch) {
                return `OCR Result:\n\n"${textMatch[1]}"`;
            }
            
            // If no explicit text is found, generate a simulated response
            const keywords = imageDescription.toLowerCase().split(/\s+/);
            
            if (keywords.includes('receipt')) {
                return `OCR Result:\n\n` +
                       `RECEIPT\n` +
                       `--------------------------------\n` +
                       `Item 1         $10.99\n` +
                       `Item 2         $5.49\n` +
                       `Item 3         $7.99\n` +
                       `--------------------------------\n` +
                       `Subtotal       $24.47\n` +
                       `Tax (8.25%)    $2.02\n` +
                       `Total          $26.49\n` +
                       `--------------------------------\n` +
                       `Thank you for your business!`;
            } else if (keywords.includes('business') || keywords.includes('card')) {
                return `OCR Result:\n\n` +
                       `John Doe\n` +
                       `Software Engineer\n` +
                       `Tech Solutions Inc.\n` +
                       `123 Main Street\n` +
                       `Anytown, ST 12345\n` +
                       `Phone: (555) 123-4567\n` +
                       `Email: john.doe@example.com`;
            } else if (keywords.includes('document') || keywords.includes('letter')) {
                return `OCR Result:\n\n` +
                       `MEMORANDUM\n` +
                       `To: All Employees\n` +
                       `From: Management\n` +
                       `Date: June 15, 2023\n` +
                       `Subject: Office Policy Update\n\n` +
                       `This memo is to inform all employees of the upcoming changes to our office policies. ` +
                       `Effective July 1st, we will be implementing a new flexible work schedule. ` +
                       `Please review the attached document for more details.`;
            } else {
                return `OCR Result:\n\n` +
                       `No clear text could be extracted from the image description. ` +
                       `For actual OCR functionality, please use a proper OCR service with an actual image file.`;
            }
        } catch (error) {
            return "Error performing OCR. Please check your input.";
        }
    }
},

{
    // Pattern to generate a data visualization description
    pattern: /visualize data (.+)/i,
    response: (match) => {
        try {
            const dataDescription = match[1];
            
            // This is a simulated data visualization
            // In a real application, you would use a proper visualization library
            
            // Parse the data description to determine the type of visualization
            const keywords = dataDescription.toLowerCase();
            
            let visualizationType;
            let description;
            
            if (keywords.includes('compare') || keywords.includes('bar')) {
                visualizationType = "Bar Chart";
                description = `A bar chart would be appropriate for comparing discrete categories or showing changes over time. ` +
                             `The chart would have vertical bars representing different categories, with the height of each bar ` +
                             `corresponding to its value. Labels would be placed below each bar, and a title would describe ` +
                             `what is being compared.`;
            } else if (keywords.includes('trend') || keywords.includes('line')) {
                visualizationType = "Line Chart";
                description = `A line chart would be ideal for showing trends over time or continuous data. ` +
                             `The chart would have points connected by lines, with the x-axis typically representing time ` +
                             `and the y-axis representing the value being measured. Multiple lines could be used to compare ` +
                             `different trends simultaneously.`;
            } else if (keywords.includes('part') || keywords.includes('whole') || keywords.includes('pie')) {
                visualizationType = "Pie Chart";
                description = `A pie chart would be suitable for showing the proportion of parts to a whole. ` +
                             `The chart would be a circle divided into slices, with each slice representing a category. ` +
                             `The size of each slice would correspond to its percentage of the whole. Labels would identify ` +
                             `each slice, and a legend could provide additional information.`;
            } else if (keywords.includes('distribution') || keywords.includes('histogram')) {
                visualizationType = "Histogram";
                description = `A histogram would be effective for showing the distribution of numerical data. ` +
                             `The chart would have adjacent vertical bars representing ranges of values (bins), with the ` +
                             `height of each bar corresponding to the frequency of data points in that range. This would ` +
                             `help visualize the shape and spread of the data distribution.`;
            } else if (keywords.includes('correlation') || keywords.includes('scatter')) {
                visualizationType = "Scatter Plot";
                description = `A scatter plot would be appropriate for showing the relationship between two numerical variables. ` +
                             `The chart would have points plotted on a grid, with the x-axis representing one variable and ` +
                             `the y-axis representing the other. The pattern of points would reveal any correlation or ` +
                             `relationship between the variables.`;
            } else {
                visualizationType = "Table";
                description = `A table would be suitable for organizing and presenting structured data. ` +
                             `The table would have rows and columns, with headers identifying what each column represents. ` +
                             `This format would make it easy to look up specific values and compare related data points.`;
            }
            
            return `Recommended Visualization: ${visualizationType}\n\n` +
                   `Description: ${description}\n\n` +
                   `Note: This is a description of a suitable visualization. For actual data visualization, ` +
                   `use a proper visualization library with the actual data.`;
        } catch (error) {
            return "Error visualizing data. Please check your input.";
        }
    }
},

{
    // Pattern to perform natural language generation
    pattern: /generate text about (.+)/i,
    response: (match) => {
        try {
            const topic = match[1];
            
            // This is a simplified natural language generation
            // In a real application, you would use a proper NLG system or language model
            
            const topicLower = topic.toLowerCase();
            let generatedText;
            
            if (topicLower.includes('climate') || topicLower.includes('environment')) {
                generatedText = `Climate change is one of the most pressing challenges of our time. Rising global temperatures, ` +
                              `melting ice caps, and extreme weather events are all indicators of a changing planet. ` +
                              `Human activities, particularly the burning of fossil fuels, have significantly contributed ` +
                              `to the increase in greenhouse gases in the atmosphere. Addressing this issue requires ` +
                              `concerted efforts from individuals, businesses, and governments worldwide to reduce ` +
                              `emissions and transition to sustainable energy sources.`;
            } else if (topicLower.includes('technology') || topicLower.includes('ai')) {
                generatedText = `Technology continues to advance at an unprecedented pace, transforming how we live, work, and communicate. ` +
                              `Artificial intelligence, in particular, has made remarkable strides in recent years, enabling machines ` +
                              `to perform tasks that were once thought to be exclusively human. From natural language processing to ` +
                              `computer vision and autonomous systems, AI is revolutionizing industries and creating new possibilities. ` +
                              `As these technologies continue to evolve, it's important to consider their ethical implications and ensure ` +
                              `they are developed and deployed responsibly.`;
            } else if (topicLower.includes('health') || topicLower.includes('medicine')) {
                generatedText = `Health and medicine have seen tremendous advancements in recent decades. New treatments, diagnostic tools, ` +
                              `and preventive measures have improved quality of life and increased life expectancy around the world. ` +
                              `Personalized medicine, which tailors treatments to individual genetic profiles, is becoming increasingly common, ` +
                              `offering more effective and targeted therapies. Mental health awareness has also grown, leading to better support ` +
                              `and resources for those struggling with psychological challenges. Despite these advances, health disparities ` +
                              `persist, highlighting the need for equitable access to care for all populations.`;
            } else if (topicLower.includes('education') || topicLower.includes('learning')) {
                generatedText = `Education is the foundation of personal and societal development. It empowers individuals with knowledge, ` +
                              `critical thinking skills, and the ability to adapt to a changing world. Traditional educational models are ` +
                              `evolving to incorporate technology, offering new ways of teaching and learning. Online education, in particular, ` +
                              `has expanded access to learning opportunities for people regardless of their location or circumstances. ` +
                              `However, challenges remain in ensuring quality education for all, addressing disparities in resources, and ` +
                              `preparing students for the jobs of the future.`;
            } else if (topicLower.includes('economy') || topicLower.includes('business')) {
                generatedText = `The global economy is a complex system of production, trade, and consumption that connects countries and markets. ` +
                              `Economic trends and policies have far-reaching impacts on businesses, employment, and individuals' quality of life. ` +
                              `In recent years, digital technologies have transformed business models, creating new opportunities and challenges. ` +
                              `Sustainability has also become a key consideration, with businesses increasingly recognizing their responsibility ` +
                              `to operate in environmentally and socially responsible ways. As the economy continues to evolve, adaptability and ` +
                              `innovation will be crucial for success.`;
            } else {
                generatedText = `${topic.charAt(0).toUpperCase() + topic.slice(1)} is a fascinating subject that encompasses many aspects of our world. ` +
                              `It touches on various elements that influence our daily lives and shapes our understanding of the world around us. ` +
                              `Exploring this topic reveals insights into how different components interact and affect one another. ` +
                              `By studying ${topicLower}, we gain valuable knowledge that can inform our decisions and actions. ` +
                              `As we continue to learn more about ${topicLower}, we uncover new possibilities and perspectives that enrich our experience.`;
            }
            
            return `Generated Text:\n\n${generatedText}`;
        } catch (error) {
            return "Error generating text. Please check your input.";
        }
    }
},
{
    // Pattern to simulate machine learning model training
    pattern: /simulate training (.+) model with (.+) epochs/i,
    response: (match) => {
        try {
            const modelType = match[1];
            const epochs = parseInt(match[2]);
            
            if (epochs < 1 || epochs > 1000) return "Number of epochs should be between 1 and 1000";
            
            // Simulate training process
            let trainingLog = `Simulating training of ${modelType} model for ${epochs} epochs...\n\n`;
            trainingLog += `Epoch | Loss    | Accuracy\n`;
            trainingLog += `------|---------|----------\n`;
            
            // Simulate improving metrics over epochs
            let loss = 2.5;
            let accuracy = 0.2;
            
            for (let epoch = 1; epoch <= epochs; epoch++) {
                // Simulate improvement with some randomness
                loss = Math.max(0.01, loss * (0.95 + Math.random() * 0.05));
                accuracy = Math.min(0.99, accuracy + (0.99 - accuracy) * 0.05 + Math.random() * 0.02);
                
                if (epoch <= 10 || epoch === epochs || epoch % 10 === 0) {
                    trainingLog += `${epoch.toString().padStart(5)} | ${loss.toFixed(4)} | ${accuracy.toFixed(4)}\n`;
                }
            }
            
            trainingLog += `\nTraining completed!\n`;
            trainingLog += `Final Loss: ${loss.toFixed(4)}\n`;
            trainingLog += `Final Accuracy: ${accuracy.toFixed(4)}\n`;
            
            if (accuracy > 0.9) {
                trainingLog += `Model performance: Excellent\n`;
            } else if (accuracy > 0.8) {
                trainingLog += `Model performance: Good\n`;
            } else if (accuracy > 0.7) {
                trainingLog += `Model performance: Fair\n`;
            } else {
                trainingLog += `Model performance: Poor - consider more training or a different approach\n`;
            }
            
            return trainingLog;
        } catch (error) {
            return "Error simulating model training. Please check your input.";
        }
    }
},

{
    // Pattern to simulate neural network architecture
    pattern: /design neural network for (.+) with (.+) layers/i,
    response: (match) => {
        try {
            const task = match[1];
            const layers = parseInt(match[2]);
            
            if (layers < 2 || layers > 20) return "Number of layers should be between 2 and 20";
            
            let architecture = `Neural Network Architecture for ${task}:\n\n`;
            
            // Determine appropriate architecture based on task
            let inputSize, outputSize;
            let layerTypes = [];
            
            if (task.toLowerCase().includes('image') || task.toLowerCase().includes('vision')) {
                inputSize = "224x224x3 (RGB Image)";
                outputSize = "Number of classes";
                layerTypes = ["Conv2D", "MaxPooling2D", "Conv2D", "MaxPooling2D", "Flatten", "Dense", "Dense"];
            } else if (task.toLowerCase().includes('text') || task.toLowerCase().includes('nlp')) {
                inputSize = "Sequence length";
                outputSize = "Vocabulary size or classes";
                layerTypes = ["Embedding", "LSTM", "LSTM", "Dense"];
            } else {
                inputSize = "Number of features";
                outputSize = "Number of classes or regression output";
                layerTypes = ["Dense", "Dense"];
            }
            
            architecture += `Input Layer: ${inputSize}\n`;
            
            // Generate layers
            for (let i = 0; i < layers - 1; i++) {
                const layerType = layerTypes[i % layerTypes.length];
                let layerDetails = "";
                
                if (layerType === "Conv2D") {
                    const filters = 32 * Math.pow(2, Math.floor(i / 2));
                    const kernelSize = 3;
                    layerDetails = `${filters} filters, ${kernelSize}x${kernelSize} kernel, ReLU activation`;
                } else if (layerType === "MaxPooling2D") {
                    layerDetails = "2x2 pool size";
                } else if (layerType === "LSTM") {
                    const units = 128 * Math.pow(0.5, Math.floor(i / 2));
                    layerDetails = `${units} units`;
                } else if (layerType === "Dense") {
                    const units = i === layers - 2 ? "Output" : 256 * Math.pow(0.5, Math.floor(i / 2));
                    const activation = i === layers - 2 ? "Output activation" : "ReLU";
                    layerDetails = `${units} units, ${activation}`;
                } else if (layerType === "Embedding") {
                    layerDetails = "Embedding dimension: 128";
                } else if (layerType === "Flatten") {
                    layerDetails = "";
                }
                
                architecture += `Layer ${i + 1}: ${layerType}`;
                if (layerDetails) {
                    architecture += ` (${layerDetails})`;
                }
                architecture += "\n";
            }
            
            architecture += `Output Layer: ${outputSize}\n\n`;
            
            // Add model summary
            architecture += `Model Summary:\n`;
            architecture += `- Total Layers: ${layers}\n`;
            architecture += `- Task Type: ${task}\n`;
            architecture += `- Recommended Optimizer: Adam\n`;
            architecture += `- Recommended Loss Function: ${task.toLowerCase().includes('classif') ? 'Categorical Crossentropy' : 'Mean Squared Error'}\n`;
            architecture += `- Recommended Metrics: Accuracy`;
            
            return architecture;
        } catch (error) {
            return "Error designing neural network. Please check your input.";
        }
    }
},

{
    // Pattern to simulate data clustering
    pattern: /perform clustering on (.+) with (\d+) clusters/i,
    response: (match) => {
        try {
            const dataType = match[1];
            const k = parseInt(match[2]);
            
            if (k < 1 || k > 20) return "Number of clusters should be between 1 and 20";
            
            // Simulate clustering process
            let result = `Simulating K-means clustering on ${dataType} data with ${k} clusters...\n\n`;
            
            // Generate simulated cluster centers
            const dimensions = dataType.toLowerCase().includes('text') ? 100 : 
                             dataType.toLowerCase().includes('image') ? 784 : 10;
            
            result += `Data Properties:\n`;
            result += `- Data Type: ${dataType}\n`;
            result += `- Number of Clusters (k): ${k}\n`;
            result += `- Feature Dimensions: ${dimensions}\n\n`;
            
            result += `Cluster Centers:\n`;
            
            for (let i = 0; i < k; i++) {
                result += `Cluster ${i + 1}: [`;
                
                // Generate random cluster center coordinates
                for (let d = 0; d < Math.min(5, dimensions); d++) {
                    result += (Math.random() * 10 - 5).toFixed(2);
                    if (d < Math.min(4, dimensions - 1)) result += ", ";
                }
                
                if (dimensions > 5) result += ", ...";
                result += "]\n";
            }
            
            // Calculate simulated metrics
            const inertia = (Math.random() * 1000 + 500).toFixed(2);
            const silhouetteScore = (Math.random() * 0.5 + 0.3).toFixed(3);
            
            result += `\nClustering Metrics:\n`;
            result += `- Inertia (Within-cluster sum of squares): ${inertia}\n`;
            result += `- Silhouette Score: ${silhouetteScore}\n`;
            
            // Interpret silhouette score
            if (silhouetteScore > 0.7) {
                result += `- Cluster Quality: Excellent\n`;
            } else if (silhouetteScore > 0.5) {
                result += `- Cluster Quality: Good\n`;
            } else if (silhouetteScore > 0.3) {
                result += `- Cluster Quality: Fair\n`;
            } else {
                result += `- Cluster Quality: Poor - consider different k or preprocessing\n`;
            }
            
            return result;
        } catch (error) {
            return "Error performing clustering. Please check your input.";
        }
    }
},

{
    // Pattern to simulate dimensionality reduction
    pattern: /reduce dimensions of (.+) to (\d+) components/i,
    response: (match) => {
        try {
            const dataType = match[1];
            const components = parseInt(match[2]);
            
            if (components < 1 || components > 100) return "Number of components should be between 1 and 100";
            
            // Simulate dimensionality reduction
            let result = `Simulating dimensionality reduction for ${dataType} data to ${components} components...\n\n`;
            
            // Determine original dimensions based on data type
            const originalDimensions = dataType.toLowerCase().includes('image') ? 784 :
                                     dataType.toLowerCase().includes('text') ? 1000 : 50;
            
            result += `Data Properties:\n`;
            result += `- Data Type: ${dataType}\n`;
            result += `- Original Dimensions: ${originalDimensions}\n`;
            result += `- Target Components: ${components}\n\n`;
            
            // Simulate explained variance ratio
            let explainedVariance = [];
            let cumulativeVariance = 0;
            
            for (let i = 0; i < components; i++) {
                // Generate decreasing explained variance
                const variance = Math.max(0.001, 0.8 * Math.exp(-0.5 * i) + Math.random() * 0.1);
                explainedVariance.push(variance);
                cumulativeVariance += variance;
            }
            
            // Normalize to ensure cumulative variance doesn't exceed 1
            if (cumulativeVariance > 1) {
                const normalizationFactor = 0.95 / cumulativeVariance;
                explainedVariance = explainedVariance.map(v => v * normalizationFactor);
                cumulativeVariance = 0.95;
            }
            
            result += `Explained Variance Ratio:\n`;
            let cumulative = 0;
            
            for (let i = 0; i < components; i++) {
                cumulative += explainedVariance[i];
                result += `Component ${i + 1}: ${explainedVariance[i].toFixed(4)} (Cumulative: ${cumulative.toFixed(4)})\n`;
            }
            
            result += `\nTotal Explained Variance: ${cumulative.toFixed(4)} (${(cumulative * 100).toFixed(2)}%)\n\n`;
            
            // Add interpretation
            if (cumulative > 0.9) {
                result += `Interpretation: The ${components} components preserve over 90% of the variance in the original data. ` +
                         `This reduction should maintain most of the information while significantly reducing complexity.`;
            } else if (cumulative > 0.7) {
                result += `Interpretation: The ${components} components preserve a good portion of the variance in the original data. ` +
                         `Some information loss may occur, but the reduced dimensionality should still be useful for visualization or further processing.`;
            } else {
                result += `Interpretation: The ${components} components preserve a limited portion of the variance in the original data. ` +
                         `Consider using more components or a different dimensionality reduction technique to preserve more information.`;
            }
            
            return result;
        } catch (error) {
            return "Error reducing dimensions. Please check your input.";
        }
    }
},

{
    // Pattern to simulate anomaly detection
    pattern: /detect anomalies in (.+) data/i,
    response: (match) => {
        try {
            const dataType = match[1];
            
            // Simulate anomaly detection
            let result = `Simulating anomaly detection for ${dataType} data...\n\n`;
            
            // Generate simulated statistics
            const dataPoints = Math.floor(Math.random() * 9000) + 1000;
            const anomaliesDetected = Math.floor(dataPoints * (Math.random() * 0.05 + 0.01)); // 1-6% anomalies
            
            result += `Data Statistics:\n`;
            result += `- Data Type: ${dataType}\n`;
            result += `- Total Data Points: ${dataPoints}\n`;
            result += `- Anomalies Detected: ${anomaliesDetected} (${(anomaliesDetected / dataPoints * 100).toFixed(2)}%)\n\n`;
            
            // Simulate anomaly types
            const anomalyTypes = [
                { type: "Point Anomalies", count: Math.floor(anomaliesDetected * 0.6), description: "Individual data points that deviate significantly from the rest" },
                { type: "Contextual Anomalies", count: Math.floor(anomaliesDetected * 0.25), description: "Data points that are anomalous in a specific context" },
                { type: "Collective Anomalies", count: Math.floor(anomaliesDetected * 0.15), description: "Collections of data points that are anomalous together" }
            ];
            
            result += `Anomaly Breakdown:\n`;
            anomalyTypes.forEach(anomaly => {
                result += `- ${anomaly.type}: ${anomaly.count} (${(anomaly.count / anomaliesDetected * 100).toFixed(1)}%) - ${anomaly.description}\n`;
            });
            
            // Simulate top anomalies
            result += `\nTop Anomalies:\n`;
            
            for (let i = 0; i < Math.min(5, anomaliesDetected); i++) {
                const anomalyScore = (Math.random() * 2 + 1).toFixed(2); // Score between 1.0 and 3.0
                const confidence = (Math.random() * 0.3 + 0.7).toFixed(2); // Confidence between 0.7 and 1.0
                
                result += `${i + 1}. Anomaly Score: ${anomalyScore}, Confidence: ${confidence}\n`;
            }
            
            // Add recommendations
            result += `\nRecommendations:\n`;
            result += `- Investigate high-scoring anomalies to determine their cause\n`;
            result += `- Consider whether anomalies represent errors, fraud, or legitimate but rare events\n`;
            result += `- Update the anomaly detection model periodically to adapt to changing patterns\n`;
            
            return result;
        } catch (error) {
            return "Error detecting anomalies. Please check your input.";
        }
    }
},

{
    // Pattern to simulate time series forecasting
    pattern: /forecast (.+) for (\d+) periods/i,
    response: (match) => {
        try {
            const metric = match[1];
            const periods = parseInt(match[2]);
            
            if (periods < 1 || periods > 50) return "Number of periods should be between 1 and 50";
            
            // Simulate time series forecasting
            let result = `Simulating time series forecast for ${metric} over ${periods} periods...\n\n`;
            
            // Generate historical data points
            const historicalPoints = 24;
            let historicalData = [];
            let baseValue = 100 + Math.random() * 50;
            
            for (let i = 0; i < historicalPoints; i++) {
                // Add trend, seasonality, and noise
                const trend = baseValue + i * 2;
                const seasonality = Math.sin(i / 3) * 10;
                const noise = (Math.random() - 0.5) * 5;
                const value = trend + seasonality + noise;
                historicalData.push(value);
            }
            
            result += `Historical Data (last ${Math.min(10, historicalPoints)} points):\n`;
            
            for (let i = Math.max(0, historicalPoints - 10); i < historicalPoints; i++) {
                result += `Period ${i + 1}: ${historicalData[i].toFixed(2)}\n`;
            }
            
            // Generate forecast
            result += `\nForecast:\n`;
            
            let lastValue = historicalData[historicalPoints - 1];
            let forecastData = [];
            
            for (let i = 0; i < periods; i++) {
                // Continue trend, seasonality, and add increasing uncertainty
                const trend = lastValue + 2;
                const seasonality = Math.sin((historicalPoints + i) / 3) * 10;
                const noise = (Math.random() - 0.5) * (5 + i * 0.5);
                const value = trend + seasonality + noise;
                
                forecastData.push(value);
                lastValue = value;
                
                result += `Period ${historicalPoints + i + 1}: ${value.toFixed(2)}`;
                
                // Add confidence interval
                const confidence = 5 + i * 0.8; // Increasing uncertainty
                result += ` (95% CI: ${(value - confidence).toFixed(2)} to ${(value + confidence).toFixed(2)})\n`;
            }
            
            // Add forecast summary
            const avgHistorical = historicalData.reduce((a, b) => a + b, 0) / historicalData.length;
            const avgForecast = forecastData.reduce((a, b) => a + b, 0) / forecastData.length;
            const growthRate = ((avgForecast - avgHistorical) / avgHistorical * 100).toFixed(1);
            
            result += `\nForecast Summary:\n`;
            result += `- Average Historical Value: ${avgHistorical.toFixed(2)}\n`;
            result += `- Average Forecast Value: ${avgForecast.toFixed(2)}\n`;
            result += `- Expected Growth Rate: ${growthRate}%\n`;
            
            // Add interpretation
            if (Math.abs(growthRate) < 5) {
                result += `- Interpretation: Stable forecast with minimal growth expected\n`;
            } else if (growthRate > 0) {
                result += `- Interpretation: Positive growth trend expected\n`;
            } else {
                result += `- Interpretation: Declining trend expected\n`;
            }
            
            return result;
        } catch (error) {
            return "Error forecasting time series. Please check your input.";
        }
    }
},

{
    // Pattern to simulate recommendation system
    pattern: /generate recommendations for user (.+) based on (.+)/i,
    response: (match) => {
        try {
            const userId = match[1];
            const itemType = match[2];
            
            // Simulate recommendation system
            let result = `Generating ${itemType} recommendations for user ${userId}...\n\n`;
            
            // Generate user profile
            const categories = ["Technology", "Entertainment", "Sports", "Science", "Business", "Arts", "Health", "Education"];
            const userPreferences = {};
            
            // Random user preferences
            categories.forEach(category => {
                userPreferences[category] = Math.random();
            });
            
            // Normalize preferences
            const totalPref = Object.values(userPreferences).reduce((a, b) => a + b, 0);
            Object.keys(userPreferences).forEach(key => {
                userPreferences[key] /= totalPref;
            });
            
            result += `User Profile:\n`;
            Object.entries(userPreferences)
                .sort((a, b) => b[1] - a[1])
                .forEach(([category, preference]) => {
                    result += `- ${category}: ${(preference * 100).toFixed(1)}%\n`;
                });
            
            // Generate recommendations
            result += `\nTop Recommendations:\n`;
            
            const recommendationCount = 10;
            const recommendations = [];
            
            for (let i = 0; i < recommendationCount; i++) {
                // Select category based on user preferences
                const rand = Math.random();
                let cumulative = 0;
                let selectedCategory = categories[0];
                
                for (const category of categories) {
                    cumulative += userPreferences[category];
                    if (rand <= cumulative) {
                        selectedCategory = category;
                        break;
                    }
                }
                
                // Generate recommendation details
                const recommendation = {
                    id: `${itemType.substring(0, 3).toUpperCase()}-${Math.floor(Math.random() * 10000)}`,
                    name: `${selectedCategory} ${itemType} ${i + 1}`,
                    category: selectedCategory,
                    rating: (Math.random() * 2 + 3).toFixed(1), // Rating between 3.0 and 5.0
                    match: (Math.random() * 30 + 70).toFixed(1) // Match percentage between 70% and 100%
                };
                
                recommendations.push(recommendation);
            }
            
            // Sort by match percentage
            recommendations.sort((a, b) => b.match - a.match);
            
            // Display recommendations
            recommendations.forEach((rec, index) => {
                result += `${index + 1}. ${rec.name} (${rec.category})\n`;
                result += `   ID: ${rec.id}, Rating: ${rec.rating}/5, Match: ${rec.match}%\n`;
            });
            
            // Add recommendation system info
            result += `\nRecommendation System Details:\n`;
            result += `- Algorithm: Collaborative Filtering with Content-Based Features\n`;
            result += `- User Similarity Threshold: 0.7\n`;
            result += `- Recommendation Diversity: Medium\n`;
            result += `- Last Updated: ${new Date().toISOString()}\n`;
            
            return result;
        } catch (error) {
            return "Error generating recommendations. Please check your input.";
        }
    }
},

{
    // Pattern to simulate natural language understanding
    pattern: /analyze intent of (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // Simulate NLU analysis
            let result = `Natural Language Understanding Analysis:\n\n`;
            result += `Input: "${text}"\n\n`;
            
            // Extract entities
            const entities = [];
            
            // Simple entity extraction patterns
            const dateRegex = /\b(\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}-\d{1,2}-\d{2,4}|\w+ \d{1,2}, \d{4})\b/g;
            const timeRegex = /\b(\d{1,2}:\d{2}(?:\s?[AP]M)?)\b/g;
            const numberRegex = /\b\d+(\.\d+)?\b/g;
            const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
            const phoneRegex = /\b(\d{3}[-.\s]?)?\d{3}[-.\s]?\d{4}\b/g;
            
            const dates = text.match(dateRegex) || [];
            const times = text.match(timeRegex) || [];
            const numbers = text.match(numberRegex) || [];
            const emails = text.match(emailRegex) || [];
            const phones = text.match(phoneRegex) || [];
            
            dates.forEach(date => entities.push({ type: "DATE", value: date }));
            times.forEach(time => entities.push({ type: "TIME", value: time }));
            numbers.forEach(number => entities.push({ type: "NUMBER", value: number }));
            emails.forEach(email => entities.push({ type: "EMAIL", value: email }));
            phones.forEach(phone => entities.push({ type: "PHONE", value: phone }));
            
            result += `Entities:\n`;
            if (entities.length > 0) {
                entities.forEach(entity => {
                    result += `- ${entity.type}: ${entity.value}\n`;
                });
            } else {
                result += `- No entities found\n`;
            }
            
            // Determine intent
            const lowerText = text.toLowerCase();
            let intent = "UNKNOWN";
            let confidence = 0.0;
            
            const intents = [
                { keywords: ["book", "reservation", "schedule", "appointment"], name: "BOOKING" },
                { keywords: ["weather", "temperature", "forecast", "rain"], name: "WEATHER" },
                { keywords: ["help", "support", "assistance", "issue"], name: "SUPPORT" },
                { keywords: ["buy", "purchase", "order", "price"], name: "SHOPPING" },
                { keywords: ["direction", "location", "address", "map"], name: "NAVIGATION" },
                { keywords: ["play", "music", "song", "video"], name: "ENTERTAINMENT" },
                { keywords: ["search", "find", "look for", "information"], name: "SEARCH" },
                { keywords: ["reminder", "alarm", "notify", "alert"], name: "REMINDER" }
            ];
            
            // Calculate intent scores
            const intentScores = {};
            
            intents.forEach(intentObj => {
                intentScores[intentObj.name] = 0;
                
                intentObj.keywords.forEach(keyword => {
                    if (lowerText.includes(keyword)) {
                        intentScores[intentObj.name]++;
                    }
                });
            });
            
            // Find the intent with the highest score
            let maxScore = 0;
            Object.entries(intentScores).forEach(([intentName, score]) => {
                if (score > maxScore) {
                    maxScore = score;
                    intent = intentName;
                }
            });
            
            // Calculate confidence based on score and text length
            confidence = Math.min(0.95, maxScore / (text.split(/\s+/).length * 0.3));
            
            result += `\nIntent: ${intent}\n`;
            result += `Confidence: ${(confidence * 100).toFixed(1)}%\n`;
            
            // Extract sentiment
            const positiveWords = ["good", "great", "excellent", "amazing", "wonderful", "fantastic", "love", "like", "happy"];
            const negativeWords = ["bad", "terrible", "awful", "hate", "dislike", "unhappy", "disappointed", "angry"];
            
            let sentimentScore = 0;
            
            positiveWords.forEach(word => {
                if (lowerText.includes(word)) sentimentScore++;
            });
            
            negativeWords.forEach(word => {
                if (lowerText.includes(word)) sentimentScore--;
            });
            
            let sentiment = "NEUTRAL";
            if (sentimentScore > 0) sentiment = "POSITIVE";
            if (sentimentScore < 0) sentiment = "NEGATIVE";
            
            result += `Sentiment: ${sentiment}\n`;
            
            return result;
        } catch (error) {
            return "Error analyzing intent. Please check your input.";
        }
    }
},

{
    // Pattern to simulate image recognition
    pattern: /recognize objects in (.+)/i,
    response: (match) => {
        try {
            const imageDescription = match[1];
            
            // Simulate image recognition
            let result = `Image Recognition Analysis:\n\n`;
            result += `Image Description: "${imageDescription}"\n\n`;
            
            // Extract potential objects from description
            const commonObjects = [
                "person", "car", "dog", "cat", "tree", "house", "building", "road", "sky", "cloud",
                "mountain", "water", "boat", "bird", "flower", "book", "computer", "phone", "table", "chair"
            ];
            
            const detectedObjects = [];
            const objectConfidences = {};
            
            // Find objects mentioned in the description
            commonObjects.forEach(obj => {
                if (imageDescription.toLowerCase().includes(obj)) {
                    const confidence = Math.min(0.99, 0.7 + Math.random() * 0.3);
                    detectedObjects.push(obj);
                    objectConfidences[obj] = confidence;
                }
            });
            
            // Add some random objects if none were found
            if (detectedObjects.length === 0) {
                const randomCount = Math.floor(Math.random() * 3) + 1;
                
                for (let i = 0; i < randomCount; i++) {
                    const randomObj = commonObjects[Math.floor(Math.random() * commonObjects.length)];
                    if (!detectedObjects.includes(randomObj)) {
                        const confidence = Math.random() * 0.4 + 0.5; // 0.5 to 0.9
                        detectedObjects.push(randomObj);
                        objectConfidences[randomObj] = confidence;
                    }
                }
            }
            
            // Sort by confidence
            detectedObjects.sort((a, b) => objectConfidences[b] - objectConfidences[a]);
            
            result += `Detected Objects:\n`;
            detectedObjects.forEach(obj => {
                result += `- ${obj}: ${(objectConfidences[obj] * 100).toFixed(1)}% confidence\n`;
            });
            
            // Simulate scene classification
            const scenes = [
                "Indoor", "Outdoor", "Urban", "Natural", "Beach", "Forest", "Mountain", "City",
                "Office", "Kitchen", "Bedroom", "Living Room", "Restaurant", "Street", "Park"
            ];
            
            const scene = scenes[Math.floor(Math.random() * scenes.length)];
            const sceneConfidence = Math.random() * 0.3 + 0.7; // 0.7 to 1.0
            
            result += `\nScene Classification:\n`;
            result += `- ${scene}: ${(sceneConfidence * 100).toFixed(1)}% confidence\n`;
            
            // Simulate color analysis
            const colors = [
                { name: "Red", percentage: Math.random() * 30 },
                { name: "Green", percentage: Math.random() * 30 },
                { name: "Blue", percentage: Math.random() * 30 },
                { name: "Yellow", percentage: Math.random() * 20 },
                { name: "Orange", percentage: Math.random() * 20 },
                { name: "Purple", percentage: Math.random() * 20 }
            ];
            
            // Normalize color percentages
            const totalColorPercentage = colors.reduce((sum, color) => sum + color.percentage, 0);
            colors.forEach(color => {
                color.percentage = (color.percentage / totalColorPercentage) * 100;
            });
            
            // Sort by percentage
            colors.sort((a, b) => b.percentage - a.percentage);
            
            result += `\nColor Analysis:\n`;
            colors.forEach(color => {
                result += `- ${color.name}: ${color.percentage.toFixed(1)}%\n`;
            });
            
            return result;
        } catch (error) {
            return "Error recognizing objects. Please check your input.";
        }
    }
},

{
    // Pattern to simulate speech recognition
    pattern: /transcribe audio with (.+) background noise/i,
    response: (match) => {
        try {
            const noiseLevel = match[1];
            
            // Determine noise impact
            let noiseImpact = 0.1; // Default low noise
            
            if (noiseLevel.toLowerCase().includes('high') || noiseLevel.toLowerCase().includes('loud')) {
                noiseImpact = 0.3;
            } else if (noiseLevel.toLowerCase().includes('medium') || noiseLevel.toLowerCase().includes('moderate')) {
                noiseImpact = 0.2;
            }
            
            // Simulate speech recognition
            let result = `Speech Recognition Transcription:\n\n`;
            result += `Background Noise Level: ${noiseLevel}\n`;
            result += `Expected Accuracy: ${((1 - noiseImpact) * 100).toFixed(1)}%\n\n`;
            
            // Generate sample transcription based on noise level
            let transcription;
            
            if (noiseImpact <= 0.15) {
                transcription = `Hello, this is a test of the speech recognition system. The audio quality is good, ` +
                              `so the transcription should be highly accurate. Speech recognition technology has improved ` +
                              `significantly in recent years, making it useful for many applications.`;
            } else if (noiseImpact <= 0.25) {
                transcription = `Hello, this is a test of the speech recognition system. The audio quality is fair, ` +
                              `so there might be some minor errors in the transcription. Speech recognition technology ` +
                              `has improved in recent years, making it useful for many applications.`;
            } else {
                transcription = `Hello, this is a test of the speech recognition system. The audio quality is poor due ` +
                              `to background noise, so there may be several errors in the transcription. Speech recognition ` +
                              `technology has improved in recent years, making it useful for many applications.`;
            }
            
            // Introduce errors based on noise level
            const errorWords = ["the", "a", "is", "of", "in", "it", "to", "and"];
            const words = transcription.split(' ');
            
            for (let i = 0; i < words.length; i++) {
                if (errorWords.includes(words[i].toLowerCase()) && Math.random() < noiseImpact) {
                    // Replace with a similar word
                    if (words[i].toLowerCase() === "the") words[i] = Math.random() > 0.5 ? "a" : "an";
                    if (words[i].toLowerCase() === "a") words[i] = Math.random() > 0.5 ? "the" : "an";
                    if (words[i].toLowerCase() === "is") words[i] = Math.random() > 0.5 ? "was" : "are";
                    if (words[i].toLowerCase() === "of") words[i] = Math.random() > 0.5 ? "for" : "from";
                    if (words[i].toLowerCase() === "in") words[i] = Math.random() > 0.5 ? "on" : "at";
                    if (words[i].toLowerCase() === "it") words[i] = Math.random() > 0.5 ? "this" : "that";
                    if (words[i].toLowerCase() === "to") words[i] = Math.random() > 0.5 ? "for" : "from";
                    if (words[i].toLowerCase() === "and") words[i] = Math.random() > 0.5 ? "or" : "but";
                }
            }
            
            transcription = words.join(' ');
            
            result += `Transcription:\n"${transcription}"\n\n`;
            
            // Add word error rate simulation
            const wordErrorRate = (noiseImpact * 15).toFixed(1);
            result += `Estimated Word Error Rate: ${wordErrorRate}%\n`;
            
            // Add recommendations
            result += `\nRecommendations for Improved Accuracy:\n`;
            if (noiseImpact > 0.2) {
                result += `- Use a noise-canceling microphone\n`;
                result += `- Record in a quieter environment\n`;
                result += `- Apply noise reduction filters\n`;
            }
            result += `- Speak clearly and at a moderate pace\n`;
            result += `- Position the microphone close to the speaker\n`;
            
            return result;
        } catch (error) {
            return "Error transcribing audio. Please check your input.";
        }
    }
},

{
    // Pattern to simulate text generation
    pattern: /generate (.+) words about (.+)/i,
    response: (match) => {
        try {
            const wordCount = parseInt(match[1]);
            const topic = match[2];
            
            if (wordCount < 10 || wordCount > 500) return "Word count should be between 10 and 500";
            
            // Simulate text generation
            let result = `Generating ${wordCount} words about ${topic}...\n\n`;
            
            // Generate text based on topic
            let generatedText = "";
            let currentWordCount = 0;
            
            // Define topic-specific vocabulary
            let topicVocabulary = [];
            
            if (topic.toLowerCase().includes('technology') || topic.toLowerCase().includes('tech')) {
                topicVocabulary = [
                    "technology", "digital", "innovation", "software", "hardware", "computer", "internet",
                    "data", "algorithm", "artificial", "intelligence", "machine", "learning", "automation",
                    "cloud", "cybersecurity", "blockchain", "virtual", "reality", "augmented", "quantum"
                ];
            } else if (topic.toLowerCase().includes('environment') || topic.toLowerCase().includes('climate')) {
                topicVocabulary = [
                    "environment", "climate", "sustainability", "renewable", "energy", "carbon", "emissions",
                    "conservation", "biodiversity", "ecosystem", "pollution", "global", "warming", "green",
                    "recycling", "solar", "wind", "electric", "vehicles", "conservation", "preservation"
                ];
            } else if (topic.toLowerCase().includes('health') || topic.toLowerCase().includes('medical')) {
                topicVocabulary = [
                    "health", "medical", "patients", "treatment", "diagnosis", "prevention", "disease",
                    "healthcare", "medicine", "therapy", "symptoms", "vaccine", "pandemic", "doctor",
                    "hospital", "research", "clinical", "pharmaceutical", "wellness", "nutrition", "exercise"
                ];
            } else if (topic.toLowerCase().includes('education') || topic.toLowerCase().includes('learning')) {
                topicVocabulary = [
                    "education", "learning", "students", "teachers", "school", "university", "knowledge",
                    "curriculum", "pedagogy", "assessment", "classroom", "online", "resources", "skills",
                    "development", "academic", "degree", "certificate", "training", "workshop", "seminar"
                ];
            } else {
                // Generic vocabulary
                topicVocabulary = [
                    "important", "significant", "development", "process", "system", "approach", "method",
                    "analysis", "research", "study", "result", "conclusion", "evidence", "factor",
                    "impact", "effect", "benefit", "challenge", "opportunity", "solution", "implementation"
                ];
            }
            
            // Common transition words
            const transitionWords = [
                "however", "therefore", "moreover", "furthermore", "consequently", "additionally",
                "nevertheless", "nonetheless", "meanwhile", "otherwise", "thus", "hence", "accordingly"
            ];
            
            // Generate sentences
            while (currentWordCount < wordCount) {
                // Generate a sentence of 5-15 words
                const sentenceLength = Math.floor(Math.random() * 11) + 5;
                const remainingWords = wordCount - currentWordCount;
                const actualSentenceLength = Math.min(sentenceLength, remainingWords);
                
                let sentence = "";
                
                for (let i = 0; i < actualSentenceLength; i++) {
                    let word;
                    
                    if (i === 0) {
                        // First word of sentence - capitalize
                        word = topicVocabulary[Math.floor(Math.random() * topicVocabulary.length)];
                        word = word.charAt(0).toUpperCase() + word.slice(1);
                    } else if (i === actualSentenceLength - 1) {
                        // Last word of sentence - add period
                        word = topicVocabulary[Math.floor(Math.random() * topicVocabulary.length)] + ".";
                    } else if (Math.random() < 0.1 && i > 2 && i < actualSentenceLength - 2) {
                        // Occasionally add a transition word
                        word = transitionWords[Math.floor(Math.random() * transitionWords.length)] + ",";
                    } else {
                        // Regular word
                        word = topicVocabulary[Math.floor(Math.random() * topicVocabulary.length)];
                    }
                    
                    sentence += word + " ";
                }
                
                generatedText += sentence + " ";
                currentWordCount += actualSentenceLength;
            }
            
            result += `Generated Text:\n\n${generatedText.trim()}\n\n`;
            result += `Word Count: ${generatedText.trim().split(/\s+/).length}\n`;
            result += `Topic: ${topic}\n`;
            result += `Generation Model: Simulated Advanced Language Model\n`;
            
            return result;
        } catch (error) {
            return "Error generating text. Please check your input.";
        }
    }
},

{
    // Pattern to simulate sentiment analysis
    pattern: /analyze sentiment of (.+) with (.+) granularity/i,
    response: (match) => {
        try {
            const text = match[1];
            const granularity = match[2];
            
            // Simulate sentiment analysis
            let result = `Sentiment Analysis with ${granularity} Granularity:\n\n`;
            result += `Text: "${text}"\n\n`;
            
            // Determine analysis approach based on granularity
            if (granularity.toLowerCase().includes('sentence')) {
                // Sentence-level analysis
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                
                result += `Sentence-Level Analysis:\n\n`;
                
                let overallScore = 0;
                
                sentences.forEach((sentence, index) => {
                    // Calculate sentiment score for this sentence
                    let score = 0;
                    
                    // Simple keyword-based sentiment scoring
                    const positiveWords = ["good", "great", "excellent", "amazing", "wonderful", "fantastic", "love", "like", "happy", "pleased"];
                    const negativeWords = ["bad", "terrible", "awful", "hate", "dislike", "unhappy", "disappointed", "sad", "angry", "frustrated"];
                    
                    const lowerSentence = sentence.toLowerCase();
                    
                    positiveWords.forEach(word => {
                        if (lowerSentence.includes(word)) score += 1;
                    });
                    
                    negativeWords.forEach(word => {
                        if (lowerSentence.includes(word)) score -= 1;
                    });
                    
                    // Normalize score to [-1, 1]
                    const normalizedScore = Math.max(-1, Math.min(1, score / 3));
                    
                    // Determine sentiment label
                    let sentiment;
                    if (normalizedScore > 0.2) sentiment = "POSITIVE";
                    else if (normalizedScore < -0.2) sentiment = "NEGATIVE";
                    else sentiment = "NEUTRAL";
                    
                    result += `Sentence ${index + 1}: ${sentiment} (${normalizedScore.toFixed(2)})\n`;
                    result += `  "${sentence.trim()}"\n\n`;
                    
                    overallScore += normalizedScore;
                });
                
                // Calculate overall sentiment
                const avgScore = overallScore / sentences.length;
                let overallSentiment;
                if (avgScore > 0.2) overallSentiment = "POSITIVE";
                else if (avgScore < -0.2) overallSentiment = "NEGATIVE";
                else overallSentiment = "NEUTRAL";
                
                result += `Overall Sentiment: ${overallSentiment} (${avgScore.toFixed(2)})\n`;
                
            } else if (granularity.toLowerCase().includes('paragraph') || granularity.toLowerCase().includes('document')) {
                // Paragraph/document-level analysis
                let score = 0;
                
                // More sophisticated sentiment analysis
                const positiveWords = ["good", "great", "excellent", "amazing", "wonderful", "fantastic", "love", "like", "happy", "pleased", "satisfied", "perfect", "best", "brilliant", "outstanding", "superb", "marvelous", "terrific", "delightful", "impressive"];
                const negativeWords = ["bad", "terrible", "awful", "hate", "dislike", "unhappy", "disappointed", "sad", "angry", "frustrated", "upset", "annoyed", "worst", "horrible", "disgusting", "annoying", "boring", "unpleasant", "dreadful", "pathetic"];
                
                const intensifiers = ["very", "extremely", "really", "absolutely", "completely", "totally", "utterly", "quite", "rather", "somewhat"];
                const negators = ["not", "no", "never", "none", "nothing", "nobody", "nowhere", "neither", "nor", "cannot"];
                
                const lowerText = text.toLowerCase();
                const words = lowerText.split(/\s+/);
                
                for (let i = 0; i < words.length; i++) {
                    const word = words[i].replace(/[^\w]/g, '');
                    
                    // Check for negation
                    let negated = false;
                    for (let j = Math.max(0, i - 3); j < i; j++) {
                        if (negators.includes(words[j].replace(/[^\w]/g, ''))) {
                            negated = true;
                            break;
                        }
                    }
                    
                    // Check for intensifiers
                    let intensified = 1;
                    for (let j = Math.max(0, i - 2); j < i; j++) {
                        if (intensifiers.includes(words[j].replace(/[^\w]/g, ''))) {
                            intensified = 1.5;
                            break;
                        }
                    }
                    
                    // Calculate sentiment contribution
                    if (positiveWords.includes(word)) {
                        score += negated ? -1 * intensified : 1 * intensified;
                    } else if (negativeWords.includes(word)) {
                        score += negated ? 1 * intensified : -1 * intensified;
                    }
                }
                
                // Normalize score to [-1, 1]
                const normalizedScore = Math.max(-1, Math.min(1, score / (words.length * 0.1)));
                
                // Determine sentiment label
                let sentiment;
                if (normalizedScore > 0.2) sentiment = "POSITIVE";
                else if (normalizedScore < -0.2) sentiment = "NEGATIVE";
                else sentiment = "NEUTRAL";
                
                result += `Sentiment Score: ${normalizedScore.toFixed(3)}\n`;
                result += `Sentiment Label: ${sentiment}\n`;
                
                // Add confidence
                const confidence = Math.min(0.99, Math.abs(normalizedScore) + 0.5);
                result += `Confidence: ${(confidence * 100).toFixed(1)}%\n`;
                
                // Add emotion detection
                const emotions = [
                    { name: "Joy", score: Math.max(0, normalizedScore) },
                    { name: "Sadness", score: Math.max(0, -normalizedScore) },
                    { name: "Anger", score: Math.max(0, -normalizedScore * 0.8) },
                    { name: "Fear", score: Math.max(0, -normalizedScore * 0.6) },
                    { name: "Surprise", score: Math.abs(normalizedScore) * 0.3 }
                ];
                
                // Normalize emotion scores
                const emotionTotal = emotions.reduce((sum, emotion) => sum + emotion.score, 0);
                if (emotionTotal > 0) {
                    emotions.forEach(emotion => {
                        emotion.score /= emotionTotal;
                    });
                }
                
                // Sort by score
                emotions.sort((a, b) => b.score - a.score);
                
                result += `\nDetected Emotions:\n`;
                emotions.forEach(emotion => {
                    result += `- ${emotion.name}: ${(emotion.score * 100).toFixed(1)}%\n`;
                });
                
            } else {
                // Word-level analysis
                const words = text.split(/\s+/);
                
                result += `Word-Level Analysis:\n\n`;
                
                let positiveWords = 0;
                let negativeWords = 0;
                let neutralWords = 0;
                
                words.forEach((word, index) => {
                    const cleanWord = word.replace(/[^\w]/g, '').toLowerCase();
                    
                    // Determine word sentiment
                    let sentiment = "NEUTRAL";
                    
                    if (["good", "great", "excellent", "amazing", "wonderful", "fantastic", "love", "like", "happy", "pleased"].includes(cleanWord)) {
                        sentiment = "POSITIVE";
                        positiveWords++;
                    } else if (["bad", "terrible", "awful", "hate", "dislike", "unhappy", "disappointed", "sad", "angry", "frustrated"].includes(cleanWord)) {
                        sentiment = "NEGATIVE";
                        negativeWords++;
                    } else {
                        neutralWords++;
                    }
                    
                    result += `${index + 1}. ${word}: ${sentiment}\n`;
                });
                
                // Calculate overall sentiment
                const totalWords = words.length;
                const positivePercentage = (positiveWords / totalWords * 100).toFixed(1);
                const negativePercentage = (negativeWords / totalWords * 100).toFixed(1);
                const neutralPercentage = (neutralWords / totalWords * 100).toFixed(1);
                
                result += `\nWord Sentiment Distribution:\n`;
                result += `- Positive: ${positiveWords} (${positivePercentage}%)\n`;
                result += `- Negative: ${negativeWords} (${negativePercentage}%)\n`;
                result += `- Neutral: ${neutralWords} (${neutralPercentage}%)\n`;
                
                // Determine overall sentiment
                let overallSentiment = "NEUTRAL";
                if (positivePercentage > negativePercentage + 10) overallSentiment = "POSITIVE";
                else if (negativePercentage > positivePercentage + 10) overallSentiment = "NEGATIVE";
                
                result += `\nOverall Sentiment: ${overallSentiment}\n`;
            }
            
            return result;
        } catch (error) {
            return "Error analyzing sentiment. Please check your input.";
        }
    }
},

{
    // Pattern to simulate topic modeling
    pattern: /extract topics from (.+) with (\d+) topics/i,
    response: (match) => {
        try {
            const text = match[1];
            const numTopics = parseInt(match[2]);
            
            if (numTopics < 1 || numTopics > 20) return "Number of topics should be between 1 and 20";
            
            // Simulate topic modeling
            let result = `Topic Modeling with ${numTopics} Topics:\n\n`;
            
            // Preprocess text
            const stopWords = [
                'a', 'an', 'the', 'and', 'or', 'but', 'of', 'at', 'by', 'for', 'with',
                'about', 'between', 'into', 'through', 'during', 'before', 'after',
                'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off',
                'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there',
                'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few',
                'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only',
                'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can', 'will',
                'just', 'don', 'should', 'now', 'd', 'll', 'm', 'o', 're', 've', 'y'
            ];
            
            // Extract words
            const words = text.toLowerCase()
                .replace(/[^\w\s]/g, ' ')
                .split(/\s+/)
                .filter(word => word.length > 3 && !stopWords.includes(word));
            
            // Count word frequency
            const wordFreq = {};
            words.forEach(word => {
                wordFreq[word] = (wordFreq[word] || 0) + 1;
            });
            
            // Sort by frequency
            const sortedWords = Object.entries(wordFreq)
                .sort((a, b) => b[1] - a[1])
                .map(entry => entry[0]);
            
            // Generate topics
            const topics = [];
            const wordsPerTopic = Math.min(10, Math.ceil(sortedWords.length / numTopics));
            
            for (let i = 0; i < numTopics; i++) {
                const topicWords = [];
                
                // Select words for this topic
                for (let j = 0; j < wordsPerTopic; j++) {
                    const wordIndex = (i * wordsPerTopic + j) % sortedWords.length;
                    topicWords.push(sortedWords[wordIndex]);
                }
                
                // Generate topic name based on most frequent word
                const topicName = topicWords[0].charAt(0).toUpperCase() + topicWords[0].slice(1);
                
                // Calculate topic distribution (simplified)
                const topicDistribution = {};
                topicWords.forEach(word => {
                    topicDistribution[word] = Math.random();
                });
                
                // Normalize distribution
                const totalDist = Object.values(topicDistribution).reduce((a, b) => a + b, 0);
                Object.keys(topicDistribution).forEach(word => {
                    topicDistribution[word] /= totalDist;
                });
                
                // Sort by probability
                topicWords.sort((a, b) => topicDistribution[b] - topicDistribution[a]);
                
                topics.push({
                    name: topicName,
                    words: topicWords,
                    distribution: topicDistribution
                });
            }
            
            // Display topics
            result += `Extracted Topics:\n\n`;
            
            topics.forEach((topic, index) => {
                result += `Topic ${index + 1}: ${topic.name}\n`;
                result += `Top Words:\n`;
                
                topic.words.slice(0, 5).forEach(word => {
                    result += `- ${word}: ${(topic.distribution[word] * 100).toFixed(1)}%\n`;
                });
                
                result += `\n`;
            });
            
            // Add topic distribution across document
            result += `Topic Distribution in Document:\n`;
            
            const documentDistribution = {};
            let totalDocDist = 0;
            
            for (let i = 0; i < numTopics; i++) {
                documentDistribution[`Topic ${i + 1}`] = Math.random();
                totalDocDist += documentDistribution[`Topic ${i + 1}`];
            }
            
            // Normalize document distribution
            Object.keys(documentDistribution).forEach(topic => {
                documentDistribution[topic] /= totalDocDist;
            });
            
            // Sort by percentage
            const sortedDocDist = Object.entries(documentDistribution)
                .sort((a, b) => b[1] - a[1]);
            
            sortedDocDist.forEach(([topic, percentage]) => {
                result += `- ${topic}: ${(percentage * 100).toFixed(1)}%\n`;
            });
            
            // Add model information
            result += `\nModel Information:\n`;
            result += `- Algorithm: Latent Dirichlet Allocation (LDA)\n`;
            result += `- Number of Topics: ${numTopics}\n`;
            result += `- Iterations: 1000\n`;
            result += `- Alpha: 0.1\n`;
            result += `- Beta: 0.01\n`;
            
            return result;
        } catch (error) {
            return "Error extracting topics. Please check your input.";
        }
    }
},

{
    // Pattern to simulate named entity recognition
    pattern: /recognize entities in (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // Simulate named entity recognition
            let result = `Named Entity Recognition:\n\n`;
            result += `Text: "${text}"\n\n`;
            
            // Define entity patterns
            const entityPatterns = {
                PERSON: /\b([A-Z][a-z]+ [A-Z][a-z]+|[A-Z][a-z]+)\b/g,
                ORGANIZATION: /\b([A-Z][a-z]+ (?:Inc|Corp|Company|Ltd|LLC)|[A-Z][a-z]+ University|[A-Z][a-z]+ College)\b/g,
                LOCATION: /\b([A-Z][a-z]+ (?:City|State|County|Province)|[A-Z][a-z]+, [A-Z]{2})\b/g,
                DATE: /\b(\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}-\d{1,2}-\d{2,4}|\w+ \d{1,2}, \d{4}|\d{4})\b/g,
                TIME: /\b(\d{1,2}:\d{2}(?:\s?[AP]M)?)\b/g,
                MONEY: /\b(\$?\d+(?:,\d{3})*(?:\.\d{2})?\s?(?:dollars?|USD|€|euros?|£|pounds?))\b/g,
                PERCENT: /\b(\d+(?:\.\d+)?%)\b/g,
                FACILITY: /\b([A-Z][a-z]+ (?:Building|Center|Hospital|School|Stadium|Airport|Station|Museum))\b/g,
                GPE: /\b([A-Z][a-z]+ (?:Country|State|Province|City)|[A-Z]{2,3})\b/g,
                PRODUCT: /\b([A-Z][a-z]+ (?:Phone|Tablet|Computer|Car|Model|Version)|[A-Z][a-z]+\s?[0-9]+)\b/g
            };
            
            // Extract entities
            const entities = {};
            
            Object.entries(entityPatterns).forEach(([entityType, pattern]) => {
                const matches = text.match(pattern);
                if (matches) {
                    entities[entityType] = [...new Set(matches)]; // Remove duplicates
                }
            });
            
            // Display entities
            if (Object.keys(entities).length > 0) {
                result += `Recognized Entities:\n\n`;
                
                Object.entries(entities).forEach(([entityType, entityList]) => {
                    result += `${entityType}:\n`;
                    entityList.forEach(entity => {
                        result += `- ${entity}\n`;
                    });
                    result += `\n`;
                });
            } else {
                result += `No named entities found in the text.\n\n`;
            }
            
            // Add entity confidence scores
            result += `Entity Confidence Scores:\n\n`;
            
            Object.entries(entities).forEach(([entityType, entityList]) => {
                result += `${entityType}:\n`;
                entityList.forEach(entity => {
                    // Generate random confidence score based on entity type
                    let baseConfidence;
                    switch (entityType) {
                        case "PERSON":
                        case "DATE":
                        case "MONEY":
                            baseConfidence = 0.9;
                            break;
                        case "ORGANIZATION":
                        case "LOCATION":
                        case "GPE":
                            baseConfidence = 0.8;
                            break;
                        case "TIME":
                        case "PERCENT":
                            baseConfidence = 0.95;
                            break;
                        default:
                            baseConfidence = 0.7;
                    }
                    
                    // Add some randomness
                    const confidence = Math.min(0.99, Math.max(0.5, baseConfidence + (Math.random() - 0.5) * 0.2));
                    result += `- ${entity}: ${(confidence * 100).toFixed(1)}%\n`;
                });
                result += `\n`;
            });
            
            // Add model information
            result += `Model Information:\n`;
            result += `- Model: Simulated Advanced NER Model\n`;
            result += `- Entity Types: ${Object.keys(entityPatterns).join(', ')}\n`;
            result += `- Context Window: 512 tokens\n`;
            result += `- Processing Time: ${(Math.random() * 100 + 50).toFixed(1)}ms\n`;
            
            return result;
        } catch (error) {
            return "Error recognizing entities. Please check your input.";
        }
    }
},

{
    // Pattern to simulate text summarization
    pattern: /summarize (.+) in (\d+) sentences/i,
    response: (match) => {
        try {
            const text = match[1];
            const sentenceCount = parseInt(match[2]);
            
            if (sentenceCount < 1 || sentenceCount > 10) return "Sentence count should be between 1 and 10";
            
            // Simulate text summarization
            let result = `Text Summarization (${sentenceCount} sentences):\n\n`;
            result += `Original Text:\n"${text}"\n\n`;
            
            // Split text into sentences
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            
            if (sentences.length <= sentenceCount) {
                result += `Summary:\n"${text}"\n\n`;
                result += `Note: The original text is already shorter than the requested summary length.`;
                return result;
            }
            
            // Simple extractive summarization using sentence scoring
            const sentenceScores = sentences.map(sentence => {
                // Calculate sentence score based on various factors
                
                // 1. Sentence position (sentences at the beginning and end tend to be more important)
                const positionScore = sentence === sentences[0] || sentence === sentences[sentences.length - 1] ? 1 : 0.5;
                
                // 2. Sentence length (medium-length sentences are often more informative)
                const length = sentence.trim().split(/\s+/).length;
                const lengthScore = length >= 10 && length <= 20 ? 1 : Math.max(0.2, 1 - Math.abs(15 - length) / 15);
                
                // 3. Keyword frequency (sentences with more frequent words are more important)
                const words = sentence.toLowerCase().split(/\s+/);
                const wordFreq = {};
                
                // Count word frequency in the entire text
                const allWords = text.toLowerCase().split(/\s+/);
                allWords.forEach(word => {
                    wordFreq[word] = (wordFreq[word] || 0) + 1;
                });
                
                // Calculate keyword score for this sentence
                let keywordScore = 0;
                words.forEach(word => {
                    if (wordFreq[word] > 1) { // Not a unique word
                        keywordScore += wordFreq[word];
                    }
                });
                keywordScore = Math.min(1, keywordScore / words.length);
                
                // 4. Proper nouns (sentences with more proper nouns are often more important)
                const properNounScore = (sentence.match(/\b[A-Z][a-z]+\b/g) || []).length / words.length;
                
                // 5. Numerical data (sentences with numbers are often more important)
                const numberScore = (sentence.match(/\b\d+\b/g) || []).length / words.length;
                
                // Calculate overall score (weighted combination)
                const overallScore = 
                    positionScore * 0.2 +
                    lengthScore * 0.2 +
                    keywordScore * 0.3 +
                    properNounScore * 0.15 +
                    numberScore * 0.15;
                
                return {
                    text: sentence.trim(),
                    score: overallScore,
                    index: sentences.indexOf(sentence)
                };
            });
            
            // Sort sentences by score and select top sentences
            sentenceScores.sort((a, b) => b.score - a.score);
            const topSentences = sentenceScores.slice(0, sentenceCount);
            
            // Sort selected sentences by their original position to maintain flow
            topSentences.sort((a, b) => a.index - b.index);
            
            // Generate summary
            const summary = topSentences.map(s => s.text).join('. ') + '.';
            
            result += `Summary:\n"${summary}"\n\n`;
            
            // Add summarization metrics
            const originalLength = text.length;
            const summaryLength = summary.length;
            const compressionRatio = ((originalLength - summaryLength) / originalLength * 100).toFixed(1);
            
            result += `Summarization Metrics:\n`;
            result += `- Original Length: ${originalLength} characters\n`;
            result += `- Summary Length: ${summaryLength} characters\n`;
            result += `- Compression Ratio: ${compressionRatio}%\n`;
            result += `- Summary Method: Extractive\n`;
            
            return result;
        } catch (error) {
            return "Error summarizing text. Please check your input.";
        }
    }
},

{
    // Pattern to simulate machine translation
    pattern: /translate (.+) from (.+) to (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            const sourceLanguage = match[2];
            const targetLanguage = match[3];
            
            // Simulate machine translation
            let result = `Machine Translation:\n\n`;
            result += `Source Language: ${sourceLanguage}\n`;
            result += `Target Language: ${targetLanguage}\n`;
            result += `Source Text: "${text}"\n\n`;
            
            // Check if this is a supported language pair
            const supportedLanguages = [
                "English", "Spanish", "French", "German", "Italian", "Portuguese", 
                "Dutch", "Russian", "Chinese", "Japanese", "Korean", "Arabic"
            ];
            
            const isSourceSupported = supportedLanguages.some(lang => 
                sourceLanguage.toLowerCase().includes(lang.toLowerCase())
            );
            
            const isTargetSupported = supportedLanguages.some(lang => 
                targetLanguage.toLowerCase().includes(lang.toLowerCase())
            );
            
            if (!isSourceSupported || !isTargetSupported) {
                result += `Translation: Language pair not fully supported. Simulated translation may be inaccurate.\n\n`;
            }
            
            // Generate translation based on language pair
            let translation;
            
            if (sourceLanguage.toLowerCase().includes("english") && targetLanguage.toLowerCase().includes("spanish")) {
                // English to Spanish simulation
                const commonTranslations = {
                    "hello": "hola",
                    "goodbye": "adiós",
                    "please": "por favor",
                    "thank you": "gracias",
                    "yes": "sí",
                    "no": "no",
                    "water": "agua",
                    "food": "comida",
                    "house": "casa",
                    "car": "coche",
                    "the": "el/la",
                    "and": "y",
                    "to": "a",
                    "of": "de",
                    "in": "en",
                    "is": "es",
                    "you": "tú/usted",
                    "that": "ese/aquel",
                    "it": "ello",
                    "for": "para",
                    "on": "en",
                    "with": "con",
                    "as": "como",
                    "I": "yo",
                    "his": "su",
                    "they": "ellos/ellas",
                    "be": "ser/estar",
                    "at": "en",
                    "by": "por",
                    "he": "él",
                    "she": "ella",
                    "or": "o",
                    "an": "un/una",
                    "my": "mi",
                    "one": "uno/una",
                    "all": "todo/todos",
                    "would": "condicional",
                    "there": "allí",
                    "their": "su/sus",
                    "what": "qué",
                    "so": "así/entonces",
                    "up": "arriba",
                    "out": "fuera",
                    "if": "si",
                    "about": "acerca de",
                    "who": "quién",
                    "get": "conseguir",
                    "which": "cuál",
                    "go": "ir",
                    "me": "mí",
                    "when": "cuándo",
                    "make": "hacer",
                    "can": "poder",
                    "like": "gustar",
                    "time": "tiempo",
                    "no": "no",
                    "just": "justo/solamente",
                    "him": "él",
                    "know": "saber/conocer",
                    "take": "tomar",
                    "people": "gente",
                    "into": "en/dentro de",
                    "year": "año",
                    "your": "tu/su",
                    "good": "bueno",
                    "some": "algunos",
                    "could": "podría",
                    "them": "ellos/ellas",
                    "see": "ver",
                    "other": "otro",
                    "than": "que",
                    "then": "entonces",
                    "now": "ahora",
                    "look": "mirar",
                    "only": "solamente",
                    "come": "venir",
                    "its": "su",
                    "over": "sobre",
                    "think": "pensar",
                    "also": "también",
                    "back": "espalda/devolver",
                    "after": "después",
                    "use": "usar",
                    "two": "dos",
                    "how": "cómo",
                    "our": "nuestro",
                    "work": "trabajar",
                    "first": "primero",
                    "well": "bien",
                    "way": "camino/manera",
                    "even": "incluso",
                    "new": "nuevo",
                    "want": "querer",
                    "because": "porque",
                    "any": "cualquier",
                    "these": "estos",
                    "give": "dar",
                    "day": "día",
                    "most": "más"
                };
                
                // Simple word-by-word translation
                const words = text.toLowerCase().split(/\s+/);
                const translatedWords = words.map(word => {
                    const cleanWord = word.replace(/[^\w]/g, '');
                    const translated = commonTranslations[cleanWord];
                    
                    if (translated) {
                        // Preserve original punctuation
                        const punctuation = word.match(/[^\w]$/);
                        return translated + (punctuation ? punctuation[0] : '');
                    }
                    
                    return word; // Return original word if no translation found
                });
                
                translation = translatedWords.join(' ');
                
                // Adjust basic grammar
                translation = translation.replace(/i /g, "yo ");
                translation = translation.replace(/ am /g, " soy ");
                translation = translation.replace(/ is /g, " es ");
                translation = translation.replace(/ are /g, " son ");
                
            } else if (sourceLanguage.toLowerCase().includes("spanish") && targetLanguage.toLowerCase().includes("english")) {
                // Spanish to English simulation
                const commonTranslations = {
                    "hola": "hello",
                    "adiós": "goodbye",
                    "por favor": "please",
                    "gracias": "thank you",
                    "sí": "yes",
                    "no": "no",
                    "agua": "water",
                    "comida": "food",
                    "casa": "house",
                    "coche": "car",
                    "el": "the",
                    "la": "the",
                    "y": "and",
                    "a": "to",
                    "de": "of",
                    "en": "in",
                    "es": "is",
                    "tú": "you",
                    "usted": "you",
                    "ese": "that",
                    "aquel": "that",
                    "ello": "it",
                    "para": "for",
                    "con": "with",
                    "como": "as",
                    "yo": "I",
                    "su": "his/her/your",
                    "ellos": "they",
                    "ellas": "they",
                    "ser": "be",
                    "estar": "be",
                    "por": "by",
                    "él": "he",
                    "ella": "she",
                    "o": "or",
                    "un": "a",
                    "una": "a",
                    "mi": "my",
                    "uno": "one",
                    "todos": "all",
                    "allí": "there",
                    "qué": "what",
                    "así": "so",
                    "entonces": "then",
                    "arriba": "up",
                    "fuera": "out",
                    "si": "if",
                    "acerca de": "about",
                    "quién": "who",
                    "conseguir": "get",
                    "cuál": "which",
                    "ir": "go",
                    "mí": "me",
                    "cuándo": "when",
                    "hacer": "make/do",
                    "poder": "can",
                    "gustar": "like",
                    "tiempo": "time",
                    "solamente": "only",
                    "ver": "see",
                    "otro": "other",
                    "que": "that",
                    "mirar": "look",
                    "venir": "come",
                    "sobre": "over/about",
                    "pensar": "think",
                    "también": "also",
                    "espalda": "back",
                    "después": "after",
                    "usar": "use",
                    "dos": "two",
                    "cómo": "how",
                    "nuestro": "our",
                    "trabajar": "work",
                    "primero": "first",
                    "bien": "well",
                    "camino": "way",
                    "manera": "way",
                    "incluso": "even",
                    "nuevo": "new",
                    "querer": "want",
                    "porque": "because",
                    "cualquier": "any",
                    "estos": "these",
                    "dar": "give",
                    "día": "day",
                    "más": "more"
                };
                
                // Simple word-by-word translation
                const words = text.toLowerCase().split(/\s+/);
                const translatedWords = words.map(word => {
                    const cleanWord = word.replace(/[^\w]/g, '');
                    const translated = commonTranslations[cleanWord];
                    
                    if (translated) {
                        // Preserve original punctuation
                        const punctuation = word.match(/[^\w]$/);
                        return translated + (punctuation ? punctuation[0] : '');
                    }
                    
                    return word; // Return original word if no translation found
                });
                
                translation = translatedWords.join(' ');
                
                // Adjust basic grammar
                translation = translation.replace(/ yo /g, " I ");
                translation = translation.replace(/ soy /g, " am ");
                translation = translation.replace(/ es /g, " is ");
                translation = translation.replace(/ son /g, " are ");
                
            } else {
                // Unsupported language pair - generate a generic translation
                translation = `[Translated from ${sourceLanguage} to ${targetLanguage}]: ${text}`;
            }
            
            result += `Translation:\n"${translation}"\n\n`;
            
            // Add translation quality metrics
            const qualityScore = Math.random() * 0.3 + 0.7; // 0.7 to 1.0
            
            let qualityLevel;
            if (qualityScore > 0.9) qualityLevel = "Excellent";
            else if (qualityScore > 0.8) qualityLevel = "Good";
            else if (qualityScore > 0.7) qualityLevel = "Fair";
            else qualityLevel = "Poor";
            
            result += `Translation Quality:\n`;
            result += `- Quality Score: ${(qualityScore * 100).toFixed(1)}%\n`;
            result += `- Quality Level: ${qualityLevel}\n`;
            
            // Add model information
            result += `\nModel Information:\n`;
            result += `- Translation Model: Simulated Neural Machine Translation\n`;
            result += `- Architecture: Transformer\n`;
            result += `- Language Pair: ${sourceLanguage} → ${targetLanguage}\n`;
            result += `- Processing Time: ${(Math.random() * 200 + 100).toFixed(1)}ms\n`;
            
            return result;
        } catch (error) {
            return "Error translating text. Please check your input.";
        }
    }
},

{
    // Pattern to simulate question answering
    pattern: /answer (.+) based on (.+)/i,
    response: (match) => {
        try {
            const question = match[1];
            const context = match[2];
            
            // Simulate question answering
            let result = `Question Answering:\n\n`;
            result += `Question: "${question}"\n`;
            result += `Context: "${context}"\n\n`;
            
            // Determine question type
            const questionLower = question.toLowerCase();
            let questionType = "UNKNOWN";
            
            if (questionLower.startsWith("what")) questionType = "WHAT";
            else if (questionLower.startsWith("who")) questionType = "WHO";
            else if (questionLower.startsWith("when")) questionType = "WHEN";
            else if (questionLower.startsWith("where")) questionType = "WHERE";
            else if (questionLower.startsWith("why")) questionType = "WHY";
            else if (questionLower.startsWith("how")) questionType = "HOW";
            else if (questionLower.includes("which") || questionLower.includes("choose")) questionType = "WHICH";
            else if (questionLower.includes("true") || questionLower.includes("false")) questionType = "BOOLEAN";
            
            result += `Question Type: ${questionType}\n\n`;
            
            // Extract keywords from question
            const questionWords = questionLower.split(/\s+/).filter(word => word.length > 3);
            const stopWords = ["what", "who", "when", "where", "why", "how", "which", "is", "are", "was", "were", "will", "would", "could", "should", "can", "have", "has", "had", "do", "does", "did", "the", "a", "an", "in", "on", "at", "to", "for", "with", "about", "of", "from", "by", "as", "and", "or", "but", "not", "this", "that", "these", "those"];
            
            const keywords = questionWords.filter(word => !stopWords.includes(word));
            
            result += `Keywords: ${keywords.join(', ')}\n\n`;
            
            // Find relevant sentences in context
            const contextSentences = context.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const relevantSentences = [];
            
            contextSentences.forEach(sentence => {
                const sentenceLower = sentence.toLowerCase();
                let relevanceScore = 0;
                
                // Calculate relevance based on keyword matches
                keywords.forEach(keyword => {
                    if (sentenceLower.includes(keyword)) {
                        relevanceScore++;
                    }
                });
                
                if (relevanceScore > 0) {
                    relevantSentences.push({
                        text: sentence.trim(),
                        score: relevanceScore
                    });
                }
            });
            
            // Sort by relevance
            relevantSentences.sort((a, b) => b.score - a.score);
            
            // Generate answer based on question type and relevant sentences
            let answer = "";
            let confidence = 0.5;
            
            if (relevantSentences.length > 0) {
                // Use the most relevant sentence(s) to generate answer
                const topSentence = relevantSentences[0].text;
                
                switch (questionType) {
                    case "WHAT":
                        // Look for definitions or descriptions
                        answer = topSentence;
                        confidence = Math.min(0.95, 0.5 + relevantSentences[0].score * 0.1);
                        break;
                        
                    case "WHO":
                        // Look for person names
                        const personNames = topSentence.match(/\b[A-Z][a-z]+ [A-Z][a-z]+\b/g);
                        if (personNames) {
                            answer = personNames[0];
                            confidence = Math.min(0.95, 0.6 + relevantSentences[0].score * 0.1);
                        } else {
                            answer = topSentence;
                            confidence = Math.min(0.85, 0.4 + relevantSentences[0].score * 0.1);
                        }
                        break;
                        
                    case "WHEN":
                        // Look for dates or times
                        const dates = topSentence.match(/\b(\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}-\d{1,2}-\d{2,4}|\w+ \d{1,2}, \d{4}|\d{4})\b/g);
                        if (dates) {
                            answer = dates[0];
                            confidence = Math.min(0.95, 0.6 + relevantSentences[0].score * 0.1);
                        } else {
                            answer = topSentence;
                            confidence = Math.min(0.85, 0.4 + relevantSentences[0].score * 0.1);
                        }
                        break;
                        
                    case "WHERE":
                        // Look for locations
                        const locations = topSentence.match(/\b[A-Z][a-z]+ (?:City|State|Country|Province)|[A-Z][a-z]+, [A-Z]{2}\b/g);
                        if (locations) {
                            answer = locations[0];
                            confidence = Math.min(0.95, 0.6 + relevantSentences[0].score * 0.1);
                        } else {
                            answer = topSentence;
                            confidence = Math.min(0.85, 0.4 + relevantSentences[0].score * 0.1);
                        }
                        break;
                        
                    case "WHY":
                        // Look for causal relationships
                        const causalWords = ["because", "since", "due to", "as a result", "therefore", "consequently"];
                        let causalSentence = topSentence;
                        
                        for (const word of causalWords) {
                            if (topSentence.toLowerCase().includes(word)) {
                                causalSentence = topSentence;
                                break;
                            }
                        }
                        
                        answer = causalSentence;
                        confidence = Math.min(0.9, 0.4 + relevantSentences[0].score * 0.1);
                        break;
                        
                    case "HOW":
                        // Look for processes or methods
                        answer = topSentence;
                        confidence = Math.min(0.9, 0.4 + relevantSentences[0].score * 0.1);
                        break;
                        
                    case "WHICH":
                        // Look for options or choices
                        answer = topSentence;
                        confidence = Math.min(0.9, 0.4 + relevantSentences[0].score * 0.1);
                        break;
                        
                    case "BOOLEAN":
                        // Determine yes/no based on context
                        const affirmativeWords = ["yes", "true", "correct", "indeed", "certainly"];
                        const negativeWords = ["no", "false", "incorrect", "not", "never"];
                        
                        let isAffirmative = false;
                        let isNegative = false;
                        
                        affirmativeWords.forEach(word => {
                            if (topSentence.toLowerCase().includes(word)) isAffirmative = true;
                        });
                        
                        negativeWords.forEach(word => {
                            if (topSentence.toLowerCase().includes(word)) isNegative = true;
                        });
                        
                        if (isAffirmative && !isNegative) {
                            answer = "Yes";
                            confidence = Math.min(0.95, 0.6 + relevantSentences[0].score * 0.1);
                        } else if (isNegative && !isAffirmative) {
                            answer = "No";
                            confidence = Math.min(0.95, 0.6 + relevantSentences[0].score * 0.1);
                        } else {
                            answer = "Cannot be determined from the context";
                            confidence = Math.min(0.7, 0.3 + relevantSentences[0].score * 0.1);
                        }
                        break;
                        
                    default:
                        answer = topSentence;
                        confidence = Math.min(0.8, 0.3 + relevantSentences[0].score * 0.1);
                }
            } else {
                // No relevant sentences found
                answer = "The answer cannot be found in the provided context.";
                confidence = 0.2;
            }
            
            result += `Answer: "${answer}"\n\n`;
            result += `Confidence: ${(confidence * 100).toFixed(1)}%\n\n`;
            
            // Add supporting evidence
            if (relevantSentences.length > 0) {
                result += `Supporting Evidence:\n`;
                const evidenceCount = Math.min(3, relevantSentences.length);
                
                for (let i = 0; i < evidenceCount; i++) {
                    result += `${i + 1}. "${relevantSentences[i].text}" (Relevance: ${relevantSentences[i].score})\n`;
                }
            }
            
            // Add model information
            result += `\nModel Information:\n`;
            result += `- QA Model: Simulated BERT-based Question Answering\n`;
            result += `- Context Length: ${context.length} characters\n`;
            result += `- Processing Time: ${(Math.random() * 150 + 50).toFixed(1)}ms\n`;
            
            return result;
        } catch (error) {
            return "Error answering question. Please check your input.";
        }
    }
},

{
    // Pattern to simulate text classification
    pattern: /classify (.+) into (.+) categories/i,
    response: (match) => {
        try {
            const text = match[1];
            const categoriesStr = match[2];
            
            // Parse categories
            const categories = categoriesStr.split(',').map(cat => cat.trim());
            
            if (categories.length < 2) return "Please provide at least 2 categories";
            
            // Simulate text classification
            let result = `Text Classification:\n\n`;
            result += `Text: "${text}"\n`;
            result += `Categories: ${categories.join(', ')}\n\n`;
            
            // Extract features from text
            const words = text.toLowerCase().split(/\s+/);
            const wordFreq = {};
            
            words.forEach(word => {
                const cleanWord = word.replace(/[^\w]/g, '');
                if (cleanWord.length > 2) {
                    wordFreq[cleanWord] = (wordFreq[cleanWord] || 0) + 1;
                }
            });
            
            // Calculate category scores based on keyword matching
            const categoryScores = {};
            
            // Define category keywords
            const categoryKeywords = {
                "Technology": ["computer", "software", "hardware", "internet", "digital", "data", "algorithm", "programming", "code", "tech", "ai", "artificial", "intelligence", "machine", "learning", "automation", "cloud", "cybersecurity"],
                "Health": ["health", "medical", "patient", "doctor", "hospital", "medicine", "treatment", "disease", "symptom", "diagnosis", "therapy", "wellness", "nutrition", "exercise", "fitness", "mental", "physical"],
                "Finance": ["money", "financial", "bank", "investment", "stock", "market", "economy", "business", "finance", "loan", "credit", "debt", "income", "expense", "profit", "revenue", "economic"],
                "Education": ["education", "school", "university", "student", "teacher", "learn", "study", "course", "degree", "knowledge", "academic", "classroom", "curriculum", "pedagogy", "assessment", "learning"],
                "Entertainment": ["movie", "film", "music", "song", "game", "play", "show", "tv", "television", "actor", "actress", "director", "entertainment", "fun", "leisure", "recreation"],
                "Sports": ["sport", "game", "player", "team", "coach", "match", "competition", "tournament", "championship", "athlete", "fitness", "exercise", "training", "win", "lose", "score"],
                "Politics": ["politics", "government", "election", "vote", "policy", "law", "democracy", "republic", "president", "senator", "congress", "political", "party", "campaign", "bill"],
                "Science": ["science", "research", "study", "experiment", "theory", "hypothesis", "scientist", "laboratory", "discovery", "innovation", "analysis", "method", "evidence", "conclusion"],
                "Environment": ["environment", "climate", "weather", "nature", "ecosystem", "pollution", "conservation", "sustainability", "renewable", "energy", "green", "planet", "earth", "global", "warming"],
                "Food": ["food", "restaurant", "recipe", "cook", "meal", "dish", "ingredient", "taste", "flavor", "cuisine", "chef", "kitchen", "eat", "drink", "nutrition", "diet"]
            };
            
            // Calculate scores for each category
            categories.forEach(category => {
                categoryScores[category] = 0;
                
                // Check if we have keywords for this category
                const keywords = categoryKeywords[category] || [category.toLowerCase()];
                
                // Calculate score based on keyword matches
                keywords.forEach(keyword => {
                    if (wordFreq[keyword]) {
                        categoryScores[category] += wordFreq[keyword];
                    }
                });
                
                // Add some randomness to simulate more complex classification
                categoryScores[category] += Math.random() * 2;
            });
            
            // Normalize scores
            const totalScore = Object.values(categoryScores).reduce((a, b) => a + b, 0);
            Object.keys(categoryScores).forEach(category => {
                categoryScores[category] /= totalScore;
            });
            
            // Sort categories by score
            const sortedCategories = Object.entries(categoryScores)
                .sort((a, b) => b[1] - a[1]);
            
            // Display classification results
            result += `Classification Results:\n\n`;
            
            sortedCategories.forEach(([category, score], index) => {
                const percentage = (score * 100).toFixed(1);
                const label = index === 0 ? "Predicted Category" : "Alternative";
                result += `${label}: ${category} (${percentage}% confidence)\n`;
            });
            
            // Add feature importance
            result += `\nKey Features:\n`;
            
            const topCategory = sortedCategories[0][0];
            const keywords = categoryKeywords[topCategory] || [topCategory.toLowerCase()];
            
            const matchedKeywords = keywords
                .filter(keyword => wordFreq[keyword])
                .sort((a, b) => wordFreq[b] - wordFreq[a])
                .slice(0, 5);
            
            if (matchedKeywords.length > 0) {
                matchedKeywords.forEach(keyword => {
                    result += `- ${keyword}: ${wordFreq[keyword]} occurrences\n`;
                });
            } else {
                result += `- No specific keywords found for the predicted category\n`;
            }
            
            // Add model information
            result += `\nModel Information:\n`;
            result += `- Classification Model: Simulated Naive Bayes Classifier\n`;
            result += `- Feature Extraction: Bag of Words with TF-IDF\n`;
            result += `- Number of Categories: ${categories.length}\n`;
            result += `- Processing Time: ${(Math.random() * 100 + 50).toFixed(1)}ms\n`;
            
            return result;
        } catch (error) {
            return "Error classifying text. Please check your input.";
        }
    }
},

{
    // Pattern to simulate text similarity
    pattern: /calculate similarity between (.+) and (.+)/i,
    response: (match) => {
        try {
            const text1 = match[1];
            const text2 = match[2];
            
            // Simulate text similarity calculation
            let result = `Text Similarity Analysis:\n\n`;
            result += `Text 1: "${text1}"\n`;
            result += `Text 2: "${text2}"\n\n`;
            
            // Preprocess texts
            const preprocess = (text) => {
                return text.toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length > 2);
            };
            
            const words1 = preprocess(text1);
            const words2 = preprocess(text2);
            
            // Calculate Jaccard similarity
            const set1 = new Set(words1);
            const set2 = new Set(words2);
            
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            
            const jaccardSimilarity = intersection.size / union.size;
            
            // Calculate cosine similarity
            const allWords = new Set([...words1, ...words2]);
            const vector1 = [];
            const vector2 = [];
            
            allWords.forEach(word => {
                vector1.push(words1.filter(w => w === word).length);
                vector2.push(words2.filter(w => w === word).length);
            });
            
            // Calculate dot product
            let dotProduct = 0;
            for (let i = 0; i < vector1.length; i++) {
                dotProduct += vector1[i] * vector2[i];
            }
            
            // Calculate magnitudes
            const magnitude1 = Math.sqrt(vector1.reduce((sum, val) => sum + val * val, 0));
            const magnitude2 = Math.sqrt(vector2.reduce((sum, val) => sum + val * val, 0));
            
            // Calculate cosine similarity
            const cosineSimilarity = magnitude1 && magnitude2 ? dotProduct / (magnitude1 * magnitude2) : 0;
            
            // Calculate Levenshtein distance (simplified)
            const levenshteinDistance = (str1, str2) => {
                const matrix = [];
                
                for (let i = 0; i <= str2.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= str1.length; j++) {
                    matrix[0][j] = j;
                }
                
                for (let i = 1; i <= str2.length; i++) {
                    for (let j = 1; j <= str1.length; j++) {
                        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                
                return matrix[str2.length][str1.length];
            };
            
            const editDistance = levenshteinDistance(text1, text2);
            const maxLength = Math.max(text1.length, text2.length);
            const editSimilarity = 1 - (editDistance / maxLength);
            
            // Calculate overall similarity (weighted average)
            const overallSimilarity = (
                jaccardSimilarity * 0.3 +
                cosineSimilarity * 0.5 +
                editSimilarity * 0.2
            );
            
            // Display results
            result += `Similarity Metrics:\n\n`;
            result += `Jaccard Similarity: ${(jaccardSimilarity * 100).toFixed(1)}%\n`;
            result += `Cosine Similarity: ${(cosineSimilarity * 100).toFixed(1)}%\n`;
            result += `Edit Distance Similarity: ${(editSimilarity * 100).toFixed(1)}%\n`;
            result += `Overall Similarity: ${(overallSimilarity * 100).toFixed(1)}%\n\n`;
            
            // Add interpretation
            result += `Interpretation:\n`;
            
            if (overallSimilarity > 0.8) {
                result += `- The texts are highly similar in content and structure.\n`;
            } else if (overallSimilarity > 0.6) {
                result += `- The texts share significant content but have notable differences.\n`;
            } else if (overallSimilarity > 0.4) {
                result += `- The texts have some common elements but are substantially different.\n`;
            } else {
                result += `- The texts are largely dissimilar in content.\n`;
            }
            
            // Add shared words
            result += `\nShared Words (${intersection.size}):\n`;
            
            if (intersection.size > 0) {
                const sharedWords = [...intersection].slice(0, 10);
                result += sharedWords.join(', ');
                
                if (intersection.size > 10) {
                    result += ` and ${intersection.size - 10} more...`;
                }
            } else {
                result += `No significant shared words found.`;
            }
            
            // Add model information
            result += `\n\nModel Information:\n`;
            result += `- Similarity Algorithm: Hybrid (Jaccard + Cosine + Edit Distance)\n`;
            result += `- Text 1 Length: ${text1.length} characters, ${words1.length} words\n`;
            result += `- Text 2 Length: ${text2.length} characters, ${words2.length} words\n`;
            result += `- Processing Time: ${(Math.random() * 100 + 50).toFixed(1)}ms\n`;
            
            return result;
        } catch (error) {
            return "Error calculating similarity. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from uploaded images
    pattern: /solve math from image (.+)/i,
    response: (match) => {
        try {
            const imageDescription = match[1];
            
            let result = `Math Problem Solver - Image Analysis:\n\n`;
            result += `Image Description: "${imageDescription}"\n\n`;
            
            // Simulate image processing and math detection
            result += `Image Processing:\n`;
            result += `- Preprocessing: Noise reduction, contrast enhancement\n`;
            result += `- Text Detection: OCR applied to identify mathematical expressions\n`;
            result += `- Structure Analysis: Layout and spatial relationships identified\n\n`;
            
            // Determine math problem type based on image description
            const problemType = detectMathProblemType(imageDescription);
            
            result += `Detected Problem Type: ${problemType.type}\n\n`;
            
            // Extract and solve the math problem
            const solution = solveMathProblem(problemType);
            
            result += `Problem Statement:\n${solution.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            solution.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${solution.answer}\n\n`;
            
            // Add confidence metrics
            result += `Analysis Confidence:\n`;
            result += `- Text Recognition: ${(Math.random() * 0.15 + 0.85).toFixed(2)}\n`;
            result += `- Problem Classification: ${(Math.random() * 0.1 + 0.9).toFixed(2)}\n`;
            result += `- Solution Accuracy: ${(Math.random() * 0.05 + 0.95).toFixed(2)}\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Simulated Math OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Processing Time: ${(Math.random() * 2 + 1).toFixed(2)} seconds\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from image. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from camera input
    pattern: /solve math from camera/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Front/Back camera selected based on device orientation\n`;
            result += `- Image Capture: 1920x1080 resolution, auto-focus enabled\n`;
            result += `- Real-time Processing: Edge detection and region of interest identification\n\n`;
            
            // Simulate detection of math problems in camera view
            result += `Detection Results:\n`;
            result += `- Mathematical Expressions Found: 2\n`;
            result += `- Handwritten Text Detected: Yes\n`;
            result += `- Printed Text Detected: Yes\n`;
            result += `- Diagrams/Graphs Detected: No\n\n`;
            
            // Simulate solving the first detected problem
            const problemTypes = [
                {
                    type: "Linear Equation",
                    problem: "Solve for x: 3x + 5 = 17",
                    steps: [
                        "Subtract 5 from both sides: 3x = 12",
                        "Divide both sides by 3: x = 4"
                    ],
                    answer: "x = 4"
                },
                {
                    type: "Quadratic Equation",
                    problem: "Solve: x² - 5x + 6 = 0",
                    steps: [
                        "Factor the quadratic: (x - 2)(x - 3) = 0",
                        "Set each factor equal to zero: x - 2 = 0 or x - 3 = 0",
                        "Solve for x: x = 2 or x = 3"
                    ],
                    answer: "x = 2 or x = 3"
                },
                {
                    type: "Derivative",
                    problem: "Find the derivative of f(x) = 3x² + 2x - 5",
                    steps: [
                        "Apply the power rule to each term",
                        "Derivative of 3x² is 6x",
                        "Derivative of 2x is 2",
                        "Derivative of -5 is 0",
                        "Combine the terms: f'(x) = 6x + 2"
                    ],
                    answer: "f'(x) = 6x + 2"
                },
                {
                    type: "Integral",
                    problem: "Find the integral of ∫(2x + 3)dx",
                    steps: [
                        "Integrate term by term",
                        "Integral of 2x is x²",
                        "Integral of 3 is 3x",
                        "Add the constant of integration: x² + 3x + C"
                    ],
                    answer: "x² + 3x + C"
                }
            ];
            
            const selectedProblem = problemTypes[Math.floor(Math.random() * problemTypes.length)];
            
            result += `Solving First Detected Problem:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features
            result += `Camera Features:\n`;
            result += `- Real-time Preview: Mathematical expressions highlighted in camera view\n`;
            result += `- Auto-capture: Automatically captures image when steady\n`;
            result += `- Multi-angle Support: Rotate device for better angle detection\n`;
            result += `- Zoom Control: Pinch to zoom for detailed expressions\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Real-time Math OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.5 + 0.3).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve geometry problems from images
    pattern: /solve geometry from image (.+)/i,
    response: (match) => {
        try {
            const imageDescription = match[1];
            
            let result = `Geometry Problem Solver - Image Analysis:\n\n`;
            result += `Image Description: "${imageDescription}"\n\n`;
            
            // Simulate image processing for geometry
            result += `Image Processing:\n`;
            result += `- Shape Detection: Identifying geometric shapes and figures\n`;
            result += `- Angle Measurement: Calculating angles between lines\n`;
            result += `- Length Calculation: Measuring distances between points\n`;
            result += `- Area Calculation: Computing areas of enclosed regions\n\n`;
            
            // Determine geometry problem type
            const geometryTypes = [
                "Triangle Problem",
                "Circle Problem",
                "Rectangle/Square Problem",
                "Polygon Problem",
                "Coordinate Geometry Problem"
            ];
            
            const selectedType = geometryTypes[Math.floor(Math.random() * geometryTypes.length)];
            
            result += `Detected Geometry Type: ${selectedType}\n\n`;
            
            // Generate and solve the geometry problem
            const solution = solveGeometryProblem(selectedType);
            
            result += `Problem Statement:\n${solution.problem}\n\n`;
            result += `Given Information:\n`;
            
            solution.given.forEach((item, index) => {
                result += `${index + 1}. ${item}\n`;
            });
            
            result += `\nSolution Steps:\n`;
            
            solution.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${solution.answer}\n\n`;
            
            // Add visualization information
            result += `Visualization:\n`;
            result += `- Interactive Diagram: Generated based on image analysis\n`;
            result += `- Measurements: All lengths and angles labeled\n`;
            result += `- Construction Lines: Auxiliary lines shown in dashed format\n`;
            result += `- Highlighted Regions: Areas of interest highlighted\n\n`;
            
            // Add confidence metrics
            result += `Analysis Confidence:\n`;
            result += `- Shape Recognition: ${(Math.random() * 0.15 + 0.85).toFixed(2)}\n`;
            result += `- Measurement Accuracy: ${(Math.random() * 0.1 + 0.9).toFixed(2)}\n`;
            result += `- Solution Correctness: ${(Math.random() * 0.05 + 0.95).toFixed(2)}\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Geometry-specific OCR\n`;
            result += `- Solver: Geometry Engine with Theorem Database\n`;
            result += `- Processing Time: ${(Math.random() * 3 + 2).toFixed(2)} seconds\n`;
            
            return result;
        } catch (error) {
            return "Error solving geometry from image. Please check your input.";
        }
    }
},

{
    // Pattern to solve calculus problems from images
    pattern: /solve calculus from image (.+)/i,
    response: (match) => {
        try {
            const imageDescription = match[1];
            
            let result = `Calculus Problem Solver - Image Analysis:\n\n`;
            result += `Image Description: "${imageDescription}"\n\n`;
            
            // Simulate image processing for calculus
            result += `Image Processing:\n`;
            result += `- Function Recognition: Identifying mathematical functions and expressions\n`;
            result += `- Graph Analysis: Extracting data points and trends from graphs\n`;
            result += `- Symbol Detection: Recognizing calculus symbols and notation\n`;
            result += `- Structure Analysis: Understanding the layout of complex expressions\n\n`;
            
            // Determine calculus problem type
            const calculusTypes = [
                "Derivative",
                "Integral",
                "Limit",
                "Series",
                "Differential Equation",
                "Multivariable Calculus"
            ];
            
            const selectedType = calculusTypes[Math.floor(Math.random() * calculusTypes.length)];
            
            result += `Detected Calculus Type: ${selectedType}\n\n`;
            
            // Generate and solve the calculus problem
            const solution = solveCalculusProblem(selectedType);
            
            result += `Problem Statement:\n${solution.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            solution.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${solution.answer}\n\n`;
            
            // Add graph visualization if applicable
            if (selectedType === "Derivative" || selectedType === "Integral") {
                result += `Graph Visualization:\n`;
                result += `- Function Plot: Original function graphed in blue\n`;
                result += `- Derivative/Integral Plot: Result graphed in red\n`;
                result += `- Critical Points: Marked with special symbols\n`;
                result += `- Interactive Features: Zoom, pan, and point inspection\n\n`;
            }
            
            // Add confidence metrics
            result += `Analysis Confidence:\n`;
            result += `- Symbol Recognition: ${(Math.random() * 0.15 + 0.85).toFixed(2)}\n`;
            result += `- Expression Parsing: ${(Math.random() * 0.1 + 0.9).toFixed(2)}\n`;
            result += `- Solution Correctness: ${(Math.random() * 0.05 + 0.95).toFixed(2)}\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Calculus-specific OCR\n`;
            result += `- Solver: Advanced Calculus Engine\n`;
            result += `- Processing Time: ${(Math.random() * 4 + 2).toFixed(2)} seconds\n`;
            
            return result;
        } catch (error) {
            return "Error solving calculus from image. Please check your input.";
        }
    }
},

{
    // Pattern to solve statistics problems from images
    pattern: /solve statistics from image (.+)/i,
    response: (match) => {
        try {
            const imageDescription = match[1];
            
            let result = `Statistics Problem Solver - Image Analysis:\n\n`;
            result += `Image Description: "${imageDescription}"\n\n`;
            
            // Simulate image processing for statistics
            result += `Image Processing:\n`;
            result += `- Data Extraction: Identifying numerical data and tables\n`;
            result += `- Graph Analysis: Extracting data from charts and plots\n`;
            result += `- Pattern Recognition: Identifying statistical patterns\n`;
            result += `- Distribution Analysis: Determining data distribution types\n\n`;
            
            // Determine statistics problem type
            const statisticsTypes = [
                "Descriptive Statistics",
                "Probability",
                "Hypothesis Testing",
                "Regression Analysis",
                "Confidence Interval",
                "ANOVA"
            ];
            
            const selectedType = statisticsTypes[Math.floor(Math.random() * statisticsTypes.length)];
            
            result += `Detected Statistics Type: ${selectedType}\n\n`;
            
            // Generate and solve the statistics problem
            const solution = solveStatisticsProblem(selectedType);
            
            result += `Problem Statement:\n${solution.problem}\n\n`;
            result += `Given Data:\n`;
            
            if (solution.data) {
                solution.data.forEach((item, index) => {
                    result += `${index + 1}. ${item}\n`;
                });
            }
            
            result += `\nSolution Steps:\n`;
            
            solution.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${solution.answer}\n\n`;
            
            // Add data visualization if applicable
            if (selectedType === "Descriptive Statistics" || selectedType === "Regression Analysis") {
                result += `Data Visualization:\n`;
                result += `- Histogram: Showing data distribution\n`;
                result += `- Box Plot: Displaying quartiles and outliers\n`;
                result += `- Scatter Plot: Showing relationships between variables\n`;
                result += `- Interactive Features: Data point inspection and filtering\n\n`;
            }
            
            // Add confidence metrics
            result += `Analysis Confidence:\n`;
            result += `- Data Extraction: ${(Math.random() * 0.15 + 0.85).toFixed(2)}\n`;
            result += `- Pattern Recognition: ${(Math.random() * 0.1 + 0.9).toFixed(2)}\n`;
            result += `- Solution Correctness: ${(Math.random() * 0.05 + 0.95).toFixed(2)}\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Statistics-specific OCR\n`;
            result += `- Solver: Advanced Statistics Engine\n`;
            result += `- Processing Time: ${(Math.random() * 3 + 2).toFixed(2)} seconds\n`;
            
            return result;
        } catch (error) {
            return "Error solving statistics from image. Please check your input.";
        }
    }
},

{
    // Pattern to solve word problems from images
    pattern: /solve word problem from image (.+)/i,
    response: (match) => {
        try {
            const imageDescription = match[1];
            
            let result = `Word Problem Solver - Image Analysis:\n\n`;
            result += `Image Description: "${imageDescription}"\n\n`;
            
            // Simulate image processing for word problems
            result += `Image Processing:\n`;
            result += `- Text Extraction: OCR applied to extract problem text\n`;
            result += `- Context Analysis: Understanding the scenario and context\n`;
            result += `- Entity Recognition: Identifying people, objects, and quantities\n`;
            result += `- Relationship Mapping: Understanding relationships between entities\n\n`;
            
            // Determine word problem type
            const wordProblemTypes = [
                "Distance/Rate/Time Problem",
                "Mixture Problem",
                "Work Problem",
                "Age Problem",
                "Finance Problem",
                "Geometry Word Problem"
            ];
            
            const selectedType = wordProblemTypes[Math.floor(Math.random() * wordProblemTypes.length)];
            
            result += `Detected Problem Type: ${selectedType}\n\n`;
            
            // Generate and solve the word problem
            const solution = solveWordProblem(selectedType);
            
            result += `Problem Statement:\n${solution.problem}\n\n`;
            result += `Solution Approach:\n`;
            result += `${solution.approach}\n\n`;
            
            result += `Solution Steps:\n`;
            
            solution.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${solution.answer}\n\n`;
            
            // Add visualization if applicable
            result += `Visualization:\n`;
            result += `- Scenario Diagram: Illustrating the problem scenario\n`;
            result += `- Variable Mapping: Showing what each variable represents\n`;
            result += `- Equation Setup: Displaying the mathematical model\n`;
            result += `- Solution Graph: Showing the solution visually if applicable\n\n`;
            
            // Add confidence metrics
            result += `Analysis Confidence:\n`;
            result += `- Text Recognition: ${(Math.random() * 0.15 + 0.85).toFixed(2)}\n`;
            result += `- Context Understanding: ${(Math.random() * 0.2 + 0.8).toFixed(2)}\n`;
            result += `- Solution Correctness: ${(Math.random() * 0.1 + 0.9).toFixed(2)}\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Advanced OCR with NLP\n`;
            result += `- Solver: Word Problem Engine with Context Analysis\n`;
            result += `- Processing Time: ${(Math.random() * 4 + 3).toFixed(2)} seconds\n`;
            
            return result;
        } catch (error) {
            return "Error solving word problem from image. Please check your input.";
        }
    }
},

{
    // Pattern to solve matrix problems from images
    pattern: /solve matrix problem from image (.+)/i,
    response: (match) => {
        try {
            const imageDescription = match[1];
            
            let result = `Matrix Problem Solver - Image Analysis:\n\n`;
            result += `Image Description: "${imageDescription}"\n\n`;
            
            // Simulate image processing for matrix problems
            result += `Image Processing:\n`;
            result += `- Matrix Detection: Identifying matrix structures in the image\n`;
            result += `- Element Extraction: Reading individual matrix elements\n`;
            result += `- Operation Recognition: Identifying matrix operations\n`;
            result += `- Size Determination: Determining matrix dimensions\n\n`;
            
            // Determine matrix problem type
            const matrixTypes = [
                "Matrix Addition/Subtraction",
                "Matrix Multiplication",
                "Matrix Inverse",
                "Matrix Determinant",
                "Eigenvalues/Eigenvectors",
                "System of Linear Equations"
            ];
            
            const selectedType = matrixTypes[Math.floor(Math.random() * matrixTypes.length)];
            
            result += `Detected Matrix Type: ${selectedType}\n\n`;
            
            // Generate and solve the matrix problem
            const solution = solveMatrixProblem(selectedType);
            
            result += `Problem Statement:\n${solution.problem}\n\n`;
            
            if (solution.matrices) {
                result += `Given Matrices:\n`;
                solution.matrices.forEach((matrix, index) => {
                    result += `Matrix ${String.fromCharCode(65 + index)}:\n`;
                    matrix.forEach(row => {
                        result += `[ ${row.join(' ')} ]\n`;
                    });
                    result += `\n`;
                });
            }
            
            result += `Solution Steps:\n`;
            
            solution.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${solution.answer}\n\n`;
            
            // Add matrix visualization
            result += `Matrix Visualization:\n`;
            result += `- Interactive Matrix Display: Color-coded elements\n`;
            result += `- Step-by-Step Transformation: Showing each operation\n`;
            result += `- Highlighted Operations: Emphasizing current operation\n`;
            result += `- Result Comparison: Side-by-side before and after\n\n`;
            
            // Add confidence metrics
            result += `Analysis Confidence:\n`;
            result += `- Matrix Detection: ${(Math.random() * 0.1 + 0.9).toFixed(2)}\n`;
            result += `- Element Recognition: ${(Math.random() * 0.15 + 0.85).toFixed(2)}\n`;
            result += `- Solution Correctness: ${(Math.random() * 0.05 + 0.95).toFixed(2)}\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Matrix-specific OCR\n`;
            result += `- Solver: Linear Algebra Engine\n`;
            result += `- Processing Time: ${(Math.random() * 2 + 1).toFixed(2)} seconds\n`;
            
            return result;
        } catch (error) {
            return "Error solving matrix problem from image. Please check your input.";
        }
    }
},

{
    // Pattern to solve trigonometry problems from images
    pattern: /solve trigonometry from image (.+)/i,
    response: (match) => {
        try {
            const imageDescription = match[1];
            
            let result = `Trigonometry Problem Solver - Image Analysis:\n\n`;
            result += `Image Description: "${imageDescription}"\n\n`;
            
            // Simulate image processing for trigonometry
            result += `Image Processing:\n`;
            result += `- Triangle Detection: Identifying triangles in the image\n`;
            result += `- Angle Measurement: Calculating angles between sides\n`;
            result += `- Side Length Calculation: Measuring distances\n`;
            result += `- Function Recognition: Identifying trigonometric functions\n\n`;
            
            // Determine trigonometry problem type
            const trigTypes = [
                "Right Triangle Problem",
                "Law of Sines Problem",
                "Law of Cosines Problem",
                "Trigonometric Identities",
                "Trigonometric Equations",
                "Unit Circle Problem"
            ];
            
            const selectedType = trigTypes[Math.floor(Math.random() * trigTypes.length)];
            
            result += `Detected Trigonometry Type: ${selectedType}\n\n`;
            
            // Generate and solve the trigonometry problem
            const solution = solveTrigonometryProblem(selectedType);
            
            result += `Problem Statement:\n${solution.problem}\n\n`;
            
            if (solution.given) {
                result += `Given Information:\n`;
                solution.given.forEach((item, index) => {
                    result += `${index + 1}. ${item}\n`;
                });
                result += `\n`;
            }
            
            result += `Solution Steps:\n`;
            
            solution.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${solution.answer}\n\n`;
            
            // Add triangle visualization if applicable
            if (selectedType.includes("Triangle") || selectedType.includes("Law")) {
                result += `Triangle Visualization:\n`;
                result += `- Interactive Triangle: Labeled with angles and sides\n`;
                result += `- Angle Highlighting: Emphasizing relevant angles\n`;
                result += `- Side Measurements: Showing all side lengths\n`;
                result += `- Calculation Overlay: Displaying formulas and calculations\n\n`;
            }
            
            // Add unit circle visualization if applicable
            if (selectedType === "Unit Circle Problem") {
                result += `Unit Circle Visualization:\n`;
                result += `- Interactive Unit Circle: With angle measurements\n`;
                result += `- Coordinate Display: Showing (x,y) coordinates\n`;
                result += `- Trigonometric Functions: Displaying sin, cos, tan values\n`;
                result += `- Angle Conversion: Between degrees and radians\n\n`;
            }
            
            // Add confidence metrics
            result += `Analysis Confidence:\n`;
            result += `- Shape Detection: ${(Math.random() * 0.15 + 0.85).toFixed(2)}\n`;
            result += `- Angle Measurement: ${(Math.random() * 0.1 + 0.9).toFixed(2)}\n`;
            result += `- Solution Correctness: ${(Math.random() * 0.05 + 0.95).toFixed(2)}\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Trigonometry-specific OCR\n`;
            result += `- Solver: Trigonometry Engine\n`;
            result += `- Processing Time: ${(Math.random() * 2 + 1).toFixed(2)} seconds\n`;
            
            return result;
        } catch (error) {
            return "Error solving trigonometry from image. Please check your input.";
        }
    }
},

{
    // Pattern to solve algebra problems from camera
    pattern: /solve algebra from camera/i,
    response: () => {
        try {
            let result = `Algebra Problem Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for algebra
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for text recognition\n`;
            result += `- Auto-focus: Adjusted for clear text capture\n`;
            result += `- Lighting Compensation: Adapting to different lighting conditions\n`;
            result += `- Real-time Preview: Highlighting algebraic expressions\n\n`;
            
            // Simulate detection of algebra problems
            result += `Detection Results:\n`;
            result += `- Algebraic Expressions Found: 3\n`;
            result += `- Equations Detected: 2\n`;
            result += `- Inequalities Detected: 1\n`;
            result += `- Word Problems Detected: 0\n\n`;
            
            // Select a random algebra problem type
            const algebraTypes = [
                {
                    type: "Linear Equation",
                    problem: "Solve for x: 2(x - 3) + 5 = 17",
                    steps: [
                        "Distribute the 2: 2x - 6 + 5 = 17",
                        "Combine like terms: 2x - 1 = 17",
                        "Add 1 to both sides: 2x = 18",
                        "Divide both sides by 2: x = 9"
                    ],
                    answer: "x = 9"
                },
                {
                    type: "Quadratic Equation",
                    problem: "Solve: 2x² - 8x + 6 = 0",
                    steps: [
                        "Divide by 2 to simplify: x² - 4x + 3 = 0",
                        "Factor the quadratic: (x - 1)(x - 3) = 0",
                        "Set each factor equal to zero: x - 1 = 0 or x - 3 = 0",
                        "Solve for x: x = 1 or x = 3"
                    ],
                    answer: "x = 1 or x = 3"
                },
                {
                    type: "System of Equations",
                    problem: "Solve the system: 2x + 3y = 12, x - y = 1",
                    steps: [
                        "From the second equation: x = y + 1",
                        "Substitute into the first equation: 2(y + 1) + 3y = 12",
                        "Simplify: 2y + 2 + 3y = 12",
                        "Combine like terms: 5y + 2 = 12",
                        "Subtract 2: 5y = 10",
                        "Divide by 5: y = 2",
                        "Substitute back: x = 2 + 1 = 3"
                    ],
                    answer: "x = 3, y = 2"
                },
                {
                    type: "Inequality",
                    problem: "Solve: 3x - 5 > 10",
                    steps: [
                        "Add 5 to both sides: 3x > 15",
                        "Divide both sides by 3: x > 5"
                    ],
                    answer: "x > 5"
                }
            ];
            
            const selectedProblem = algebraTypes[Math.floor(Math.random() * algebraTypes.length)];
            
            result += `Solving First Detected Problem:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features for algebra
            result += `Camera Features for Algebra:\n`;
            result += `- Expression Highlighting: Algebraic expressions highlighted in real-time\n`;
            result += `- Variable Tracking: Variables tracked and color-coded\n`;
            result += `- Step-by-Step Solution: Solution displayed as it's being solved\n`;
            result += `- Interactive Graph: Graphical representation when applicable\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Algebra-specific OCR\n`;
            result += `- Solver: Advanced Algebra Engine\n`;
            result += `- Latency: ${(Math.random() * 0.5 + 0.3).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving algebra from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve graph problems from camera
    pattern: /solve graph from camera/i,
    response: () => {
        try {
            let result = `Graph Problem Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for graphs
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for graph recognition\n`;
            result += `- Edge Detection: Identifying axes, lines, and curves\n`;
            result += `- Grid Detection: Recognizing coordinate grids\n`;
            result += `- Real-time Preview: Highlighting graph elements\n\n`;
            
            // Simulate detection of graph elements
            result += `Detection Results:\n`;
            result += `- Coordinate System Detected: Cartesian\n`;
            result += `- Functions/Relations Found: 2\n`;
            result += `- Data Points Identified: 15\n`;
            result += `- Special Points Detected: 3 (intercepts, maxima/minima)\n\n`;
            
            // Select a random graph problem type
            const graphTypes = [
                {
                    type: "Linear Function",
                    problem: "Find the equation of the line passing through points (2, 3) and (5, 9)",
                    steps: [
                        "Calculate the slope: m = (9 - 3) / (5 - 2) = 6 / 3 = 2",
                        "Use point-slope form: y - 3 = 2(x - 2)",
                        "Simplify: y - 3 = 2x - 4",
                        "Solve for y: y = 2x - 1"
                    ],
                    answer: "y = 2x - 1"
                },
                {
                    type: "Quadratic Function",
                    problem: "Find the equation of the parabola with vertex at (2, 3) and passing through (4, 7)",
                    steps: [
                        "Use vertex form: y = a(x - 2)² + 3",
                        "Substitute the point (4, 7): 7 = a(4 - 2)² + 3",
                        "Simplify: 7 = a(2)² + 3",
                        "Solve for a: 7 = 4a + 3, so 4a = 4, a = 1",
                        "Write the equation: y = (x - 2)² + 3",
                        "Expand: y = x² - 4x + 4 + 3 = x² - 4x + 7"
                    ],
                    answer: "y = x² - 4x + 7"
                },
                {
                    type: "Exponential Function",
                    problem: "Find the equation of the exponential function passing through (0, 2) and (3, 16)",
                    steps: [
                        "Use exponential form: y = ab^x",
                        "Substitute (0, 2): 2 = ab^0 = a(1), so a = 2",
                        "Substitute (3, 16): 16 = 2b^3",
                        "Solve for b: b^3 = 8, so b = 2",
                        "Write the equation: y = 2(2^x)"
                    ],
                    answer: "y = 2(2^x)"
                },
                {
                    type: "Data Analysis",
                    problem: "Find the line of best fit for the data points: (1, 2), (2, 3), (3, 5), (4, 4), (5, 6)",
                    steps: [
                        "Calculate the means: x̄ = (1+2+3+4+5)/5 = 3, ȳ = (2+3+5+4+6)/5 = 4",
                        "Calculate the slope: m = Σ((x - x̄)(y - ȳ)) / Σ((x - x̄)²)",
                        "Numerator: (1-3)(2-4) + (2-3)(3-4) + (3-3)(5-4) + (4-3)(4-4) + (5-3)(6-4) = 4 + 1 + 0 + 0 + 4 = 9",
                        "Denominator: (1-3)² + (2-3)² + (3-3)² + (4-3)² + (5-3)² = 4 + 1 + 0 + 1 + 4 = 10",
                        "Slope: m = 9/10 = 0.9",
                        "Calculate the y-intercept: b = ȳ - mx̄ = 4 - 0.9(3) = 4 - 2.7 = 1.3",
                        "Equation: y = 0.9x + 1.3"
                    ],
                    answer: "y = 0.9x + 1.3"
                }
            ];
            
            const selectedProblem = graphTypes[Math.floor(Math.random() * graphTypes.length)];
            
            result += `Solving First Detected Graph Problem:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features for graphs
            result += `Camera Features for Graphs:\n`;
            result += `- Graph Recognition: Identifying different types of graphs\n`;
            result += `- Point Extraction: Extracting data points from plotted graphs\n`;
            result += `- Axis Scaling: Determining scale and units\n`;
            result += `- Interactive Analysis: Touch points to see coordinates\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Graph: Displayed with camera image overlay\n`;
            result += `- Solution Graph: Showing the calculated function/equation\n`;
            result += `- Point Verification: Highlighting points used in calculation\n`;
            result += `- Error Analysis: Showing residuals for regression problems\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Graph-specific OCR\n`;
            result += `- Solver: Advanced Graph Analysis Engine\n`;
            result += `- Latency: ${(Math.random() * 0.7 + 0.5).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving graph from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve geometry problems from camera
    pattern: /solve geometry from camera/i,
    response: () => {
        try {
            let result = `Geometry Problem Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for geometry
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for shape recognition\n`;
            result += `- Shape Detection: Identifying geometric shapes and figures\n`;
            result += `- Angle Measurement: Calculating angles between lines\n`;
            result += `- Real-time Preview: Highlighting geometric elements\n\n`;
            
            // Simulate detection of geometric elements
            result += `Detection Results:\n`;
            result += `- Triangles Detected: 2\n`;
            result += `- Circles Detected: 1\n`;
            result += `- Rectangles Detected: 1\n`;
            result += `- Lines/Angles Detected: 8\n\n`;
            
            // Select a random geometry problem type
            const geometryTypes = [
                {
                    type: "Triangle Area",
                    problem: "Find the area of a triangle with base 8 cm and height 5 cm",
                    steps: [
                        "Use the formula for the area of a triangle: A = (1/2)bh",
                        "Substitute the given values: A = (1/2)(8)(5)",
                        "Calculate: A = (1/2)(40) = 20"
                    ],
                    answer: "20 cm²"
                },
                {
                    type: "Circle Circumference",
                    problem: "Find the circumference of a circle with radius 6 cm",
                    steps: [
                        "Use the formula for circumference: C = 2πr",
                        "Substitute the given radius: C = 2π(6)",
                        "Calculate: C = 12π ≈ 37.7 cm"
                    ],
                    answer: "12π cm or approximately 37.7 cm"
                },
                {
                    type: "Pythagorean Theorem",
                    problem: "Find the length of the hypotenuse of a right triangle with legs 5 cm and 12 cm",
                    steps: [
                        "Use the Pythagorean theorem: a² + b² = c²",
                        "Substitute the given values: 5² + 12² = c²",
                        "Calculate: 25 + 144 = c²",
                        "Simplify: 169 = c²",
                        "Take the square root: c = √169 = 13"
                    ],
                    answer: "13 cm"
                },
                {
                    type: "Angle Sum",
                    problem: "Find the measure of angle x in a triangle with angles 40° and 75°",
                    steps: [
                        "Use the angle sum property of triangles: sum of angles = 180°",
                        "Set up the equation: 40° + 75° + x = 180°",
                        "Simplify: 115° + x = 180°",
                        "Solve for x: x = 180° - 115° = 65°"
                    ],
                    answer: "65°"
                }
            ];
            
            const selectedProblem = geometryTypes[Math.floor(Math.random() * geometryTypes.length)];
            
            result += `Solving First Detected Geometry Problem:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features for geometry
            result += `Camera Features for Geometry:\n`;
            result += `- Shape Recognition: Identifying different geometric shapes\n`;
            result += `- Angle Measurement: Calculating angles between lines\n`;
            result += `- Length Measurement: Measuring distances between points\n`;
            result += `- Area Calculation: Computing areas of enclosed regions\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Interactive Diagram: Highlighting relevant parts\n`;
            result += `- Measurement Overlay: Showing measurements on the image\n`;
            result += `- Construction Lines: Displaying auxiliary constructions\n`;
            result += `- Step-by-Step Animation: Showing solution process\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Geometry-specific OCR\n`;
            result += `- Solver: Advanced Geometry Engine\n`;
            result += `- Latency: ${(Math.random() * 0.6 + 0.4).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving geometry from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve handwritten math from camera
    pattern: /solve handwritten math from camera/i,
    response: () => {
        try {
            let result = `Handwritten Math Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for handwritten math
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for handwriting recognition\n`;
            result += `- Handwriting Detection: Identifying handwritten text and symbols\n`;
            result += `- Stroke Analysis: Analyzing individual strokes and characters\n`;
            result += `- Real-time Preview: Highlighting recognized expressions\n\n`;
            
            // Simulate detection of handwritten elements
            result += `Detection Results:\n`;
            result += `- Handwritten Expressions Found: 3\n`;
            result += `- Mathematical Symbols Detected: 15\n`;
            result += `- Numbers Recognized: 12\n`;
            result += `- Variables Identified: 5\n\n`;
            
            // Select a random handwritten math problem type
            const handwrittenTypes = [
                {
                    type: "Fraction Simplification",
                    problem: "Simplify the fraction: 24/36",
                    steps: [
                        "Find the greatest common divisor (GCD) of 24 and 36",
                        "Factors of 24: 1, 2, 3, 4, 6, 8, 12, 24",
                        "Factors of 36: 1, 2, 3, 4, 6, 9, 12, 18, 36",
                        "Common factors: 1, 2, 3, 4, 6, 12",
                        "GCD is 12",
                        "Divide numerator and denominator by 12: 24÷12 / 36÷12 = 2/3"
                    ],
                    answer: "2/3"
                },
                {
                    type: "Exponent Simplification",
                    problem: "Simplify: (2³ × 2⁵) / 2⁴",
                    steps: [
                        "Apply the product rule in the numerator: 2³ × 2⁵ = 2^(3+5) = 2⁸",
                        "Rewrite the expression: 2⁸ / 2⁴",
                        "Apply the quotient rule: 2^(8-4) = 2⁴",
                        "Calculate: 2⁴ = 16"
                    ],
                    answer: "16"
                },
                {
                    type: "Polynomial Addition",
                    problem: "Add: (3x² + 2x - 5) + (4x² - 3x + 7)",
                    steps: [
                        "Remove parentheses: 3x² + 2x - 5 + 4x² - 3x + 7",
                        "Group like terms: (3x² + 4x²) + (2x - 3x) + (-5 + 7)",
                        "Combine like terms: 7x² - x + 2"
                    ],
                    answer: "7x² - x + 2"
                },
                {
                    type: "Logarithm Evaluation",
                    problem: "Evaluate: log₂(32)",
                    steps: [
                        "Rewrite 32 as a power of 2: 32 = 2⁵",
                        "Substitute: log₂(2⁵)",
                        "Apply the logarithm power rule: 5 × log₂(2)",
                        "Since log₂(2) = 1, we have: 5 × 1 = 5"
                    ],
                    answer: "5"
                }
            ];
            
            const selectedProblem = handwrittenTypes[Math.floor(Math.random() * handwrittenTypes.length)];
            
            result += `Solving First Detected Handwritten Problem:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features for handwritten math
            result += `Camera Features for Handwritten Math:\n`;
            result += `- Handwriting Recognition: Advanced OCR for handwritten text\n`;
            result += `- Stroke Analysis: Analyzing individual strokes for better recognition\n`;
            result += `- Symbol Recognition: Identifying mathematical symbols\n`;
            result += `- Expression Parsing: Understanding mathematical structure\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Handwriting: Displayed with camera image overlay\n`;
            result += `- Recognized Text: Showing the interpreted expression\n`;
            result += `- Step-by-Step Solution: Displayed with clear formatting\n`;
            result += `- Interactive Elements: Tappable steps for more explanation\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Handwriting-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.8 + 0.5).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving handwritten math from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve formula recognition from camera
    pattern: /recognize formula from camera/i,
    response: () => {
        try {
            let result = `Formula Recognition - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for formula recognition
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for formula recognition\n`;
            result += `- Formula Detection: Identifying mathematical formulas\n`;
            result += `- Symbol Recognition: Recognizing mathematical symbols\n`;
            result += `- Structure Analysis: Understanding formula structure\n\n`;
            
            // Simulate detection of formula elements
            result += `Detection Results:\n`;
            result += `- Formulas Detected: 2\n`;
            result += `- Mathematical Symbols Recognized: 20\n`;
            result += `- Variables Identified: 8\n`;
            result += `- Operators Recognized: 12\n\n`;
            
            // Select a random formula type
            const formulaTypes = [
                {
                    type: "Quadratic Formula",
                    formula: "x = (-b ± √(b² - 4ac)) / 2a",
                    description: "Used to solve quadratic equations of the form ax² + bx + c = 0",
                    variables: "a, b, c are coefficients; x is the variable",
                    usage: "Solving quadratic equations"
                },
                {
                    type: "Pythagorean Theorem",
                    formula: "a² + b² = c²",
                    description: "In a right triangle, the square of the hypotenuse equals the sum of squares of the other two sides",
                    variables: "a, b are legs; c is the hypotenuse",
                    usage: "Finding missing sides in right triangles"
                },
                {
                    type: "Area of a Circle",
                    formula: "A = πr²",
                    description: "The area of a circle is π times the square of its radius",
                    variables: "A is area; r is radius; π is approximately 3.14159",
                    usage: "Calculating the area of circles"
                },
                {
                    type: "Einstein's Mass-Energy Equivalence",
                    formula: "E = mc²",
                    description: "Energy equals mass times the speed of light squared",
                    variables: "E is energy; m is mass; c is speed of light",
                    usage: "Converting between mass and energy"
                },
                {
                    type: "Newton's Second Law",
                    formula: "F = ma",
                    description: "Force equals mass times acceleration",
                    variables: "F is force; m is mass; a is acceleration",
                    usage: "Calculating force in physics"
                }
            ];
            
            const selectedFormula = formulaTypes[Math.floor(Math.random() * formulaTypes.length)];
            
            result += `Recognized Formula:\n\n`;
            result += `Formula Type: ${selectedFormula.type}\n`;
            result += `Formula: ${selectedFormula.formula}\n`;
            result += `Description: ${selectedFormula.description}\n`;
            result += `Variables: ${selectedFormula.variables}\n`;
            result += `Usage: ${selectedFormula.usage}\n\n`;
            
            // Add camera-specific features for formula recognition
            result += `Camera Features for Formula Recognition:\n`;
            result += `- Formula Detection: Identifying mathematical formulas in real-time\n`;
            result += `- Symbol Recognition: Recognizing a wide range of mathematical symbols\n`;
            result += `- Structure Analysis: Understanding the structure of complex formulas\n`;
            result += `- Formula Database: Matching against a database of known formulas\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Formula Display: Rendered in mathematical notation\n`;
            result += `- Variable Highlighting: Variables highlighted for clarity\n`;
            result += `- Interactive Elements: Tappable variables for explanation\n`;
            result += `- Related Formulas: Showing related mathematical formulas\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Formula-specific OCR\n`;
            result += `- Database: Extensive formula database\n`;
            result += `- Latency: ${(Math.random() * 0.6 + 0.3).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error recognizing formula from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve table problems from camera
    pattern: /solve table problem from camera/i,
    response: () => {
        try {
            let result = `Table Problem Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for tables
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for table recognition\n`;
            result += `- Table Detection: Identifying table structures\n`;
            result += `- Cell Extraction: Extracting data from table cells\n`;
            result += `- Structure Analysis: Understanding table layout\n\n`;
            
            // Simulate detection of table elements
            result += `Detection Results:\n`;
            result += `- Tables Detected: 2\n`;
            result += `- Rows Identified: 15\n`;
            result += `- Columns Identified: 4\n`;
            result += `- Data Points Extracted: 60\n\n`;
            
            // Select a random table problem type
            const tableTypes = [
                {
                    type: "Data Analysis",
                    problem: "Find the mean, median, and mode of the data in the table",
                    table: "Values: 12, 15, 18, 22, 22, 25, 30",
                    steps: [
                        "Mean: Sum all values and divide by count: (12+15+18+22+22+25+30)/7 = 144/7 ≈ 20.57",
                        "Median: Middle value when ordered: 22",
                        "Mode: Most frequent value: 22"
                    ],
                    answer: "Mean ≈ 20.57, Median = 22, Mode = 22"
                },
                {
                    type: "Pattern Recognition",
                    problem: "Find the pattern in the table and determine the next value",
                    table: "n: 1, 2, 3, 4, 5\nf(n): 3, 7, 11, 15, 19",
                    steps: [
                        "Observe the relationship between n and f(n)",
                        "Notice that f(n) = 4n - 1",
                        "For n = 1: 4(1) - 1 = 3 ✓",
                        "For n = 2: 4(2) - 1 = 7 ✓",
                        "The pattern is confirmed",
                        "For n = 6: f(6) = 4(6) - 1 = 23"
                    ],
                    answer: "23"
                },
                {
                    type: "Rate Calculation",
                    problem: "Calculate the rate of change from the data in the table",
                    table: "Time (s): 0, 1, 2, 3, 4\nDistance (m): 0, 5, 12, 21, 32",
                    steps: [
                        "The rate of change is the change in distance divided by change in time",
                        "From t=0 to t=4: distance changes from 0 to 32",
                        "Change in distance = 32 - 0 = 32 m",
                        "Change in time = 4 - 0 = 4 s",
                        "Rate of change = 32/4 = 8 m/s"
                    ],
                    answer: "8 m/s"
                },
                {
                    type: "Percentage Calculation",
                    problem: "Calculate the percentage of each category from the table",
                    table: "Category: A, B, C, D\nCount: 15, 25, 10, 20",
                    steps: [
                        "Calculate the total count: 15 + 25 + 10 + 20 = 70",
                        "Calculate percentage for A: (15/70) × 100 ≈ 21.4%",
                        "Calculate percentage for B: (25/70) × 100 ≈ 35.7%",
                        "Calculate percentage for C: (10/70) × 100 ≈ 14.3%",
                        "Calculate percentage for D: (20/70) × 100 ≈ 28.6%"
                    ],
                    answer: "A: 21.4%, B: 35.7%, C: 14.3%, D: 28.6%"
                }
            ];
            
            const selectedProblem = tableTypes[Math.floor(Math.random() * tableTypes.length)];
            
            result += `Solving First Detected Table Problem:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n`;
            result += `Table Data: ${selectedProblem.table}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features for table problems
            result += `Camera Features for Table Problems:\n`;
            result += `- Table Detection: Identifying table structures in real-time\n`;
            result += `- Cell Extraction: Extracting data from individual cells\n`;
            result += `- Structure Recognition: Understanding table layout and relationships\n`;
            result += `- Data Validation: Checking for data consistency and errors\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Table Display: Rendered in a clean, readable format\n`;
            result += `- Highlighted Cells: Important cells highlighted for analysis\n`;
            result += `- Interactive Elements: Tappable cells for more information\n`;
            result += `- Graphical Representation: Charts and graphs based on table data\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Table-specific OCR\n`;
            result += `- Solver: Data Analysis Engine\n`;
            result += `- Latency: ${(Math.random() * 0.7 + 0.4).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving table problem from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve equation systems from camera
    pattern: /solve equation system from camera/i,
    response: () => {
        try {
            let result = `Equation System Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for equation systems
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for equation recognition\n`;
            result += `- Equation Detection: Identifying mathematical equations\n`;
            result += `- Variable Recognition: Recognizing variables and coefficients\n`;
            result += `- System Analysis: Understanding relationships between equations\n\n`;
            
            // Simulate detection of equation system elements
            result += `Detection Results:\n`;
            result += `- Equation Systems Detected: 2\n`;
            result += `- Equations in First System: 3\n`;
            result += `- Variables in First System: 3\n`;
            result += `- Equations in Second System: 2\n`;
            result += `- Variables in Second System: 2\n\n`;
            
            // Select a random equation system type
            const equationTypes = [
                {
                    type: "Linear System (2 variables)",
                    problem: "Solve the system: 2x + 3y = 8, 4x - y = 6",
                    steps: [
                        "From the second equation: y = 4x - 6",
                        "Substitute into the first equation: 2x + 3(4x - 6) = 8",
                        "Simplify: 2x + 12x - 18 = 8",
                        "Combine like terms: 14x - 18 = 8",
                        "Add 18: 14x = 26",
                        "Divide by 14: x = 26/14 = 13/7",
                        "Substitute back: y = 4(13/7) - 6 = 52/7 - 42/7 = 10/7"
                    ],
                    answer: "x = 13/7, y = 10/7"
                },
                {
                    type: "Linear System (3 variables)",
                    problem: "Solve the system: x + y + z = 6, 2x - y + z = 3, x + 2y - z = 2",
                    steps: [
                        "Add equations 1 and 3: (x + y + z) + (x + 2y - z) = 6 + 2",
                        "Simplify: 2x + 3y = 8 (Equation 4)",
                        "Multiply equation 1 by 2: 2x + 2y + 2z = 12 (Equation 5)",
                        "Subtract equation 2 from equation 5: (2x + 2y + 2z) - (2x - y + z) = 12 - 3",
                        "Simplify: 3y + z = 9 (Equation 6)",
                        "From equation 3: z = x + 2y - 2",
                        "Substitute into equation 2: 2x - y + (x + 2y - 2) = 3",
                        "Simplify: 3x + y - 2 = 3, so 3x + y = 5 (Equation 7)",
                        "Multiply equation 7 by 3: 9x + 3y = 15 (Equation 8)",
                        "Subtract equation 4 from equation 8: (9x + 3y) - (2x + 3y) = 15 - 8",
                        "Simplify: 7x = 7, so x = 1",
                        "Substitute x = 1 into equation 7: 3(1) + y = 5, so y = 2",
                        "Substitute x = 1 and y = 2 into equation 1: 1 + 2 + z = 6, so z = 3"
                    ],
                    answer: "x = 1, y = 2, z = 3"
                },
                {
                    type: "Nonlinear System",
                    problem: "Solve the system: x² + y = 10, x + y = 4",
                    steps: [
                        "From the second equation: y = 4 - x",
                        "Substitute into the first equation: x² + (4 - x) = 10",
                        "Simplify: x² - x + 4 = 10",
                        "Rearrange: x² - x - 6 = 0",
                        "Factor: (x - 3)(x + 2) = 0",
                        "Solve for x: x = 3 or x = -2",
                        "For x = 3: y = 4 - 3 = 1",
                        "For x = -2: y = 4 - (-2) = 6"
                    ],
                    answer: "x = 3, y = 1 or x = -2, y = 6"
                },
                {
                    type: "Matrix System",
                    problem: "Solve the system using matrices: 3x + 2y = 7, x - y = 1",
                    steps: [
                        "Write in matrix form AX = B, where A = [[3, 2], [1, -1]], X = [[x], [y]], B = [[7], [1]]",
                        "Find the inverse of A: A⁻¹ = (1/det(A)) × adj(A)",
                        "Calculate det(A) = (3)(-1) - (2)(1) = -3 - 2 = -5",
                        "Find adj(A) = [[-1, -2], [-1, 3]]",
                        "Calculate A⁻¹ = (-1/5) × [[-1, -2], [-1, 3]] = [[1/5, 2/5], [1/5, -3/5]]",
                        "Solve for X: X = A⁻¹B = [[1/5, 2/5], [1/5, -3/5]] × [[7], [1]]",
                        "Calculate: x = (1/5)(7) + (2/5)(1) = 7/5 + 2/5 = 9/5",
                        "Calculate: y = (1/5)(7) + (-3/5)(1) = 7/5 - 3/5 = 4/5"
                    ],
                    answer: "x = 9/5, y = 4/5"
                }
            ];
            
            const selectedProblem = equationTypes[Math.floor(Math.random() * equationTypes.length)];
            
            result += `Solving First Detected Equation System:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features for equation systems
            result += `Camera Features for Equation Systems:\n`;
            result += `- Equation Detection: Identifying multiple equations in real-time\n`;
            result += `- Variable Tracking: Tracking variables across equations\n`;
            result += `- System Analysis: Understanding relationships between equations\n`;
            result += `- Solution Method Selection: Choosing appropriate solving method\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Equation Display: Rendered in mathematical notation\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Method Explanation: Explanation of chosen solution method\n`;
            result += `- Graphical Representation: Graphical solution when applicable\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Equation-specific OCR\n`;
            result += `- Solver: Advanced Equation System Engine\n`;
            result += `- Latency: ${(Math.random() * 0.8 + 0.5).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving equation system from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve calculus problems from camera
    pattern: /solve calculus from camera/i,
    response: () => {
        try {
            let result = `Calculus Problem Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for calculus
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for calculus recognition\n`;
            result += `- Function Detection: Identifying mathematical functions\n`;
            result += `- Symbol Recognition: Recognizing calculus symbols\n`;
            result += `- Structure Analysis: Understanding calculus expressions\n\n`;
            
            // Simulate detection of calculus elements
            result += `Detection Results:\n`;
            result += `- Functions Detected: 3\n`;
            result += `- Derivatives Identified: 2\n`;
            result += `- Integrals Identified: 1\n`;
            result += `- Limits Identified: 1\n\n`;
            
            // Select a random calculus problem type
            const calculusTypes = [
                {
                    type: "Derivative",
                    problem: "Find the derivative of f(x) = 3x⁴ - 2x² + 5x - 7",
                    steps: [
                        "Apply the power rule to each term",
                        "Derivative of 3x⁴ is 12x³",
                        "Derivative of -2x² is -4x",
                        "Derivative of 5x is 5",
                        "Derivative of -7 is 0",
                        "Combine the terms: f'(x) = 12x³ - 4x + 5"
                    ],
                    answer: "f'(x) = 12x³ - 4x + 5"
                },
                {
                    type: "Integral",
                    problem: "Find the integral of ∫(4x³ - 3x² + 2)dx",
                    steps: [
                        "Integrate term by term",
                        "Integral of 4x³ is x⁴",
                        "Integral of -3x² is -x³",
                        "Integral of 2 is 2x",
                        "Add the constant of integration: x⁴ - x³ + 2x + C"
                    ],
                    answer: "x⁴ - x³ + 2x + C"
                },
                {
                    type: "Limit",
                    problem: "Find the limit: lim(x→2) (x² - 4)/(x - 2)",
                    steps: [
                        "Direct substitution gives 0/0, which is indeterminate",
                        "Factor the numerator: x² - 4 = (x - 2)(x + 2)",
                        "Rewrite the limit: lim(x→2) ((x - 2)(x + 2))/(x - 2)",
                        "Cancel the common factor: lim(x→2) (x + 2)",
                        "Evaluate the limit: 2 + 2 = 4"
                    ],
                    answer: "4"
                },
                {
                    type: "Application",
                    problem: "Find the maximum area of a rectangle with perimeter 20",
                    steps: [
                        "Let the sides be x and y, so 2x + 2y = 20, which simplifies to x + y = 10",
                        "Solve for y: y = 10 - x",
                        "The area is A = xy = x(10 - x) = 10x - x²",
                        "Find the derivative: A' = 10 - 2x",
                        "Set the derivative equal to zero to find critical points: 10 - 2x = 0, so x = 5",
                        "Find y: y = 10 - 5 = 5",
                        "The maximum area is A = 5 × 5 = 25"
                    ],
                    answer: "25 square units"
                }
            ];
            
            const selectedProblem = calculusTypes[Math.floor(Math.random() * calculusTypes.length)];
            
            result += `Solving First Detected Calculus Problem:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features for calculus
            result += `Camera Features for Calculus:\n`;
            result += `- Function Recognition: Identifying mathematical functions\n`;
            result += `- Symbol Recognition: Recognizing calculus symbols and notation\n`;
            result += `- Graph Analysis: Extracting data from graphs when applicable\n`;
            result += `- Expression Parsing: Understanding complex calculus expressions\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Function Plot: Graph of the original function\n`;
            result += `- Derivative/Integral Plot: Graph of the result when applicable\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable steps for more explanation\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Calculus-specific OCR\n`;
            result += `- Solver: Advanced Calculus Engine\n`;
            result += `- Latency: ${(Math.random() * 0.9 + 0.6).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving calculus from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve statistics problems from camera
    pattern: /solve statistics from camera/i,
    response: () => {
        try {
            let result = `Statistics Problem Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for statistics
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for statistics recognition\n`;
            result += `- Data Detection: Identifying numerical data and statistics\n`;
            result += `- Graph Recognition: Recognizing statistical graphs and plots\n`;
            result += `- Table Analysis: Extracting data from statistical tables\n\n`;
            
            // Simulate detection of statistics elements
            result += `Detection Results:\n`;
            result += `- Data Sets Detected: 2\n`;
            result += `- Graphs/Plots Detected: 3\n`;
            result += `- Statistical Tables Detected: 1\n`;
            result += `- Statistical Measures Identified: 8\n\n`;
            
            // Select a random statistics problem type
            const statisticsTypes = [
                {
                    type: "Descriptive Statistics",
                    problem: "Calculate the mean, median, mode, range, and standard deviation for: 12, 15, 18, 22, 22, 25, 30",
                    steps: [
                        "Mean: Sum all values and divide by count: (12+15+18+22+22+25+30)/7 = 144/7 ≈ 20.57",
                        "Median: Middle value when ordered: 22",
                        "Mode: Most frequent value: 22",
                        "Range: Difference between max and min: 30 - 12 = 18",
                        "Standard Deviation: σ = √[Σ(x-μ)²/N]",
                        "Calculate squared differences: (12-20.57)² + (15-20.57)² + (18-20.57)² + (22-20.57)² + (22-20.57)² + (25-20.57)² + (30-20.57)²",
                        "σ = √(58.78 + 31.02 + 6.60 + 2.04 + 2.04 + 19.62 + 88.98)/7 = √208.08/7 = √29.73 ≈ 5.45"
                    ],
                    answer: "Mean ≈ 20.57, Median = 22, Mode = 22, Range = 18, Standard Deviation ≈ 5.45"
                },
                {
                    type: "Probability",
                    problem: "A bag contains 4 red marbles, 3 blue marbles, and 5 green marbles. What is the probability of drawing a red marble?",
                    steps: [
                        "Count the total number of marbles: 4 + 3 + 5 = 12",
                        "Count the number of red marbles: 4",
                        "Probability = Number of favorable outcomes / Total number of outcomes",
                        "P(Red) = 4/12 = 1/3 ≈ 0.333 or 33.3%"
                    ],
                    answer: "1/3 or approximately 33.3%"
                },
                {
                    type: "Hypothesis Testing",
                    problem: "A sample of 50 students has a mean test score of 78 with a standard deviation of 8. Test the hypothesis that the population mean is 75 at a 5% significance level.",
                    steps: [
                        "Null hypothesis (H₀): μ = 75",
                        "Alternative hypothesis (H₁): μ ≠ 75",
                        "Calculate the test statistic: t = (x̄ - μ) / (s/√n)",
                        "t = (78 - 75) / (8/√50) = 3 / (8/7.07) = 3 / 1.13 ≈ 2.65",
                        "Degrees of freedom = n - 1 = 50 - 1 = 49",
                        "For a two-tailed test at α = 0.05 and df = 49, the critical t-value is approximately ±2.01",
                        "Since 2.65 > 2.01, we reject the null hypothesis",
                        "Conclusion: There is sufficient evidence to conclude that the population mean is different from 75"
                    ],
                    answer: "Reject the null hypothesis. The population mean is different from 75."
                },
                {
                    type: "Regression Analysis",
                    problem: "Find the regression line for the data: (1,2), (2,3), (3,5), (4,4), (5,6)",
                    steps: [
                        "Calculate the means: x̄ = (1+2+3+4+5)/5 = 3, ȳ = (2+3+5+4+6)/5 = 4",
                        "Calculate the slope: m = Σ((x - x̄)(y - ȳ)) / Σ((x - x̄)²)",
                        "Numerator: (1-3)(2-4) + (2-3)(3-4) + (3-3)(5-4) + (4-3)(4-4) + (5-3)(6-4) = 4 + 1 + 0 + 0 + 4 = 9",
                        "Denominator: (1-3)² + (2-3)² + (3-3)² + (4-3)² + (5-3)² = 4 + 1 + 0 + 1 + 4 = 10",
                        "Slope: m = 9/10 = 0.9",
                        "Calculate the y-intercept: b = ȳ - mx̄ = 4 - 0.9(3) = 4 - 2.7 = 1.3",
                        "Regression equation: y = 0.9x + 1.3"
                    ],
                    answer: "y = 0.9x + 1.3"
                }
            ];
            
            const selectedProblem = statisticsTypes[Math.floor(Math.random() * statisticsTypes.length)];
            
            result += `Solving First Detected Statistics Problem:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features for statistics
            result += `Camera Features for Statistics:\n`;
            result += `- Data Detection: Identifying numerical data and statistics\n`;
            result += `- Graph Recognition: Recognizing statistical graphs and plots\n`;
            result += `- Table Analysis: Extracting data from statistical tables\n`;
            result += `- Pattern Recognition: Identifying statistical patterns\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Data Visualization: Charts and graphs based on the data\n`;
            result += `- Statistical Plots: Histograms, box plots, scatter plots\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Statistics-specific OCR\n`;
            result += `- Solver: Advanced Statistics Engine\n`;
            result += `- Latency: ${(Math.random() * 1.0 + 0.7).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving statistics from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve word problems from camera
    pattern: /solve word problem from camera/i,
    response: () => {
        try {
            let result = `Word Problem Solver - Camera Input:\n\n`;
            
            // Simulate camera capture and processing for word problems
            result += `Camera Processing:\n`;
            result += `- Camera Activated: Optimized for text recognition\n`;
            result += `- Text Extraction: OCR applied to extract problem text\n`;
            result += `- Context Analysis: Understanding the scenario and context\n`;
            result += `- Entity Recognition: Identifying people, objects, and quantities\n\n`;
            
            // Simulate detection of word problem elements
            result += `Detection Results:\n`;
            result += `- Word Problems Detected: 2\n`;
            result += `- Entities Identified: 15\n`;
            result += `- Quantities Detected: 8\n`;
            result += `- Relationships Mapped: 6\n\n`;
            
            // Select a random word problem type
            const wordProblemTypes = [
                {
                    type: "Distance/Rate/Time Problem",
                    problem: "A car travels at 60 mph for 2.5 hours. How far does it travel?",
                    steps: [
                        "Identify the formula: Distance = Rate × Time",
                        "Substitute the given values: Distance = 60 mph × 2.5 hours",
                        "Calculate: Distance = 150 miles"
                    ],
                    answer: "150 miles"
                },
                {
                    type: "Mixture Problem",
                    problem: "How many liters of a 20% acid solution must be added to 10 liters of a 50% acid solution to make a 30% acid solution?",
                    steps: [
                        "Let x be the number of liters of 20% solution to add",
                        "Amount of acid in the 20% solution: 0.20x",
                        "Amount of acid in the 50% solution: 0.50 × 10 = 5 liters",
                        "Total amount of acid in the mixture: 0.20x + 5",
                        "Total volume of the mixture: x + 10",
                        "Set up the equation: 0.20x + 5 = 0.30(x + 10)",
                        "Simplify: 0.20x + 5 = 0.30x + 3",
                        "Rearrange: 5 - 3 = 0.30x - 0.20x",
                        "Solve: 2 = 0.10x, so x = 20"
                    ],
                    answer: "20 liters"
                },
                {
                    type: "Work Problem",
                    problem: "If John can complete a job in 6 hours and Mary can complete the same job in 4 hours, how long will it take them to complete the job together?",
                    steps: [
                        "John's rate: 1/6 job per hour",
                        "Mary's rate: 1/4 job per hour",
                        "Combined rate: 1/6 + 1/4 = 2/12 + 3/12 = 5/12 job per hour",
                        "Time to complete the job together: 1 ÷ (5/12) = 12/5 = 2.4 hours",
                        "Convert to hours and minutes: 2.4 hours = 2 hours and 0.4 × 60 = 24 minutes"
                    ],
                    answer: "2 hours and 24 minutes"
                },
                {
                    type: "Age Problem",
                    problem: "John is twice as old as Mary. Five years ago, the sum of their ages was 28. How old are they now?",
                    steps: [
                        "Let Mary's current age be x years",
                        "John's current age is 2x years",
                        "Five years ago, Mary's age was x - 5",
                        "Five years ago, John's age was 2x - 5",
                        "Set up the equation: (x - 5) + (2x - 5) = 28",
                        "Simplify: 3x - 10 = 28",
                        "Solve: 3x = 38, so x = 38/3 ≈ 12.67",
                        "Mary's current age: x ≈ 12.67 years",
                        "John's current age: 2x ≈ 25.33 years"
                    ],
                    answer: "Mary is approximately 12.67 years old, John is approximately 25.33 years old"
                }
            ];
            
            const selectedProblem = wordProblemTypes[Math.floor(Math.random() * wordProblemTypes.length)];
            
            result += `Solving First Detected Word Problem:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add camera-specific features for word problems
            result += `Camera Features for Word Problems:\n`;
            result += `- Text Extraction: OCR applied to extract problem text\n`;
            result += `- Context Analysis: Understanding the scenario and context\n`;
            result += `- Entity Recognition: Identifying people, objects, and quantities\n`;
            result += `- Relationship Mapping: Understanding relationships between entities\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Scenario Diagram: Illustrating the problem scenario\n`;
            result += `- Variable Mapping: Showing what each variable represents\n`;
            result += `- Equation Setup: Displaying the mathematical model\n`;
            result += `- Solution Graph: Showing the solution visually if applicable\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Advanced OCR with NLP\n`;
            result += `- Solver: Word Problem Engine with Context Analysis\n`;
            result += `- Latency: ${(Math.random() * 1.2 + 0.8).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving word problem from camera. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from calculator app
    pattern: /solve math from calculator app/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Calculator App Integration:\n\n`;
            
            // Simulate calculator app integration
            result += `Calculator App Processing:\n`;
            result += `- App Integration: Connected to calculator app\n`;
            result += `- Expression Extraction: Extracting mathematical expressions\n`;
            result += `- History Analysis: Analyzing calculation history\n`;
            result += `- Real-time Processing: Processing calculations as they're entered\n\n`;
            
            // Simulate detection of calculator elements
            result += `Detection Results:\n`;
            result += `- Expressions Found: 5\n`;
            result += `- Calculations Performed: 8\n`;
            result += `- Variables Used: 3\n`;
            result += `- Functions Used: 4\n\n`;
            
            // Select a random calculator problem type
            const calculatorTypes = [
                {
                    type: "Basic Arithmetic",
                    problem: "Calculate: 3 + 5 × 2 - 4 ÷ 2",
                    steps: [
                        "Apply order of operations (PEMDAS/BODMAS)",
                        "First, multiplication: 5 × 2 = 10",
                        "Next, division: 4 ÷ 2 = 2",
                        "Now we have: 3 + 10 - 2",
                        "Addition: 3 + 10 = 13",
                        "Subtraction: 13 - 2 = 11"
                    ],
                    answer: "11"
                },
                {
                    type: "Scientific Functions",
                    problem: "Calculate: sin(30°) + cos(60°)",
                    steps: [
                        "Calculate sin(30°): sin(30°) = 0.5",
                        "Calculate cos(60°): cos(60°) = 0.5",
                        "Add the results: 0.5 + 0.5 = 1"
                    ],
                    answer: "1"
                },
                {
                    type: "Logarithmic Functions",
                    problem: "Calculate: log₂(8) + ln(e³)",
                    steps: [
                        "Calculate log₂(8): 2^x = 8, so x = 3",
                        "Calculate ln(e³): ln(e³) = 3",
                        "Add the results: 3 + 3 = 6"
                    ],
                    answer: "6"
                },
                {
                    type: "Complex Expression",
                    problem: "Simplify: (2x + 3)(x - 4) - x² + 5",
                    steps: [
                        "Expand the product: (2x + 3)(x - 4) = 2x² - 8x + 3x - 12 = 2x² - 5x - 12",
                        "Substitute back: 2x² - 5x - 12 - x² + 5",
                        "Combine like terms: (2x² - x²) - 5x + (-12 + 5) = x² - 5x - 7"
                    ],
                    answer: "x² - 5x - 7"
                }
            ];
            
            const selectedProblem = calculatorTypes[Math.floor(Math.random() * calculatorTypes.length)];
            
            result += `Solving Calculator Expression:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Expression: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add calculator-specific features
            result += `Calculator App Features:\n`;
            result += `- Expression History: Tracking previous calculations\n`;
            result += `- Variable Storage: Storing and recalling variables\n`;
            result += `- Function Library: Access to mathematical functions\n`;
            result += `- Step-by-Step Solution: Detailed solution process\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Expression Display: Rendered in mathematical notation\n`;
            result += `- Step Highlighting: Current step highlighted\n`;
            result += `- Interactive Elements: Tappable steps for more explanation\n`;
            result += `- Graphical Representation: Graphs when applicable\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Calculator Expression Parser\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.4 + 0.2).toFixed(2)} seconds\n`;
            result += `- App Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from calculator app. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from screenshot
    pattern: /solve math from screenshot/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Screenshot Analysis:\n\n`;
            
            // Simulate screenshot processing
            result += `Screenshot Processing:\n`;
            result += `- Screenshot Capture: High-resolution image captured\n`;
            result += `- Image Enhancement: Improving clarity and contrast\n`;
            result += `- Region Detection: Identifying mathematical regions\n`;
            result += `- Text Extraction: OCR applied to extract text\n\n`;
            
            // Simulate detection of screenshot elements
            result += `Detection Results:\n`;
            result += `- Mathematical Regions Found: 3\n`;
            result += `- Text Extracted: 150 characters\n`;
            result += `- Expressions Identified: 4\n`;
            result += `- Diagrams/Graphs Detected: 1\n\n`;
            
            // Select a random screenshot problem type
            const screenshotTypes = [
                {
                    type: "Algebraic Equation",
                    problem: "Solve for x: 2(x - 3) + 4x = 5x - 2",
                    steps: [
                        "Distribute the 2: 2x - 6 + 4x = 5x - 2",
                        "Combine like terms: 6x - 6 = 5x - 2",
                        "Subtract 5x from both sides: x - 6 = -2",
                        "Add 6 to both sides: x = 4"
                    ],
                    answer: "x = 4"
                },
                {
                    type: "Geometry Problem",
                    problem: "Find the area of a trapezoid with bases 8 cm and 12 cm, and height 5 cm",
                    steps: [
                        "Use the formula for the area of a trapezoid: A = (1/2)(b₁ + b₂)h",
                        "Substitute the given values: A = (1/2)(8 + 12)(5)",
                        "Simplify: A = (1/2)(20)(5)",
                        "Calculate: A = 10 × 5 = 50"
                    ],
                    answer: "50 cm²"
                },
                {
                    type: "Trigonometric Identity",
                    problem: "Verify the identity: sin²θ + cos²θ = 1",
                    steps: [
                        "Start with the left side: sin²θ + cos²θ",
                        "Recall the definitions: sinθ = opposite/hypotenuse, cosθ = adjacent/hypotenuse",
                        "Consider a right triangle with hypotenuse 1",
                        "Let the opposite side be a and the adjacent side be b",
                        "By the Pythagorean theorem: a² + b² = 1² = 1",
                        "Substitute: sin²θ + cos²θ = (a/1)² + (b/1)² = a² + b² = 1",
                        "Therefore, sin²θ + cos²θ = 1"
                    ],
                    answer: "The identity is verified"
                },
                {
                    type: "Probability Problem",
                    problem: "A standard deck has 52 cards. What is the probability of drawing a heart or a face card?",
                    steps: [
                        "Count the number of hearts: 13",
                        "Count the number of face cards: 12 (J, Q, K of each suit)",
                        "Count the number of heart face cards: 3 (J, Q, K of hearts)",
                        "Use the inclusion-exclusion principle: P(Heart or Face) = P(Heart) + P(Face) - P(Heart and Face)",
                        "Calculate each probability: P(Heart) = 13/52, P(Face) = 12/52, P(Heart and Face) = 3/52",
                        "Substitute: P(Heart or Face) = 13/52 + 12/52 - 3/52 = 22/52 = 11/26"
                    ],
                    answer: "11/26 or approximately 42.3%"
                }
            ];
            
            const selectedProblem = screenshotTypes[Math.floor(Math.random() * screenshotTypes.length)];
            
            result += `Solving Problem from Screenshot:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add screenshot-specific features
            result += `Screenshot Features:\n`;
            result += `- High-Resolution Processing: Detailed analysis of screenshot\n`;
            result += `- Multiple Region Detection: Identifying multiple math problems\n`;
            result += `- Context Preservation: Maintaining context of original problem\n`;
            result += `- Annotation Support: Adding annotations to original screenshot\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Screenshot: Displayed with solution overlay\n`;
            result += `- Region Highlighting: Highlighting relevant parts of the screenshot\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Screenshot-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.6 + 0.4).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from screenshot. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from whiteboard
    pattern: /solve math from whiteboard/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Whiteboard Analysis:\n\n`;
            
            // Simulate whiteboard processing
            result += `Whiteboard Processing:\n`;
            result += `- Whiteboard Capture: Image of whiteboard captured\n`;
            result += `- Background Removal: Isolating whiteboard content\n`;
            result += `- Stroke Analysis: Analyzing individual strokes\n`;
            result += `- Structure Recognition: Understanding mathematical structure\n\n`;
            
            // Simulate detection of whiteboard elements
            result += `Detection Results:\n`;
            result += `- Mathematical Expressions Found: 4\n`;
            result += `- Diagrams/Graphs Detected: 2\n`;
            result += `- Annotations Detected: 6\n`;
            result += `- Equations Solved: 3\n\n`;
            
            // Select a random whiteboard problem type
            const whiteboardTypes = [
                {
                    type: "System of Equations",
                    problem: "Solve the system: 2x + y = 7, x - y = 1",
                    steps: [
                        "Add the two equations: (2x + y) + (x - y) = 7 + 1",
                        "Simplify: 3x = 8",
                        "Solve for x: x = 8/3",
                        "Substitute x = 8/3 into the second equation: (8/3) - y = 1",
                        "Solve for y: y = 8/3 - 1 = 8/3 - 3/3 = 5/3"
                    ],
                    answer: "x = 8/3, y = 5/3"
                },
                {
                    type: "Quadratic Function",
                    problem: "Find the vertex of the parabola y = 2x² - 8x + 5",
                    steps: [
                        "The vertex form of a parabola is y = a(x - h)² + k, where (h, k) is the vertex",
                        "For a parabola in standard form y = ax² + bx + c, the x-coordinate of the vertex is h = -b/(2a)",
                        "In our equation, a = 2 and b = -8",
                        "Calculate h: h = -(-8)/(2×2) = 8/4 = 2",
                        "Substitute x = 2 into the equation to find k: k = 2(2)² - 8(2) + 5 = 8 - 16 + 5 = -3",
                        "The vertex is (2, -3)"
                    ],
                    answer: "(2, -3)"
                },
                {
                    type: "Derivative Application",
                    problem: "Find the maximum and minimum values of f(x) = x³ - 6x² + 9x + 1 on the interval [0, 4]",
                    steps: [
                        "Find the derivative: f'(x) = 3x² - 12x + 9",
                        "Set the derivative equal to zero to find critical points: 3x² - 12x + 9 = 0",
                        "Divide by 3: x² - 4x + 3 = 0",
                        "Factor: (x - 1)(x - 3) = 0",
                        "Critical points: x = 1 and x = 3",
                        "Evaluate the function at the critical points and endpoints:",
                        "f(0) = 0³ - 6(0)² + 9(0) + 1 = 1",
                        "f(1) = 1³ - 6(1)² + 9(1) + 1 = 1 - 6 + 9 + 1 = 5",
                        "f(3) = 3³ - 6(3)² + 9(3) + 1 = 27 - 54 + 27 + 1 = 1",
                        "f(4) = 4³ - 6(4)² + 9(4) + 1 = 64 - 96 + 36 + 1 = 5",
                        "Maximum value is 5 at x = 1 and x = 4",
                        "Minimum value is 1 at x = 0 and x = 3"
                    ],
                    answer: "Maximum value: 5 at x = 1 and x = 4, Minimum value: 1 at x = 0 and x = 3"
                },
                {
                    type: "Geometry Proof",
                    problem: "Prove that the sum of the angles in a triangle is 180°",
                    steps: [
                        "Consider a triangle ABC",
                        "Draw a line parallel to BC passing through A",
                        "Label the points where this line intersects extensions of AB and AC as D and E, respectively",
                        "Since DE is parallel to BC, we have alternate angles equal:",
                        "∠DAB = ∠ABC and ∠EAC = ∠ACB",
                        "Note that ∠DAB + ∠BAC + ∠EAC = 180° (they form a straight line)",
                        "Substituting the equal angles: ∠ABC + ∠BAC + ∠ACB = 180°",
                        "Therefore, the sum of the angles in triangle ABC is 180°"
                    ],
                    answer: "The sum of the angles in a triangle is 180°"
                }
            ];
            
            const selectedProblem = whiteboardTypes[Math.floor(Math.random() * whiteboardTypes.length)];
            
            result += `Solving Problem from Whiteboard:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add whiteboard-specific features
            result += `Whiteboard Features:\n`;
            result += `- Stroke Recognition: Advanced recognition of handwritten strokes\n`;
            result += `- Structure Analysis: Understanding mathematical structure\n`;
            result += `- Annotation Detection: Identifying annotations and corrections\n`;
            result += `- Multi-Color Recognition: Distinguishing different ink colors\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Whiteboard: Displayed with solution overlay\n`;
            result += `- Stroke Highlighting: Highlighting relevant strokes\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Whiteboard-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.7 + 0.5).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from whiteboard. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from textbook
    pattern: /solve math from textbook/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Textbook Analysis:\n\n`;
            
            // Simulate textbook processing
            result += `Textbook Processing:\n`;
            result += `- Textbook Capture: Image of textbook page captured\n`;
            result += `- Page Analysis: Analyzing layout and structure\n`;
            result += `- Problem Detection: Identifying problem sections\n`;
            result += `- Context Extraction: Extracting relevant context\n\n`;
            
            // Simulate detection of textbook elements
            result += `Detection Results:\n`;
            result += `- Problems Detected: 5\n`;
            result += `- Examples Found: 3\n`;
            result += `- Diagrams/Illustrations Detected: 2\n`;
            result += `- Formulas/Equations Detected: 8\n\n`;
            
            // Select a random textbook problem type
            const textbookTypes = [
                {
                    type: "Exponential Growth",
                    problem: "A bacteria culture doubles every 3 hours. If there are 500 bacteria initially, how many will there be after 24 hours?",
                    steps: [
                        "This is an exponential growth problem with formula: P = P₀ × 2^(t/d)",
                        "Where P₀ is the initial population, t is time, and d is doubling time",
                        "Given: P₀ = 500, t = 24 hours, d = 3 hours",
                        "Substitute: P = 500 × 2^(24/3) = 500 × 2^8",
                        "Calculate: 2^8 = 256",
                        "Final calculation: P = 500 × 256 = 128,000"
                    ],
                    answer: "128,000 bacteria"
                },
                {
                    type: "Logarithmic Equation",
                    problem: "Solve for x: log₃(x + 2) + log₃(x - 1) = 2",
                    steps: [
                        "Use the product rule for logarithms: log₃((x + 2)(x - 1)) = 2",
                        "Simplify inside the logarithm: log₃(x² + x - 2) = 2",
                        "Convert to exponential form: x² + x - 2 = 3²",
                        "Simplify: x² + x - 2 = 9",
                        "Rearrange: x² + x - 11 = 0",
                        "Use the quadratic formula: x = (-b ± √(b² - 4ac)) / (2a)",
                        "Substitute a = 1, b = 1, c = -11: x = (-1 ± √(1 + 44)) / 2 = (-1 ± √45) / 2",
                        "Simplify: x = (-1 ± 3√5) / 2",
                        "Check for extraneous solutions: Both solutions are valid since they make the original logarithms defined"
                    ],
                    answer: "x = (-1 + 3√5) / 2 or x = (-1 - 3√5) / 2"
                },
                {
                    type: "Trigonometric Identity",
                    problem: "Verify the identity: (1 - cos²θ)(1 + cot²θ) = 1",
                    steps: [
                        "Start with the left side: (1 - cos²θ)(1 + cot²θ)",
                        "Recall the Pythagorean identity: 1 - cos²θ = sin²θ",
                        "Substitute: sin²θ(1 + cot²θ)",
                        "Recall that cotθ = cosθ/sinθ, so cot²θ = cos²θ/sin²θ",
                        "Substitute: sin²θ(1 + cos²θ/sin²θ)",
                        "Distribute: sin²θ × 1 + sin²θ × cos²θ/sin²θ",
                        "Simplify: sin²θ + cos²θ",
                        "Recall the Pythagorean identity: sin²θ + cos²θ = 1",
                        "Therefore, (1 - cos²θ)(1 + cot²θ) = 1"
                    ],
                    answer: "The identity is verified"
                },
                {
                    type: "Vector Operations",
                    problem: "Given vectors u = 2i - 3j + k and v = -i + 4j - 2k, find u · v and u × v",
                    steps: [
                        "Calculate the dot product u · v:",
                        "u · v = (2)(-1) + (-3)(4) + (1)(-2) = -2 - 12 - 2 = -16",
                        "Calculate the cross product u × v:",
                        "u × v = |i  j  k|",
                        "        |2 -3  1|",
                        "        |-1 4 -2|",
                        "= i[(-3)(-2) - (1)(4)] - j[(2)(-2) - (1)(-1)] + k[(2)(4) - (-3)(-1)]",
                        "= i[6 - 4] - j[-4 + 1] + k[8 - 3]",
                        "= i[2] - j[-3] + k[5]",
                        "= 2i + 3j + 5k"
                    ],
                    answer: "u · v = -16, u × v = 2i + 3j + 5k"
                }
            ];
            
            const selectedProblem = textbookTypes[Math.floor(Math.random() * textbookTypes.length)];
            
            result += `Solving Problem from Textbook:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add textbook-specific features
            result += `Textbook Features:\n`;
            result += `- Page Recognition: Identifying page numbers and sections\n`;
            result += `- Context Analysis: Understanding the context of the problem\n`;
            result += `- Reference Detection: Identifying related examples and formulas\n`;
            result += `- Chapter Organization: Maintaining chapter and section structure\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Textbook: Displayed with solution overlay\n`;
            result += `- Reference Highlighting: Highlighting relevant textbook content\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Textbook-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.8 + 0.6).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from textbook. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from worksheet
    pattern: /solve math from worksheet/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Worksheet Analysis:\n\n`;
            
            // Simulate worksheet processing
            result += `Worksheet Processing:\n`;
            result += `- Worksheet Capture: Image of worksheet captured\n`;
            result += `- Layout Analysis: Analyzing worksheet layout and structure\n`;
            result += `- Problem Detection: Identifying individual problems\n`;
            result += `- Answer Space Detection: Identifying areas for answers\n\n`;
            
            // Simulate detection of worksheet elements
            result += `Detection Results:\n`;
            result += `- Problems Detected: 10\n`;
            result += `- Answer Spaces Detected: 10\n`;
            result += `- Instructions Detected: 2\n`;
            result += `- Diagrams/Illustrations Detected: 3\n\n`;
            
            // Select a random worksheet problem type
            const worksheetTypes = [
                {
                    type: "Fraction Operations",
                    problem: "Calculate: 2/3 + 3/4 - 1/2",
                    steps: [
                        "Find a common denominator for 3, 4, and 2",
                        "The least common multiple is 12",
                        "Convert each fraction: 2/3 = 8/12, 3/4 = 9/12, 1/2 = 6/12",
                        "Perform the operations: 8/12 + 9/12 - 6/12 = (8 + 9 - 6)/12 = 11/12"
                    ],
                    answer: "11/12"
                },
                {
                    type: "Percentage Calculation",
                    problem: "What is 35% of 80?",
                    steps: [
                        "Convert the percentage to a decimal: 35% = 0.35",
                        "Multiply by the number: 0.35 × 80 = 28"
                    ],
                    answer: "28"
                },
                {
                    type: "Area Calculation",
                    problem: "Find the area of a rectangle with length 12 cm and width 8 cm",
                    steps: [
                        "Use the formula for the area of a rectangle: A = length × width",
                        "Substitute the given values: A = 12 cm × 8 cm",
                        "Calculate: A = 96 cm²"
                    ],
                    answer: "96 cm²"
                },
                {
                    type: "Solving Equations",
                    problem: "Solve for x: 3x - 7 = 14",
                    steps: [
                        "Add 7 to both sides: 3x = 14 + 7",
                        "Simplify: 3x = 21",
                        "Divide both sides by 3: x = 21/3",
                        "Simplify: x = 7"
                    ],
                    answer: "x = 7"
                }
            ];
            
            const selectedProblem = worksheetTypes[Math.floor(Math.random() * worksheetTypes.length)];
            
            result += `Solving Problem from Worksheet:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add worksheet-specific features
            result += `Worksheet Features:\n`;
            result += `- Problem Numbering: Maintaining original problem numbering\n`;
            result += `- Answer Space Detection: Identifying where to write answers\n`;
            result += `- Instruction Recognition: Understanding worksheet instructions\n`;
            result += `- Multi-Problem Processing: Handling multiple problems simultaneously\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Worksheet: Displayed with solution overlay\n`;
            result += `- Answer Highlighting: Highlighting where to write answers\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Worksheet-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.5 + 0.3).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from worksheet. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from handwritten notes
    pattern: /solve math from handwritten notes/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Handwritten Notes Analysis:\n\n`;
            
            // Simulate handwritten notes processing
            result += `Handwritten Notes Processing:\n`;
            result += `- Notes Capture: Image of handwritten notes captured\n`;
            result += `- Handwriting Recognition: Advanced OCR for handwritten text\n`;
            result += `- Stroke Analysis: Analyzing individual strokes and characters\n`;
            result += `- Structure Recognition: Understanding mathematical structure\n\n`;
            
            // Simulate detection of handwritten notes elements
            result += `Detection Results:\n`;
            result += `- Mathematical Expressions Found: 6\n`;
            result += `- Diagrams/Sketches Detected: 2\n`;
            result += `- Annotations Detected: 8\n`;
            result += `- Equations Solved: 4\n\n`;
            
            // Select a random handwritten notes problem type
            const handwrittenTypes = [
                {
                    type: "Polynomial Division",
                    problem: "Divide: (x³ - 6x² + 11x - 6) ÷ (x - 1)",
                    steps: [
                        "Set up polynomial long division:",
                        "      x² - 5x + 6",
                        "    _______________",
                        "x - 1 | x³ - 6x² + 11x - 6",
                        "      -(x³ -  x²)",
                        "      ___________",
                        "           -5x² + 11x",
                        "         -(-5x² + 5x)",
                        "         __________",
                        "                 6x - 6",
                        "               -(6x - 6)",
                        "               _______",
                        "                     0",
                        "The quotient is x² - 5x + 6 with no remainder"
                    ],
                    answer: "x² - 5x + 6"
                },
                {
                    type: "Logarithmic Differentiation",
                    problem: "Find the derivative of y = x^x",
                    steps: [
                        "Take the natural logarithm of both sides: ln(y) = ln(x^x)",
                        "Simplify using logarithm properties: ln(y) = x·ln(x)",
                        "Differentiate both sides with respect to x:",
                        "(1/y)·dy/dx = ln(x) + x·(1/x)",
                        "Simplify: (1/y)·dy/dx = ln(x) + 1",
                        "Solve for dy/dx: dy/dx = y·(ln(x) + 1)",
                        "Substitute y = x^x: dy/dx = x^x·(ln(x) + 1)"
                    ],
                    answer: "dy/dx = x^x·(ln(x) + 1)"
                },
                {
                    type: "Integration by Parts",
                    problem: "Evaluate: ∫x·e^x dx",
                    steps: [
                        "Use integration by parts formula: ∫u·dv = uv - ∫v·du",
                        "Let u = x, dv = e^x dx",
                        "Then du = dx, v = e^x",
                        "Apply the formula: ∫x·e^x dx = x·e^x - ∫e^x dx",
                        "Evaluate the integral: ∫e^x dx = e^x + C",
                        "Substitute back: ∫x·e^x dx = x·e^x - e^x + C",
                        "Factor: ∫x·e^x dx = e^x(x - 1) + C"
                    ],
                    answer: "e^x(x - 1) + C"
                },
                {
                    type: "Matrix Operations",
                    problem: "Given matrices A = [[2, 3], [1, 4]] and B = [[1, 0], [2, -1]], find 2A - B",
                    steps: [
                        "Calculate 2A: 2 × [[2, 3], [1, 4]] = [[4, 6], [2, 8]]",
                        "Calculate 2A - B: [[4, 6], [2, 8]] - [[1, 0], [2, -1]]",
                        "Subtract corresponding elements: [[4-1, 6-0], [2-2, 8-(-1)]]",
                        "Simplify: [[3, 6], [0, 9]]"
                    ],
                    answer: "[[3, 6], [0, 9]]"
                }
            ];
            
            const selectedProblem = handwrittenTypes[Math.floor(Math.random() * handwrittenTypes.length)];
            
            result += `Solving Problem from Handwritten Notes:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add handwritten notes-specific features
            result += `Handwritten Notes Features:\n`;
            result += `- Advanced Handwriting Recognition: Recognizing various handwriting styles\n`;
            result += `- Stroke Analysis: Analyzing individual strokes for better recognition\n`;
            result += `- Annotation Detection: Identifying annotations and corrections\n`;
            result += `- Structure Recognition: Understanding mathematical structure\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Notes: Displayed with solution overlay\n`;
            result += `- Stroke Highlighting: Highlighting relevant strokes\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Handwriting-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.9 + 0.6).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from handwritten notes. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from graph paper
    pattern: /solve math from graph paper/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Graph Paper Analysis:\n\n`;
            
            // Simulate graph paper processing
            result += `Graph Paper Processing:\n`;
            result += `- Graph Paper Capture: Image of graph paper captured\n`;
            result += `- Grid Detection: Identifying grid lines and structure\n`;
            result += `- Coordinate System Detection: Identifying coordinate system\n`;
            result += `- Plot Analysis: Analyzing plotted points and graphs\n\n`;
            
            // Simulate detection of graph paper elements
            result += `Detection Results:\n`;
            result += `- Grid Lines Detected: 20 horizontal, 20 vertical\n`;
            result += `- Coordinate System Detected: Cartesian\n`;
            result += `- Plotted Points Detected: 8\n`;
            result += `- Graphs/Functions Detected: 2\n\n`;
            
            // Select a random graph paper problem type
            const graphPaperTypes = [
                {
                    type: "Linear Function",
                    problem: "Find the equation of the line passing through points (2, 3) and (5, 9)",
                    steps: [
                        "Calculate the slope: m = (9 - 3) / (5 - 2) = 6 / 3 = 2",
                        "Use point-slope form: y - 3 = 2(x - 2)",
                        "Simplify: y - 3 = 2x - 4",
                        "Solve for y: y = 2x - 1"
                    ],
                    answer: "y = 2x - 1"
                },
                {
                    type: "Parabola Analysis",
                    problem: "Find the vertex, axis of symmetry, and y-intercept of the parabola y = x² - 4x + 3",
                    steps: [
                        "The vertex form of a parabola is y = a(x - h)² + k, where (h, k) is the vertex",
                        "Complete the square: y = x² - 4x + 3 = (x² - 4x + 4) - 4 + 3 = (x - 2)² - 1",
                        "Vertex: (2, -1)",
                        "Axis of symmetry: x = 2",
                        "Y-intercept: Set x = 0: y = 0² - 4(0) + 3 = 3"
                    ],
                    answer: "Vertex: (2, -1), Axis of symmetry: x = 2, Y-intercept: 3"
                },
                {
                    type: "Distance Formula",
                    problem: "Find the distance between points A(3, 4) and B(7, 1)",
                    steps: [
                        "Use the distance formula: d = √[(x₂ - x₁)² + (y₂ - y₁)²]",
                        "Substitute the coordinates: d = √[(7 - 3)² + (1 - 4)²]",
                        "Calculate: d = √[4² + (-3)²] = √[16 + 9] = √25",
                        "Simplify: d = 5"
                    ],
                    answer: "5 units"
                },
                {
                    type: "System of Equations Graphically",
                    problem: "Solve the system graphically: y = 2x + 1, y = -x + 4",
                    steps: [
                        "Graph both equations on the same coordinate system",
                        "The first equation y = 2x + 1 has a slope of 2 and y-intercept of 1",
                        "The second equation y = -x + 4 has a slope of -1 and y-intercept of 4",
                        "Find the point of intersection by setting the equations equal: 2x + 1 = -x + 4",
                        "Solve for x: 3x = 3, so x = 1",
                        "Substitute x = 1 into the first equation: y = 2(1) + 1 = 3",
                        "The point of intersection is (1, 3)"
                    ],
                    answer: "x = 1, y = 3"
                }
            ];
            
            const selectedProblem = graphPaperTypes[Math.floor(Math.random() * graphPaperTypes.length)];
            
            result += `Solving Problem from Graph Paper:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add graph paper-specific features
            result += `Graph Paper Features:\n`;
            result += `- Grid Detection: Identifying grid lines and structure\n`;
            result += `- Coordinate System Detection: Identifying coordinate system\n`;
            result += `- Plot Analysis: Analyzing plotted points and graphs\n`;
            result += `- Scale Detection: Determining scale of the graph\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Graph Paper: Displayed with solution overlay\n`;
            result += `- Grid Highlighting: Highlighting relevant grid sections\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Graph paper-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.6 + 0.4).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from graph paper. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from presentation slides
    pattern: /solve math from presentation slides/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Presentation Slides Analysis:\n\n`;
            
            // Simulate presentation slides processing
            result += `Presentation Slides Processing:\n`;
            result += `- Slides Capture: Images of presentation slides captured\n`;
            result += `- Slide Analysis: Analyzing slide layout and structure\n`;
            result += `- Content Detection: Identifying mathematical content\n`;
            result += `- Context Extraction: Extracting relevant context\n\n`;
            
            // Simulate detection of presentation slides elements
            result += `Detection Results:\n`;
            result += `- Slides Processed: 5\n`;
            result += `- Mathematical Content Found: 8 sections\n`;
            result += `- Formulas/Equations Detected: 12\n`;
            result += `- Diagrams/Graphs Detected: 6\n\n`;
            
            // Select a random presentation slides problem type
            const presentationTypes = [
                {
                    type: "Quadratic Formula",
                    problem: "Derive the quadratic formula for ax² + bx + c = 0",
                    steps: [
                        "Start with the standard form: ax² + bx + c = 0",
                        "Divide by a (assuming a ≠ 0): x² + (b/a)x + c/a = 0",
                        "Complete the square: x² + (b/a)x + (b/2a)² - (b/2a)² + c/a = 0",
                        "Simplify: (x + b/2a)² - b²/4a² + c/a = 0",
                        "Rearrange: (x + b/2a)² = b²/4a² - c/a",
                        "Find a common denominator: (x + b/2a)² = (b² - 4ac)/4a²",
                        "Take the square root of both sides: x + b/2a = ±√(b² - 4ac)/2a",
                        "Solve for x: x = -b/2a ± √(b² - 4ac)/2a",
                        "Combine terms: x = (-b ± √(b² - 4ac))/2a"
                    ],
                    answer: "x = (-b ± √(b² - 4ac))/2a"
                },
                {
                    type: "Pythagorean Theorem Proof",
                    problem: "Prove the Pythagorean theorem: a² + b² = c² for a right triangle",
                    steps: [
                        "Consider a right triangle with legs a and b, and hypotenuse c",
                        "Construct a square with side length (a + b)",
                        "Inside this square, place four copies of the right triangle",
                        "The remaining space forms a smaller square with side length c",
                        "Area of the large square: (a + b)² = a² + 2ab + b²",
                        "Area of the four triangles: 4 × (1/2)ab = 2ab",
                        "Area of the smaller square: c²",
                        "Since the area of the large square equals the sum of the areas of the triangles and the smaller square:",
                        "a² + 2ab + b² = 2ab + c²",
                        "Subtract 2ab from both sides: a² + b² = c²"
                    ],
                    answer: "a² + b² = c²"
                },
                {
                    type: "Derivative of sin(x)",
                    problem: "Prove that the derivative of sin(x) is cos(x)",
                    steps: [
                        "Use the definition of the derivative: f'(x) = lim(h→0) [f(x+h) - f(x)]/h",
                        "For f(x) = sin(x): f'(x) = lim(h→0) [sin(x+h) - sin(x)]/h",
                        "Use the angle addition formula: sin(x+h) = sin(x)cos(h) + cos(x)sin(h)",
                        "Substitute: f'(x) = lim(h→0) [sin(x)cos(h) + cos(x)sin(h) - sin(x)]/h",
                        "Rearrange: f'(x) = lim(h→0) [sin(x)(cos(h) - 1) + cos(x)sin(h)]/h",
                        "Split the limit: f'(x) = sin(x)·lim(h→0)[(cos(h) - 1)/h] + cos(x)·lim(h→0)[sin(h)/h]",
                        "Use known limits: lim(h→0)[(cos(h) - 1)/h] = 0 and lim(h→0)[sin(h)/h] = 1",
                        "Substitute: f'(x) = sin(x)·0 + cos(x)·1 = cos(x)"
                    ],
                    answer: "The derivative of sin(x) is cos(x)"
                },
                {
                    type: "Area of a Circle",
                    problem: "Derive the formula for the area of a circle: A = πr²",
                    steps: [
                        "Consider a circle with radius r",
                        "Divide the circle into n equal sectors",
                        "Rearrange the sectors to form a parallelogram-like shape",
                        "As n approaches infinity, the shape becomes a rectangle",
                        "The height of the rectangle is approximately r",
                        "The base of the rectangle is approximately half the circumference: πr",
                        "Area of the rectangle: base × height = πr × r = πr²",
                        "Therefore, the area of the circle is πr²"
                    ],
                    answer: "A = πr²"
                }
            ];
            
            const selectedProblem = presentationTypes[Math.floor(Math.random() * presentationTypes.length)];
            
            result += `Solving Problem from Presentation Slides:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add presentation slides-specific features
            result += `Presentation Slides Features:\n`;
            result += `- Slide Recognition: Identifying individual slides\n`;
            result += `- Content Organization: Maintaining slide organization\n`;
            result += `- Animation Detection: Identifying animated elements\n`;
            result += `- Speaker Notes Detection: Identifying speaker notes if present\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Slides: Displayed with solution overlay\n`;
            result += `- Slide Navigation: Navigating through multiple slides\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Presentation slides-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.7 + 0.5).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from presentation slides. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from blackboard
    pattern: /solve math from blackboard/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Blackboard Analysis:\n\n`;
            
            // Simulate blackboard processing
            result += `Blackboard Processing:\n`;
            result += `- Blackboard Capture: Image of blackboard captured\n`;
            result += `- Background Removal: Isolating chalk/whiteboard marker content\n`;
            result += `- Stroke Analysis: Analyzing individual strokes\n`;
            result += `- Structure Recognition: Understanding mathematical structure\n\n`;
            
            // Simulate detection of blackboard elements
            result += `Detection Results:\n`;
            result += `- Mathematical Expressions Found: 7\n`;
            result += `- Diagrams/Graphs Detected: 3\n`;
            result += `- Annotations Detected: 10\n`;
            result += `- Equations Solved: 5\n\n`;
            
            // Select a random blackboard problem type
            const blackboardTypes = [
                {
                    type: "Integration by Substitution",
                    problem: "Evaluate: ∫2x(x² + 1)³ dx",
                    steps: [
                        "Let u = x² + 1",
                        "Then du/dx = 2x, so du = 2x dx",
                        "Substitute into the integral: ∫(x² + 1)³ · 2x dx = ∫u³ du",
                        "Integrate: (1/4)u⁴ + C",
                        "Substitute back for u: (1/4)(x² + 1)⁴ + C"
                    ],
                    answer: "(1/4)(x² + 1)⁴ + C"
                },
                {
                    type: "Trigonometric Identity",
                    problem: "Prove: sin(3x) = 3sin(x) - 4sin³(x)",
                    steps: [
                        "Use the triple angle formula: sin(3x) = sin(2x + x)",
                        "Apply the angle addition formula: sin(2x + x) = sin(2x)cos(x) + cos(2x)sin(x)",
                        "Use double angle formulas: sin(2x) = 2sin(x)cos(x) and cos(2x) = 1 - 2sin²(x)",
                        "Substitute: sin(3x) = 2sin(x)cos(x)cos(x) + (1 - 2sin²(x))sin(x)",
                        "Simplify: sin(3x) = 2sin(x)cos²(x) + sin(x) - 2sin³(x)",
                        "Use the Pythagorean identity: cos²(x) = 1 - sin²(x)",
                        "Substitute: sin(3x) = 2sin(x)(1 - sin²(x)) + sin(x) - 2sin³(x)",
                        "Expand: sin(3x) = 2sin(x) - 2sin³(x) + sin(x) - 2sin³(x)",
                        "Combine like terms: sin(3x) = 3sin(x) - 4sin³(x)"
                    ],
                    answer: "sin(3x) = 3sin(x) - 4sin³(x)"
                },
                {
                    type: "Matrix Inverse",
                    problem: "Find the inverse of matrix A = [[2, 3], [1, 4]]",
                    steps: [
                        "Use the formula for the inverse of a 2×2 matrix: A⁻¹ = (1/det(A)) × [[d, -b], [-c, a]]",
                        "Where A = [[a, b], [c, d]]",
                        "For our matrix: a = 2, b = 3, c = 1, d = 4",
                        "Calculate the determinant: det(A) = ad - bc = (2)(4) - (3)(1) = 8 - 3 = 5",
                        "Apply the formula: A⁻¹ = (1/5) × [[4, -3], [-1, 2]]",
                        "Multiply: A⁻¹ = [[4/5, -3/5], [-1/5, 2/5]]"
                    ],
                    answer: "[[4/5, -3/5], [-1/5, 2/5]]"
                },
                {
                    type: "Limit Evaluation",
                    problem: "Evaluate: lim(x→0) (sin(x))/x",
                    steps: [
                        "Direct substitution gives 0/0, which is indeterminate",
                        "Use L'Hôpital's Rule: lim(x→0) (sin(x))/x = lim(x→0) (cos(x))/1",
                        "Evaluate: cos(0)/1 = 1/1 = 1",
                        "Alternatively, use the geometric definition of the derivative of sin(x) at x = 0",
                        "The derivative of sin(x) is cos(x), so at x = 0, it's cos(0) = 1",
                        "This confirms our result"
                    ],
                    answer: "1"
                }
            ];
            
            const selectedProblem = blackboardTypes[Math.floor(Math.random() * blackboardTypes.length)];
            
            result += `Solving Problem from Blackboard:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add blackboard-specific features
            result += `Blackboard Features:\n`;
            result += `- Chalk/Marker Recognition: Distinguishing between chalk and whiteboard marker\n`;
            result += `- Stroke Analysis: Analyzing individual strokes for better recognition\n`;
            result += `- Erasure Detection: Identifying erased content\n`;
            result += `- Multi-Color Recognition: Distinguishing different chalk/marker colors\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Blackboard: Displayed with solution overlay\n`;
            result += `- Stroke Highlighting: Highlighting relevant strokes\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Blackboard-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.8 + 0.6).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from blackboard. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from document
    pattern: /solve math from document/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Document Analysis:\n\n`;
            
            // Simulate document processing
            result += `Document Processing:\n`;
            result += `- Document Capture: Image of document captured\n`;
            result += `- Document Analysis: Analyzing document structure and layout\n`;
            result += `- Content Detection: Identifying mathematical content\n`;
            result += `- Context Extraction: Extracting relevant context\n\n`;
            
            // Simulate detection of document elements
            result += `Detection Results:\n`;
            result += `- Pages Processed: 3\n`;
            result += `- Mathematical Sections Found: 5\n`;
            result += `- Formulas/Equations Detected: 15\n`;
            result += `- Diagrams/Graphs Detected: 7\n\n`;
            
            // Select a random document problem type
            const documentTypes = [
                {
                    type: "Differential Equation",
                    problem: "Solve the differential equation: dy/dx = 2x/y",
                    steps: [
                        "This is a separable differential equation",
                        "Separate the variables: y dy = 2x dx",
                        "Integrate both sides: ∫y dy = ∫2x dx",
                        "Calculate the integrals: (1/2)y² = x² + C",
                        "Multiply both sides by 2: y² = 2x² + 2C",
                        "Let K = 2C (a new constant): y² = 2x² + K",
                        "Solve for y: y = ±√(2x² + K)"
                    ],
                    answer: "y = ±√(2x² + K)"
                },
                {
                    type: "Complex Number Operations",
                    problem: "Given z₁ = 3 + 4i and z₂ = 1 - 2i, find z₁ + z₂, z₁ - z₂, z₁ × z₂, and z₁/z₂",
                    steps: [
                        "Addition: z₁ + z₂ = (3 + 4i) + (1 - 2i) = (3 + 1) + (4 - 2)i = 4 + 2i",
                        "Subtraction: z₁ - z₂ = (3 + 4i) - (1 - 2i) = (3 - 1) + (4 - (-2))i = 2 + 6i",
                        "Multiplication: z₁ × z₂ = (3 + 4i)(1 - 2i) = 3(1) + 3(-2i) + 4i(1) + 4i(-2i) = 3 - 6i + 4i - 8i²",
                        "Since i² = -1: 3 - 6i + 4i - 8(-1) = 3 - 6i + 4i + 8 = 11 - 2i",
                        "Division: z₁/z₂ = (3 + 4i)/(1 - 2i)",
                        "Multiply numerator and denominator by the conjugate of the denominator: (3 + 4i)(1 + 2i)/((1 - 2i)(1 + 2i))",
                        "Calculate numerator: (3 + 4i)(1 + 2i) = 3(1) + 3(2i) + 4i(1) + 4i(2i) = 3 + 6i + 4i + 8i² = 3 + 10i + 8(-1) = 3 + 10i - 8 = -5 + 10i",
                        "Calculate denominator: (1 - 2i)(1 + 2i) = 1² - (2i)² = 1 - 4i² = 1 - 4(-1) = 1 + 4 = 5",
                        "Final result: (-5 + 10i)/5 = -1 + 2i"
                    ],
                    answer: "z₁ + z₂ = 4 + 2i, z₁ - z₂ = 2 + 6i, z₁ × z₂ = 11 - 2i, z₁/z₂ = -1 + 2i"
                },
                {
                    type: "Vector Calculus",
                    problem: "Find the divergence and curl of the vector field F = (x²y, y²z, z²x)",
                    steps: [
                        "The divergence of F = (P, Q, R) is given by div(F) = ∂P/∂x + ∂Q/∂y + ∂R/∂z",
                        "Calculate partial derivatives:",
                        "∂P/∂x = ∂(x²y)/∂x = 2xy",
                        "∂Q/∂y = ∂(y²z)/∂y = 2yz",
                        "∂R/∂z = ∂(z²x)/∂z = 2zx",
                        "Divergence: div(F) = 2xy + 2yz + 2zx = 2(xy + yz + zx)",
                        "The curl of F = (P, Q, R) is given by:",
                        "curl(F) = (∂R/∂y - ∂Q/∂z, ∂P/∂z - ∂R/∂x, ∂Q/∂x - ∂P/∂y)",
                        "Calculate partial derivatives:",
                        "∂R/∂y = ∂(z²x)/∂y = 0",
                        "∂Q/∂z = ∂(y²z)/∂z = y²",
                        "∂P/∂z = ∂(x²y)/∂z = 0",
                        "∂R/∂x = ∂(z²x)/∂x = z²",
                        "∂Q/∂x = ∂(y²z)/∂x = 0",
                        "∂P/∂y = ∂(x²y)/∂y = x²",
                        "Curl: curl(F) = (0 - y², 0 - z², 0 - x²) = (-y², -z², -x²)"
                    ],
                    answer: "Divergence: 2(xy + yz + zx), Curl: (-y², -z², -x²)"
                },
                {
                    type: "Fourier Series",
                    problem: "Find the Fourier series of the function f(x) = x on the interval [-π, π]",
                    steps: [
                        "The Fourier series of f(x) is given by:",
                        "f(x) = a₀/2 + Σ[n=1 to ∞](aₙcos(nx) + bₙsin(nx))",
                        "Where a₀ = (1/π)∫[-π to π] f(x) dx",
                        "aₙ = (1/π)∫[-π to π] f(x)cos(nx) dx",
                        "bₙ = (1/π)∫[-π to π] f(x)sin(nx) dx",
                        "Calculate a₀: a₀ = (1/π)∫[-π to π] x dx = (1/π)[x²/2] from -π to π = (1/π)(π²/2 - π²/2) = 0",
                        "Calculate aₙ: aₙ = (1/π)∫[-π to π] xcos(nx) dx",
                        "Using integration by parts: u = x, dv = cos(nx) dx, du = dx, v = sin(nx)/n",
                        "aₙ = (1/π)[x·sin(nx)/n - ∫sin(nx)/n dx] from -π to π",
                        "aₙ = (1/π)[x·sin(nx)/n + cos(nx)/n²] from -π to π",
                        "aₙ = (1/π)[(π·sin(nπ)/n + cos(nπ)/n²) - (-π·sin(-nπ)/n + cos(-nπ)/n²)]",
                        "Since sin(nπ) = sin(-nπ) = 0 and cos(nπ) = cos(-nπ) = (-1)ⁿ:",
                        "aₙ = (1/π)[(0 + (-1)ⁿ/n²) - (0 + (-1)ⁿ/n²)] = 0",
                        "Calculate bₙ: bₙ = (1/π)∫[-π to π] xsin(nx) dx",
                        "Using integration by parts: u = x, dv = sin(nx) dx, du = dx, v = -cos(nx)/n",
                        "bₙ = (1/π)[-x·cos(nx)/n - ∫-cos(nx)/n dx] from -π to π",
                        "bₙ = (1/π)[-x·cos(nx)/n + sin(nx)/n²] from -π to π",
                        "bₙ = (1/π)[(-π·cos(nπ)/n + sin(nπ)/n²) - (-(-π)·cos(-nπ)/n + sin(-nπ)/n²)]",
                        "Since sin(nπ) = sin(-nπ) = 0 and cos(nπ) = cos(-nπ) = (-1)ⁿ:",
                        "bₙ = (1/π)[(-π·(-1)ⁿ/n) - (π·(-1)ⁿ/n)] = (1/π)[-2π·(-1)ⁿ/n] = -2(-1)ⁿ/n",
                        "Therefore, the Fourier series is:",
                        "f(x) = Σ[n=1 to ∞](-2(-1)ⁿ/n)sin(nx) = 2Σ[n=1 to ∞](-1)^(n+1)/n·sin(nx)"
                    ],
                    answer: "f(x) = 2Σ[n=1 to ∞](-1)^(n+1)/n·sin(nx)"
                }
            ];
            
            const selectedProblem = documentTypes[Math.floor(Math.random() * documentTypes.length)];
            
            result += `Solving Problem from Document:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add document-specific features
            result += `Document Features:\n`;
            result += `- Page Recognition: Identifying individual pages\n`;
            result += `- Document Structure: Maintaining document structure\n`;
            result += `- Cross-Reference Detection: Identifying references between sections\n`;
            result += `- Metadata Extraction: Extracting document metadata\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Original Document: Displayed with solution overlay\n`;
            result += `- Page Navigation: Navigating through multiple pages\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Document-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.9 + 0.7).toFixed(2)} seconds\n`;
            result += `- Device Compatibility: iOS 12+, Android 8+\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from document. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from online platform
    pattern: /solve math from online platform/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Online Platform Integration:\n\n`;
            
            // Simulate online platform integration
            result += `Online Platform Processing:\n`;
            result += `- Platform Connection: Connected to online math platform\n`;
            result += `- Problem Extraction: Extracting problems from the platform\n`;
            result += `- Format Conversion: Converting platform format to standard format\n`;
            result += `- Solution Generation: Generating step-by-step solutions\n\n`;
            
            // Simulate detection of online platform elements
            result += `Detection Results:\n`;
            result += `- Problems Extracted: 5\n`;
            result += `- Platform Format: Detected and converted\n`;
            result += `- Interactive Elements: Identified and preserved\n`;
            result += `- Hints/Explanations: Extracted when available\n\n`;
            
            // Select a random online platform problem type
            const onlineTypes = [
                {
                    type: "Algebra Word Problem",
                    problem: "John is twice as old as Jane. Five years ago, the sum of their ages was 28. How old are they now?",
                    steps: [
                        "Let Jane's current age be x years",
                        "John's current age is 2x years",
                        "Five years ago, Jane's age was x - 5",
                        "Five years ago, John's age was 2x - 5",
                        "Set up the equation: (x - 5) + (2x - 5) = 28",
                        "Simplify: 3x - 10 = 28",
                        "Add 10: 3x = 38",
                        "Divide by 3: x = 38/3 ≈ 12.67",
                        "Jane's current age: x ≈ 12.67 years",
                        "John's current age: 2x ≈ 25.33 years"
                    ],
                    answer: "Jane is approximately 12.67 years old, John is approximately 25.33 years old"
                },
                {
                    type: "Geometry Problem",
                    problem: "A circle has a radius of 5 cm. Find the length of an arc that subtends an angle of 60° at the center.",
                    steps: [
                        "Use the formula for arc length: L = (θ/360) × 2πr",
                        "Where θ is the central angle in degrees and r is the radius",
                        "Substitute the given values: L = (60/360) × 2π(5)",
                        "Simplify: L = (1/6) × 10π",
                        "Calculate: L = 10π/6 = 5π/3",
                        "Approximate: L ≈ 5(3.14159)/3 ≈ 5.24 cm"
                    ],
                    answer: "5π/3 cm or approximately 5.24 cm"
                },
                {
                    type: "Statistics Problem",
                    problem: "The test scores of 10 students are: 85, 90, 75, 92, 88, 76, 95, 89, 84, 91. Find the mean, median, mode, and range.",
                    steps: [
                        "Mean: Sum all scores and divide by the number of students",
                        "Sum = 85 + 90 + 75 + 92 + 88 + 76 + 95 + 89 + 84 + 91 = 865",
                        "Mean = 865/10 = 86.5",
                        "Median: Arrange scores in ascending order and find the middle value(s)",
                        "Ordered scores: 75, 76, 84, 85, 88, 89, 90, 91, 92, 95",
                        "Since there are 10 scores (even number), the median is the average of the 5th and 6th scores",
                        "Median = (88 + 89)/2 = 88.5",
                        "Mode: The score that appears most frequently",
                        "In this case, no score appears more than once, so there is no mode",
                        "Range: Difference between the highest and lowest scores",
                        "Range = 95 - 75 = 20"
                    ],
                    answer: "Mean = 86.5, Median = 88.5, Mode = None, Range = 20"
                },
                {
                    type: "Calculus Problem",
                    problem: "Find the absolute maximum and minimum values of f(x) = x³ - 12x + 1 on the interval [-3, 3]",
                    steps: [
                        "Find the derivative: f'(x) = 3x² - 12",
                        "Set the derivative equal to zero to find critical points: 3x² - 12 = 0",
                        "Solve: 3x² = 12, x² = 4, x = ±2",
                        "Both x = -2 and x = 2 are in the interval [-3, 3]",
                        "Evaluate the function at the critical points and endpoints:",
                        "f(-3) = (-3)³ - 12(-3) + 1 = -27 + 36 + 1 = 10",
                        "f(-2) = (-2)³ - 12(-2) + 1 = -8 + 24 + 1 = 17",
                        "f(2) = (2)³ - 12(2) + 1 = 8 - 24 + 1 = -15",
                        "f(3) = (3)³ - 12(3) + 1 = 27 - 36 + 1 = -8",
                        "The absolute maximum value is 17 at x = -2",
                        "The absolute minimum value is -15 at x = 2"
                    ],
                    answer: "Absolute maximum: 17 at x = -2, Absolute minimum: -15 at x = 2"
                }
            ];
            
            const selectedProblem = onlineTypes[Math.floor(Math.random() * onlineTypes.length)];
            
            result += `Solving Problem from Online Platform:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add online platform-specific features
            result += `Online Platform Features:\n`;
            result += `- Platform Integration: Seamless integration with popular math platforms\n`;
            result += `- Format Recognition: Recognizing various platform formats\n`;
            result += `- Interactive Elements: Preserving interactive elements from the platform\n`;
            result += `- Hint Integration: Incorporating platform hints when available\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Platform Interface: Displaying solution in platform-compatible format\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n`;
            result += `- Export Options: Options to export solution back to platform\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Platform-specific OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 0.6 + 0.4).toFixed(2)} seconds\n`;
            result += `- Platform Compatibility: Khan Academy, Wolfram Alpha, Chegg, etc.\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from online platform. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems from multiple sources
    pattern: /solve math from multiple sources/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Multiple Sources Integration:\n\n`;
            
            // Simulate multiple sources integration
            result += `Multiple Sources Processing:\n`;
            result += `- Source Detection: Identifying and categorizing different sources\n`;
            result += `- Format Standardization: Converting all sources to standard format\n`;
            result += `- Content Integration: Integrating content from multiple sources\n`;
            result += `- Cross-Reference Analysis: Analyzing relationships between sources\n\n`;
            
            // Simulate detection of multiple source elements
            result += `Detection Results:\n`;
            result += `- Sources Detected: 4\n`;
            result += `- Textbook Pages: 2\n`;
            result += `- Worksheet Problems: 5\n`;
            result += `- Online Platform Problems: 3\n`;
            result += `- Handwritten Notes: 1\n\n`;
            
            // Select a random multiple sources problem type
            const multipleTypes = [
                {
                    type: "Comprehensive Algebra Review",
                    problem: "Solve the system of equations: 2x + y - z = 1, x + 2y + z = 8, 3x - y + 2z = 5",
                    steps: [
                        "Label the equations:",
                        "(1) 2x + y - z = 1",
                        "(2) x + 2y + z = 8",
                        "(3) 3x - y + 2z = 5",
                        "Add equations (1) and (2): (2x + y - z) + (x + 2y + z) = 1 + 8",
                        "Simplify: 3x + 3y = 9, so x + y = 3 (Equation 4)",
                        "Multiply equation (2) by 2: 2x + 4y + 2z = 16 (Equation 5)",
                        "Subtract equation (3) from equation (5): (2x + 4y + 2z) - (3x - y + 2z) = 16 - 5",
                        "Simplify: -x + 5y = 11 (Equation 6)",
                        "Add equations (4) and (6): (x + y) + (-x + 5y) = 3 + 11",
                        "Simplify: 6y = 14, so y = 14/6 = 7/3",
                        "Substitute y = 7/3 into equation (4): x + 7/3 = 3",
                        "Solve for x: x = 3 - 7/3 = 9/3 - 7/3 = 2/3",
                        "Substitute x = 2/3 and y = 7/3 into equation (1): 2(2/3) + 7/3 - z = 1",
                        "Simplify: 4/3 + 7/3 - z = 1, so 11/3 - z = 1",
                        "Solve for z: z = 11/3 - 1 = 11/3 - 3/3 = 8/3"
                    ],
                    answer: "x = 2/3, y = 7/3, z = 8/3"
                },
                {
                    type: "Multi-Concept Geometry Problem",
                    problem: "A circle is inscribed in a right triangle with legs 6 cm and 8 cm. Find the radius of the circle.",
                    steps: [
                        "First, find the hypotenuse of the right triangle using the Pythagorean theorem:",
                        "c² = a² + b² = 6² + 8² = 36 + 64 = 100",
                        "c = √100 = 10 cm",
                        "The area of the triangle can be calculated in two ways:",
                        "Area = (1/2) × base × height = (1/2) × 6 × 8 = 24 cm²",
                        "Area = (1/2) × perimeter × inradius (r)",
                        "Perimeter = 6 + 8 + 10 = 24 cm",
                        "Set the two area expressions equal: (1/2) × 24 × r = 24",
                        "Simplify: 12r = 24",
                        "Solve for r: r = 2 cm"
                    ],
                    answer: "2 cm"
                },
                {
                    type: "Integrated Calculus Problem",
                    problem: "Find the volume of the solid generated by revolving the region bounded by y = x², y = 0, and x = 2 about the x-axis.",
                    steps: [
                        "This is a volume of revolution problem using the disk method",
                        "The formula for volume using the disk method is: V = π∫[a to b] [f(x)]² dx",
                        "In this case, f(x) = x², a = 0, and b = 2",
                        "Substitute into the formula: V = π∫[0 to 2] (x²)² dx = π∫[0 to 2] x⁴ dx",
                        "Integrate: V = π[x⁵/5] from 0 to 2",
                        "Evaluate: V = π[(2⁵/5) - (0⁵/5)] = π[32/5 - 0] = 32π/5",
                        "Approximate: V ≈ 32(3.14159)/5 ≈ 20.11 cubic units"
                    ],
                    answer: "32π/5 cubic units or approximately 20.11 cubic units"
                },
                {
                    type: "Cross-Domain Statistics Problem",
                    problem: "A company produces light bulbs with a mean life of 1000 hours and a standard deviation of 100 hours. Assuming a normal distribution, what percentage of bulbs will last between 900 and 1100 hours?",
                    steps: [
                        "This is a normal distribution problem",
                        "We need to find P(900 < X < 1100) where X ~ N(1000, 100²)",
                        "Convert to standard normal distribution (Z-scores):",
                        "Z₁ = (900 - 1000)/100 = -100/100 = -1",
                        "Z₂ = (1100 - 1000)/100 = 100/100 = 1",
                        "P(900 < X < 1100) = P(-1 < Z < 1)",
                        "Using the standard normal table:",
                        "P(Z < 1) = 0.8413",
                        "P(Z < -1) = 0.1587",
                        "P(-1 < Z < 1) = P(Z < 1) - P(Z < -1) = 0.8413 - 0.1587 = 0.6826",
                        "Therefore, approximately 68.26% of bulbs will last between 900 and 1100 hours"
                    ],
                    answer: "Approximately 68.26%"
                }
            ];
            
            const selectedProblem = multipleTypes[Math.floor(Math.random() * multipleTypes.length)];
            
            result += `Solving Problem from Multiple Sources:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add multiple sources-specific features
            result += `Multiple Sources Features:\n`;
            result += `- Source Integration: Seamless integration of multiple source types\n`;
            result += `- Format Standardization: Converting all sources to standard format\n`;
            result += `- Cross-Reference Analysis: Analyzing relationships between sources\n`;
            result += `- Content Consolidation: Consolidating related content from different sources\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Source Comparison: Side-by-side comparison of sources\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n`;
            result += `- Source Attribution: Attributing information to original sources\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Multi-source OCR\n`;
            result += `- Solver: Advanced Math Engine\n`;
            result += `- Latency: ${(Math.random() * 1.0 + 0.8).toFixed(2)} seconds\n`;
            result += `- Source Compatibility: Textbooks, worksheets, online platforms, handwritten notes, etc.\n`;
            
            return result;
        } catch (error) {
            return "Error solving math from multiple sources. Please check your input.";
        }
    }
},

{
    // Pattern to solve math problems with real-world context
    pattern: /solve math with real-world context/i,
    response: () => {
        try {
            let result = `Math Problem Solver - Real-World Context:\n\n`;
            
            // Simulate real-world context processing
            result += `Real-World Context Processing:\n`;
            result += `- Context Analysis: Analyzing real-world context\n`;
            result += `- Scenario Recognition: Recognizing real-world scenarios\n`;
            result += `- Variable Mapping: Mapping real-world quantities to variables\n`;
            result += `- Model Formulation: Formulating mathematical models\n\n`;
            
            // Simulate detection of real-world context elements
            result += `Detection Results:\n`;
            result += `- Real-World Scenarios Detected: 3\n`;
            result += `- Physical Quantities Identified: 8\n`;
            result += `- Units of Measurement Detected: 5\n`;
            result += `- Practical Constraints Identified: 4\n\n`;
            
            // Select a random real-world context problem type
            const realWorldTypes = [
                {
                    type: "Finance Problem",
                    problem: "A car loan of $20,000 is taken out at an annual interest rate of 5% compounded monthly. If the loan is to be repaid over 5 years, what is the monthly payment?",
                    steps: [
                        "Use the formula for monthly loan payments: P = (r·PV)/(1 - (1 + r)^(-n))",
                        "Where P is the monthly payment, r is the monthly interest rate, PV is the present value, and n is the number of payments",
                        "Calculate the monthly interest rate: r = 5%/12 = 0.05/12 ≈ 0.004167",
                        "Calculate the number of payments: n = 5 years × 12 months/year = 60 months",
                        "Substitute into the formula: P = (0.004167 × 20000)/(1 - (1 + 0.004167)^(-60))",
                        "Calculate the numerator: 0.004167 × 20000 ≈ 83.34",
                        "Calculate the denominator: 1 - (1.004167)^(-60) ≈ 1 - 0.7792 = 0.2208",
                        "Calculate the monthly payment: P ≈ 83.34/0.2208 ≈ 377.42"
                    ],
                    answer: "$377.42"
                },
                {
                    type: "Physics Problem",
                    problem: "A ball is thrown vertically upward with an initial velocity of 20 m/s. How long does it take to reach its maximum height, and what is the maximum height?",
                    steps: [
                        "At the maximum height, the final velocity is 0 m/s",
                        "Use the equation: v = u + at, where v is final velocity, u is initial velocity, a is acceleration, and t is time",
                        "For vertical motion, a = -g = -9.8 m/s² (negative because it's downward)",
                        "Substitute: 0 = 20 + (-9.8)t",
                        "Solve for t: 9.8t = 20, so t = 20/9.8 ≈ 2.04 seconds",
                        "To find the maximum height, use the equation: v² = u² + 2as",
                        "Substitute: 0² = 20² + 2(-9.8)s",
                        "Simplify: 0 = 400 - 19.6s",
                        "Solve for s: 19.6s = 400, so s = 400/19.6 ≈ 20.41 meters"
                    ],
                    answer: "Time to reach maximum height: 2.04 seconds, Maximum height: 20.41 meters"
                },
                {
                    type: "Engineering Problem",
                    problem: "A cylindrical water tank has a diameter of 4 meters and a height of 6 meters. If water is flowing into the tank at a rate of 0.5 cubic meters per minute, how long will it take to fill the tank?",
                    steps: [
                        "Calculate the volume of the cylindrical tank: V = πr²h",
                        "Radius r = diameter/2 = 4/2 = 2 meters",
                        "Height h = 6 meters",
                        "Substitute: V = π(2)²(6) = π(4)(6) = 24π cubic meters",
                        "Approximate: V ≈ 24(3.14159) ≈ 75.40 cubic meters",
                        "Calculate the time to fill the tank: time = volume/rate",
                        "Rate = 0.5 cubic meters per minute",
                        "Time = 75.40/0.5 = 150.80 minutes",
                        "Convert to hours and minutes: 150.80 minutes = 2 hours and 30.80 minutes"
                    ],
                    answer: "2 hours and 30.80 minutes"
                },
                {
                    type: "Biology Problem",
                    problem: "A bacteria culture starts with 500 bacteria and doubles every 3 hours. How many bacteria will there be after 24 hours?",
                    steps: [
                        "This is an exponential growth problem",
                        "Use the formula: N = N₀ × 2^(t/d)",
                        "Where N is the final number of bacteria, N₀ is the initial number, t is time, and d is doubling time",
                        "Substitute the given values: N = 500 × 2^(24/3)",
                        "Simplify: N = 500 × 2^8",
                        "Calculate: 2^8 = 256",
                        "Final calculation: N = 500 × 256 = 128,000"
                    ],
                    answer: "128,000 bacteria"
                }
            ];
            
            const selectedProblem = realWorldTypes[Math.floor(Math.random() * realWorldTypes.length)];
            
            result += `Solving Problem with Real-World Context:\n\n`;
            result += `Problem Type: ${selectedProblem.type}\n`;
            result += `Problem Statement: ${selectedProblem.problem}\n\n`;
            result += `Solution Steps:\n`;
            
            selectedProblem.steps.forEach((step, index) => {
                result += `${index + 1}. ${step}\n`;
            });
            
            result += `\nFinal Answer: ${selectedProblem.answer}\n\n`;
            
            // Add real-world context-specific features
            result += `Real-World Context Features:\n`;
            result += `- Scenario Recognition: Recognizing real-world scenarios\n`;
            result += `- Variable Mapping: Mapping real-world quantities to variables\n`;
            result += `- Unit Analysis: Analyzing and converting units of measurement\n`;
            result += `- Practical Constraints: Considering practical constraints\n\n`;
            
            // Add visualization information
            result += `Visualization Features:\n`;
            result += `- Scenario Diagram: Illustrating the real-world scenario\n`;
            result += `- Step-by-Step Solution: Clear progression through solving process\n`;
            result += `- Interactive Elements: Tappable elements for more information\n`;
            result += `- Real-World Application: Showing how the solution applies to the real world\n\n`;
            
            // Add processing information
            result += `Processing Information:\n`;
            result += `- Recognition Engine: Context-aware OCR\n`;
            result += `- Solver: Advanced Math Engine with real-world knowledge\n`;
            result += `- Latency: ${(Math.random() * 0.8 + 0.6).toFixed(2)} seconds\n`;
            result += `- Domain Compatibility: Finance, Physics, Engineering, Biology, etc.\n`;
            
            return result;
        } catch (error) {
            return "Error solving math with real-world context. Please check your input.";
        }
    }
},


{
    // Pattern to simulate speech synthesis
    pattern: /synthesize speech for (.+) with (.+) voice/i,
    response: (match) => {
        try {
            const text = match[1];
            const voiceType = match[2];
            
            // Simulate speech synthesis
            let result = `Speech Synthesis:\n\n`;
            result += `Text: "${text}"\n`;
            result += `Voice Type: ${voiceType}\n\n`;
            
            // Determine voice characteristics
            let voiceCharacteristics = {};
            
            if (voiceType.toLowerCase().includes("male")) {
                voiceCharacteristics = {
                    gender: "Male",
                    pitch: "Low to Medium",
                    speed: "Medium",
                    age: "Adult"
                };
            } else if (voiceType.toLowerCase().includes("female")) {
                voiceCharacteristics = {
                    gender: "Female",
                    pitch: "Medium to High",
                    speed: "Medium",
                    age: "Adult"
                };
            } else if (voiceType.toLowerCase().includes("child")) {
                voiceCharacteristics = {
                    gender: voiceType.toLowerCase().includes("boy") ? "Male" : 
                              voiceType.toLowerCase().includes("girl") ? "Female" : "Neutral",
                    pitch: "High",
                    speed: "Medium to Fast",
                    age: "Child"
                };
            } else if (voiceType.toLowerCase().includes("elderly") || voiceType.toLowerCase().includes("old")) {
                voiceCharacteristics = {
                    gender: voiceType.toLowerCase().includes("man") ? "Male" : 
                              voiceType.toLowerCase().includes("woman") ? "Female" : "Neutral",
                    pitch: "Low",
                    speed: "Slow",
                    age: "Elderly"
                };
            } else {
                // Default voice
                voiceCharacteristics = {
                    gender: "Neutral",
                    pitch: "Medium",
                    speed: "Medium",
                    age: "Adult"
                };
            }
            
            // Display voice characteristics
            result += `Voice Characteristics:\n`;
            result += `- Gender: ${voiceCharacteristics.gender}\n`;
            result += `- Pitch: ${voiceCharacteristics.pitch}\n`;
            result += `- Speed: ${voiceCharacteristics.speed}\n`;
            result += `- Age: ${voiceCharacteristics.age}\n\n`;
            
            // Calculate speech duration
            const wordCount = text.split(/\s+/).length;
            let wordsPerMinute;
            
            switch (voiceCharacteristics.speed) {
                case "Slow":
                    wordsPerMinute = 130;
                    break;
                case "Medium to Fast":
                    wordsPerMinute = 180;
                    break;
                case "Fast":
                    wordsPerMinute = 200;
                    break;
                default:
                    wordsPerMinute = 160;
            }
            
            const durationSeconds = (wordCount / wordsPerMinute) * 60;
            const minutes = Math.floor(durationSeconds / 60);
            const seconds = Math.round(durationSeconds % 60);
            
            result += `Speech Properties:\n`;
            result += `- Word Count: ${wordCount}\n`;
            result += `- Estimated Duration: ${minutes} minute${minutes !== 1 ? 's' : ''} ${seconds} second${seconds !== 1 ? 's' : ''}\n`;
            result += `- Speaking Rate: ${wordsPerMinute} words per minute\n\n`;
            
            // Add prosody information
            result += `Prosody Analysis:\n`;
            
            // Analyze text for prosody cues
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const questions = text.match(/\?/g) || [];
            const exclamations = text.match(/!/g) || [];
            
            result += `- Sentences: ${sentences.length}\n`;
            result += `- Questions: ${questions.length}\n`;
            result += `- Exclamations: ${exclamations.length}\n`;
            
            // Determine intonation patterns
            if (questions.length > exclamations.length && questions.length > sentences.length / 3) {
                result += `- Predominant Intonation: Rising (questioning)\n`;
            } else if (exclamations.length > questions.length && exclamations.length > sentences.length / 3) {
                result += `- Predominant Intonation: Exclamatory (emotional)\n`;
            } else {
                result += `- Predominant Intonation: Declarative (neutral)\n`;
            }
            
            // Add phoneme count estimation
            const phonemeEstimate = Math.round(wordCount * 4.5); // Average of 4.5 phonemes per word in English
            result += `- Estimated Phonemes: ${phonemeEstimate}\n\n`;
            
            // Add synthesis information
            result += `Synthesis Information:\n`;
            result += `- Synthesis Method: Concatenative Synthesis\n`;
            result += `- Audio Format: WAV (44.1kHz, 16-bit)\n`;
            result += `- File Size Estimate: ${(durationSeconds * 176).toFixed(1)} KB\n`;
            result += `- Processing Time: ${(Math.random() * 200 + 100).toFixed(1)}ms\n`;
            
            return result;
        } catch (error) {
            return "Error synthesizing speech. Please check your input.";
        }
    }
},

{
    // Pattern to simulate speech recognition
    pattern: /recognize speech with (.+) accuracy/i,
    response: (match) => {
        try {
            const accuracyLevel = match[1];
            
            // Determine accuracy based on level
            let targetAccuracy;
            let errorRate;
            
            if (accuracyLevel.toLowerCase().includes("high") || accuracyLevel.toLowerCase().includes("excellent")) {
                targetAccuracy = 0.95;
                errorRate = 0.05;
            } else if (accuracyLevel.toLowerCase().includes("medium") || accuracyLevel.toLowerCase().includes("good")) {
                targetAccuracy = 0.85;
                errorRate = 0.15;
            } else if (accuracyLevel.toLowerCase().includes("low") || accuracyLevel.toLowerCase().includes("basic")) {
                targetAccuracy = 0.70;
                errorRate = 0.30;
            } else {
                // Default to medium accuracy
                targetAccuracy = 0.85;
                errorRate = 0.15;
            }
            
            // Simulate speech recognition
            let result = `Speech Recognition with ${accuracyLevel} Accuracy:\n\n`;
            
            // Generate sample audio properties
            const duration = Math.random() * 30 + 10; // 10-40 seconds
            const sampleRate = 16000; // 16kHz
            const channels = 1; // Mono
            const bitDepth = 16; // 16-bit
            
            result += `Audio Properties:\n`;
            result += `- Duration: ${duration.toFixed(1)} seconds\n`;
            result += `- Sample Rate: ${sampleRate} Hz\n`;
            result += `- Channels: ${channels}\n`;
            result += `- Bit Depth: ${bitDepth}-bit\n`;
            result += `- File Size: ${(duration * sampleRate * channels * bitDepth / 8 / 1024).toFixed(1)} KB\n\n`;
            
            // Generate transcription
            const sampleTranscriptions = [
                "Hello, this is a test of the speech recognition system. The audio quality is good, so the transcription should be highly accurate.",
                "Speech recognition technology has improved significantly in recent years, making it useful for many applications including virtual assistants and transcription services.",
                "The quick brown fox jumps over the lazy dog. This pangram contains every letter of the alphabet and is often used to test typing and recognition systems.",
                "Machine learning algorithms have revolutionized the field of automatic speech recognition, enabling more accurate and natural interactions between humans and computers.",
                "Weather today will be partly cloudy with a high of seventy-five degrees and a low of sixty degrees. There is a twenty percent chance of rain in the evening."
            ];
            
            const transcription = sampleTranscriptions[Math.floor(Math.random() * sampleTranscriptions.length)];
            
            // Introduce errors based on error rate
            const words = transcription.split(' ');
            const errorWords = ["the", "a", "is", "of", "in", "it", "to", "and"];
            
            for (let i = 0; i < words.length; i++) {
                if (errorWords.includes(words[i].toLowerCase()) && Math.random() < errorRate) {
                    // Replace with a similar word
                    if (words[i].toLowerCase() === "the") words[i] = Math.random() > 0.5 ? "a" : "an";
                    if (words[i].toLowerCase() === "a") words[i] = Math.random() > 0.5 ? "the" : "an";
                    if (words[i].toLowerCase() === "is") words[i] = Math.random() > 0.5 ? "was" : "are";
                    if (words[i].toLowerCase() === "of") words[i] = Math.random() > 0.5 ? "for" : "from";
                    if (words[i].toLowerCase() === "in") words[i] = Math.random() > 0.5 ? "on" : "at";
                    if (words[i].toLowerCase() === "it") words[i] = Math.random() > 0.5 ? "this" : "that";
                    if (words[i].toLowerCase() === "to") words[i] = Math.random() > 0.5 ? "for" : "from";
                    if (words[i].toLowerCase() === "and") words[i] = Math.random() > 0.5 ? "or" : "but";
                }
            }
            
            const recognizedText = words.join(' ');
            
            result += `Recognition Results:\n\n`;
            result += `Original Text:\n"${transcription}"\n\n`;
            result += `Recognized Text:\n"${recognizedText}"\n\n`;
            
            // Calculate actual accuracy
            const originalWords = transcription.toLowerCase().split(' ');
            const recognizedWords = recognizedText.toLowerCase().split(' ');
            
            let correctWords = 0;
            
            for (let i = 0; i < Math.min(originalWords.length, recognizedWords.length); i++) {
                if (originalWords[i] === recognizedWords[i]) {
                    correctWords++;
                }
            }
            
            const actualAccuracy = correctWords / originalWords.length;
            const actualErrorRate = 1 - actualAccuracy;
            
            result += `Accuracy Metrics:\n`;
            result += `- Target Accuracy: ${(targetAccuracy * 100).toFixed(1)}%\n`;
            result += `- Actual Accuracy: ${(actualAccuracy * 100).toFixed(1)}%\n`;
            result += `- Word Error Rate: ${(actualErrorRate * 100).toFixed(1)}%\n`;
            result += `- Correct Words: ${correctWords}/${originalWords.length}\n\n`;
            
            // Add recognition details
            result += `Recognition Details:\n`;
            result += `- Recognition Engine: Simulated Deep Speech Model\n`;
            result += `- Language Model: N-gram with Neural Network LM\n`;
            result += `- Acoustic Model: TDNN (Time Delay Neural Network)\n`;
            result += `- Processing Time: ${(duration * 0.3 + Math.random() * 0.2).toFixed(1)} seconds\n`;
            result += `- Confidence Score: ${(Math.random() * 0.2 + actualAccuracy - 0.1).toFixed(3)}\n`;
            
            // Add confidence scores for each word
            result += `\nWord-Level Confidence Scores:\n`;
            
            for (let i = 0; i < Math.min(10, recognizedWords.length); i++) {
                const wordConfidence = Math.random() * 0.3 + actualAccuracy - 0.15;
                result += `- ${recognizedWords[i]}: ${Math.max(0, Math.min(1, wordConfidence)).toFixed(3)}\n`;
            }
            
            if (recognizedWords.length > 10) {
                result += `- ... and ${recognizedWords.length - 10} more words\n`;
            }
            
            return result;
        } catch (error) {
            return "Error recognizing speech. Please check your input.";
        }
    }
},
{
    // Pattern to perform speech-to-text simulation
    pattern: /transcribe speech (.+)/i,
    response: (match) => {
        try {
            const speechDescription = match[1];
            
            // This is a simulated speech-to-text transcription
            // In a real application, you would use a proper speech recognition service
            
            // Extract potential content from the description
            const contentKeywords = speechDescription.toLowerCase();
            
            let transcription;
            
            if (contentKeywords.includes('meeting')) {
                transcription = `Good morning everyone, thank you for joining today's meeting. We have several important items on our agenda. ` +
                               `First, let's review the progress on our current projects. The development team has made significant strides on the new platform, ` +
                               `and we're on track to meet our Q3 launch date. Second, we need to discuss the marketing strategy for the upcoming product release. ` +
                               `The marketing department has prepared a comprehensive plan that includes social media campaigns, influencer partnerships, and targeted advertising. ` +
                               `Finally, we'll address the budget allocation for the next fiscal year. Please come prepared with your department's needs and priorities. ` +
                               `Are there any questions before we begin?`;
            } else if (contentKeywords.includes('lecture') || contentKeywords.includes('education')) {
                transcription = `Welcome to today's lecture on the fundamentals of computer science. In this session, we'll explore the basic concepts that form ` +
                               `the foundation of modern computing. We'll begin with an overview of binary systems and how computers process information using only two digits: 0 and 1. ` +
                               `From there, we'll move on to discuss algorithms and data structures, which are essential building blocks for creating efficient software. ` +
                               `We'll also cover programming paradigms, including procedural, object-oriented, and functional approaches. By the end of this course, ` +
                               `you'll have a solid understanding of these core principles and be prepared for more advanced topics in computer science.`;
            } else if (contentKeywords.includes('interview')) {
                transcription = `Interviewer: Thank you for coming in today. Could you start by telling us a little about yourself and your background? ` +
                               `Candidate: Certainly. I graduated with a degree in computer science five years ago and have been working as a software developer ever since. ` +
                               `I specialize in front-end development and have experience with various frameworks including React and Angular. In my current role, ` +
                               `I led a team that redesigned our company's customer portal, resulting in a 30% increase in user engagement. I'm passionate about creating ` +
                               `intuitive user experiences and enjoy solving complex problems. I'm excited about the opportunity to bring my skills to your organization.`;
            } else if (contentKeywords.includes('presentation')) {
                transcription = `Good afternoon, everyone. Thank you for attending today's presentation on sustainable business practices. ` +
                               `Over the next thirty minutes, I'll be sharing insights on how companies can reduce their environmental impact while maintaining profitability. ` +
                               `We'll explore three key areas: energy efficiency, waste reduction, and sustainable supply chains. For each area, I'll provide case studies ` +
                               `of businesses that have successfully implemented these practices and the benefits they've realized. We'll also discuss practical steps ` +
                               `that organizations of any size can take to begin their sustainability journey. By the end of this presentation, you'll have a clear understanding ` +
                               `of why sustainability matters and how to make it a core part of your business strategy.`;
            } else {
                transcription = `Hello, this is a simulated transcription of the speech you described. In a real speech-to-text system, ` +
                               `audio would be processed and converted to written text using advanced speech recognition algorithms. ` +
                               `These systems analyze the acoustic patterns, phonemes, and linguistic context to accurately transcribe spoken words. ` +
                               `Modern speech recognition can handle various accents, speaking styles, and background noise to produce highly accurate transcriptions. ` +
                               `This technology is used in numerous applications, from virtual assistants and transcription services to accessibility tools for the hearing impaired.`;
            }
            
            return `Speech Transcription:\n\n${transcription}`;
        } catch (error) {
            return "Error transcribing speech. Please check your input.";
        }
    }
},

{
    // Pattern to perform text-to-speech simulation
    pattern: /generate speech for (.+)/i,
    response: (match) => {
        try {
            const text = match[1];
            
            // This is a simulated text-to-speech response
            // In a real application, you would use a proper TTS service
            
            // Analyze the text to determine speech characteristics
            const wordCount = text.split(/\s+/).length;
            const sentenceCount = text.split(/[.!?]+/).filter(s => s.trim().length > 0).length;
            const avgWordsPerSentence = wordCount / sentenceCount;
            
            // Estimate speech duration (average speaking rate is about 150 words per minute)
            const estimatedDurationMinutes = wordCount / 150;
            const minutes = Math.floor(estimatedDurationMinutes);
            const seconds = Math.round((estimatedDurationMinutes - minutes) * 60);
            
            // Determine speech characteristics
            let speechType = "Normal";
            if (text.includes('!')) speechType = "Excited";
            if (text.includes('?')) speechType = "Inquisitive";
            if (text.toLowerCase().includes('important') || text.toLowerCase().includes('urgent')) speechType = "Serious";
            
            // Generate response
            return `Text-to-Speech Simulation:\n\n` +
                   `Text: "${text}"\n\n` +
                   `Speech Characteristics:\n` +
                   `- Type: ${speechType}\n` +
                   `- Word Count: ${wordCount}\n` +
                   `- Sentence Count: ${sentenceCount}\n` +
                   `- Average Words per Sentence: ${avgWordsPerSentence.toFixed(1)}\n` +
                   `- Estimated Duration: ${minutes} minute${minutes !== 1 ? 's' : ''} ${seconds} second${seconds !== 1 ? 's' : ''}\n\n` +
                   `Note: This is a simulation of text-to-speech. For actual speech generation, ` +
                   `use a proper TTS service that would convert the text to spoken audio.`;
        } catch (error) {
            return "Error generating speech. Please check your input.";
        }
    }
},

{
    // Pattern to convert text to NATO phonetic alphabet
    pattern: /convert (.+) to nato phonetic alphabet/i,
    response: (match) => {
        try {
            const text = match[1].toLowerCase();
            const natoPhonetic = {
                'a': 'Alfa', 'b': 'Bravo', 'c': 'Charlie', 'd': 'Delta', 'e': 'Echo',
                'f': 'Foxtrot', 'g': 'Golf', 'h': 'Hotel', 'i': 'India', 'j': 'Juliett',
                'k': 'Kilo', 'l': 'Lima', 'm': 'Mike', 'n': 'November', 'o': 'Oscar',
                'p': 'Papa', 'q': 'Quebec', 'r': 'Romeo', 's': 'Sierra', 't': 'Tango',
                'u': 'Uniform', 'v': 'Victor', 'w': 'Whiskey', 'x': 'X-ray', 'y': 'Yankee', 'z': 'Zulu',
                '0': 'Zero', '1': 'One', '2': 'Two', '3': 'Three', '4': 'Four',
                '5': 'Five', '6': 'Six', '7': 'Seven', '8': 'Eight', '9': 'Nine'
            };
            
            const phoneticText = text.split('').map(char => natoPhonetic[char] || char).join(' ');
            return phoneticText;
        } catch (error) {
            return "Error converting to NATO phonetic alphabet. Please check your input.";
        }
    }
},

{
    // Pattern to generate a lorem ipsum text
    pattern: /generate lorem ipsum with (\d+) words/i,
    response: (match) => {
        try {
            const wordCount = parseInt(match[1]);
            if (wordCount < 1) return "Word count must be at least 1";
            if (wordCount > 500) return "Word count cannot exceed 500";
            
            const loremWords = [
                'lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit',
                'sed', 'do', 'eiusmod', 'tempor', 'incididunt', 'ut', 'labore', 'et', 'dolore',
                'magna', 'aliqua', 'enim', 'ad', 'minim', 'veniam', 'quis', 'nostrud',
                'exercitation', 'ullamco', 'laboris', 'nisi', 'aliquip', 'ex', 'ea', 'commodo',
                'consequat', 'duis', 'aute', 'irure', 'in', 'reprehenderit', 'voluptate',
                'velit', 'esse', 'cillum', 'fugiat', 'nulla', 'pariatur', 'excepteur', 'sint',
                'occaecat', 'cupidatat', 'non', 'proident', 'sunt', 'culpa', 'qui', 'officia',
                'deserunt', 'mollit', 'anim', 'id', 'est', 'laborum'
            ];
            
            let loremText = '';
            for (let i = 0; i < wordCount; i++) {
                const randomIndex = Math.floor(Math.random() * loremWords.length);
                loremText += loremWords[randomIndex];
                
                // Capitalize the first letter of the first word
                if (i === 0) {
                    loremText = loremText.charAt(0).toUpperCase() + loremText.slice(1);
                }
                
                // Add space after each word except the last one
                if (i < wordCount - 1) {
                    loremText += ' ';
                }
                
                // Add a period at the end
                if (i === wordCount - 1) {
                    loremText += '.';
                }
            }
            
            return loremText;
        } catch (error) {
            return "Error generating lorem ipsum text. Please check your input.";
        }
    }
},


{
    // Pattern to find prime factors
    pattern: /prime factors of (\d+)/i,
    response: (match) => {
        try {
            const num = parseInt(match[1]);
            if (num <= 1) return "Prime factors are not defined for numbers less than 2";
            
            const factors = [];
            let n = num;
            
            for (let i = 2; i <= n; i++) {
                while (n % i === 0) {
                    factors.push(i);
                    n = n / i;
                }
            }
            
            return `Prime factors of ${num}: ${factors.join(', ')}`;
        } catch (error) {
            return "Error finding prime factors. Please enter a valid integer greater than 1.";
        }
    }
},

{
    // Pattern to calculate LCM (Least Common Multiple)
    pattern: /lcm of (\d+) and (\d+)/i,
    response: (match) => {
        try {
            const a = parseInt(match[1]);
            const b = parseInt(match[2]);
            if (a <= 0 || b <= 0) return "Numbers must be positive integers";
            
            const gcd = (x, y) => {
                return y === 0 ? x : gcd(y, x % y);
            };
            
            const lcm = (a * b) / gcd(a, b);
            
            return `The LCM of ${a} and ${b} is ${lcm}`;
        } catch (error) {
            return "Error calculating LCM. Please enter valid positive integers.";
        }
    }
},

{
    // Pattern to solve a quadratic equation
    pattern: /solve quadratic equation (.+)x\^2 \+ (.+)x \+ (.+) = 0/i,
    response: (match) => {
        try {
            const a = parseFloat(match[1]);
            const b = parseFloat(match[2]);
            const c = parseFloat(match[3]);
            
            if (a === 0) return "This is not a quadratic equation (a cannot be 0)";
            
            const discriminant = b * b - 4 * a * c;
            
            if (discriminant < 0) {
                return "The equation has no real solutions";
            } else if (discriminant === 0) {
                const x = -b / (2 * a);
                return `The equation has one real solution: x = ${x}`;
            } else {
                const x1 = (-b + Math.sqrt(discriminant)) / (2 * a);
                const x2 = (-b - Math.sqrt(discriminant)) / (2 * a);
                return `The equation has two real solutions: x1 = ${x1.toFixed(4)}, x2 = ${x2.toFixed(4)}`;
            }
        } catch (error) {
            return "Error solving quadratic equation. Please enter valid coefficients.";
        }
    }
},

{
    // Pattern to calculate speed
    pattern: /calculate speed: distance (\d+) km, time (\d+) hours/i,
    response: (match) => {
        try {
            const distance = parseFloat(match[1]);
            const time = parseFloat(match[2]);
            if (time <= 0) return "Time must be a positive number";
            const speed = distance / time;
            return `Speed is ${speed.toFixed(2)} km/h`;
        } catch (error) {
            return "Error calculating speed. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate distance
    pattern: /calculate distance: speed (\d+) km\/h, time (\d+) hours/i,
    response: (match) => {
        try {
            const speed = parseFloat(match[1]);
            const time = parseFloat(match[2]);
            if (speed < 0 || time < 0) return "Speed and time must be non-negative numbers";
            const distance = speed * time;
            return `Distance is ${distance.toFixed(2)} km`;
        } catch (error) {
            return "Error calculating distance. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate time
    pattern: /calculate time: distance (\d+) km, speed (\d+) km\/h/i,
    response: (match) => {
        try {
            const distance = parseFloat(match[1]);
            const speed = parseFloat(match[2]);
            if (speed <= 0) return "Speed must be a positive number";
            if (distance < 0) return "Distance must be a non-negative number";
            const time = distance / speed;
            return `Time is ${time.toFixed(2)} hours`;
        } catch (error) {
            return "Error calculating time. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate volume of a sphere
    pattern: /volume of sphere with radius (\d+)/i,
    response: (match) => {
        try {
            const radius = parseFloat(match[1]);
            if (radius < 0) return "Radius cannot be negative";
            const volume = (4/3) * Math.PI * radius * radius * radius;
            return `The volume of the sphere is ${volume.toFixed(2)}`;
        } catch (error) {
            return "Error calculating sphere volume. Please enter a valid number.";
        }
    }
},

{
    // Pattern to calculate volume of a cylinder
    pattern: /volume of cylinder with radius (\d+) and height (\d+)/i,
    response: (match) => {
        try {
            const radius = parseFloat(match[1]);
            const height = parseFloat(match[2]);
            if (radius < 0 || height < 0) return "Radius and height cannot be negative";
            const volume = Math.PI * radius * radius * height;
            return `The volume of the cylinder is ${volume.toFixed(2)}`;
        } catch (error) {
            return "Error calculating cylinder volume. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate surface area of a cube
    pattern: /surface area of cube with side (\d+)/i,
    response: (match) => {
        try {
            const side = parseFloat(match[1]);
            if (side < 0) return "Side length cannot be negative";
            const surfaceArea = 6 * side * side;
            return `The surface area of the cube is ${surfaceArea}`;
        } catch (error) {
            return "Error calculating cube surface area. Please enter a valid number.";
        }
    }
},

{
    // Pattern to calculate surface area of a sphere
    pattern: /surface area of sphere with radius (\d+)/i,
    response: (match) => {
        try {
            const radius = parseFloat(match[1]);
            if (radius < 0) return "Radius cannot be negative";
            const surfaceArea = 4 * Math.PI * radius * radius;
            return `The surface area of the sphere is ${surfaceArea.toFixed(2)}`;
        } catch (error) {
            return "Error calculating sphere surface area. Please enter a valid number.";
        }
    }
},

{
    // Pattern to calculate perimeter of a rectangle
    pattern: /perimeter of rectangle with width (\d+) and height (\d+)/i,
    response: (match) => {
        try {
            const width = parseFloat(match[1]);
            const height = parseFloat(match[2]);
            if (width < 0 || height < 0) return "Width and height cannot be negative";
            const perimeter = 2 * (width + height);
            return `The perimeter of the rectangle is ${perimeter}`;
        } catch (error) {
            return "Error calculating rectangle perimeter. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate circumference of a circle
    pattern: /circumference of circle with radius (\d+)/i,
    response: (match) => {
        try {
            const radius = parseFloat(match[1]);
            if (radius < 0) return "Radius cannot be negative";
            const circumference = 2 * Math.PI * radius;
            return `The circumference of the circle is ${circumference.toFixed(2)}`;
        } catch (error) {
            return "Error calculating circle circumference. Please enter a valid number.";
        }
    }
},

{
    // Pattern to calculate simple probability
    pattern: /probability of (\d+) favorable outcomes out of (\d+) total outcomes/i,
    response: (match) => {
        try {
            const favorable = parseInt(match[1]);
            const total = parseInt(match[2]);
            if (total <= 0) return "Total outcomes must be a positive number";
            if (favorable < 0 || favorable > total) return "Favorable outcomes must be between 0 and total outcomes";
            const probability = favorable / total;
            const percentage = probability * 100;
            return `The probability is ${probability.toFixed(4)} or ${percentage.toFixed(2)}%`;
        } catch (error) {
            return "Error calculating probability. Please enter valid integers.";
        }
    }
},

{
    // Pattern to calculate combinations (n choose k)
    pattern: /combinations of (\d+) items taken (\d+) at a time/i,
    response: (match) => {
        try {
            const n = parseInt(match[1]);
            const k = parseInt(match[2]);
            if (n < 0 || k < 0) return "n and k must be non-negative integers";
            if (k > n) return "k cannot be greater than n";
            
            const factorial = (num) => {
                if (num <= 1) return 1;
                return num * factorial(num - 1);
            };
            
            const combinations = factorial(n) / (factorial(k) * factorial(n - k));
            
            return `There are ${combinations} combinations of ${n} items taken ${k} at a time`;
        } catch (error) {
            return "Error calculating combinations. Please enter valid non-negative integers.";
        }
    }
},

{
    // Pattern to calculate permutations (n permute k)
    pattern: /permutations of (\d+) items taken (\d+) at a time/i,
    response: (match) => {
        try {
            const n = parseInt(match[1]);
            const k = parseInt(match[2]);
            if (n < 0 || k < 0) return "n and k must be non-negative integers";
            if (k > n) return "k cannot be greater than n";
            
            const factorial = (num) => {
                if (num <= 1) return 1;
                return num * factorial(num - 1);
            };
            
            const permutations = factorial(n) / factorial(n - k);
            
            return `There are ${permutations} permutations of ${n} items taken ${k} at a time`;
        } catch (error) {
            return "Error calculating permutations. Please enter valid non-negative integers.";
        }
    }
},
{
    // Pattern to check if a number is prime
    pattern: /is (\d+) a prime number/i,
    response: (match) => {
        try {
            const num = parseInt(match[1]);
            if (num <= 1) return `${num} is not a prime number`;
            if (num === 2) return `${num} is a prime number`;
            if (num % 2 === 0) return `${num} is not a prime number`;
            
            for (let i = 3; i <= Math.sqrt(num); i += 2) {
                if (num % i === 0) return `${num} is not a prime number`;
            }
            
            return `${num} is a prime number`;
        } catch (error) {
            return "Error checking prime number. Please enter a valid integer.";
        }
    }
},

{
    // Pattern to calculate GCD (Greatest Common Divisor)
    pattern: /gcd of (\d+) and (\d+)/i,
    response: (match) => {
        try {
            const a = parseInt(match[1]);
            const b = parseInt(match[2]);
            
            const gcd = (x, y) => {
                return y === 0 ? x : gcd(y, x % y);
            };
            
            return `The GCD of ${a} and ${b} is ${gcd(a, b)}`;
        } catch (error) {
            return "Error calculating GCD. Please enter valid integers.";
        }
    }
},

{
    // Pattern to calculate volume of a cube
    pattern: /volume of cube with side (\d+)/i,
    response: (match) => {
        try {
            const side = parseInt(match[1]);
            const volume = side * side * side;
            return `The volume of the cube is ${volume}`;
        } catch (error) {
            return "Error calculating cube volume. Please enter a valid number.";
        }
    }
},

{
    // Pattern to calculate hypotenuse of a right triangle
    pattern: /hypotenuse of triangle with sides (\d+) and (\d+)/i,
    response: (match) => {
        try {
            const a = parseInt(match[1]);
            const b = parseInt(match[2]);
            const hypotenuse = Math.sqrt(a * a + b * b);
            return `The hypotenuse is ${hypotenuse.toFixed(2)}`;
        } catch (error) {
            return "Error calculating hypotenuse. Please enter valid numbers.";
        }
    }
},

{
    // Pattern to calculate the sum of numbers
    pattern: /sum of (.+)/i,
    response: (match) => {
        const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
        const sum = numbers.reduce((acc, curr) => acc + curr, 0);
        return `The sum is: ${sum}`;
    }
},

{
    // Pattern to calculate the average of numbers
    pattern: /average of (.+)/i,
    response: (match) => {
        const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
        const average = numbers.reduce((acc, curr) => acc + curr, 0) / numbers.length;
        return `The average is: ${average.toFixed(2)}`;
    }
},

{
    // Pattern to sort numbers in ascending order
    pattern: /sort (.+) in ascending order/i,
    response: (match) => {
        const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
        const sorted = numbers.sort((a, b) => a - b);
        return `Sorted in ascending order: ${sorted.join(', ')}`;
    }
},

{
    // Pattern to sort numbers in descending order
    pattern: /sort (.+) in descending order/i,
    response: (match) => {
        const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
        const sorted = numbers.sort((a, b) => b - a);
        return `Sorted in descending order: ${sorted.join(', ')}`;
    }
},

{
    // Pattern to count the number of items in a list
    pattern: /count items in (.+)/i,
    response: (match) => {
        const items = match[1].split(',').map(item => item.trim());
        return `There are ${items.length} items in the list`;
    }
},

{
    // Pattern to convert text to uppercase
    pattern: /convert (.+) to uppercase/i,
    response: (match) => {
        return match[1].toUpperCase();
    }
},

{
    // Pattern to convert text to lowercase
    pattern: /convert (.+) to lowercase/i,
    response: (match) => {
        return match[1].toLowerCase();
    }
},

{
    // Pattern to reverse a string
    pattern: /reverse (.+)/i,
    response: (match) => {
        return match[1].split('').reverse().join('');
    }
},

{
    // Pattern to check if a number is even or odd
    pattern: /is (\d+) even or odd/i,
    response: (match) => {
        const num = parseInt(match[1]);
        return `${num} is ${num % 2 === 0 ? 'even' : 'odd'}`;
    }
},

{
    // Pattern to calculate factorial
    pattern: /factorial of (\d+)/i,
    response: (match) => {
        const num = parseInt(match[1]);
        let result = 1;
        for (let i = 2; i <= num; i++) {
            result *= i;
        }
        return `The factorial of ${num} is ${result}`;
    }
},

{
    // Pattern to check if a word is a palindrome
    pattern: /is (.+) a palindrome/i,
    response: (match) => {
        const word = match[1].toLowerCase().replace(/[^a-z0-9]/g, '');
        const reversed = word.split('').reverse().join('');
        return `${match[1]} is ${word === reversed ? 'a palindrome' : 'not a palindrome'}`;
    }
},

{
    // Pattern to calculate area of a rectangle
    pattern: /area of rectangle with width (\d+) and height (\d+)/i,
    response: (match) => {
        const width = parseInt(match[1]);
        const height = parseInt(match[2]);
        const area = width * height;
        return `The area of the rectangle is ${area}`;
    }
},

{
    // Pattern to calculate area of a circle
    pattern: /area of circle with radius (\d+)/i,
    response: (match) => {
        const radius = parseInt(match[1]);
        const area = Math.PI * radius * radius;
        return `The area of the circle is ${area.toFixed(2)}`;
    }
},

{
    // Pattern to convert Celsius to Fahrenheit
    pattern: /convert (\d+) celsius to fahrenheit/i,
    response: (match) => {
        const celsius = parseInt(match[1]);
        const fahrenheit = (celsius * 9/5) + 32;
        return `${celsius}°C is equal to ${fahrenheit.toFixed(2)}°F`;
    }
},

{
    // Pattern to convert Fahrenheit to Celsius
    pattern: /convert (\d+) fahrenheit to celsius/i,
    response: (match) => {
        const fahrenheit = parseInt(match[1]);
        const celsius = (fahrenheit - 32) * 5/9;
        return `${fahrenheit}°F is equal to ${celsius.toFixed(2)}°C`;
    }
},


{ 
    pattern: /random number between (\d+) and (\d+)/i, 
    response: (match) => {
        const min = parseInt(match[1]);
        const max = parseInt(match[2]);
        const randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;
        return `The random number between ${min} and ${max} is: ${randomNumber}`;
    }
},{
    pattern: /generate password with (\d+) characters/i,
    response: (match) => {
        const length = parseInt(match[1]);
        const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_-+=<>?";
        let password = "";
        
        for (let i = 0; i < length; i++) {
            const randomIndex = Math.floor(Math.random() * charset.length);
            password += charset[randomIndex];
        }

        return `Your generated password is: ${password}`;
    }
},{
    pattern: /name an animal/i,
    response: () => {
        const animals = [
            "Lion", "Tiger", "Elephant", "Giraffe", "Zebra", 
            "Panda", "Kangaroo", "Koala", "Penguin", "Cheetah", 
            "Bear", "Wolf", "Gorilla", "Hippo", "Sloth", 
            "Rhino", "Leopard", "Hawk", "Eagle", "Owl", 
            "Shark", "Whale", "Dolphin", "Crocodile", "Alligator", 
            "Octopus", "Starfish", "Turtle", "Snake", "Lizard"
        ];
        const randomAnimal = animals[Math.floor(Math.random() * animals.length)];
        return `Here is an animal: ${randomAnimal}`;
    }
},{
    pattern: /what sound does a (.+) make/i,
    response: (match) => {
        const animal = match[1].toLowerCase();
        const sounds = {
            "dog": "bark",
            "cat": "meow",
            "cow": "moo",
            "sheep": "baa",
            "lion": "roar",
            "duck": "quack",
            "bird": "chirp",
            "horse": "neigh",
            "elephant": "trumpet",
            "snake": "hiss"
        };
        const sound = sounds[animal] || "I don't know the sound of that animal.";
        return `A ${animal} makes a ${sound}.`;
    }
},{
    pattern: /tell me a fact about (.+)/i,
    response: (match) => {
        const facts = {
            "lion": "Lions are the only cats that live in groups, called prides.",
            "tiger": "Tigers have striped skin, not just striped fur.",
            "elephant": "Elephants are the largest land animals on Earth.",
            "giraffe": "Giraffes are the tallest mammals on Earth.",
            "penguin": "Penguins are birds that cannot fly but are excellent swimmers.",
            "koala": "Koalas sleep up to 18 hours a day."
        };
        const animal = match[1].toLowerCase();
        const fact = facts[animal] || "I don't have any facts about that animal.";
        return `Here's a fact about ${animal}: ${fact}`;
    }
},{
    pattern: /give me a random animal/i,
    response: () => {
        const animals = ["Lion", "Tiger", "Elephant", "Giraffe", "Zebra", 
            "Panda", "Kangaroo", "Koala", "Penguin", "Cheetah", 
            "Bear", "Wolf", "Gorilla", "Hippo", "Sloth", 
            "Rhino", "Leopard", "Hawk", "Eagle", "Owl", 
            "Shark", "Whale", "Dolphin", "Crocodile", "Alligator", 
            "Octopus", "Starfish", "Turtle", "Snake", "Lizard"];
        const randomAnimal = animals[Math.floor(Math.random() * animals.length)];
        return `Here is a random animal: ${randomAnimal}`;
    }
},{
    pattern: /where does a (.+) live/i,
    response: (match) => {
        const habitats = {
            "lion": "Lions live in grasslands, savannas, and open woodlands.",
            "polar bear": "Polar bears live in the Arctic region.",
            "koala": "Koalas live in eucalyptus forests in Australia.",
            "panda": "Pandas live in the mountain ranges of central China.",
            "shark": "Sharks live in oceans and seas around the world."
        };
        const animal = match[1].toLowerCase();
        const habitat = habitats[animal] || "I don't know where that animal lives.";
        return `A ${animal} lives in: ${habitat}`;
    }
},{
    pattern: /what is the classification of a (.+)/i,
    response: (match) => {
        const classifications = {
            "lion": "Lion is a mammal.",
            "penguin": "Penguin is a bird.",
            "crocodile": "Crocodile is a reptile.",
            "shark": "Shark is a fish.",
            "frog": "Frog is an amphibian."
        };
        const animal = match[1].toLowerCase();
        const classification = classifications[animal] || "I don't know the classification of that animal.";
        return `A ${animal} is: ${classification}`;
    }
},{
    pattern: /how many legs does a (.+) have/i,
    response: (match) => {
        const legsCount = {
            "dog": 4,
            "cat": 4,
            "human": 2,
            "spider": 8,
            "centipede": 100,
            "elephant": 4,
            "bird": 2
        };
        const animal = match[1].toLowerCase();
        const count = legsCount[animal] || "I don't know how many legs that animal has.";
        return `A ${animal} has ${count} legs.`;
    }
},{
    pattern: /how long does a (.+) live/i,
    response: (match) => {
        const lifespans = {
            "dog": "Dogs live around 10-15 years.",
            "cat": "Cats live around 15-20 years.",
            "elephant": "Elephants live around 60-70 years.",
            "turtle": "Turtles can live for more than 100 years.",
            "koala": "Koalas live around 10-12 years."
        };
        const animal = match[1].toLowerCase();
        const lifespan = lifespans[animal] || "I don't know the lifespan of that animal.";
        return `A ${animal} lives for approximately: ${lifespan}`;
    }
},{
    pattern: /what is the fastest animal/i,
    response: () => {
        return "The fastest animal is the cheetah, which can run up to 60-70 mph!";
    }
},{
    pattern: /what is the population of (.+)/i,
    response: (match) => {
        const populations = {
            "tiger": "There are approximately 3,900 tigers left in the wild.",
            "panda": "There are around 1,800 giant pandas left in the wild.",
            "rhino": "There are fewer than 30,000 rhinos remaining worldwide.",
            "elephant": "There are around 415,000 African elephants left in the wild."
        };
        const animal = match[1].toLowerCase();
        const population = populations[animal] || "I don't have the population data for that animal.";
        return `The population of ${animal} is: ${population}`;
    }
},{
    pattern: /write a letter to (.+)/i,
    response: (match) => {
        const recipient = match[1];
        return `Dear ${recipient},\n\nI hope this letter finds you in good health and spirits. I wanted to take a moment to thank you for your continued support and kindness. I appreciate all the efforts you have made, and I look forward to more collaboration in the future.\n\nBest regards,\nYour Friend`;
    }
},{
    pattern: /write a paragraph about (.+)/i,
    response: (match) => {
        const topic = match[1];
        return `Here is a paragraph about ${topic}:\n\n${topic} is an essential part of our daily lives. It provides us with necessary information, entertainment, and sometimes even comfort. Understanding ${topic} can help improve our overall knowledge and assist us in making informed decisions. It's important to constantly learn and stay updated about ${topic}, as it has a significant impact on various aspects of life.`;
    }
},{
    pattern: /generate a sentence/i,
    response: () => {
        const sentences = [
            "The sun is setting, and the sky is painted in beautiful shades of orange.",
            "A gentle breeze swirled through the trees as the birds chirped in harmony.",
            "The city streets were bustling with people, each heading towards their destination.",
            "Under the starry night sky, everything seemed peaceful and quiet."
        ];
        const randomSentence = sentences[Math.floor(Math.random() * sentences.length)];
        return randomSentence;
    }
},{
    pattern: /tell me a story about (.+)/i,
    response: (match) => {
        const theme = match[1];
        return `Once upon a time, in a land far away, there lived a brave soul who ventured through the wilderness of ${theme}. The journey was full of obstacles, but the courage of the traveler never wavered. One day, they encountered a challenge unlike any other. With intelligence, determination, and a kind heart, they overcame the hardship and became a legend in the land of ${theme}. The people of ${theme} still remember the traveler’s bravery and kindness to this day.`;
    }
},{
    pattern: /give me a compliment/i,
    response: () => {
        const compliments = [
            "You have a great sense of humor!",
            "Your kindness knows no bounds.",
            "You are truly an inspiring person!",
            "You have such a positive attitude, it's contagious!"
        ];
        const randomCompliment = compliments[Math.floor(Math.random() * compliments.length)];
        return randomCompliment;
    }
},{
    pattern: /give me a motivational quote/i,
    response: () => {
        const quotes = [
            "The only way to do great work is to love what you do. – Steve Jobs",
            "Success is not final, failure is not fatal: It is the courage to continue that counts. – Winston Churchill",
            "Believe you can and you're halfway there. – Theodore Roosevelt",
            "The best time to plant a tree was 20 years ago. The second best time is now. – Chinese Proverb",
            "It does not matter how slowly you go as long as you do not stop. – Confucius",
            "You are never too old to set another goal or to dream a new dream. – C.S. Lewis",
            "Everything you can imagine is real. – Pablo Picasso",
            "The future belongs to those who believe in the beauty of their dreams. – Eleanor Roosevelt",
            "Don’t watch the clock; do what it does. Keep going. – Sam Levenson",
            "Success is not how high you have climbed, but how you make a positive difference to the world. – Roy T. Bennett",
            "Your time is limited, so don’t waste it living someone else’s life. – Steve Jobs",
            "Opportunities don't happen, you create them. – Chris Grosser",
            "Don’t be pushed around by the fears in your mind. Be led by the dreams in your heart. – Roy T. Bennett",
            "Success usually comes to those who are too busy to be looking for it. – Henry David Thoreau",
            "Act as if what you do makes a difference. It does. – William James"
        ];
        const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
        return randomQuote;
    }
},{
    pattern: /give me a fun fact/i,
    response: () => {
        const funFacts = [
            "Honey never spoils. Archaeologists have found pots of honey in ancient tombs that are over 3,000 years old.",
            "A group of flamingos is called a 'flamboyance'.",
            "Cows have best friends and can become stressed when they are separated.",
            "The Eiffel Tower can be 15 cm taller during the summer due to the expansion of the metal in the heat.",
            "Bananas are berries, but strawberries are not.",
            "Wombat poop is cube-shaped to prevent it from rolling away.",
            "An octopus has three hearts and blue blood.",
            "Sharks have been around longer than trees.",
            "A day on Venus is longer than a year on Venus.",
            "Sloths can hold their breath for up to 40 minutes underwater.",
            "The shortest war in history lasted 38 to 45 minutes between Britain and Zanzibar on August 27, 1896.",
            "The longest hiccuping spree lasted 68 years.",
            "Humans share 60% of their DNA with bananas.",
            "There are more stars in the universe than grains of sand on all the Earth’s beaches.",
            "The world's largest desert is actually Antarctica, not the Sahara."
        ];
        const randomFact = funFacts[Math.floor(Math.random() * funFacts.length)];
        return randomFact;
    }
},{
    pattern: /(?:translate|convert|say|how to say)\s+(.+?)\s+(?:to|in)\s+(tamil|ta)/i,
    response: (match) => {
        const tamilCombined = new Map([
            // Common phrases
            ["good morning", "காலை வணக்கம்"],
            ["good afternoon", "மத்தியான் வணக்கம்"],
            ["good evening", "மாலை வணக்கம்"],
            ["good night", "இரவு வணக்கம்"],
            ["thank you", "நன்றி"],
            ["you're welcome", "வருக"],
            ["excuse me", "மன்னிக்கவும்"],
            ["i'm sorry", "மன்னிக்கவும்"],
            ["how are you", "நீங்கள் எப்படி இருக்கிறீர்கள்"],
            ["i am fine", "நான் நலமாக இருக்கிறேன்"],
            ["what is your name", "உங்கள் பெயர் என்ன"],
            ["my name is", "என் பெயர்"],
            ["where are you from", "நீங்கள் எங்கிருந்து வருகிறீர்கள்"],
            ["i am from", "நான் இருந்து வருகிறேன்"],
            ["nice to meet you", "உங்களை சந்தித்ததில் மகிழ்ச்சி"],
            ["have a nice day", "ஒரு நல்ல நாள் கொண்டாடுங்கள்"],
            ["see you later", "பின்னர் உங்களைப் பார்கிறேன்"],
            ["take care", "கவனித்துக்கொள்ளுங்கள்"],
            
            // Common words
            ["what", "என்ன"], ["this", "இது"], ["is", "ஆகும்"], ["to", "க்கு"], ["tamil", "தமிழ்"],
            ["alagu", "அழகு"], ["arun", "அருண்"], ["kavi", "கவி"], ["hello", "வணக்கம்"], ["good", "நல்ல"],
            ["morning", "காலை"], ["night", "இரவு"], ["food", "உணவு"], ["water", "நீர்"], ["love", "காதல்"],
            ["friend", "நண்பர்"], ["home", "வீடு"], ["school", "பள்ளி"], ["book", "புத்தகம்"], ["pen", "பேனா"],
            ["work", "வேலை"], ["day", "நாள்"], ["time", "நேரம்"], ["year", "வருடம்"], ["month", "மாதம்"],
            ["week", "வாரம்"], ["today", "இன்று"], ["tomorrow", "நாளை"], ["yesterday", "நேற்று"],
            ["yes", "ஆம்"], ["no", "இல்லை"], ["please", "தயவு செய்து"], ["thank you", "நன்றி"],
            ["sorry", "மன்னிக்கவும்"], ["help", "உதவி"], ["name", "பெயர்"], ["age", "வயது"], ["city", "நகரம்"],
            ["country", "நாடு"], ["language", "மொழி"], ["people", "மக்கள்"], ["child", "குழந்தை"],
            ["man", "ஆண்"], ["woman", "பெண்"], ["family", "குடும்பம்"], ["father", "தந்தை"], ["mother", "தாய்"],
            ["brother", "சகோதரன்"], ["sister", "சகோதரி"], ["son", "மகன்"], ["daughter", "மகள்"],
            ["teacher", "ஆசிரியர்"], ["student", "மாணவர்"], ["doctor", "மருத்துவர்"], ["hospital", "மருத்துவமனை"],
            ["money", "பணம்"], ["price", "விலை"], ["shop", "கடை"], ["car", "கார்"], ["bus", "பேருந்து"],
            ["train", "ரயில்"], ["airport", "விமான நிலையம்"], ["hotel", "ஹோட்டல்"], ["room", "அறை"],
            ["phone", "தொலைபேசி"], ["computer", "கணினி"], ["internet", "இணையம்"], ["game", "விளையாட்டு"],
            ["music", "இசை"], ["movie", "திரைப்படம்"], ["song", "பாடல்"], ["dance", "நடனம்"], ["art", "கலை"],
            ["color", "நிறம்"], ["red", "சிவப்பு"], ["blue", "நீலம்"], ["green", "பச்சை"], ["yellow", "மஞ்சள்"],
            ["black", "கருப்பு"], ["white", "வெள்ளை"], ["big", "பெரிய"], ["small", "சிறிய"], ["hot", "சூடான"],
            ["cold", "குளிர்"], ["happy", "மகிழ்ச்சி"], ["sad", "வருத்தம்"], ["angry", "கோபம்"], ["tired", "சோர்வு"],
            ["hungry", "பசி"], ["thirsty", "தாகம்"], ["beautiful", "அழகான"], ["ugly", "அசிங்கமான"],
            ["easy", "எளிதான"], ["difficult", "கடினமான"], ["new", "புதிய"], ["old", "பழைய"], ["young", "இளைய"],
            ["right", "சரியான"], ["wrong", "தவறான"], ["true", "உண்மை"], ["false", "பொய்"], ["open", "திறந்த"],
            ["close", "மூடிய"], ["start", "தொடக்கம்"], ["end", "முடிவு"], ["up", "மேல்"], ["down", "கீழ்"],
            ["left", "இடது"], ["right", "வலது"], ["here", "இங்கே"], ["there", "அங்கே"], ["who", "யார்"],
            ["what", "என்ன"], ["where", "எங்கே"], ["when", "எப்போது"], ["why", "ஏன்"], ["how", "எப்படி"],
            ["which", "எது"], ["whose", "யாருடைய"], ["and", "மற்றும்"], ["or", "அல்லது"], ["but", "ஆனால்"],
            ["because", "ஏனெனில்"], ["if", "என்றால்"], ["then", "பின்னர்"], ["now", "இப்போது"], ["later", "பின்னர்"],
            ["always", "எப்போதும்"], ["never", "ஒருபோதும்"], ["sometimes", "சில நேரங்களில்"], ["often", "பெரும்பாலும்"],
            ["very", "மிகவும்"], ["little", "சிறிது"], ["many", "பல"], ["few", "சில"], ["all", "அனைத்தும்"],
            ["some", "சில"], ["none", "எதுவும் இல்லை"], ["more", "மேலும்"], ["less", "குறைவாக"], ["enough", "போதுமான"],
            ["only", "மட்டும்"], ["also", "மேலும்"], ["even", "கூட"], ["just", "வெறும்"], ["about", "பற்றி"],
            ["after", "பிறகு"], ["before", "முன்"], ["during", "போது"], ["until", "வரை"], ["again", "மீண்டும்"],
            ["once", "ஒருமுறை"], ["twice", "இருமுறை"], ["first", "முதல்"], ["second", "இரண்டாம்"], ["last", "கடைசி"],
            ["next", "அடுத்த"], ["every", "ஒவ்வொரு"], ["each", "ஒவ்வொன்றும்"], ["other", "மற்ற"], ["another", "மற்றொரு"],
            ["same", "அதே"], ["different", "வேறுபட்ட"], ["such", "அத்தகைய"], ["own", "சொந்த"],
            
            // Additional common words
            ["i", "நான்"], ["you", "நீங்கள்"], ["he", "அவன்"], ["she", "அவள்"], ["it", "அது"],
            ["we", "நாம்"], ["they", "அவர்கள்"], ["me", "என்னை"], ["him", "அவனை"], ["her", "அவளை"],
            ["us", "எங்களை"], ["them", "அவர்களை"], ["my", "என்"], ["your", "உங்கள்"], ["his", "அவனுடைய"],
            ["her", "அவளுடைய"], ["its", "அதன்"], ["our", "எங்கள்"], ["their", "அவர்களுடைய"],
            ["mine", "என்னுடையது"], ["yours", "உங்களுடையது"], ["ours", "எங்களுடையது"], ["theirs", "அவர்களுடையது"],
            ["am", "இருக்கிறேன்"], ["is", "இருக்கிறது"], ["are", "இருக்கிறார்கள்"], ["was", "இருந்தது"],
            ["were", "இருந்தனர்"], ["be", "இரு"], ["being", "இருப்பது"], ["been", "இருந்திருக்கிறது"],
            ["have", "கொண்டுள்ளேன்"], ["has", "கொண்டுள்ளது"], ["had", "கொண்டிருந்தது"], ["having", "கொண்டிருப்பது"],
            ["do", "செய்"], ["does", "செய்கிறது"], ["did", "செய்தது"], ["doing", "செய்வது"],
            ["will", "செய்வார்"], ["would", "செய்வார்"], ["shall", "செய்வேன்"], ["should", "செய்ய வேண்டும்"],
            ["can", "முடியும்"], ["could", "முடியும்"], ["may", "இருக்கலாம்"], ["might", "இருக்கலாம்"],
            ["must", "வேண்டும்"], ["ought", "வேண்டும்"], ["need", "தேவை"], ["dare", "துணிகிறேன்"],
            ["a", "ஒரு"], ["an", "ஒரு"], ["the", "அந்த"], ["some", "சில"], ["any", "எந்த"],
            ["this", "இந்த"], ["that", "அந்த"], ["these", "இந்த"], ["those", "அந்த"],
            ["such", "அத்தகைய"], ["what", "என்ன"], ["which", "எது"], ["who", "யார்"],
            ["whom", "யாரை"], ["whose", "யாருடைய"], ["where", "எங்கே"], ["when", "எப்போது"],
            ["why", "ஏன்"], ["how", "எப்படி"], ["whether", "என்று"], ["if", "என்றால்"],
            ["that", "அது"], ["because", "ஏனெனில்"], ["when", "எப்போது"], ["while", "அதே சமயம்"],
            ["where", "எங்கே"], ["whereas", "ஆனால்"], ["if", "என்றால்"], ["unless", "தவிர"],
            ["until", "வரை"], ["till", "வரை"], ["than", "விட"], ["as", "போல"],
            ["whether", "என்று"], ["either", "இரண்டில் ஒன்று"], ["neither", "இரண்டும் இல்லை"],
            ["both", "இரண்டும்"], ["not", "இல்லை"], ["only", "மட்டும்"], ["but", "ஆனால்"],
            ["however", "இருப்பினும்"], ["moreover", "மேலும்"], ["besides", "அதைத் தவிர"],
            ["though", "என்றாலும்"], ["although", "என்றாலும்"], ["yet", "இருப்பினும்"],
            ["still", "இன்னும்"], ["nevertheless", "இருப்பினும்"], ["nonetheless", "இருப்பினும்"],
            ["instead", "அதற்கு பதிலாக"], ["otherwise", "இல்லையேல்"], ["likewise", "அதுபோல"],
            ["similarly", "இதேபோல"], ["therefore", "எனவே"], ["hence", "எனவே"],
            ["thus", "எனவே"], ["consequently", "இதன் விளைவாக"], ["accordingly", "அதன்படி"],
            ["meanwhile", "அதே சமயம்"], ["furthermore", "மேலும்"], ["moreover", "மேலும்"],
            ["besides", "அதைத் தவிர"], ["additionally", "கூடுதலாக"], ["again", "மீண்டும்"],
            ["further", "மேலும்"], ["then", "பின்னர்"], ["now", "இப்போது"], ["soon", "விரைவில்"],
            ["later", "பின்னர்"], ["earlier", "முன்பு"], ["formerly", "முன்பு"], ["previously", "முன்பு"],
            ["finally", "இறுதியாக"], ["lastly", "இறுதியாக"], ["firstly", "முதலில்"], ["secondly", "இரண்டாவதாக"],
            ["next", "அடுத்து"], ["afterwards", "பின்னர்"], ["before", "முன்"], ["after", "பிறகு"],
            ["since", "முதல்"], ["until", "வரை"], ["till", "வரை"], ["while", "அதே சமயம்"],
            ["during", "போது"], ["before", "முன்"], ["after", "பிறகு"], ["as", "போல"],
            ["because", "ஏனெனில்"], ["since", "முதல்"], ["so", "ஆகையால்"], ["then", "பின்னர்"],
            ["therefore", "எனவே"], ["thus", "எனவே"], ["hence", "எனவே"], ["consequently", "இதன் விளைவாக"],
            ["accordingly", "அதன்படி"], ["otherwise", "இல்லையேல்"], ["nevertheless", "இருப்பினும்"],
            ["nonetheless", "இருப்பினும்"], ["however", "இருப்பினும்"], ["moreover", "மேலும்"],
            ["besides", "அதைத் தவிர"], ["additionally", "கூடுதலாக"], ["furthermore", "மேலும்"],
            ["likewise", "அதுபோல"], ["similarly", "இதேபோல"], ["instead", "அதற்கு பதிலாக"],
            ["again", "மீண்டும்"], ["further", "மேலும்"], ["then", "பின்னர்"], ["now", "இப்போது"],
            ["soon", "விரைவில்"], ["later", "பின்னர்"], ["earlier", "முன்பு"], ["formerly", "முன்பு"],
            ["previously", "முன்பு"], ["finally", "இறுதியாக"], ["lastly", "இறுதியாக"], ["firstly", "முதலில்"],
            ["secondly", "இரண்டாவதாக"], ["next", "அடுத்து"], ["afterwards", "பின்னர்"], ["before", "முன்"],
            ["after", "பிறகு"], ["since", "முதல்"], ["until", "வரை"], ["till", "வரை"], ["while", "அதே சமயம்"],
            ["during", "போது"], ["before", "முன்"], ["after", "பிறகு"], ["as", "போல"],
            ["because", "ஏனெனில்"], ["since", "முதல்"], ["so", "ஆகையால்"], ["then", "பின்னர்"]
        ]);
        
        const phrase = match[1].trim().toLowerCase();
        const language = match[2].trim().toLowerCase();
        
        // Check if the language is Tamil
        if (language !== "tamil" && language !== "ta") {
            return "Sorry, I only support translation to Tamil at the moment.";
        }
        
        // First, try to match the entire phrase
        if (tamilCombined.has(phrase)) {
            return tamilCombined.get(phrase);
        }
        
        // Split the phrase into words
        const words = phrase.split(/\s+/);
        let translatedText = "";
        
        // Try to translate word by word
        for (const word of words) {
            // Remove punctuation from the word
            const cleanWord = word.replace(/[.,!?;:()]/g, '');
            const punctuation = word.replace(cleanWord, '');
            
            if (tamilCombined.has(cleanWord)) {
                translatedText += tamilCombined.get(cleanWord) + punctuation + " ";
            } else {
                // Try to find the word with different case
                const capitalizedWord = cleanWord.charAt(0).toUpperCase() + cleanWord.slice(1);
                if (tamilCombined.has(capitalizedWord)) {
                    translatedText += tamilCombined.get(capitalizedWord) + punctuation + " ";
                } else {
                    // Fallback: Translate character by character
                    let translatedWord = "";
                    for (let i = 0; i < cleanWord.length; i++) {
                        const char = cleanWord[i].toLowerCase();
                        translatedWord += tamilCombined.get(char) || char;
                    }
                    translatedText += translatedWord + punctuation + " ";
                }
            }
        }
        
        return translatedText.trim();
    }
},
{ pattern: /reverse (.+)/i, response: (match) => match[1].split('').reverse().join('') },{ pattern: /count words (.+)/i, response: (match) => `Number of words: ${match[1].split(/\s+/).length}` },{ pattern: /uppercase (.+)/i, response: (match) => match[1].toUpperCase() },{ pattern: /lowercase (.+)/i, response: (match) => match[1].toLowerCase() },{ pattern: /reverse words (.+)/i, response: (match) => match[1].split(' ').map(word => word.split('').reverse().join('')).join(' ') },{ pattern: /count vowels (.+)/i, response: (match) => `Number of vowels: ${match[1].replace(/[^aeiouAEIOU]/g, "").length}` },{ pattern: /replace (.+) with (.+)/i, response: (match) => match[1].replace(new RegExp(match[1], 'gi'), match[2]) },

{ 
    pattern: /solve quadratic equation ([\d.-]+)x\^2 \+ ([\d.-]+)x \+ ([\d.-]+)/i, 
    response: (match) => {
        const a = parseFloat(match[1]);
        const b = parseFloat(match[2]);
        const c = parseFloat(match[3]);
        const discriminant = b * b - 4 * a * c;

        if (discriminant > 0) {
            const root1 = (-b + Math.sqrt(discriminant)) / (2 * a);
            const root2 = (-b - Math.sqrt(discriminant)) / (2 * a);
            return `The roots are ${root1.toFixed(2)} and ${root2.toFixed(2)}`;
        } else if (discriminant === 0) {
            const root = -b / (2 * a);
            return `The root is ${root.toFixed(2)}`;
        } else {
            return "The equation has no real roots.";
        }
    }
},{ 
    pattern: /repeat (.+) (\d+) times/i, 
    response: (match) => {
        const message = match[1];  
        const times = parseInt(match[2]);  

        if (times <= 0) return "Please enter a valid repeat count.";

        return Array(times).fill(message).join("\n");
    }
},{ 
    pattern: /split (.+)/i, 
    response: (match) => {
        const message = match[1];  
        return `Split Message: ` + message.split("").join(" ");
    }
},{ 
    pattern: /style (.+)/i, 
    response: (match) => {
        const text = match[1].toUpperCase(); // Convert input to uppercase for styling

        const fancyFonts = {
            'A': '𝐀', 'B': '𝐁', 'C': '𝐂', 'D': '𝐃', 'E': '𝐄', 'F': '𝐅', 'G': '𝐆', 
            'H': '𝐇', 'I': '𝐈', 'J': '𝐉', 'K': '𝐊', 'L': '𝐋', 'M': '𝐌', 'N': '𝐍', 
            'O': '𝐎', 'P': '𝐏', 'Q': '𝐐', 'R': '𝐑', 'S': '𝐒', 'T': '𝐓', 'U': '𝐔', 
            'V': '𝐕', 'W': '𝐖', 'X': '𝐗', 'Y': '𝐘', 'Z': '𝐙'
        };

        let styledText = text.split('').map(char => fancyFonts[char] || char).join('');
        
        return `Styled Text: ${styledText}`;
    }
},{
    pattern: /style2 (.+)/i, 
    response: (match) => {
        const text = match[1].toUpperCase(); // Convert input to uppercase
        // Different font styles
        const fontStyles = {
            bold: { 'A': '𝐀', 'B': '𝐁', 'C': '𝐂', 'D': '𝐃', 'E': '𝐄', 'F': '𝐅', 'G': '𝐆', 
                    'H': '𝐇', 'I': '𝐈', 'J': '𝐉', 'K': '𝐊', 'L': '𝐋', 'M': '𝐌', 'N': '𝐍', 
                    'O': '𝐎', 'P': '𝐏', 'Q': '𝐐', 'R': '𝐑', 'S': '𝐒', 'T': '𝐓', 'U': '𝐔', 
                    'V': '𝐕', 'W': '𝐖', 'X': '𝐗', 'Y': '𝐘', 'Z': '𝐙' },
            italic: { 'A': '𝘈', 'B': '𝘉', 'C': '𝘊', 'D': '𝘋', 'E': '𝘌', 'F': '𝘍', 'G': '𝘎',
                      'H': '𝘏', 'I': '𝘐', 'J': '𝘑', 'K': '𝘒', 'L': '𝘓', 'M': '𝘔', 'N': '𝘕',
                      'O': '𝘖', 'P': '𝘗', 'Q': '𝘘', 'R': '𝘙', 'S': '𝘚', 'T': '𝘛', 'U': '𝘜',
                      'V': '𝘝', 'W': '𝘞', 'X': '𝘟', 'Y': '𝘠', 'Z': '𝘡' },
            script: { 'A': '𝒜', 'B': 'ℬ', 'C': '𝒞', 'D': '𝒟', 'E': 'ℰ', 'F': 'ℱ', 'G': '𝒢',
                      'H': 'ℋ', 'I': 'ℐ', 'J': '𝒥', 'K': '𝒦', 'L': 'ℒ', 'M': 'ℳ', 'N': '𝒩',
                      'O': '𝒪', 'P': '𝒫', 'Q': '𝒬', 'R': 'ℛ', 'S': '𝒮', 'T': '𝒯', 'U': '𝒰',
                      'V': '𝒱', 'W': '𝒲', 'X': '𝒳', 'Y': '𝒴', 'Z': '𝒵' },
            monospace: { 'A': '𝙰', 'B': '𝙱', 'C': '𝙲', 'D': '𝙳', 'E': '𝙴', 'F': '𝙵', 'G': '𝙶',
                         'H': '𝙷', 'I': '𝙸', 'J': '𝙹', 'K': '𝙺', 'L': '𝙻', 'M': '𝙼', 'N': '𝙽',
                         'O': '𝙾', 'P': '𝙿', 'Q': '𝚀', 'R': '𝚁', 'S': '𝚂', 'T': '𝚃', 'U': '𝚄',
                         'V': '𝚅', 'W': '𝚆', 'X': '𝚇', 'Y': '𝚈', 'Z': '𝚉' },
            sansserif: { 'A': '𝖠', 'B': '𝖡', 'C': '𝖢', 'D': '𝖣', 'E': '𝖤', 'F': '𝖥', 'G': '𝖦',
                         'H': '𝖧', 'I': '𝖨', 'J': '𝖩', 'K': '𝖪', 'L': '𝖫', 'M': '𝖬', 'N': '𝖭',
                         'O': '𝖮', 'P': '𝖯', 'Q': '𝖰', 'R': '𝖱', 'S': '𝖲', 'T': '𝖳', 'U': '𝖴',
                         'V': '𝖵', 'W': '𝖶', 'X': '𝖷', 'Y': '𝖸', 'Z': '𝖹' },
            serif: { 'A': '𝐴', 'B': '𝐵', 'C': '𝐶', 'D': '𝐷', 'E': '𝐸', 'F': '𝐹', 'G': '𝐺',
                    'H': '𝐻', 'I': '𝐼', 'J': '𝐽', 'K': '𝐾', 'L': '𝐿', 'M': '𝑀', 'N': '𝑁',
                    'O': '𝑂', 'P': '𝑃', 'Q': '𝑄', 'R': '𝑅', 'S': '𝑆', 'T': '𝑇', 'U': '𝑈',
                    'V': '𝑉', 'W': '𝑊', 'X': '𝑋', 'Y': '𝑌', 'Z': '𝑍' },
            doublestruck: { 'A': '𝔸', 'B': '𝔹', 'C': 'ℂ', 'D': '𝔻', 'E': '𝔼', 'F': '𝔽', 'G': '𝔾',
                             'H': 'ℍ', 'I': '𝕀', 'J': '𝕁', 'K': '𝕂', 'L': '𝕃', 'M': '𝕄', 'N': 'ℕ',
                             'O': '𝕆', 'P': 'ℙ', 'Q': 'ℚ', 'R': 'ℝ', 'S': '𝕊', 'T': '𝕋', 'U': '𝕌',
                             'V': '𝕍', 'W': '𝕎', 'X': '𝕏', 'Y': '𝕐', 'Z': 'ℤ' },
            fraktur: { 'A': '𝔄', 'B': '𝔅', 'C': 'ℭ', 'D': '𝔇', 'E': '𝔈', 'F': '𝔉', 'G': '𝔊',
                       'H': 'ℌ', 'I': 'ℑ', 'J': '𝔍', 'K': '𝔎', 'L': '𝔏', 'M': '𝔐', 'N': '𝔑',
                       'O': '𝔒', 'P': '𝔓', 'Q': '𝔔', 'R': 'ℜ', 'S': '𝔖', 'T': '𝔗', 'U': '𝔘',
                       'V': '𝔙', 'W': '𝔚', 'X': '𝔛', 'Y': '𝔜', 'Z': 'ℨ' },
            blackboard: { 'A': '𝔸', 'B': '𝔹', 'C': 'ℂ', 'D': '𝔻', 'E': '𝔼', 'F': '𝔽', 'G': '𝔾',
                          'H': 'ℍ', 'I': '𝕀', 'J': '𝕁', 'K': '𝕂', 'L': '𝕃', 'M': '𝕄', 'N': 'ℕ',
                          'O': '𝕆', 'P': 'ℙ', 'Q': 'ℚ', 'R': 'ℝ', 'S': '𝕊', 'T': '𝕋', 'U': '𝕌',
                          'V': '𝕍', 'W': '𝕎', 'X': '𝕏', 'Y': '𝕐', 'Z': 'ℤ' },
            circled: { 'A': 'Ⓐ', 'B': 'Ⓑ', 'C': 'Ⓒ', 'D': 'Ⓓ', 'E': 'Ⓔ', 'F': 'Ⓕ', 'G': 'Ⓖ',
                       'H': 'Ⓗ', 'I': 'Ⓘ', 'J': 'Ⓚ', 'K': 'Ⓚ', 'L': 'Ⓛ', 'M': 'Ⓜ', 'N': 'Ⓝ',
                       'O': 'Ⓞ', 'P': 'Ⓟ', 'Q': 'Ⓠ', 'R': 'Ⓡ', 'S': 'Ⓢ', 'T': 'Ⓣ', 'U': 'Ⓤ',
                       'V': 'Ⓥ', 'W': 'Ⓦ', 'X': 'Ⓧ', 'Y': 'Ⓨ', 'Z': 'Ⓩ' },
            negativecircled: { 'A': '🅐', 'B': '🅑', 'C': '🅒', 'D': '🅓', 'E': '🅔', 'F': '🅕', 'G': '🅖',
                                'H': '🅗', 'I': '🅘', 'J': '🅙', 'K': '🅚', 'L': '🅛', 'M': '🅜', 'N': '🅝',
                                'O': '🅞', 'P': '🅟', 'Q': '🅠', 'R': '🅡', 'S': '🅢', 'T': '🅣', 'U': '🅤',
                                'V': '🅥', 'W': '🅦', 'X': '🅧', 'Y': '🅨', 'Z': '🅩' },
            squared: { 'A': '🄰', 'B': '🄱', 'C': '🄲', 'D': '🄳', 'E': '🄴', 'F': '🄵', 'G': '🄶',
                       'H': '🄷', 'I': '🄸', 'J': '🄹', 'K': '🄺', 'L': '🄻', 'M': '🄼', 'N': '🄽',
                       'O': '🄾', 'P': '🄿', 'Q': '🅀', 'R': '🅁', 'S': '🅂', 'T': '🅃', 'U': '🅄',
                       'V': '🅅', 'W': '🅆', 'X': '🅇', 'Y': '🅈', 'Z': '🅉' },
            negativesquared: { 'A': '🅰', 'B': '🅱', 'C': '🅲', 'D': '🅳', 'E': '🅴', 'F': '🅵', 'G': '🅶',
                                'H': '🅷', 'I': '🅸', 'J': '🅹', 'K': '🅺', 'L': '🅻', 'M': '🅼', 'N': '🅽',
                                'O': '🅾', 'P': '🅿', 'Q': '🆀', 'R': '🆁', 'S': '🆂', 'T': '🆃', 'U': '🆄',
                                'V': '🆅', 'W': '🆆', 'X': '🆇', 'Y': '🆈', 'Z': '🆉' }
        };
        // Convert text to each font style
        const convertToStyle = (style) => 
            text.split('').map(char => fontStyles[style][char] || char).join('');
        
        // Display all font styles
        return `Styled Texts:\n` +
               `🔹 **Bold:** ${convertToStyle('bold')}\n` +
               `🔹 *Italic:* ${convertToStyle('italic')}\n` +
               `🔹 ✨ Script: ${convertToStyle('script')}\n` +
               `🔹 ⌨️ Monospace: ${convertToStyle('monospace')}\n` +
               `🔹 𝖠 Sans-serif: ${convertToStyle('sansserif')}\n` +
               `🔹 𝐴 Serif: ${convertToStyle('serif')}\n` +
               `🔹 𝔸 Double-struck: ${convertToStyle('doublestruck')}\n` +
               `🔹 𝔄 Fraktur: ${convertToStyle('fraktur')}\n` +
               `🔹 𝔸 Blackboard: ${convertToStyle('blackboard')}\n` +
               `🔹 Ⓐ Circled: ${convertToStyle('circled')}\n` +
               `🔹 🅐 Negative Circled: ${convertToStyle('negativecircled')}\n` +
               `🔹 🄰 Squared: ${convertToStyle('squared')}\n` +
               `🔹 🅰 Negative Squared: ${convertToStyle('negativesquared')}`;
    }
},
{
    pattern: /help me fix this code:\s*```([\s\S]*?)```/i,
    response: (match) => {
        const code = match[1];
        
        // Common syntax errors and their fixes
        const commonErrors = [
            {
                pattern: /for\s*\(\s*let\s+\w+\s*=\s*0\s*;\s*\w+\s*<\s*\w+\s*length\s*;\s*\w+\+\+\s*\)/g,
                fix: "for (let i = 0; i < array.length; i++)",
                description: "Standard for loop syntax for iterating through an array"
            },
            {
                pattern: /console\.log\s*\(\s*['"](.+)['"]\s*\+\s*(.+)\s*\)/g,
                fix: "console.log(`$1${$2}`)",
                description: "Use template literals instead of string concatenation"
            },
            {
                pattern: /document\.getElementById\s*\(\s*['"](.+)['"]\s*\)\.value/g,
                fix: "document.getElementById('$1').value",
                description: "Correct syntax for getting an element's value"
            },
            {
                pattern: /if\s*\(\s*(.+)\s*=\s*(.+)\s*\)/g,
                fix: "if ($1 === $2)",
                description: "Use strict equality (===) instead of assignment (=) in conditions"
            },
            {
                pattern: /function\s*\(\s*\)\s*\{/g,
                fix: "function() {",
                description: "Correct function declaration syntax"
            }
        ];
        
        let issuesFound = [];
        let fixedCode = code;
        
        // Check for common errors
        for (const error of commonErrors) {
            if (error.pattern.test(code)) {
                issuesFound.push(error.description);
                fixedCode = fixedCode.replace(error.pattern, error.fix);
            }
        }
        
        // Check for unmatched brackets, braces, or parentheses
        const brackets = {
            '(': 0,
            '[': 0,
            '{': 0
        };
        
        const closingBrackets = {
            ')': '(',
            ']': '[',
            '}': '{'
        };
        
        for (let i = 0; i < code.length; i++) {
            const char = code[i];
            
            if (brackets.hasOwnProperty(char)) {
                brackets[char]++;
            } else if (closingBrackets.hasOwnProperty(char)) {
                brackets[closingBrackets[char]]--;
            }
        }
        
        for (const [bracket, count] of Object.entries(brackets)) {
            if (count !== 0) {
                const closingBracket = Object.keys(closingBrackets).find(key => closingBrackets[key] === bracket);
                issuesFound.push(`Unmatched ${bracket}${count > 0 ? ' - missing ' + count + ' ' + closingBracket : ' - too many ' + closingBracket}`);
            }
        }
        
        // Check for missing semicolons
        const linesWithoutSemicolons = code.split('\n').filter((line, index) => {
            const trimmed = line.trim();
            return trimmed.length > 0 && 
                   !trimmed.endsWith(';') && 
                   !trimmed.endsWith('{') && 
                   !trimmed.endsWith('}') && 
                   !trimmed.startsWith('//') && 
                   !trimmed.startsWith('if') && 
                   !trimmed.startsWith('for') && 
                   !trimmed.startsWith('while') && 
                   !trimmed.includes('function');
        });
        
        if (linesWithoutSemicolons.length > 0) {
            issuesFound.push("Possible missing semicolons");
        }
        
        // Generate response
        let response = "I've analyzed your code and found the following issues:\n\n";
        
        if (issuesFound.length === 0) {
            response += "No obvious syntax errors detected. However, there might be logical errors that would require running the code to identify.\n";
        } else {
            response += issuesFound.map((issue, index) => `${index + 1}. ${issue}`).join('\n');
            response += "\n\nHere's your code with suggested fixes:\n\n```javascript\n" + fixedCode + "\n```";
        }
        
        response += "\n\nIf you're still having issues, please provide more context about what the code is supposed to do and any error messages you're receiving.";
        
        return response;
    }
},

{
    pattern: /abc (.+)/i,
    response: (match) => {
        const text = match[1].toLowerCase();
        const abc = {
            "a": "b",
            "c": "d",
            "e": "f",
            "g": "h",
            "i": "j",
            "k": "l",
            "m": "n",
            "o": "p",
            "q": "r",
            "s": "t",
            "y": "v",
            "w": "x",
            "y": "z",
            
            "b": "a",
            "d": "c",
            "f": "e",
            "h": "g",
            "j": "i",
            "l": "k",
            "n": "m",
            "p": "o",
            "r": "q",
            "t": "s",
            "v": "y",
            "x": "w",
            "z": "y"
        };
        const abcd = abc[text];
        return `${abcd}`;
    }
},
{
    pattern: /stats (.+)/i,
    response: (match) => {
        const player = match[1];
        return `Fetching stats for ${player}...`;
    }
},
{
    pattern: /item (.+)/i,
    response: (match) => {
        const item = match[1].toLowerCase();
        const items = {
            "sword": "⚔️ A sharp blade for close combat.",
            "shield": "🛡️ Blocks enemy attacks.",
            "potion": "🧪 Restores 50 HP.",
            "bow": "🏹 Long-range weapon with arrows."
        };
        return items[item] || "❌ Item not found!";
    }
},
{
    pattern: /cheat (.+)/i,
    response: (match) => {
        const cheat = match[1].toLowerCase();
        const cheats = {
            "godmode": "🛡️ God Mode activated! You are now invincible.",
            "noclip": "🚀 No-Clip enabled! You can walk through walls.",
            "speed": "⚡ Speed Boost activated! Run 2x faster.",
            "ammo": "🔫 Unlimited Ammo granted!"
        };
        return cheats[cheat] || "❌ Invalid cheat code!";
    }
},
{
    pattern: /enemy near/i,
    response: () => {
        return "🔍 Scanning... Enemy detected at 50m!";
    }
},
{
    pattern: /switch to (.+)/i,
    response: (match) => {
        const weapon = match[1].toLowerCase();
        return `🔄 Switched to ${weapon}! Ready for battle.`;
    }
},
{
    pattern: /leaderboard/i,
    response: () => {
        return "🏆 Top Players:\n1. ShadowKiller - 5000 points\n2. NoobSlayer - 4800 points\n3. ProGamerX - 4500 points";
    }
},
{
    pattern: /health/i,
    response: () => {
        return "❤️ Your health is at 80/100 HP.";
    }
},
{
    pattern: /server status/i,
    response: () => {
        return "🟢 Game server is ONLINE! No issues detected.";
    }
},
{
    pattern: /start snake game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start snakegame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startsnake game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startsnakegame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},



{
    pattern: /start Bong game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start Bonggame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startBong game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startBonggame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},

{
    pattern: /give abcd letter (\d+)/i,
    response: (match) => {
        const alphabet = "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z".split(",");
        let count = parseInt(match[1]);

        if (count > 26) count = 26; // Limit to max 26 letters
        if (count < 1) return "❌ Please enter a number between 1 and 26.";

        return alphabet.slice(0, count).join(", ");
    }
},
{
    pattern: /what is the meaning of (.+)/i,
    response: (match) => {
        const term = match[1];
        // Fetch or generate the definition for 'term'
        return `The meaning of ${term} is...`;
    }
},
{
    pattern: /how do I (.+)/i,
    response: (match) => {
        const task = match[1];
        // Provide steps or guidance on 'task'
        return `To ${task}, you can follow these steps...`;
    }
},
{
    pattern: /what are the symptoms of (.+)/i,
    response: (match) => {
        const condition = match[1];
        // Provide information about symptoms of 'condition'
        return `The symptoms of ${condition} include...`;
    }
},

{
    pattern: /angry emojis/i,
    response: () => {
        return "Here are 10 types of Angry Emojis! \n\n" +
            "1. 😠\n" +
            "2. 😡\n" +
            "3. 🤬\n" +
            "4. 😤\n" +
            "5. 🙄\n" +
            "6. 😾\n" +
            "7. 👿\n" +
            "8. 💢\n" +
            "9. 😒\n" +
            "10. 😣";
    }
},

{
    pattern: /happy emojis/i,
    response: () => {
        return "Here are 10 types of Happy Emojis! \n\n" +
            "1. 😀\n" +
            "2. 😃\n" +
            "3. 😄\n" +
            "4. 😁\n" +
            "5. 😆\n" +
            "6. 😊\n" +
            "7. 🤗\n" +
            "8. 😍\n" +
            "9. 🤩\n" +
            "10. 🥳";
    }
},

{
    pattern: /love emojis/i,
    response: () => {
        return "Here are 10 types of Love Emojis! \n\n" +
            "1. ❤️\n" +
            "2. 💕\n" +
            "3. 💖\n" +
            "4. 💘\n" +
            "5. 💝\n" +
            "6. 💗\n" +
            "7. 💓\n" +
            "8. 💞\n" +
            "9. 😍\n" +
            "10. 😘";
    }
},

{
    pattern: /comedy emojis/i,
    response: () => {
        return "Here are 10 types of Comedy Emojis! \n\n" +
            "1. 😂\n" +
            "2. 🤣\n" +
            "3. 😹\n" +
            "4. 😆\n" +
            "5. 😜\n" +
            "6. 🤪\n" +
            "7. 😝\n" +
            "8. 😛\n" +
            "9. 🤭\n" +
            "10. 😹";
    }
},

{
    pattern: /sad emojis/i,
    response: () => {
        return "Here are 10 types of Sad Emojis! \n\n" +
            "1. 😢\n" +
            "2. 😞\n" +
            "3. 😔\n" +
            "4. 😟\n" +
            "5. 😕\n" +
            "6. 🙁\n" +
            "7. 😣\n" +
            "8. 😖\n" +
            "9. 🥺\n" +
            "10. 😿";
    }
},

{
    pattern: /crying emojis/i,
    response: () => {
        return "Here are 10 types of Crying Emojis! \n\n" +
            "1. 😭\n" +
            "2. 😢\n" +
            "3. 😿\n" +
            "4. 🥲\n" +
            "5. 😥\n" +
            "6. 😓\n" +
            "7. 🥺\n" +
            "8. 😔\n" +
            "9. 😖\n" +
            "10. 😩";
    }
},

{
    pattern: /style name (.+)/i,
    response: (match) => {
        const name = match[1];
        // Create stylized letters
        const stylizedName = name.toUpperCase().split('').map(letter => {
            return `【${letter}】`;
        }).join(' ');
        
        return `Your stylized name:\n${stylizedName}\n\n` +
            `Other styles:\n` +
            `1. ${name.toUpperCase().split('').join('.')}\n` +
            `2. ${name.toUpperCase().split('').join(' ')}\n` +
            `3. ${name.split('').map(c => c === ' ' ? ' ' : c + c).join('')}`;
    }
},

{
    pattern: /banner name (.+)/i,
    response: (match) => {
        const name = match[1].toUpperCase();
        let banner = '';
        
        // Create a simple banner with the name
        banner += '╔' + '═'.repeat(name.length + 4) + '╗\n';
        banner += '║  ' + name + '  ║\n';
        banner += '╚' + '═'.repeat(name.length + 4) + '╝';
        
        return `Here's your name banner:\n\n${banner}`;
    }
},

{
    pattern: /fancy name (.+)/i,
    response: (match) => {
        const name = match[1];
        
        // Map of regular characters to fancy alternatives
        const fancyMap = {
            'a': 'α', 'b': 'в', 'c': '¢', 'd': '∂', 'e': 'ε',
            'f': 'ƒ', 'g': 'g', 'h': 'н', 'i': 'ι', 'j': 'נ',
            'k': 'к', 'l': 'ℓ', 'm': 'м', 'n': 'η', 'o': 'σ',
            'p': 'ρ', 'q': 'q', 'r': 'я', 's': 'ѕ', 't': 'т',
            'u': 'υ', 'v': 'ν', 'w': 'ω', 'x': 'χ', 'y': 'у',
            'z': 'z', 'A': 'Δ', 'B': 'ß', 'C': 'Ç', 'D': 'Đ',
            'E': 'Σ', 'F': 'ƒ', 'G': 'G', 'H': 'H', 'I': 'I',
            'J': 'J', 'K': 'K', 'L': 'L', 'M': 'M', 'N': 'N',
            'O': 'Ø', 'P': 'P', 'Q': 'Q', 'R': 'R', 'S': '§',
            'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',
            'Y': 'Y', 'Z': 'Z'
        };
        
        // Convert name to fancy
        const fancyName = name.split('').map(char => fancyMap[char] || char).join('');
        
        return `Your fancy name: ${fancyName}\n\n` +
            `Other variations:\n` +
            `1. ${name.split('').map(c => c === ' ' ? ' ' : c + '̲').join('')}\n` +
            `2. ${name.split('').map(c => c === ' ' ? ' ' : '҉' + c).join('')}`;
    }
},

{
    pattern: /ascii name (.+)/i,
    response: (match) => {
        const name = match[1].toUpperCase();
        
        // Simple ASCII art letters
        const asciiLetters = {
            'A': ['  ▄  ', ' ▄▄▄ ', '▄   ▄', '▀▄▄▄▀'],
            'B': ['▄▄▄▄ ', '▄   ▄', '▄   ▄', '▀▀▀▀ '],
            'C': [' ▄▄▄ ', '▄    ', '▄    ', ' ▀▀▀ '],
            'D': ['▄▄▄▄ ', '▄   ▄', '▄   ▄', '▀▀▀▀ '],
            'E': ['▄▄▄▄▄', '▄    ', '▄▄▄  ', '▀▀▀▀▀'],
            'F': ['▄▄▄▄▄', '▄    ', '▄▄▄  ', '▀    '],
            'G': [' ▄▄▄ ', '▄    ', '▄  ▄▄', ' ▀▀▀ '],
            'H': ['▄   ▄', '▄▄▄▄▄', '▄   ▄', '▀   ▀'],
            'I': ['▄▄▄▄▄', '  ▄  ', '  ▄  ', '▄▄▄▄▄'],
            'J': ['▀▀▀▀▀', '   ▄ ', '  ▄  ', '▄▄▄▄ '],
            'K': ['▄   ▄', '▄▄  ▄', '▄  ▄▄', '▀   ▀'],
            'L': ['▄    ', '▄    ', '▄    ', '▀▀▀▀▀'],
            'M': ['▄   ▄', '▄▄ ▄▄', '▄ ▄ ▄', '▀   ▀'],
            'N': ['▄   ▄', '▄▄  ▄', '▄  ▄▄', '▀   ▀'],
            'O': [' ▄▄▄ ', '▄   ▄', '▄   ▄', ' ▀▀▀ '],
            'P': ['▄▄▄▄ ', '▄   ▄', '▄▄▄▄ ', '▀    '],
            'Q': [' ▄▄▄ ', '▄   ▄', '▄  ▀▄', ' ▀▀▀▀'],
            'R': ['▄▄▄▄ ', '▄   ▄', '▄▄▄▄ ', '▀   ▀'],
            'S': [' ▄▄▄▄', '▄    ', ' ▀▀▀ ', '▀▀▀▀▄'],
            'T': ['▄▄▄▄▄', '  ▄  ', '  ▄  ', '  ▀  '],
            'U': ['▄   ▄', '▄   ▄', '▄   ▄', ' ▀▀▀ '],
            'V': ['▄   ▄', '▄   ▄', ' ▄ ▄ ', '  ▀  '],
            'W': ['▄   ▄', '▄ ▄ ▄', '▄▄ ▄▄', '▀   ▀'],
            'X': ['▄   ▄', ' ▄ ▄ ', '  ▀  ', ' ▀ ▀ '],
            'Y': ['▄   ▄', ' ▄ ▄ ', '  ▀  ', '  ▀  '],
            'Z': ['▄▄▄▄▄', '   ▄ ', ' ▄   ', '▀▀▀▀▀'],
            ' ': ['     ', '     ', '     ', '     ']
        };
        
        // Create ASCII art
        let asciiArt = ['', '', '', ''];
        for (let i = 0; i < name.length; i++) {
            const letter = name[i];
            if (asciiLetters[letter]) {
                for (let j = 0; j < 4; j++) {
                    asciiArt[j] += asciiLetters[letter][j] + ' ';
                }
            }
        }
        
        return `Your name in ASCII art:\n\n${asciiArt.join('\n')}`;
    }
},
{
    pattern: /translate (.+) into (.+)/i,
    response: (match) => {
        const phrase = match[1].toLowerCase().trim();
        const language = match[2].toLowerCase().trim();
        
        // Expanded translation database
        const translations = {
            "good morning": { 
                "spanish": "buenos días", 
                "french": "bonjour", 
                "german": "guten Morgen",
                "italian": "buongiorno",
                "portuguese": "bom dia",
                "japanese": "おはようございます (ohayō gozaimasu)",
                "chinese": "早上好 (zǎo shàng hǎo)",
                "russian": "доброе утро (dobroye utro)"
            },
            "hello": { 
                "spanish": "hola", 
                "french": "bonjour", 
                "german": "hallo",
                "italian": "ciao",
                "portuguese": "olá",
                "japanese": "こんにちは (konnichiwa)",
                "chinese": "你好 (nǐ hǎo)",
                "russian": "привет (privet)"
            },
            "thank you": { 
                "spanish": "gracias", 
                "french": "merci", 
                "german": "danke",
                "italian": "grazie",
                "portuguese": "obrigado",
                "japanese": "ありがとう (arigatō)",
                "chinese": "谢谢 (xiè xiè)",
                "russian": "спасибо (spasibo)"
            },
            "goodbye": { 
                "spanish": "adiós", 
                "french": "au revoir", 
                "german": "auf Wiedersehen",
                "italian": "arrivederci",
                "portuguese": "tchau",
                "japanese": "さようなら (sayōnara)",
                "chinese": "再见 (zài jiàn)",
                "russian": "до свидания (do svidaniya)"
            },
            "please": { 
                "spanish": "por favor", 
                "french": "s'il vous plaît", 
                "german": "bitte",
                "italian": "per favore",
                "portuguese": "por favor",
                "japanese": "お願いします (onegaishimasu)",
                "chinese": "请 (qǐng)",
                "russian": "пожалуйста (pozhaluysta)"
            }
        };
        
        // Language name normalization
        const languageAliases = {
            "spanish": ["spanish", "español", "es"],
            "french": ["french", "français", "fr"],
            "german": ["german", "deutsch", "de"],
            "italian": ["italian", "italiano", "it"],
            "portuguese": ["portuguese", "português", "pt"],
            "japanese": ["japanese", "日本語", "ja"],
            "chinese": ["chinese", "中文", "zh"],
            "russian": ["russian", "русский", "ru"]
        };
        
        // Find the canonical language name
        let canonicalLanguage = null;
        for (const [lang, aliases] of Object.entries(languageAliases)) {
            if (aliases.includes(language)) {
                canonicalLanguage = lang;
                break;
            }
        }
        
        // Check if we have the translation
        if (translations[phrase] && canonicalLanguage && translations[phrase][canonicalLanguage]) {
            const translation = translations[phrase][canonicalLanguage];
            
            // Provide additional context for some languages
            let context = "";
            if (["japanese", "chinese", "russian"].includes(canonicalLanguage)) {
                context = ` (Note: This includes romanization for pronunciation)`;
            }
            
            return `The translation of '${phrase}' into ${canonicalLanguage} is '${translation}'.${context}`;
        } else if (!canonicalLanguage) {
            // Language not supported
            const supportedLanguages = Object.keys(languageAliases).join(", ");
            return `Sorry, I don't support translations into '${language}'. Supported languages are: ${supportedLanguages}.`;
        } else if (!translations[phrase]) {
            // Phrase not found, try to find similar phrases
            const similarPhrases = Object.keys(translations).filter(key => 
                key.includes(phrase) || phrase.includes(key)
            );
            
            if (similarPhrases.length > 0) {
                return `I don't have a translation for '${phrase}'. Did you mean one of these: ${similarPhrases.join(", ")}?`;
            } else {
                return `Sorry, I don't have a translation for '${phrase}' in ${canonicalLanguage}.`;
            }
        } else {
            return `Sorry, I don't have a translation for '${phrase}' in ${canonicalLanguage}.`;
        }
    }
},
{
    pattern: /tell me a joke/i,
    response: () => {
        // Provide a random joke
        return "Why don't scientists trust atoms? Because they make up everything!";
    }
},
{
    pattern: /tell me about the (.+)/i,
    response: (match) => {
        const topic = match[1];
        // Provide information about 'topic'
        return `Here's some information about the ${topic}...`;
    }
},
{
    pattern: /how do I (.+) in (.+)/i,
    response: (match) => {
        const task = match[1];
        const language = match[2];
        // Provide coding assistance for 'task' in 'language'
        return `To ${task} in ${language}, you can...`;
    }
},

{
    pattern: /can you give me advice on (.+)/i,
    response: (match) => {
        const topic = match[1];
        // Provide advice on 'topic'
        return `Here is some advice on ${topic}...`;
    }
},

    { pattern: /what is ([\d.]+) \+ ([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+) - ([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+) \* ([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /what is ([\d.]+) \/ ([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    { pattern: /what is ([\d.]+)% of ([\d.]+)/i, response: (match) => `${match[1]}% of ${match[2]} = ${(parseFloat(match[1]) / 100 * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /square root of ([\d.]+)/i, response: (match) => `√${match[1]} = ${Math.sqrt(parseFloat(match[1])).toFixed(2)}` },
    { pattern: /power of ([\d.]+) to ([\d.]+)/i, response: (match) => `${match[1]}^${match[2]} = ${Math.pow(parseFloat(match[1]), parseFloat(match[2])).toFixed(2)}` },
    { pattern: /log of ([\d.]+)/i, response: (match) => `log(${match[1]}) = ${Math.log10(parseFloat(match[1])).toFixed(2)}` },
    { pattern: /sin\(([\d.]+)\)/i, response: (match) => `sin(${match[1]}) = ${Math.sin((parseFloat(match[1]) * Math.PI) / 180).toFixed(2)}` },
    { pattern: /cos\(([\d.]+)\)/i, response: (match) => `cos(${match[1]}) = ${Math.cos((parseFloat(match[1]) * Math.PI) / 180).toFixed(2)}` },
    { pattern: /tan\(([\d.]+)\)/i, response: (match) => `tan(${match[1]}) = ${Math.tan((parseFloat(match[1]) * Math.PI) / 180).toFixed(2)}` },
      { pattern: /what is ([\d.]+)\+([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+)-([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+)\*([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /what is ([\d.]+)\/([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    
      { pattern: /([\d.]+)\+([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /([\d.]+)-([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /([\d.]+)\*([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /([\d.]+)\/([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    
      { pattern: /([\d.]+) \+ ([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /([\d.]+) - ([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /([\d.]+) \* ([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /([\d.]+) \/ ([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    
{
    pattern: /unlock image to text/i,
    response: "Unlocking Image to Text feature... Please upload your image."
}, 

// Sentiment Analysis Pattern
{
    pattern: /(.+)/i,
    response: (match) => {
        const message = match[1].toLowerCase();
        
        // Sentiment word database
        const sentimentData = {
            happy: {
                keywords: ["happy", "joy", "excited", "glad", "cheerful", "delighted", "pleased", "content", "jubilant", "elated"],
                responses: [
                    "I'm glad you're feeling happy! 😊",
                    "Your happiness is contagious! What's making you feel this way?",
                    "Wonderful to hear you're in good spirits! How can I help you today?",
                    "It's great that you're feeling positive! Anything special happening?",
                    "Your joyful energy is amazing! What can I assist you with?"
                ]
            },
            sad: {
                keywords: ["sad", "unhappy", "depressed", "down", "miserable", "gloomy", "heartbroken", "melancholy", "blue", "dejected"],
                responses: [
                    "I'm sorry you're feeling sad. Is there anything I can do to help? 🙁",
                    "I understand things might be tough right now. Would you like to talk about it?",
                    "I'm here for you. Sometimes sharing what's bothering you can help.",
                    "It's okay to feel sad sometimes. Would you like a distraction or some encouragement?",
                    "I'm sorry you're feeling this way. Remember that tough times don't last forever."
                ]
            },
            angry: {
                keywords: ["angry", "mad", "furious", "irritated", "annoyed", "frustrated", "rage", "livid", "irate", "outraged"],
                responses: [
                    "I sense you're feeling angry. Take a deep breath. Would you like to talk about what's bothering you? 😠",
                    "It sounds like something has upset you. Would you like to share what happened?",
                    "Anger is a natural emotion. Would you like help finding ways to manage it?",
                    "I'm here to listen. What's causing these feelings of anger?",
                    "It's okay to feel angry. Would you like some suggestions to help you calm down?"
                ]
            },
            anxious: {
                keywords: ["anxious", "worried", "nervous", "stressed", "tense", "uneasy", "apprehensive", "concerned", "troubled", "panicked"],
                responses: [
                    "I can sense you're feeling anxious. Take a deep breath. Would you like to talk about what's worrying you? 🧘",
                    "It sounds like you might be feeling stressed. Remember to take things one step at a time.",
                    "Anxiety can be challenging. Would you like some relaxation techniques or a distraction?",
                    "I'm here to help. Would you like to break down what's making you feel this way?",
                    "Try to focus on the present moment. Would you like some guidance on managing these feelings?"
                ]
            },
            confused: {
                keywords: ["confused", "unclear", "don't understand", "puzzled", "lost", "unsure", "baffled", "perplexed", "bewildered"],
                responses: [
                    "I sense some confusion. Let me try to explain things more clearly. 🤔",
                    "Don't worry, confusion is normal when learning new things. What specifically is unclear?",
                    "I'm here to help clarify things. What part would you like me to explain better?",
                    "It's okay to feel confused sometimes. Let's figure this out together.",
                    "Let me try to approach this differently to help you understand better."
                ]
            },
            tired: {
                keywords: ["tired", "exhausted", "fatigued", "sleepy", "drained", "worn out", "weary", "drowsy", "lethargic"],
                responses: [
                    "I can sense you might be feeling tired. Remember to take care of yourself and get some rest. 😴",
                    "It sounds like you could use some relaxation. Have you been getting enough sleep?",
                    "Fatigue can make everything harder. Is there anything I can help you with to make things easier?",
                    "Rest is important. Would you like some tips for better sleep or more energy?",
                    "I hear you're feeling tired. Don't forget to take breaks and listen to your body."
                ]
            },
            excited: {
                keywords: ["excited", "thrilled", "eager", "enthusiastic", "pumped", "stoked", "ecstatic", "jazzed", "elated"],
                responses: [
                    "Your excitement is contagious! What's got you so thrilled? 🎉",
                    "I love your enthusiasm! What are you looking forward to?",
                    "That's wonderful to hear! What's making you so excited?",
                    "Your energy is amazing! What's happening that's got you so pumped?",
                    "It's great to feel excited about things! What's the source of your excitement?"
                ]
            }
        };
        
        // Analyze sentiment
        let detectedSentiment = null;
        let maxScore = 0;
        
        // Check each sentiment category
        for (const [sentiment, data] of Object.entries(sentimentData)) {
            let score = 0;
            for (const keyword of data.keywords) {
                if (message.includes(keyword)) {
                    score++;
                }
            }
            
            if (score > maxScore) {
                maxScore = score;
                detectedSentiment = sentiment;
            }
        }
        
        // If we detected a sentiment, return a random response for that sentiment
        if (detectedSentiment && maxScore > 0) {
            const responses = sentimentData[detectedSentiment].responses;
            return responses[Math.floor(Math.random() * responses.length)];
        }
        
        return "I'm here to help! How can I assist you today? Feel free to share what's on your mind.";
    }
},

// Default response pattern (should come after the sentiment pattern)
{
    pattern: /.*/,
    response: () => {
        const defaultResponses = [
            "I'm sorry, I didn't understand that. Try asking a Math Related question!",
            "I'm not sure what you mean. Could you rephrase that?",
            "I didn't quite get that. Can you say it differently?",
            "Hmm, I'm not sure how to respond to that. Try asking something else.",
            "I'm still learning! Could you try asking in a different way?",
            "That's beyond my current understanding. Try a simpler question.",
            "I'm not programmed to understand that yet. Try asking about math!",
            "I'm sorry, I didn't catch that. Could you try again?",
            "That doesn't compute for me. Try a math question instead!",
            "I'm not sure what you're asking. Can you clarify?",
            "I'm still developing my knowledge. Try a basic math question!",
            "I don't understand that request. Try asking about mathematics.",
            "That's not in my knowledge base yet. Try a math problem!",
            "I'm confused by that question. Try something simpler.",
            "I'm not equipped to answer that. Try a math-related question!",
            "That's not something I can help with right now. Try asking about math!",
            "I'm still learning new things. Try a basic math question!",
            "I don't have information about that. Try asking about mathematics!",
            "That's beyond my programming. Try a math question instead!",
            "i am Limited Data Ai Edition .So This Data Not Programmed .Any Help You Need To Say Help !"
        ];
        
        // Return a random response from the array
        return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
    }
},

{
    pattern: /.*/,
    response: () => {
        const defaultResponses = [
            "I'm sorry, I didn't understand that. Try asking a Math Related question!",
            "I'm not sure what you mean. Could you rephrase that?",
            "I didn't quite get that. Can you say it differently?",
            "Hmm, I'm not sure how to respond to that. Try asking something else.",
            "I'm still learning! Could you try asking in a different way?",
            "That's beyond my current understanding. Try a simpler question.",
            "I'm not programmed to understand that yet. Try asking about math!",
            "I'm sorry, I didn't catch that. Could you try again?",
            "That doesn't compute for me. Try a math question instead!",
            "I'm not sure what you're asking. Can you clarify?",
            "I'm still developing my knowledge. Try a basic math question!",
            "I don't understand that request. Try asking about mathematics.",
            "That's not in my knowledge base yet. Try a math problem!",
            "I'm confused by that question. Try something simpler.",
            "I'm not equipped to answer that. Try a math-related question!",
            "That's not something I can help with right now. Try asking about math!",
            "I'm still learning new things. Try a basic math question!",
            "I don't have information about that. Try asking about mathematics!",
            "That's beyond my programming. Try a math question instead!",
            "i am Limited Data Ai Edition .So This Data Not Programmed .Any Help You Need To Say Help !"
        ];
        
        // Return a random response from the array
        return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
    }
},
  
    
];


let chatHistory = []; // Stores chat messages with timestamps
let calculatorEnabled = false; // Switch ON/OFF calculator mode
let weatherEnabled = false; // Weather mode toggle
// News mode toggle
let newsEnabled = false;
let ipEnabled = false; // IP mode is OFF by default
// ===== Declare Variables at Top =====
let ipTrackerEnabled = false; // IP Tracker Mode OFF by default
let isLocked = false; // Flag to check if the process is locked
let htmlLoadEnabled = false;  // Flag to check if the HTML load mode is enabled



let wikipediaEnabled = false; // Wikipedia mode toggle

// Advanced Calculator Function to handle multiple operations and expressions
function advancedCalculator(expression) {
    try {
        // Remove extra spaces before calculating
        expression = expression.replace(/\s+/g, '');

        // Evaluate the expression using eval (ensure valid operations)
        const result = eval(expression); 

        return result;
    } catch (e) {
        return 'Error in expression';
    }
}


// Wikipedia API function using Fetch
async function getWikipediaSummary(topic) {
    const encodedTopic = encodeURIComponent(topic);
    const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodedTopic}`;

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.extract) {
            return `📖 *Wikipedia Summary:*\n${data.extract}`;
        } else {
            return `❌ No Wikipedia data found for '${topic}'.`;
        }
    } catch (error) {
        return "⚠️ Error fetching Wikipedia data. Please try again later.";
    }
}



// Weather API function using Open-Meteo (no API key needed)
async function getWeather(city) {
    try {
        // First, get latitude and longitude for the city using OpenStreetMap Nominatim
        const geoResponse = await fetch(`https://nominatim.openstreetmap.org/search?city=${encodeURIComponent(city)}&format=json`);
        const geoData = await geoResponse.json();

        if (geoData.length === 0) {
            return `Sorry, I couldn't find the location "${city}".`;
        }

        const latitude = geoData[0].lat;
        const longitude = geoData[0].lon;

        // Now, fetch weather using Open-Meteo API
        const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);
        const weatherData = await weatherResponse.json();

        if (weatherData.current_weather) {
            const temp = weatherData.current_weather.temperature;
            const windspeed = weatherData.current_weather.windspeed;
            const weathercode = weatherData.current_weather.weathercode;

            return `Weather in ${city}:\nTemperature: ${temp}°C\nWind Speed: ${windspeed} km/h\nWeather Code: ${weathercode}`;
        } else {
            return "Sorry, weather information is not available right now.";
        }
    } catch (error) {
        return "Error fetching weather data. Please try again.";
    }
}

async function getLatestNews(searchTerms) {
    const apiKey = 'fa78fd6e485b416cbb55681c48e6a080';
    const baseUrl = 'https://newsapi.org/v2/everything';

    let newsResults = '';

    for (const term of searchTerms) {
        const url = `${baseUrl}?q=${encodeURIComponent(term)}&apiKey=${apiKey}`;

        try {
            const response = await fetch(url);
            const data = await response.json();

            if (data.articles && data.articles.length > 0) {
                const topArticle = data.articles[0];
                newsResults += `📰 *News for "${term}":*\nTitle: ${topArticle.title}\nDescription: ${topArticle.description}\n🔗 [Read more](${topArticle.url})\n\n`;
            } else {
                newsResults += `❌ No news found for "${term}".\n\n`;
            }
        } catch (error) {
            newsResults += `⚠️ Error fetching news for "${term}".\n\n`;
        }
    }

    return newsResults.trim() || "❌ No news found for any search term.";
}

// Function to fetch details of any IP address
async function getIPDetails(ipAddress) {
    const url = `https://ipinfo.io/${ipAddress}/json?token=16d9d846db0eb5`; // Your token added here

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data && data.ip) {
            return `🌐 *IP Address:* ${data.ip}\n` +
                   `🏙️ *City:* ${data.city}\n` +
                   `🌍 *Region:* ${data.region}\n` +
                   `🌎 *Country:* ${data.country}\n` +
                   `🏢 *ISP/Org:* ${data.org}\n` +
                   `📍 *Location Coordinates:* ${data.loc}`;
        } else {
            return "❌ Could not fetch details for the given IP address.";
        }
    } catch (error) {
        return "⚠️ Error fetching IP details. Please try again.";
    }
}
function generateImage(prompt) {
    const chatBox = document.getElementById("chat-box");
    
    // Create the image message container with your bot-container class
    const imageMessageContainer = document.createElement("div");
    imageMessageContainer.classList.add("bot-container");
    
    // Create a header div to contain the title and buttons
    const headerContainer = document.createElement("div");
    headerContainer.style.display = "flex";
    headerContainer.style.flexDirection = "column";
    headerContainer.style.alignItems = "flex-start";
    headerContainer.style.width = "100%";
    headerContainer.style.marginBottom = "10px";
    headerContainer.style.gap = "10px";
    
    // Create a div for the buttons
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    
    // Create copy button using your CSS class
    const copyButton = document.createElement('button');
    copyButton.textContent = 'Copy';
    copyButton.classList.add('copy-btn');
    copyButton.onclick = () => {
        navigator.clipboard.writeText(prompt);
        showNotification("Prompt copied to clipboard!");
    };
    buttonContainer.appendChild(copyButton);
    
    // Create share button using your CSS class
    const shareButton = document.createElement('button');
    shareButton.textContent = 'Share';
    shareButton.classList.add('copy-btn');
    shareButton.onclick = () => {
        if (navigator.share) {
            navigator.share({
                title: 'AI Generated Image',
                text: `Check out this image generated with the prompt: "${prompt}"`,
                url: window.location.href
            }).catch(err => console.error('Error sharing:', err));
        } else {
            // Fallback for browsers that don't support the Web Share API
            const shareUrl = `${window.location.href}?image=${encodeURIComponent(generatedImage.src)}&prompt=${encodeURIComponent(prompt)}`;
            navigator.clipboard.writeText(shareUrl);
            showNotification("Share link copied to clipboard!");
        }
    };
    buttonContainer.appendChild(shareButton);
    
    // Create download button using your CSS class
    const downloadButton = document.createElement('button');
    downloadButton.textContent = 'Download';
    downloadButton.classList.add('copy-btn');
    downloadButton.onclick = () => {
        // Create a zip file with all images or download the first one
        if (generatedImages.length > 1) {
            // For multiple images, we'll download them one by one
            generatedImages.forEach((img, index) => {
                setTimeout(() => {
                    const link = document.createElement("a");
                    link.href = img.src;
                    link.download = `ai-image-${index + 1}-${Date.now()}.png`;
                    link.click();
                }, index * 200); // Small delay between downloads
            });
        } else {
            // For single image
            const link = document.createElement("a");
            link.href = generatedImages[0].src;
            link.download = `ai-image-${Date.now()}.png`;
            link.click();
        }
    };
    buttonContainer.appendChild(downloadButton);
    
    // Create the bot message for image generation
    const botMessage = document.createElement("div");
    botMessage.classList.add("bot-message");
    botMessage.innerHTML = `<strong style="color: white; background: linear-gradient(145deg, #d30, #d35); padding: 4px 8px; box-shadow: 0 0 5px #d35;border-radius: 6px; display: inline-block;">AI Image:</strong> Generating image for: "${prompt}"`;
    
    // Add the button container first, then the bot message below it
    headerContainer.appendChild(buttonContainer);
    headerContainer.appendChild(botMessage);
    
    // Create a photo shape loading indicator with your specified colors
    const loadingIndicator = document.createElement("div");
    loadingIndicator.classList.add("photo-loading");
    loadingIndicator.innerHTML = `
        <div class="photo-loading-container">
            <div class="photo-frame">
                <div class="photo-content">
                    <div class="photo-gradient"></div>
                    <div class="photo-text">AI 3.0</div>
                    <div class="photo-dots">
                        <div class="photo-dot"></div>
                        <div class="photo-dot"></div>
                        <div class="photo-dot"></div>
                    </div>
                </div>
            </div>
            <div class="loading-text">Generating amazing images...</div>
        </div>
    `;
    
    // Create a container for multiple images
    const imagesContainer = document.createElement("div");
    imagesContainer.style.display = "flex";
    imagesContainer.style.flexWrap = "wrap";
    imagesContainer.style.gap = "10px";
    imagesContainer.style.marginTop = "10px";
    imagesContainer.style.marginBottom = "10px";
    
    // Initially hide the images container
    imagesContainer.style.display = "none";
    
    // Parse the prompt to extract animal type and quantity
    const { animalType, quantity } = parseImagePrompt(prompt);
    
    // Get random images based on the parsed prompt
    getRandomImages(animalType, quantity).then(imagePaths => {
        // Create image elements for each path
        const generatedImages = [];
        let validImagesCount = 0;
        
        imagePaths.forEach((imagePath, index) => {
            const generatedImage = document.createElement("img");
            generatedImage.classList.add("generated-image");
            generatedImage.alt = `Generated image ${index + 1} for: ${prompt}`;
            generatedImage.src = imagePath;
            // Set reduced dimensions
            generatedImage.style.width = "300px";
            generatedImage.style.height = "200px";
            generatedImage.style.objectFit = "cover";
            generatedImage.style.borderRadius = "8px";
            generatedImage.style.cursor = "pointer";
            
            // Add error handling in case the image doesn't exist
            generatedImage.onerror = function() {
                // If image doesn't load, remove it from the container
                this.remove();
                validImagesCount--;
                
                // If no valid images were found, show a message
                if (validImagesCount === 0 && index === imagePaths.length - 1) {
                    const noImagesMessage = document.createElement("div");
                    noImagesMessage.style.padding = "20px";
                    noImagesMessage.style.backgroundColor = "#f8f9fa";
                    noImagesMessage.style.borderRadius = "8px";
                    noImagesMessage.style.color = "#666";
                    noImagesMessage.textContent = `No ${animalType} images found. Please try a different animal type.`;
                    imagesContainer.appendChild(noImagesMessage);
                }
            };
            
            // Add success handling
            generatedImage.onload = function() {
                validImagesCount++;
            };
            
            // Add click event to view full size
            generatedImage.onclick = () => {
                viewFullSizeImage(imagePath);
            };
            
            generatedImages.push(generatedImage);
            imagesContainer.appendChild(generatedImage);
        });
        
        // Append the header and loading indicator to the image message container
        imageMessageContainer.appendChild(headerContainer);
        imageMessageContainer.appendChild(loadingIndicator);
        imageMessageContainer.appendChild(imagesContainer);
        
        // Append the container to chatBox
        chatBox.appendChild(imageMessageContainer);
        chatBox.appendChild(document.createElement("br"));
        
        // Scroll to bottom
        chatBox.scrollTop = chatBox.scrollHeight;
        
        // Simulate loading delay before showing the images
        setTimeout(() => {
            // Remove loading indicator
            imageMessageContainer.removeChild(loadingIndicator);
            
            // Show the images container
            imagesContainer.style.display = "flex";
            
            // Save to history
            chatHistory.push(`[${new Date().toLocaleTimeString()}] AI Image: Generated for prompt "${prompt}"`);
            
            // Scroll to bottom again to show the images
            chatBox.scrollTop = chatBox.scrollHeight;
        }, 1500); // 1.5 second delay to simulate generation
    });
}

// Function to parse the image prompt to extract animal type and quantity
function parseImagePrompt(prompt) {
    const lowerPrompt = prompt.toLowerCase();
    
    // Default values
    let animalType = "animal";
    let quantity = 1;
    
    // Check for specific animal types - more specific checks first
    if (lowerPrompt.includes("cat")) {
        animalType = "cat";
    } else if (lowerPrompt.includes("dog")) {
        animalType = "dog";
    } else if (lowerPrompt.includes("bird")) {
        animalType = "bird";
    } else if (lowerPrompt.includes("fish")) {
        animalType = "fish";
    } else if (lowerPrompt.includes("lion")) {
        animalType = "lion";
    } else if (lowerPrompt.includes("tiger")) {
        animalType = "tiger";
    } else if (lowerPrompt.includes("elephant")) {
        animalType = "elephant";
    } else if (lowerPrompt.includes("monkey")) {
        animalType = "monkey";
    } else if (lowerPrompt.includes("animal")) {
        animalType = "animal";
    }
    
    // Check for quantity (e.g., "2 photo", "6 photos")
    const quantityMatch = lowerPrompt.match(/(\d+)\s*(photo|photos|image|images)/i);
    if (quantityMatch) {
        quantity = parseInt(quantityMatch[1]);
        // Limit the quantity to a reasonable number
        quantity = Math.min(quantity, 200);
    }
    
    return { animalType, quantity };
}

// Define your image directory paths for different animal types
const animalImageDirs = {
    animal: "ANIMAL/",
    cat: "ANIMAL/CAT/",
    dog: "ANIMAL/DOG/",
    bird: "ANIMAL/BIRD/",
    fish: "ANIMAL/FISH/",
    lion: "ANIMAL/LION/",
    tiger: "ANIMAL/TIGER/",
    elephant: "ANIMAL/ELEPHANT/",
    monkey: "ANIMAL/MONKEY/"
};

// Cache for storing image lists to avoid repeated requests
const imageCache = {};

// Universal function to get random images based on animal type and quantity
async function getRandomImages(animalType, quantity) {
    // Check if we already have the image list cached
    if (imageCache[animalType]) {
        return getRandomImagesFromList(imageCache[animalType], quantity);
    }
    
    // Try to fetch the image list from the server
    try {
        const response = await fetch(`api/images.php?type=${animalType}`);
        
        if (response.ok) {
            const imageList = await response.json();
            // Cache the image list
            imageCache[animalType] = imageList;
            return getRandomImagesFromList(imageList, quantity);
        }
    } catch (error) {
        console.error("Error fetching image list:", error);
    }
    
    // Fallback to sequential naming pattern if server request fails
    return getRandomImagesSequential(animalType, quantity);
}

// Function to get random images from a list
function getRandomImagesFromList(imageList, quantity) {
    const randomImages = [];
    const usedIndices = new Set();
    
    for (let i = 0; i < quantity && i < imageList.length; i++) {
        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * imageList.length);
        } while (usedIndices.has(randomIndex));
        
        usedIndices.add(randomIndex);
        randomImages.push(imageList[randomIndex]);
    }
    
    return randomImages;
}

// Fallback function for sequential naming pattern
function getRandomImagesSequential(animalType, quantity) {
    const imageDir = animalImageDirs[animalType] || animalImageDirs.animal;
    
    // Define the maximum number of images for each animal type
    const maxImagesPerType = {
        animal: 21,
        cat: 9,
        dog: 12,
        bird: 6,
        fish: 6,
        lion: 6,
        tiger: 6,
        elephant: 6,
        monkey: 6
    };
    
    const maxImages = maxImagesPerType[animalType] || 21;
    
    const randomImages = [];
    const usedIndices = new Set();
    
    for (let i = 0; i < quantity && i < maxImages; i++) {
        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * maxImages) + 1;
        } while (usedIndices.has(randomIndex));
        
        usedIndices.add(randomIndex);
        
        // Create the image path with proper naming convention
        let imagePrefix = animalType === "animal" ? "Animal" : animalType.charAt(0).toUpperCase() + animalType.slice(1);
        const imagePath = `${imageDir}${imagePrefix}${randomIndex}.png`;
        randomImages.push(imagePath);
    }
    
    return randomImages;
}

// Function to view full size image
function viewFullSizeImage(imagePath) {
    // Create modal overlay
    const modalOverlay = document.createElement("div");
    modalOverlay.style.position = "fixed";
    modalOverlay.style.top = "0";
    modalOverlay.style.left = "0";
    modalOverlay.style.width = "100%";
    modalOverlay.style.height = "100%";
    modalOverlay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    modalOverlay.style.display = "flex";
    modalOverlay.style.justifyContent = "center";
    modalOverlay.style.alignItems = "center";
    modalOverlay.style.zIndex = "1000";
    
    // Create full size image
    const fullSizeImage = document.createElement("img");
    fullSizeImage.src = imagePath;
    fullSizeImage.style.maxWidth = "90%";
    fullSizeImage.style.maxHeight = "90%";
    fullSizeImage.style.borderRadius = "8px";
    
    // Add error handling in case the image doesn't exist
    fullSizeImage.onerror = function() {
        // Try to load a default image if the specific one doesn't exist
        const animalType = imagePath.split('/')[1].toLowerCase();
        this.src = `${animalImageDirs[animalType] || animalImageDirs.animal}default.png`;
        this.onerror = function() {
            // If even the default doesn't exist, show an error message
            this.style.display = "none";
            const errorMessage = document.createElement("div");
            errorMessage.style.color = "white";
            errorMessage.textContent = "Image not available";
            modalOverlay.appendChild(errorMessage);
        };
    };
    
    // Add click event to close modal
    modalOverlay.onclick = () => {
        document.body.removeChild(modalOverlay);
    };
    
    // Append image to modal and modal to body
    modalOverlay.appendChild(fullSizeImage);
    document.body.appendChild(modalOverlay);
}



// Add this to your existing code
let uploadedImagePath = null;
let handDetected = false;

// Function to handle image upload
function handleImageUpload(event) {
    const file = event.target.files[0];
    if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = function(e) {
            uploadedImagePath = e.target.result;
            
            // Create a preview of the uploaded image
            const previewContainer = document.createElement("div");
            previewContainer.classList.add("bot-container");
            previewContainer.style.marginBottom = "10px";
            
            const previewImage = document.createElement("img");
            previewImage.src = uploadedImagePath;
            previewImage.style.maxWidth = "300px";
            previewImage.style.maxHeight = "200px";
            previewImage.style.borderRadius = "8px";
            previewImage.style.margin = "10px 0";
            
            const previewText = document.createElement("div");
            previewText.textContent = "Image uploaded. Now you can ask me to add objects to your hand.";
            previewText.style.color = "#666";
            previewText.style.fontSize = "14px";
            
            previewContainer.appendChild(previewImage);
            previewContainer.appendChild(previewText);
            
            const chatBox = document.getElementById("chat-box");
            chatBox.appendChild(previewContainer);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Simulate hand detection
            setTimeout(() => {
                handDetected = true;
                previewText.textContent = "Image uploaded. Hand detected. You can now ask me to add objects to your hand.";
            }, 1500);
        };
        reader.readAsDataURL(file);
    }
}

// Update your sendMessage function to handle the new image generation commands
function sendMessage() {
    const userInputRaw = document.getElementById("user-input").value.trim();
    if (userInputRaw === "") return;

    const chatBox = document.getElementById("chat-box");

    // Start time of chat
    if (chatHistory.length === 0) {
        chatHistory.push(`Chat Start: ${new Date().toLocaleString()}\n`);
    }

    // Add user message
    const userMessage = document.createElement("div");
    userMessage.classList.add("user-message");  // Add class for styling
    userMessage.textContent = "You: " + userInputRaw;    

    chatBox.appendChild(userMessage);
    chatBox.appendChild(document.createElement("br"));

    // Save user message
    chatHistory.push(`[${new Date().toLocaleTimeString()}] You: ${userInputRaw}`);

    // Check for image generation patterns
    const imagePatterns = [
        { 
            pattern: /show me a (.+) (\d+) photo/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) photo/i, 
            extractParam: (match) => match[0]
        },
                { 
            pattern: /i need (.+) photo/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /i need (.+) (\d+) photos/i, 
            extractParam: (match) => match[0]
        },
           { 
            pattern: /show me a (.+) (\d+) photos/i, 
            extractParam: (match) => match[0]
        },
                   { 
            pattern: /(.+) (\d+) photos/i, 
            extractParam: (match) => match[0]
        },
      
        { 
            pattern: /show me a (.+) photos/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) (\d+) image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) (\d+) images/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) images/i, 
            extractParam: (match) => match[0]
        },
            { 
            pattern: /Give me a(.+) photos/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me a(.+) (\d+) image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me a(.+) image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me a(.+) (\d+) images/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me a(.+) images/i, 
            extractParam: (match) => match[0]
        },
            { 
            pattern: /Give me(.+) photos/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me(.+) (\d+) image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me(.+) image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me(.+) (\d+) images/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me(.+) images/i, 
            extractParam: (match) => match[0]
        },
        
                { 
            pattern: /Give me(.+) (\d+) Photos/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me(.+) Photos/i, 
            extractParam: (match) => match[0]
        },
        
                { 
            pattern: /Give me(.+) (\d+) Photo/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /Give me(.+) Photo/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /generate (multiple|several|a few) (images|pictures|photos) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me (multiple|several|a few) (images|pictures|photos) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /generate an? (image|picture|photo) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /create an? (image|picture|photo) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /draw (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /make an? (image|picture|photo) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me (.+)/i, 
            extractParam: (match) => match[0]
        },
        
        
        
        { 
            pattern: /show me a (.+) (\d+) Image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) Image/i, 
            extractParam: (match) => match[0]
        },
                { 
            pattern: /i need (.+) Image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /i need (.+) (\d+) Images/i, 
            extractParam: (match) => match[0]
        },
           { 
            pattern: /show me a (.+) (\d+) Images/i, 
            extractParam: (match) => match[0]
        },
  
        { 
            pattern: /show me a (.+) Images/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) (\d+) image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) image/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) (\d+) images/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me a (.+) images/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /generate (multiple|several|a few) (images|pictures|photos) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /show me (multiple|several|a few) (images|pictures|photos) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /generate an? (image|picture|photo) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /create an? (image|picture|photo) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /draw (.+)/i, 
            extractParam: (match) => match[0]
        },
        { 
            pattern: /make an? (image|picture|photo) of (.+)/i, 
            extractParam: (match) => match[0]
        },
        
    ];

    // Check if the input matches any image generation pattern
    for (const pattern of imagePatterns) {
        const match = userInputRaw.match(pattern.pattern);
        if (match) {
            const prompt = pattern.extractParam(match);
            generateImage(prompt);
            document.getElementById("user-input").value = "";
            return; // Exit early since we've handled this as an image request
        }
    }

    // Unlock and lock commands inside sendMessage
    if (/unlock weather mode/i.test(userInputRaw) || /open weather/i.test(userInputRaw)) {
        weatherEnabled = true;
        botReply("Weather Mode is now UNLOCKED! Type a city name like 'weather in London' to get the current weather.");
        document.getElementById("user-input").value = "";
        return;
    }

   
if (/close weather mode/i.test(userInputRaw) || /lock weather/i.test(userInputRaw)) {
    weatherEnabled = false;
    botReply("Weather Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

// Handle weather requests
if (weatherEnabled) {
    const city = userInputRaw.replace(/weather in /i, "").trim();
    if (city) {
        getWeather(city).then((weatherInfo) => {
            botReply(weatherInfo);
        });
        document.getElementById("user-input").value = "";
        return; // <- ADD THIS RETURN to stop further reply
    } else {
        botReply("Please specify a city to get the weather.");
        document.getElementById("user-input").value = "";
        return; // <- also here
    }
}

// Inside your message handler:

if (/unlock News mode/i.test(userInputRaw)) {
    newsEnabled = true;
    botReply("News Mode is now UNLOCKED! Ask me 'Who is <name>' or type keywords to get a summary.");
    document.getElementById("user-input").value = "";
    return;
}
if (/close News mode/i.test(userInputRaw)) {
    newsEnabled = false;
            botReply(`${this.currentGame.name} loaded! ${this.currentGame.instructions}`);y("News Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

if (newsEnabled) {
    // Extract keywords from the user input
    let searchTerms = userInputRaw
        .replace(/news mode|who is|news/gi, '') // remove these words
        .split(/[,\s]+/) // split by space or comma
        .filter(term => term.trim() !== ''); // remove empty strings

    if (searchTerms.length === 0) {
        botReply("❗ Please provide a name or keyword to search for news.");
        document.getElementById("user-input").value = "";
    } else {
        getLatestNews(searchTerms).then(newsInfo => {
            botReply(newsInfo);
        });
        document.getElementById("user-input").value = "";
    }
    return; // Stop further normal reply
}

// Handle unlock/lock commands
if (/unlock wikipedia mode/i.test(userInputRaw) || /open wikipedia/i.test(userInputRaw)) {
    wikipediaEnabled = true;
    botReply("Wikipedia Mode is now UNLOCKED! Ask me 'Who is <name>' to get a summary.");
    document.getElementById("user-input").value = "";
    return;
}

if (/close wikipedia mode/i.test(userInputRaw) || /lock wikipedia/i.test(userInputRaw)) {
    wikipediaEnabled = false;
    botReply("Wikipedia Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}



// Handle Wikipedia requests
if (wikipediaEnabled) {
    const match = userInputRaw.match(/who is (.+)/i); // Check if the query matches the pattern "who is <name>"
    if (match && match[1]) {
        const topic = match[1];

        // Call the getWikipediaSummary function
        getWikipediaSummary(topic).then((wikipediaInfo) => {
            botReply(wikipediaInfo); // Send the response back to the bot
        });
        document.getElementById("user-input").value = "";
        return; // Stop further reply after sending response
    } else {
        botReply("Please ask something like 'Who is Albert Einstein'.");
        document.getElementById("user-input").value = "";
        return; // Stop further reply here as well
    }
}
// Function to fetch your public IP address
async function getMyIP() {
    const url = 'https://api.ipify.org?format=json'; // Free public IP API

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.ip) {
            return `🌐 Your Public IP Address is: *${data.ip}*`;
            document.getElementById("user-input").value = "";
        } else {
            return "❌ Could not fetch IP address.";
            document.getElementById("user-input").value = "";
        }
    } catch (error) {
        return "⚠️ Error fetching IP address. Please try again later.";
        document.getElementById("user-input").value = "";
    }
}
// Unlock IP Mode
if (/unlock ip mode/i.test(userInputRaw) || /open ip check/i.test(userInputRaw)) {
    ipEnabled = true;
    botReply("IP Check Mode is now UNLOCKED! Type anything to see your IP address.");
    return;
}

// Lock IP Mode
if (/close ip mode/i.test(userInputRaw) || /lock ip check/i.test(userInputRaw)) {
    ipEnabled = false;
    botReply("IP Check Mode is now LOCKED! Back to normal chatting.");
    return;
}

// Now handle IP Check if IP mode is enabled
if (ipEnabled) {
    getMyIP().then(ipInfo => {
        botReply(ipInfo);
    });
    return; // stop further reply
}




// ==== Toggle IP Tracker Mode =====
if (/unlock ip tracker mode/i.test(userInputRaw)) {
    ipTrackerEnabled = true;
    botReply("IP Tracker Mode is now UNLOCKED! Type any IP address to check details.");
    return;
}

if (/close ip tracker mode/i.test(userInputRaw)) {
    ipTrackerEnabled = false;
    botReply("IP Tracker Mode is now LOCKED! Back to normal chatting.");
    return;
}


// ==== Handle IP Address Input in Tracker Mode =====
if (ipTrackerEnabled) {
    // Try to detect IP Address Format
    const ipRegex = /(\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b)/;
    const match = userInputRaw.match(ipRegex);

    if (match) {
        const ipAddress = match[1];
        getIPDetails(ipAddress).then(ipInfo => {
            botReply(ipInfo);
        });
    } else {
        botReply("❗ Please enter a valid IP address like 8.8.8.8");
    }
    return; // Stop further reply
}


const badWords = [
    // English bad words (sex related + common)
    "fuck", "shit", "bitch", "asshole", "bastard", "dumb", "stupid", "idiot",
    "dick", "cock", "pussy", "penis", "vagina", "boobs", "nipple", "cum", "suck",
    "sex", "sexy", "horny", "porn", "pornhub", "milf", "slut", "whore", "fucker",
    "motherfucker", "cunt", "ass", "jerk", "jerking", "blowjob", "handjob", "orgasm",
    "moan", "bang", "rape", "nude", "nudes", "naked",

    // Hindi bad words (India)
    "chutiya", "bhosdike", "bhenchod", "madarchod", "gandu", "loda", "lund", "randi",
    "chut", "gaand", "chutmarani", "gaandfat", "chutiyapa",

    // Spanish bad words
    "puta", "mierda", "coño", "polla", "cabron", "pendejo", "puto", "culero",

    // Arabic bad words
    "sharmuta", "kos ommak", "ibn al kalb", "ibn sharmuta", "ayreh", "khara",

    // French bad words
    "pute", "merde", "salope", "connard", "enculé",

    // Portuguese bad words
    "porra", "caralho", "puta", "merda", "bosta",

    // Russian bad words
    "blyad", "suka", "pidor", "khuy", "ebat",

    // Extra offensive English
    "motherfucking", "assfucker", "cumshot", "cockslut", "fuckboy", "fuckgirl"
];


// Direct check without foundBadWord variable
if (badWords.some(badWord => new RegExp("\\b" + badWord + "\\b", "i").test(userInputRaw))) {
    botReply("Warning ⚠️ !");
    return;
}


// Check special commands for calculator mode
if (/unlock advanced calculator|Advance Calculator|Advanced Calculator/i.test(userInputRaw) || /open calculator/i.test(userInputRaw)) {
    calculatorEnabled = true;
    botReply("Advanced Calculator Mode is now UNLOCKED! Type your mathematical expressions to calculate.");
    document.getElementById("user-input").value = "";
    return;
}

if (/close advanced calculator/i.test(userInputRaw) || /lock calculator/i.test(userInputRaw)) {
    calculatorEnabled = false;
    botReply("Advanced Calculator Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

if (/reset calculator/i.test(userInputRaw)) {
    calculatorEnabled = false;
    botReply("Calculator Mode has been RESET! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

    // Now handle based on mode
    if (calculatorEnabled) {
        const result = advancedCalculator(userInputRaw);
        botReply(`Result: ${result}`);
        document.getElementById("user-input").value = "";
    } else {
    document.getElementById("user-input").value = "";
        // Normal chatbot mode
        let reply = "Sorry, I don't understand that.";
        for (let pair of responses) {
            if (pair.pattern instanceof RegExp && pair.pattern.test(userInputRaw)) {
                reply = typeof pair.response === "function" ? pair.response(userInputRaw.match(pair.pattern)) : pair.response;
                break;
            }
        }
        botReply(reply);
    }

    // Clear input field
    document.getElementById("user-input").value = "";
    
        // Check if user wants to clear chat
    if (/clear all/i.test(userInputRaw)) {
        chatBox.innerHTML = "";
        chatHistory = []; // Reset chat history
        document.getElementById("user-input").value = "";        
        
        botReply(` Welcome To VIPTEAMMOD AI 3.0`);
        return;
    }

// Enhanced Photo Editor with Advanced Features and Upgrades
class PhotoEditor {
    constructor() {
        this.initializeEditor();
        this.setupDownloadSystem();
        this.setupEffectSelection();
        this.setupHistorySystem();
        this.setupBatchProcessing();
        this.initializeAdvancedFeatures();
    }

    initializeEditor() {
        // Create hidden file input
        this.fileInput = document.createElement('input');
        this.fileInput.type = 'file';
        this.fileInput.accept = 'image/*';
        this.fileInput.style.display = 'none';
        this.fileInput.id = 'photoEditorInput';
        document.body.appendChild(this.fileInput);
        
        // Add event listener
        this.fileInput.addEventListener('change', (e) => this.handleImageUpload(e));
        
        // Initialize editor state
        this.currentImage = null;
        this.originalImageData = null;
        this.processingHistory = [];
        this.redoStack = [];
        this.batchMode = false;
        this.batchImages = [];
        this.currentBatchIndex = 0;
        
        // Create progress indicator
        this.progressIndicator = document.createElement('div');
        this.progressIndicator.className = 'progress-indicator';
        this.progressIndicator.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
            text-align: center;
        `;
        document.body.appendChild(this.progressIndicator);
    }

    setupDownloadSystem() {
        // Create download notification container
        this.downloadNotification = document.createElement('div');
        this.downloadNotification.className = 'download-notification';
        this.downloadNotification.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            max-width: 300px;
            transition: all 0.3s ease;
        `;
        document.body.appendChild(this.downloadNotification);
        
        // Create share options
        this.shareOptions = document.createElement('div');
        this.shareOptions.className = 'share-options';
        this.shareOptions.style.cssText = `
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            padding: 10px;
        `;
        document.body.appendChild(this.shareOptions);
    }

    setupEffectSelection() {
        // Available effects with enhanced metadata
        this.availableEffects = [
            { id: 'none', name: 'No Effect', icon: '🖼️', category: 'basic' },
            { id: 'crack', name: 'Crack Effect', icon: '🔨', category: 'artistic' },
            { id: 'vintage', name: 'Vintage', icon: '📜', category: 'color' },
            { id: 'grayscale', name: 'Grayscale', icon: '⚫', category: 'color' },
            { id: 'sepia', name: 'Sepia', icon: '🟤', category: 'color' },
            { id: 'blur', name: 'Blur', icon: '💧', category: 'adjustment', adjustable: true },
            { id: 'sharpen', name: 'Sharpen', icon: '🔍', category: 'adjustment', adjustable: true },
            { id: 'pixelate', name: 'Pixelate', icon: '🧩', category: 'artistic', adjustable: true },
            { id: 'glitch', name: 'Glitch', icon: '📺', category: 'artistic' },
            { id: 'neon', name: 'Neon', icon: '💡', category: 'artistic' },
            { id: 'brightness', name: 'Brightness', icon: '☀️', category: 'adjustment', adjustable: true },
            { id: 'contrast', name: 'Contrast', icon: '🌗', category: 'adjustment', adjustable: true },
            { id: 'saturation', name: 'Saturation', icon: '🎨', category: 'adjustment', adjustable: true },
            { id: 'hue', name: 'Hue Shift', icon: '🌈', category: 'adjustment', adjustable: true },
            { id: 'invert', name: 'Invert', icon: '🔄', category: 'color' },
            { id: 'edge', name: 'Edge Detect', icon: '📐', category: 'artistic' },
            { id: 'emboss', name: 'Emboss', icon: '🗿', category: 'artistic' },
            { id: 'oil', name: 'Oil Painting', icon: '🖌️', category: 'artistic' },
            { id: 'cartoon', name: 'Cartoon', icon: '🎭', category: 'artistic' },
            { id: 'mirror', name: 'Mirror', icon: '🪞', category: 'transform' },
            { id: 'rotate', name: 'Rotate', icon: '🔄', category: 'transform', adjustable: true },
            { id: 'crop', name: 'Crop', icon: '✂️', category: 'transform', adjustable: true },
            { id: 'vignette', name: 'Vignette', icon: '🌑', category: 'adjustment', adjustable: true },
            { id: 'noise', name: 'Add Noise', icon: '📶', category: 'adjustment', adjustable: true },
            { id: 'posterize', name: 'Posterize', icon: '🎪', category: 'artistic', adjustable: true },
            { id: 'solarize', name: 'Solarize', icon: '☀️', category: 'artistic' },
            { id: 'ghibli', name: 'Ghibli Style', icon: '🌿', category: 'artistic' },
            // New effects
            { id: 'bokeh', name: 'Bokeh', icon: '✨', category: 'artistic' },
            { id: 'lensflare', name: 'Lens Flare', icon: '🌟', category: 'artistic' },
            { id: 'hdr', name: 'HDR', icon: '🔆', category: 'adjustment' },
            { id: 'tiltshift', name: 'Tilt Shift', icon: '🏙️', category: 'artistic' },
            { id: 'watercolor', name: 'Watercolor', icon: '🎨', category: 'artistic' },
            { id: 'sketch', name: 'Sketch', icon: '✏️', category: 'artistic' },
            { id: 'doubleexposure', name: 'DoubleExposure', icon: '👥', category: 'advanced' },
            { id: 'colorpop', name: 'ColorPop', icon: '🎈', category: 'color' },
            { id: 'retro', name: 'Retro', icon: '📻', category: 'color' }
        ];
        
        this.selectedEffect = 'none';
        this.effectParameters = {};
        this.activeCategory = 'all';
    }

    setupHistorySystem() {
        // Create history controls
        this.historyControls = document.createElement('div');
        this.historyControls.className = 'history-controls';
        this.historyControls.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 10px;
            z-index: 1000;
            display: none;
        `;
        
        // Add undo/redo buttons
        const undoButton = document.createElement('button');
        undoButton.innerHTML = '↶ Undo';
        undoButton.style.cssText = `
            background: #f0f0f0;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            margin-right: 5px;
            cursor: pointer;
        `;
        undoButton.addEventListener('click', () => this.undo());
        
        const redoButton = document.createElement('button');
        redoButton.innerHTML = '↷ Redo';
        redoButton.style.cssText = `
            background: #f0f0f0;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
        `;
        redoButton.addEventListener('click', () => this.redo());
        
        this.historyControls.appendChild(undoButton);
        this.historyControls.appendChild(redoButton);
        document.body.appendChild(this.historyControls);
    }

    setupBatchProcessing() {
        // Create batch processing controls
        this.batchControls = document.createElement('div');
        this.batchControls.className = 'batch-controls';
        this.batchControls.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 10px;
            z-index: 1000;
            display: none;
        `;
        
        // Add batch mode toggle
        const batchToggle = document.createElement('button');
        batchToggle.innerHTML = '📁 Batch Mode';
        batchToggle.style.cssText = `
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
        `;
        batchToggle.addEventListener('click', () => this.toggleBatchMode());
        
        this.batchControls.appendChild(batchToggle);
        document.body.appendChild(this.batchControls);
        
        // Create batch file input
        this.batchFileInput = document.createElement('input');
        this.batchFileInput.type = 'file';
        this.batchFileInput.accept = 'image/*';
        this.batchFileInput.multiple = true;
        this.batchFileInput.style.display = 'none';
        this.batchFileInput.id = 'batchPhotoEditorInput';
        document.body.appendChild(this.batchFileInput);
        
        this.batchFileInput.addEventListener('change', (e) => this.handleBatchImageUpload(e));
    }

    initializeAdvancedFeatures() {
        // Create advanced features panel
        this.advancedPanel = document.createElement('div');
        this.advancedPanel.className = 'advanced-panel';
        this.advancedPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 20px;
            z-index: 2000;
            display: none;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        `;
        document.body.appendChild(this.advancedPanel);
        
        // Create close button for advanced panel
        const closeButton = document.createElement('button');
        closeButton.innerHTML = '✕';
        closeButton.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        `;
        closeButton.addEventListener('click', () => {
            this.advancedPanel.style.display = 'none';
        });
        this.advancedPanel.appendChild(closeButton);
    }

    // Trigger photo editing with effect selection
    triggerPhotoEdit(userInput) {
        // Check if user specified a specific effect
        const effectMatch = userInput.match(/edit photo\s+(\w+)/i);
        
        if (effectMatch) {
            const effectName = effectMatch[1].toLowerCase();
            const effect = this.availableEffects.find(e => e.id === effectName);
            
            if (effect) {
                this.selectedEffect = effect.id;
                botReply(`Selected: ${effect.name}. Please upload your photo.`);
                setTimeout(() => {
                    this.fileInput.click();
                }, 1000);
                return;
            } else {
                botReply(`Effect "${effectName}" not found. Available effects: ${this.availableEffects.map(e => e.name).join(', ')}`);
                return;
            }
        }
        
        // If no specific effect was mentioned, show selection UI
        this.showEffectSelection();
    }

    // Show effect selection interface with categories
    showEffectSelection() {
        botReply("Choose an effect for your photo:");
        
        // Create effect selection container
        const effectContainer = document.createElement('div');
        effectContainer.className = 'effect-selection';
        effectContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            margin-top: 15px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
        `;
        
        // Create category tabs
        const categories = ['all', 'basic', 'color', 'adjustment', 'artistic', 'transform', 'advanced'];
        const categoryNames = {
            'all': 'All Effects',
            'basic': 'Basic',
            'color': 'Color',
            'adjustment': 'Adjustments',
            'artistic': 'Artistic',
            'transform': 'Transform',
            'advanced': 'Advanced'
        };
        
        const categoryTabs = document.createElement('div');
        categoryTabs.className = 'category-tabs';
        categoryTabs.style.cssText = `
            display: flex;
            margin-bottom: 15px;
            overflow-x: auto;
        `;
        
        categories.forEach(category => {
            const tab = document.createElement('button');
            tab.className = 'category-tab';
            tab.textContent = categoryNames[category];
            tab.style.cssText = `
                background: ${this.activeCategory === category ? '#4CAF50' : '#ddd'};
                color: ${this.activeCategory === category ? 'white' : 'black'};
                border: none;
                border-radius: 4px;
                padding: 8px 12px;
                margin-right: 5px;
                cursor: pointer;
                white-space: nowrap;
            `;
            
            tab.addEventListener('click', () => {
                this.activeCategory = category;
                this.showEffectSelection();
            });
            
            categoryTabs.appendChild(tab);
        });
        
        effectContainer.appendChild(categoryTabs);
        
        // Create effects grid
        const effectsGrid = document.createElement('div');
        effectsGrid.className = 'effects-grid';
        effectsGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        `;
        
        // Filter effects by active category
        const filteredEffects = this.activeCategory === 'all' 
            ? this.availableEffects 
            : this.availableEffects.filter(effect => effect.category === this.activeCategory);
        
        // Create effect buttons
        filteredEffects.forEach(effect => {
            const effectButton = document.createElement('button');
            effectButton.className = 'effect-button';
            effectButton.style.cssText = `
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 15px 10px;
                background: white;
                border: 2px solid #ddd;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 14px;
            `;
            
            effectButton.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">${effect.icon}</div>
                <div>${effect.name}</div>
                ${effect.adjustable ? '<div style="font-size: 10px; color: #666;">Adjustable</div>' : ''}
            `;
            
            effectButton.addEventListener('click', () => {
                if (effect.adjustable) {
                    this.showEffectAdjustment(effect.id);
                } else {
                    this.selectEffect(effect.id);
                }
            });
            
            effectButton.addEventListener('mouseenter', () => {
                effectButton.style.transform = 'translateY(-5px)';
                effectButton.style.boxShadow = '0 5px 15px rgba(0,0,0,0.1)';
                effectButton.style.borderColor = '#4CAF50';
            });
            
            effectButton.addEventListener('mouseleave', () => {
                effectButton.style.transform = 'translateY(0)';
                effectButton.style.boxShadow = 'none';
                effectButton.style.borderColor = '#ddd';
            });
            
            effectsGrid.appendChild(effectButton);
        });
        
        effectContainer.appendChild(effectsGrid);
        
        // Add batch mode option
        const batchOption = document.createElement('div');
        batchOption.style.cssText = `
            margin-top: 15px;
            text-align: center;
        `;
        
        const batchButton = document.createElement('button');
        batchButton.innerHTML = '📁 Process Multiple Images';
        batchButton.style.cssText = `
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 15px;
            cursor: pointer;
        `;
        batchButton.addEventListener('click', () => {
            this.toggleBatchMode();
            this.batchFileInput.click();
        });
        
        batchOption.appendChild(batchButton);
        effectContainer.appendChild(batchOption);
        
        // Add to chat
        const messageContainer = document.createElement('div');
        messageContainer.appendChild(effectContainer);
        document.querySelector('.chat-messages').appendChild(messageContainer);
        
        // Scroll to bottom
        document.querySelector('.chat-container').scrollTop = document.querySelector('.chat-container').scrollHeight;
    }

    // Show effect adjustment panel for adjustable effects
    showEffectAdjustment(effectId) {
        const effect = this.availableEffects.find(e => e.id === effectId);
        if (!effect) return;
        
        // Clear advanced panel
        this.advancedPanel.innerHTML = '';
        
        // Add close button
        const closeButton = document.createElement('button');
        closeButton.innerHTML = '✕';
        closeButton.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        `;
        closeButton.addEventListener('click', () => {
            this.advancedPanel.style.display = 'none';
        });
        this.advancedPanel.appendChild(closeButton);
        
        // Add title
        const title = document.createElement('h2');
        title.textContent = `${effect.name} Settings`;
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
        `;
        this.advancedPanel.appendChild(title);
        
        // Add preview area
        const previewContainer = document.createElement('div');
        previewContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: center;
        `;
        
        const previewImage = document.createElement('img');
        previewImage.style.cssText = `
            max-width: 100%;
            max-height: 200px;
            border-radius: 4px;
        `;
        
        if (this.currentImage) {
            previewImage.src = this.currentImage.src;
        } else {
            previewImage.src = 'https://picsum.photos/seed/preview/400/300.jpg';
        }
        
        previewContainer.appendChild(previewImage);
        this.advancedPanel.appendChild(previewContainer);
        
        // Add controls based on effect type
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'effect-controls';
        
        switch (effectId) {
            case 'blur':
            case 'sharpen':
                this.addSliderControl(controlsContainer, 'Intensity', 0, 100, 50, 'intensity');
                break;
            case 'pixelate':
                this.addSliderControl(controlsContainer, 'Pixel Size', 2, 20, 10, 'pixelSize');
                break;
            case 'brightness':
                this.addSliderControl(controlsContainer, 'Brightness', -100, 100, 30, 'brightness');
                break;
            case 'contrast':
                this.addSliderControl(controlsContainer, 'Contrast', -100, 100, 50, 'contrast');
                break;
            case 'saturation':
                this.addSliderControl(controlsContainer, 'Saturation', -100, 100, 50, 'saturation');
                break;
            case 'hue':
                this.addSliderControl(controlsContainer, 'Hue Shift', 0, 360, 30, 'hueShift');
                break;
            case 'rotate':
                this.addSliderControl(controlsContainer, 'Rotation Angle', 0, 360, 90, 'rotation');
                break;
            case 'crop':
                this.addCropControls(controlsContainer);
                break;
            case 'vignette':
                this.addSliderControl(controlsContainer, 'Vignette Strength', 0, 100, 80, 'vignetteStrength');
                break;
            case 'noise':
                this.addSliderControl(controlsContainer, 'Noise Amount', 0, 100, 50, 'noiseAmount');
                break;
            case 'posterize':
                this.addSliderControl(controlsContainer, 'Color Levels', 2, 16, 4, 'colorLevels');
                break;
        }
        
        this.advancedPanel.appendChild(controlsContainer);
        
        // Add apply button
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply Effect';
        applyButton.style.cssText = `
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 15px;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
            width: 100%;
        `;
        
        applyButton.addEventListener('click', () => {
            this.selectEffect(effectId, this.effectParameters);
            this.advancedPanel.style.display = 'none';
        });
        
        this.advancedPanel.appendChild(applyButton);
        
        // Show the panel
        this.advancedPanel.style.display = 'block';
    }

    // Add slider control to the adjustment panel
    addSliderControl(container, label, min, max, defaultValue, paramName) {
        const controlContainer = document.createElement('div');
        controlContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.textContent = label;
        labelElement.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        controlContainer.appendChild(labelElement);
        
        const sliderContainer = document.createElement('div');
        sliderContainer.style.cssText = `
            display: flex;
            align-items: center;
        `;
        
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = min;
        slider.max = max;
        slider.value = defaultValue;
        slider.style.cssText = `
            flex: 1;
            margin-right: 10px;
        `;
        
        const valueDisplay = document.createElement('span');
        valueDisplay.textContent = defaultValue;
        valueDisplay.style.cssText = `
            min-width: 40px;
            text-align: right;
        `;
        
        slider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            valueDisplay.textContent = value;
            this.effectParameters[paramName] = value;
            
            // Update preview if current image exists
            if (this.currentImage) {
                this.updatePreview();
            }
        });
        
        // Initialize parameter
        this.effectParameters[paramName] = defaultValue;
        
        sliderContainer.appendChild(slider);
        sliderContainer.appendChild(valueDisplay);
        controlContainer.appendChild(sliderContainer);
        container.appendChild(controlContainer);
    }

    // Add crop controls to the adjustment panel
    addCropControls(container) {
        const cropInfo = document.createElement('p');
        cropInfo.textContent = 'Crop will be applied to the center of the image. You can adjust the aspect ratio below.';
        cropInfo.style.cssText = `
            margin-bottom: 15px;
            color: #666;
        `;
        container.appendChild(cropInfo);
        
        const aspectRatios = [
            { name: 'Original', value: 'original' },
            { name: 'Square (1:1)', value: '1:1' },
            { name: 'Landscape (4:3)', value: '4:3' },
            { name: 'Landscape (16:9)', value: '16:9' },
            { name: 'Portrait (3:4)', value: '3:4' },
            { name: 'Portrait (9:16)', value: '9:16' }
        ];
        
        const ratioContainer = document.createElement('div');
        ratioContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const ratioLabel = document.createElement('label');
        ratioLabel.textContent = 'Aspect Ratio:';
        ratioLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        ratioContainer.appendChild(ratioLabel);
        
        const ratioSelect = document.createElement('select');
        ratioSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        `;
        
        aspectRatios.forEach(ratio => {
            const option = document.createElement('option');
            option.value = ratio.value;
            option.textContent = ratio.name;
            ratioSelect.appendChild(option);
        });
        
        ratioSelect.addEventListener('change', (e) => {
            this.effectParameters.aspectRatio = e.target.value;
        });
        
        // Initialize parameter
        this.effectParameters.aspectRatio = '1:1';
        
        ratioContainer.appendChild(ratioSelect);
        container.appendChild(ratioContainer);
    }

    // Update preview image with current effect settings
    updatePreview() {
        if (!this.currentImage) return;
        
        const previewImage = this.advancedPanel.querySelector('img');
        if (!previewImage) return;
        
        // Create a canvas for processing
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = this.currentImage.width;
        canvas.height = this.currentImage.height;
        ctx.drawImage(this.currentImage, 0, 0);
        
        // Apply the effect with current parameters
        this.applyEffect(canvas, ctx, this.selectedEffect, this.effectParameters);
        
        // Update preview
        previewImage.src = canvas.toDataURL();
    }

    // Toggle batch processing mode
    toggleBatchMode() {
        this.batchMode = !this.batchMode;
        
        if (this.batchMode) {
            botReply("Batch mode enabled. You can now select multiple images to process with the same effect.");
            this.batchControls.style.display = 'block';
        } else {
            botReply("Batch mode disabled.");
            this.batchControls.style.display = 'none';
        }
    }

    // Handle batch image upload
    handleBatchImageUpload(event) {
        const files = Array.from(event.target.files);
        if (files.length === 0) return;
        
        // Validate all files
        const invalidFiles = files.filter(file => !file.type.match('image.*'));
        if (invalidFiles.length > 0) {
            botReply(`${invalidFiles.length} files are not valid images. Please select only image files.`);
            return;
        }
        
        // Check file sizes
        const largeFiles = files.filter(file => file.size > 10 * 1024 * 1024);
        if (largeFiles.length > 0) {
            botReply(`${largeFiles.length} files are too large. Please select images under 10MB each.`);
            return;
        }
        
        // Store batch images
        this.batchImages = files;
        this.currentBatchIndex = 0;
        
        botReply(`Loaded ${files.length} images for batch processing. Please select an effect to apply to all images.`);
        
        // Show effect selection
        this.showEffectSelection();
    }

    // Handle effect selection with optional parameters
    selectEffect(effectId, parameters = {}) {
        this.selectedEffect = effectId;
        this.effectParameters = parameters;
        const effectName = this.availableEffects.find(e => e.id === effectId).name;
        
        if (this.batchMode && this.batchImages.length > 0) {
            botReply(`Selected: ${effectName}. Processing ${this.batchImages.length} images...`);
            this.processBatchImages();
        } else {
            botReply(`Selected: ${effectName}. Please upload your photo.`);
            
            // Remove effect selection UI
            const effectSelection = document.querySelector('.effect-selection');
            if (effectSelection) {
                effectSelection.remove();
            }
            
            // Trigger file picker
            setTimeout(() => {
                this.fileInput.click();
            }, 1000);
        }
    }

    // Process batch images
    processBatchImages() {
        if (this.currentBatchIndex >= this.batchImages.length) {
            botReply(`Batch processing complete! All ${this.batchImages.length} images have been processed and downloaded.`);
            this.batchImages = [];
            this.currentBatchIndex = 0;
            this.batchMode = false;
            this.batchControls.style.display = 'none';
            return;
        }
        
        const file = this.batchImages[this.currentBatchIndex];
        const reader = new FileReader();
        
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.currentImage = img;
                this.processImage(img, file.name, true);
                this.currentBatchIndex++;
                
                // Process next image with a small delay
                setTimeout(() => {
                    this.processBatchImages();
                }, 500);
            };
            img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
        
        // Show progress
        this.showProgress(`Processing image ${this.currentBatchIndex + 1} of ${this.batchImages.length}...`);
    }

    // Show progress indicator
    showProgress(message) {
        this.progressIndicator.textContent = message;
        this.progressIndicator.style.display = 'block';
    }

    // Hide progress indicator
    hideProgress() {
        this.progressIndicator.style.display = 'none';
    }

    // Handle image upload
    handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (!file.type.match('image.*')) {
            botReply("Please select a valid image file.");
            return;
        }
        
        // Check file size (limit to 10MB)
        if (file.size > 10 * 1024 * 1024) {
            botReply("Image is too large. Please select an image under 10MB.");
            return;
        }
        
        botReply("Loading image for editing...");
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.currentImage = img;
                this.processImage(img, file.name);
            };
            img.onerror = () => {
                botReply("Error loading image. Please try a different file.");
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // Process image with selected effect
    processImage(img, originalFilename, isBatch = false) {
        const effectName = this.availableEffects.find(e => e.id === this.selectedEffect).name;
        
        if (!isBatch) {
            botReply(`Editing your image with ${effectName} effect...`);
            this.showProgress('Processing image...');
        }
        
        try {
            // Create canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // Save original image data for undo functionality
            if (!isBatch) {
                this.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                this.processingHistory = [];
                this.redoStack = [];
                this.historyControls.style.display = 'block';
            }
            
            // Apply base enhancements
            this.autoEnhance(canvas, ctx);
            
            // Apply selected effect with parameters
            this.applyEffect(canvas, ctx, this.selectedEffect, this.effectParameters);
            
            // Save to history if not in batch mode
            if (!isBatch) {
                this.saveToHistory(ctx.getImageData(0, 0, canvas.width, canvas.height));
            }
            
            // Create edited filename
            const editedFilename = this.createEditedFilename(originalFilename, this.selectedEffect);
            
            // Automatically download the edited image
            this.downloadEditedImage(canvas, editedFilename);
            
            // Show download notification
            if (!isBatch) {
                this.hideProgress();
                this.showDownloadNotification(editedFilename);
                
                // Show share options
                this.showShareOptions(canvas, editedFilename);
            }
            
        } catch (error) {
            botReply("Error processing image. Please try again.");
            console.error("Processing Error:", error);
            this.hideProgress();
        }
    }

    // Save current state to history
    saveToHistory(imageData) {
        this.processingHistory.push(imageData);
        this.redoStack = []; // Clear redo stack when new action is performed
        
        // Limit history size to prevent memory issues
        if (this.processingHistory.length > 10) {
            this.processingHistory.shift();
        }
    }

    // Undo last action
    undo() {
        if (this.processingHistory.length <= 1) return;
        
        // Move current state to redo stack
        const currentState = this.processingHistory.pop();
        this.redoStack.push(currentState);
        
        // Restore previous state
        const previousState = this.processingHistory[this.processingHistory.length - 1];
        
        // Create canvas and restore state
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = previousState.width;
        canvas.height = previousState.height;
        ctx.putImageData(previousState, 0, 0);
        
        // Update current image
        this.currentImage = new Image();
        this.currentImage.onload = () => {
            // Update preview if advanced panel is open
            if (this.advancedPanel.style.display === 'block') {
                this.updatePreview();
            }
        };
        this.currentImage.src = canvas.toDataURL();
        
        botReply("Undo successful.");
    }

    // Redo last undone action
    redo() {
        if (this.redoStack.length === 0) return;
        
        // Get state from redo stack
        const nextState = this.redoStack.pop();
        
        // Add to history
        this.processingHistory.push(nextState);
        
        // Create canvas and restore state
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = nextState.width;
        canvas.height = nextState.height;
        ctx.putImageData(nextState, 0, 0);
        
        // Update current image
        this.currentImage = new Image();
        this.currentImage.onload = () => {
            // Update preview if advanced panel is open
            if (this.advancedPanel.style.display === 'block') {
                this.updatePreview();
            }
        };
        this.currentImage.src = canvas.toDataURL();
        
        botReply("Redo successful.");
    }

    // Show share options
    showShareOptions(canvas, filename) {
        // Clear previous options
        this.shareOptions.innerHTML = '';
        
        // Add title
        const title = document.createElement('div');
        title.textContent = 'Share your edited image:';
        title.style.cssText = `
            font-weight: bold;
            margin-bottom: 10px;
        `;
        this.shareOptions.appendChild(title);
        
        // Add social media buttons
        const socialPlatforms = [
            { name: 'Facebook', icon: '📘', action: () => this.shareToSocial(canvas, 'facebook') },
            { name: 'Twitter', icon: '🐦', action: () => this.shareToSocial(canvas, 'twitter') },
            { name: 'Instagram', icon: '📷', action: () => this.shareToSocial(canvas, 'instagram') },
            { name: 'Download', icon: '💾', action: () => this.downloadEditedImage(canvas, filename) }
        ];
        
        socialPlatforms.forEach(platform => {
            const button = document.createElement('button');
            button.innerHTML = `${platform.icon} ${platform.name}`;
            button.style.cssText = `
                display: block;
                width: 100%;
                background: #f0f0f0;
                border: none;
                border-radius: 4px;
                padding: 8px;
                margin-bottom: 5px;
                cursor: pointer;
                text-align: left;
            `;
            
            button.addEventListener('click', () => {
                platform.action();
                this.shareOptions.style.display = 'none';
            });
            
            this.shareOptions.appendChild(button);
        });
        
        // Show the share options
        this.shareOptions.style.display = 'block';
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
            this.shareOptions.style.display = 'none';
        }, 10000);
    }

    // Share to social media (simplified implementation)
    shareToSocial(canvas, platform) {
        // Convert canvas to blob
        canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            
            // In a real implementation, this would integrate with each platform's API
            // For this example, we'll just open a new window with the image
            switch (platform) {
                case 'facebook':
                    window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(window.location.href)}`, '_blank');
                    break;
                case 'twitter':
                    window.open(`https://twitter.com/intent/tweet?text=Check out my edited image!&url=${encodeURIComponent(window.location.href)}`, '_blank');
                    break;
                case 'instagram':
                    botReply("To share on Instagram, please download the image and upload it through the Instagram app.");
                    break;
            }
            
            // Clean up
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
        }, 'image/jpeg', 0.9);
    }

    // Apply selected effect with parameters
    applyEffect(canvas, ctx, effectId, parameters = {}) {
        switch(effectId) {
            case 'crack':
                this.applyCrackEffect(canvas, ctx, parameters);
                break;
            case 'vintage':
                this.applyVintageEffect(canvas, ctx, parameters);
                break;
            case 'grayscale':
                this.applyGrayscaleEffect(canvas, ctx, parameters);
                break;
            case 'sepia':
                this.applySepiaEffect(canvas, ctx, parameters);
                break;
            case 'blur':
                this.applyBlurEffect(canvas, ctx, parameters);
                break;
            case 'sharpen':
                this.applySharpenEffect(canvas, ctx, parameters);
                break;
            case 'pixelate':
                this.applyPixelateEffect(canvas, ctx, parameters);
                break;
            case 'glitch':
                this.applyGlitchEffect(canvas, ctx, parameters);
                break;
            case 'neon':
                this.applyNeonEffect(canvas, ctx, parameters);
                break;
            case 'brightness':
                this.applyBrightnessEffect(canvas, ctx, parameters);
                break;
            case 'contrast':
                this.applyContrastEffect(canvas, ctx, parameters);
                break;
            case 'saturation':
                this.applySaturationEffect(canvas, ctx, parameters);
                break;
            case 'hue':
                this.applyHueEffect(canvas, ctx, parameters);
                break;
            case 'invert':
                this.applyInvertEffect(canvas, ctx, parameters);
                break;
            case 'edge':
                this.applyEdgeDetectionEffect(canvas, ctx, parameters);
                break;
            case 'emboss':
                this.applyEmbossEffect(canvas, ctx, parameters);
                break;
            case 'oil':
                this.applyOilPaintingEffect(canvas, ctx, parameters);
                break;
            case 'cartoon':
                this.applyCartoonEffect(canvas, ctx, parameters);
                break;
            case 'mirror':
                this.applyMirrorEffect(canvas, ctx, parameters);
                break;
            case 'rotate':
                this.applyRotateEffect(canvas, ctx, parameters);
                break;
            case 'crop':
                this.applyCropEffect(canvas, ctx, parameters);
                break;
            case 'vignette':
                this.applyVignetteEffect(canvas, ctx, parameters);
                break;
            case 'noise':
                this.applyNoiseEffect(canvas, ctx, parameters);
                break;
            case 'posterize':
                this.applyPosterizeEffect(canvas, ctx, parameters);
                break;
            case 'solarize':
                this.applySolarizeEffect(canvas, ctx, parameters);
                break;
            case 'ghibli':
                this.applyGhibliEffect(canvas, ctx, parameters);
                break;
            // New effects
            case 'bokeh':
                this.applyBokehEffect(canvas, ctx, parameters);
                break;
            case 'lensflare':
                this.applyLensFlareEffect(canvas, ctx, parameters);
                break;
            case 'hdr':
                this.applyHDREffect(canvas, ctx, parameters);
                break;
            case 'tiltshift':
                this.applyTiltShiftEffect(canvas, ctx, parameters);
                break;
            case 'watercolor':
                this.applyWatercolorEffect(canvas, ctx, parameters);
                break;
            case 'sketch':
                this.applySketchEffect(canvas, ctx, parameters);
                break;
            case 'doubleexposure':
                this.applyDoubleExposureEffect(canvas, ctx, parameters);
                break;
            case 'colorpop':
                this.applyColorPopEffect(canvas, ctx, parameters);
                break;
            case 'retro':
                this.applyRetroEffect(canvas, ctx, parameters);
                break;
            default:
                // No effect
                break;
        }
    }

    // Apply crack effect with parameters
    applyCrackEffect(canvas, ctx, parameters = {}) {
        // Use the existing implementation but with customizable parameters
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create a temporary canvas for the original image
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // Determine the mirror axis (vertical or horizontal)
        const mirrorVertical = Math.random() > 0.5;
        
        // Create high-density star crack pattern on one half
        const starCenters = parameters.starCount || Math.floor(Math.random() * 15) + 10; // More star centers
        
        for (let s = 0; s < starCenters; s++) {
            // Star center point (only on one side of the mirror axis)
            let centerX, centerY;
            
            if (mirrorVertical) {
                // Left half only
                centerX = Math.floor(Math.random() * (canvas.width / 2));
                centerY = Math.floor(Math.random() * canvas.height);
            } else {
                // Top half only
                centerX = Math.floor(Math.random() * canvas.width);
                centerY = Math.floor(Math.random() * (canvas.height / 2));
            }
            
            // Number of rays for each star
            const rayCount = parameters.rayCount || Math.floor(Math.random() * 8) + 5; // 5-12 rays per star
            
            for (let r = 0; r < rayCount; r++) {
                // Ray angle
                const angle = (r / rayCount) * Math.PI * 2;
                
                // Ray direction
                let dx = Math.cos(angle);
                let dy = Math.sin(angle);
                
                // Ray length
                const length = parameters.rayLength || Math.floor(Math.random() * 120) + 60; // Longer rays
                
                // Draw ray
                let x = centerX;
                let y = centerY;
                
                // Store points for mirroring
                const rayPoints = [];
                
                for (let i = 0; i < length; i++) {
                    // Add some randomness to direction for more natural look
                    dx += (Math.random() - 0.5) * 0.3;
                    dy += (Math.random() - 0.5) * 0.3;
                    
                    // Normalize direction
                    const magnitude = Math.sqrt(dx * dx + dy * dy);
                    dx /= magnitude;
                    dy /= magnitude;
                    
                    // Update position
                    x += dx;
                    y += dy;
                    
                    // Check bounds
                    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) break;
                    
                    // Store point for mirroring
                    rayPoints.push({x: Math.floor(x), y: Math.floor(y)});
                    
                    // Apply crack (darken pixel more for star effect)
                    const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
                    
                    // Darken more at the center, less at the edges
                    const distanceFromCenter = i / length;
                    const darknessFactor = parameters.darkness || 0.3 + (0.5 * (1 - distanceFromCenter));
                    
                    data[idx] *= darknessFactor;     // Red
                    data[idx + 1] *= darknessFactor; // Green
                    data[idx + 2] *= darknessFactor; // Blue
                    
                    // Add width to the crack (wider at the center)
                    const maxWidth = 1 + Math.floor((1 - distanceFromCenter) * 4); // Wider at center
                    for (let w = 1; w <= maxWidth; w++) {
                        // Perpendicular direction
                        const perpX = -dy;
                        const perpY = dx;
                        
                        // Points on both sides of the crack
                        const side1X = Math.floor(x + perpX * w);
                        const side1Y = Math.floor(y + perpY * w);
                        const side2X = Math.floor(x - perpX * w);
                        const side2Y = Math.floor(y - perpY * w);
                        
                        // Apply crack to side points if within bounds
                        if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                            const side1Idx = (side1Y * canvas.width + side1X) * 4;
                            const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                            data[side1Idx] *= sideDarkness;
                            data[side1Idx + 1] *= sideDarkness;
                            data[side1Idx + 2] *= sideDarkness;
                        }
                        
                        if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                            const side2Idx = (side2Y * canvas.width + side2X) * 4;
                            const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                            data[side2Idx] *= sideDarkness;
                            data[side2Idx + 1] *= sideDarkness;
                            data[side2Idx + 2] *= sideDarkness;
                        }
                    }
                }
                
                // Mirror the ray
                rayPoints.forEach(point => {
                    let mirrorX, mirrorY;
                    
                    if (mirrorVertical) {
                        // Mirror horizontally
                        mirrorX = canvas.width - point.x - 1;
                        mirrorY = point.y;
                    } else {
                        // Mirror vertically
                        mirrorX = point.x;
                        mirrorY = canvas.height - point.y - 1;
                    }
                    
                    // Apply mirrored ray
                    const mirrorIdx = (mirrorY * canvas.width + mirrorX) * 4;
                    
                    // Calculate distance from mirrored center
                    let mirrorCenterX, mirrorCenterY;
                    if (mirrorVertical) {
                        mirrorCenterX = canvas.width - centerX - 1;
                        mirrorCenterY = centerY;
                    } else {
                        mirrorCenterX = centerX;
                        mirrorCenterY = canvas.height - centerY - 1;
                    }
                    
                    const dx = point.x - centerX;
                    const dy = point.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDistance = length;
                    const distanceFromCenter = Math.min(1, distance / maxDistance);
                    const darknessFactor = parameters.darkness || 0.3 + (0.5 * (1 - distanceFromCenter));
                    
                    data[mirrorIdx] *= darknessFactor;     // Red
                    data[mirrorIdx + 1] *= darknessFactor; // Green
                    data[mirrorIdx + 2] *= darknessFactor; // Blue
                    
                    // Add width to the mirrored ray
                    const maxWidth = 1 + Math.floor((1 - distanceFromCenter) * 4);
                    for (let w = 1; w <= maxWidth; w++) {
                        // Perpendicular direction (flipped for mirror)
                        const perpX = dy;
                        const perpY = dx;
                        
                        // Points on both sides of the mirrored ray
                        const side1X = Math.floor(mirrorX + perpX * w);
                        const side1Y = Math.floor(mirrorY + perpY * w);
                        const side2X = Math.floor(mirrorX - perpX * w);
                        const side2Y = Math.floor(mirrorY - perpY * w);
                        
                        // Apply crack to side points if within bounds
                        if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                            const side1Idx = (side1Y * canvas.width + side1X) * 4;
                            const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                            data[side1Idx] *= sideDarkness;
                            data[side1Idx + 1] *= sideDarkness;
                            data[side1Idx + 2] *= sideDarkness;
                        }
                        
                        if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                            const side2Idx = (side2Y * canvas.width + side2X) * 4;
                            const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                            data[side2Idx] *= sideDarkness;
                            data[side2Idx + 1] *= sideDarkness;
                            data[side2Idx + 2] *= sideDarkness;
                        }
                    }
                });
            }
        }
        
        // Add many small connecting cracks between stars for more complexity
        const connectionCount = parameters.connectionCount || Math.floor(Math.random() * 20) + 15; // More connections
        
        for (let c = 0; c < connectionCount; c++) {
            // Random start point (on one side of the mirror axis)
            let startX, startY;
            
            if (mirrorVertical) {
                startX = Math.floor(Math.random() * (canvas.width / 2));
                startY = Math.floor(Math.random() * canvas.height);
            } else {
                startX = Math.floor(Math.random() * canvas.width);
                startY = Math.floor(Math.random() * (canvas.height / 2));
            }
            
            // Random end point (on the same side)
            let endX, endY;
            
            if (mirrorVertical) {
                endX = Math.floor(Math.random() * (canvas.width / 2));
                endY = Math.floor(Math.random() * canvas.height);
            } else {
                endX = Math.floor(Math.random() * canvas.width);
                endY = Math.floor(Math.random() * (canvas.height / 2));
            }
            
            // Calculate direction
            let dx = endX - startX;
            let dy = endY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dx /= distance;
            dy /= distance;
            
            // Draw connecting crack
            let x = startX;
            let y = startY;
            
            // Store points for mirroring
            const connectionPoints = [];
            
            const steps = Math.floor(distance);
            for (let i = 0; i < steps; i++) {
                // Add some randomness to direction
                dx += (Math.random() - 0.5) * 0.4;
                dy += (Math.random() - 0.5) * 0.4;
                
                // Normalize direction
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                dx /= magnitude;
                dy /= magnitude;
                
                // Update position
                x += dx;
                y += dy;
                
                // Check bounds
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) break;
                
                // Store point for mirroring
                connectionPoints.push({x: Math.floor(x), y: Math.floor(y)});
                
                // Apply crack (less dark than star rays)
                const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
                data[idx] *= 0.8;     // Red
                data[idx + 1] *= 0.8; // Green
                data[idx + 2] *= 0.8; // Blue
                
                // Add width to the crack
                const crackWidth = 1;
                for (let w = 1; w <= crackWidth; w++) {
                    // Perpendicular direction
                    const perpX = -dy;
                    const perpY = dx;
                    
                    // Points on both sides of the crack
                    const side1X = Math.floor(x + perpX * w);
                    const side1Y = Math.floor(y + perpY * w);
                    const side2X = Math.floor(x - perpX * w);
                    const side2Y = Math.floor(y - perpY * w);
                    
                    // Apply crack to side points if within bounds
                    if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                        const side1Idx = (side1Y * canvas.width + side1X) * 4;
                        data[side1Idx] *= 0.85;
                        data[side1Idx + 1] *= 0.85;
                        data[side1Idx + 2] *= 0.85;
                    }
                    
                    if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                        const side2Idx = (side2Y * canvas.width + side2X) * 4;
                        data[side2Idx] *= 0.85;
                        data[side2Idx + 1] *= 0.85;
                        data[side2Idx + 2] *= 0.85;
                    }
                }
            }
            
            // Mirror the connection
            connectionPoints.forEach(point => {
                let mirrorX, mirrorY;
                
                if (mirrorVertical) {
                    // Mirror horizontally
                    mirrorX = canvas.width - point.x - 1;
                    mirrorY = point.y;
                } else {
                    // Mirror vertically
                    mirrorX = point.x;
                    mirrorY = canvas.height - point.y - 1;
                }
                
                // Apply mirrored connection
                const mirrorIdx = (mirrorY * canvas.width + mirrorX) * 4;
                data[mirrorIdx] *= 0.8;     // Red
                data[mirrorIdx + 1] *= 0.8; // Green
                data[mirrorIdx + 2] *= 0.8; // Blue
                
                // Add width to the mirrored connection
                const crackWidth = 1;
                for (let w = 1; w <= crackWidth; w++) {
                    // Perpendicular direction (flipped for mirror)
                    const perpX = dy;
                    const perpY = dx;
                    
                    // Points on both sides of the mirrored crack
                    const side1X = Math.floor(mirrorX + perpX * w);
                    const side1Y = Math.floor(mirrorY + perpY * w);
                    const side2X = Math.floor(mirrorX - perpX * w);
                    const side2Y = Math.floor(mirrorY - perpY * w);
                    
                    // Apply crack to side points if within bounds
                    if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                        const side1Idx = (side1Y * canvas.width + side1X) * 4;
                        data[side1Idx] *= 0.85;
                        data[side1Idx + 1] *= 0.85;
                        data[side1Idx + 2] *= 0.85;
                    }
                    
                    if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                        const side2Idx = (side2Y * canvas.width + side2X) * 4;
                        data[side2Idx] *= 0.85;
                        data[side2Idx + 1] *= 0.85;
                        data[side2Idx + 2] *= 0.85;
                    }
                }
            });
        }
        
        // Add dense cracks along the mirror axis
        const axisCrackCount = parameters.axisCrackCount || Math.floor(Math.random() * 8) + 5; // More axis cracks
        
        for (let c = 0; c < axisCrackCount; c++) {
            let x, y;
            
            if (mirrorVertical) {
                // Along the vertical center line
                x = Math.floor(canvas.width / 2) + Math.floor(Math.random() * 20) - 10;
                y = Math.floor(Math.random() * canvas.height);
            } else {
                // Along the horizontal center line
                x = Math.floor(Math.random() * canvas.width);
                y = Math.floor(canvas.height / 2) + Math.floor(Math.random() * 20) - 10;
            }
            
            // Direction (mostly along the axis)
            let dx, dy;
            
            if (mirrorVertical) {
                dx = (Math.random() - 0.5) * 0.5; // Less horizontal movement
                dy = (Math.random() - 0.5) * 2;   // More vertical movement
            } else {
                dx = (Math.random() - 0.5) * 2;   // More horizontal movement
                dy = (Math.random() - 0.5) * 0.5; // Less vertical movement
            }
            
            // Length
            const length = parameters.axisCrackLength || Math.floor(Math.random() * 100) + 50; // Longer axis cracks
            
            // Draw crack along the axis
            for (let i = 0; i < length; i++) {
                // Add some randomness to direction
                dx += (Math.random() - 0.5) * 0.3;
                dy += (Math.random() - 0.5) * 0.3;
                
                // Normalize direction
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                dx /= magnitude;
                dy /= magnitude;
                
                // Update position
                x += dx;
                y += dy;
                
                // Check bounds
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) break;
                
                // Apply crack (darken pixel more along the axis)
                const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
                data[idx] *= 0.4;     // Red
                data[idx + 1] *= 0.4; // Green
                data[idx + 2] *= 0.4; // Blue
                
                // Add width to the crack
                const crackWidth = 1 + Math.floor(Math.random() * 3);
                for (let w = 1; w <= crackWidth; w++) {
                    // Perpendicular direction
                    const perpX = -dy;
                    const perpY = dx;
                    
                    // Points on both sides of the crack
                    const side1X = Math.floor(x + perpX * w);
                    const side1Y = Math.floor(y + perpY * w);
                    const side2X = Math.floor(x - perpX * w);
                    const side2Y = Math.floor(y - perpY * w);
                    
                    // Apply crack to side points if within bounds
                    if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                        const side1Idx = (side1Y * canvas.width + side1X) * 4;
                        data[side1Idx] *= 0.6;
                        data[side1Idx + 1] *= 0.6;
                        data[side1Idx + 2] *= 0.6;
                    }
                    
                    if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                        const side2Idx = (side2Y * canvas.width + side2X) * 4;
                        data[side2Idx] *= 0.6;
                        data[side2Idx + 1] *= 0.6;
                        data[side2Idx + 2] *= 0.6;
                    }
                }
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply vintage effect with parameters
    applyVintageEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const sepiaIntensity = parameters.sepiaIntensity || 1.0;
        const noiseAmount = parameters.noiseAmount || 10;
        const vignetteStrength = parameters.vignetteStrength || 0.8;
        
        for (let i = 0; i < data.length; i += 4) {
            // Extract RGB
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Apply vintage effect (sepia + reduced contrast + vignette)
            data[i] = Math.min(255, (r * 0.393 * sepiaIntensity) + (g * 0.769 * sepiaIntensity) + (b * 0.189 * sepiaIntensity));     // Red
            data[i + 1] = Math.min(255, (r * 0.349 * sepiaIntensity) + (g * 0.686 * sepiaIntensity) + (b * 0.168 * sepiaIntensity)); // Green
            data[i + 2] = Math.min(255, (r * 0.272 * sepiaIntensity) + (g * 0.534 * sepiaIntensity) + (b * 0.131 * sepiaIntensity)); // Blue
            
            // Add some noise for vintage feel
            const noise = Math.random() * noiseAmount - noiseAmount / 2;
            data[i] = Math.min(255, Math.max(0, data[i] + noise));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Apply vignette
        this.applyVignetteEffect(canvas, ctx, { strength: vignetteStrength });
    }

    // Apply grayscale effect
    applyGrayscaleEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const method = parameters.method || 'luminance'; // 'luminance', 'average', 'desaturation'
        
        for (let i = 0; i < data.length; i += 4) {
            // Calculate grayscale using specified method
            let gray;
            
            switch (method) {
                case 'average':
                    gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    break;
                case 'desaturation':
                    const max = Math.max(data[i], data[i + 1], data[i + 2]);
                    const min = Math.min(data[i], data[i + 1], data[i + 2]);
                    gray = (max + min) / 2;
                    break;
                case 'luminance':
                default:
                    gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    break;
            }
            
            data[i] = gray;     // Red
            data[i + 1] = gray; // Green
            data[i + 2] = gray; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply sepia effect with parameters
    applySepiaEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        
        for (let i = 0; i < data.length; i += 4) {
            // Extract RGB
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Apply sepia transformation
            data[i] = Math.min(255, (r * 0.393 * intensity) + (g * 0.769 * intensity) + (b * 0.189 * intensity));     // Red
            data[i + 1] = Math.min(255, (r * 0.349 * intensity) + (g * 0.686 * intensity) + (b * 0.168 * intensity)); // Green
            data[i + 2] = Math.min(255, (r * 0.272 * intensity) + (g * 0.534 * intensity) + (b * 0.131 * intensity)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply blur effect with parameters
    applyBlurEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const blurAmount = parameters.blurAmount || parameters.intensity || 5;
        
        // Apply blur filter
        tempCtx.filter = `blur(${blurAmount}px)`;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Draw blurred image back to original canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(tempCanvas, 0, 0);
    }

    // Apply sharpen effect with parameters
    applySharpenEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        
        // Sharpen kernel
        const kernel = [
             0, -intensity,  0,
            -intensity, 1 + 4 * intensity, -intensity,
             0, -intensity,  0
        ];
        
        // Apply convolution
        for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                let r = 0, g = 0, b = 0;
                
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const kidx = ((y + ky) * canvas.width + (x + kx)) * 4;
                        const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                        
                        r += temp[kidx] * weight;
                        g += temp[kidx + 1] * weight;
                        b += temp[kidx + 2] * weight;
                    }
                }
                
                data[idx] = Math.min(255, Math.max(0, r));
                data[idx + 1] = Math.min(255, Math.max(0, g));
                data[idx + 2] = Math.min(255, Math.max(0, b));
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply pixelate effect with parameters
    applyPixelateEffect(canvas, ctx, parameters = {}) {
        // Get parameters
        const pixelSize = parameters.pixelSize || 10;
        
        // Save original image
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw pixelated image
        for (let y = 0; y < canvas.height; y += pixelSize) {
            for (let x = 0; x < canvas.width; x += pixelSize) {
                // Get pixel color
                const pixelData = tempCtx.getImageData(x, y, 1, 1).data;
                
                // Draw pixel block
                ctx.fillStyle = `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
                ctx.fillRect(x, y, pixelSize, pixelSize);
            }
        }
    }

    // Apply glitch effect with parameters
    applyGlitchEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        const colorShift = parameters.colorShift || 20;
        
        // Create RGB channels
        const rChannel = new Uint8ClampedArray(data.length / 4);
        const gChannel = new Uint8ClampedArray(data.length / 4);
        const bChannel = new Uint8ClampedArray(data.length / 4);
        
        // Extract channels
        for (let i = 0, j = 0; i < data.length; i += 4, j++) {
            rChannel[j] = data[i];
            gChannel[j] = data[i + 1];
            bChannel[j] = data[i + 2];
        }
        
        // Apply glitch effect (shift channels)
        const glitchHeight = Math.floor(canvas.height / 5);
        const glitchY = Math.floor(Math.random() * (canvas.height - glitchHeight));
        
        // Shift red channel
        const shiftR = Math.floor(Math.random() * colorShift * intensity) - colorShift / 2;
        for (let y = glitchY; y < glitchY + glitchHeight; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const srcIdx = y * canvas.width + x;
                const dstIdx = y * canvas.width + ((x + shiftR + canvas.width) % canvas.width);
                
                if (srcIdx < rChannel.length && dstIdx < rChannel.length) {
                    const temp = rChannel[srcIdx];
                    rChannel[srcIdx] = rChannel[dstIdx];
                    rChannel[dstIdx] = temp;
                }
            }
        }
        
        // Shift blue channel
        const shiftB = Math.floor(Math.random() * colorShift * intensity) - colorShift / 2;
        for (let y = glitchY; y < glitchY + glitchHeight; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const srcIdx = y * canvas.width + x;
                const dstIdx = y * canvas.width + ((x + shiftB + canvas.width) % canvas.width);
                
                if (srcIdx < bChannel.length && dstIdx < bChannel.length) {
                    const temp = bChannel[srcIdx];
                    bChannel[srcIdx] = bChannel[dstIdx];
                    bChannel[dstIdx] = temp;
                }
            }
        }
        
        // Recombine channels
        for (let i = 0, j = 0; i < data.length; i += 4, j++) {
            data[i] = rChannel[j];
            data[i + 1] = gChannel[j];
            data[i + 2] = bChannel[j];
        }
        
        // Add some random noise
        const noiseAmount = 0.05 * intensity;
        for (let i = 0; i < data.length; i += 4) {
            if (Math.random() < noiseAmount) {
                data[i] = Math.random() * 255;     // Red
                data[i + 1] = Math.random() * 255; // Green
                data[i + 2] = Math.random() * 255; // Blue
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply neon effect with parameters
    applyNeonEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const color = parameters.color || '#00ffff'; // Default cyan
        const glowSize = parameters.glowSize || 15;
        
        // Convert to grayscale
        this.applyGrayscaleEffect(canvas, ctx);
        
        // Invert colors
        this.applyInvertEffect(canvas, ctx);
        
        // Apply blur
        this.applyBlurEffect(canvas, ctx, { blurAmount: glowSize });
        
        // Get the processed image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Apply color dodge blending with original
        const originalData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const original = originalData.data;
        
        // Parse the neon color
        const r = parseInt(color.substr(1, 2), 16);
        const g = parseInt(color.substr(3, 2), 16);
        const b = parseInt(color.substr(5, 2), 16);
        
        for (let i = 0; i < data.length; i += 4) {
            // Color dodge formula
            data[i] = original[i] === 255 ? 255 : Math.min(255, (data[i] * 255) / (255 - original[i]));
            data[i + 1] = original[i + 1] === 255 ? 255 : Math.min(255, (data[i + 1] * 255) / (255 - original[i + 1]));
            data[i + 2] = original[i + 2] === 255 ? 255 : Math.min(255, (data[i + 2] * 255) / (255 - original[i + 2]));
            
            // Apply neon color tint
            data[i] = Math.min(255, data[i] * r / 255);
            data[i + 1] = Math.min(255, data[i + 1] * g / 255);
            data[i + 2] = Math.min(255, data[i + 2] * b / 255);
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply brightness effect with parameters
    applyBrightnessEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const brightness = parameters.brightness || 30; // Brightness adjustment value
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, Math.max(0, data[i] + brightness));     // Red
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + brightness)); // Green
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + brightness)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply contrast effect with parameters
    applyContrastEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const contrast = parameters.contrast || 1.5; // Contrast adjustment value
        
        for (let i = 0; i < data.length; i += 4) {
            // Apply contrast formula
            data[i] = Math.min(255, Math.max(0, ((data[i] - 128) * contrast) + 128));     // Red
            data[i + 1] = Math.min(255, Math.max(0, ((data[i + 1] - 128) * contrast) + 128)); // Green
            data[i + 2] = Math.min(255, Math.max(0, ((data[i + 2] - 128) * contrast) + 128)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply saturation effect with parameters
    applySaturationEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const saturation = parameters.saturation || 1.5; // Saturation adjustment value
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Convert to HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // Achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            // Adjust saturation
            s = Math.min(1, Math.max(0, s * saturation));
            
            // Convert back to RGB
            let r2, g2, b2;
            
            if (s === 0) {
                r2 = g2 = b2 = l; // Achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r2 = hue2rgb(p, q, h + 1/3);
                g2 = hue2rgb(p, q, h);
                b2 = hue2rgb(p, q, h - 1/3);
            }
            
            data[i] = r2 * 255;
            data[i + 1] = g2 * 255;
            data[i + 2] = b2 * 255;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply hue shift effect with parameters
    applyHueEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const hueShift = parameters.hueShift || parameters.hue || 30; // Hue shift in degrees
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i] / 255;
            const g = data[i + 1] / 255;
            const b = data[i + 2] / 255;
            
            // Convert to HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // Achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            // Adjust hue
            h = (h + hueShift / 360) % 1;
            if (h < 0) h += 1;
            
            // Convert back to RGB
            let r2, g2, b2;
            
            if (s === 0) {
                r2 = g2 = b2 = l; // Achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r2 = hue2rgb(p, q, h + 1/3);
                g2 = hue2rgb(p, q, h);
                b2 = hue2rgb(p, q, h - 1/3);
            }
            
            data[i] = r2 * 255;
            data[i + 1] = g2 * 255;
            data[i + 2] = b2 * 255;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply invert effect with parameters
    applyInvertEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i] + (255 - data[i] * 2) * intensity;         // Red
            data[i + 1] = data[i + 1] + (255 - data[i + 1] * 2) * intensity; // Green
            data[i + 2] = data[i + 2] + (255 - data[i + 2] * 2) * intensity; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply edge detection effect with parameters
    applyEdgeDetectionEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Get parameters
        const threshold = parameters.threshold || 50;
        const method = parameters.method || 'sobel'; // 'sobel', 'prewitt', 'roberts'
        
        let kernelX, kernelY;
        
        switch (method) {
            case 'prewitt':
                kernelX = [
                    -1, 0, 1,
                    -1, 0, 1,
                    -1, 0, 1
                ];
                
                kernelY = [
                    -1, -1, -1,
                     0,  0,  0,
                     1,  1,  1
                ];
                break;
            case 'roberts':
                kernelX = [
                    1, 0,
                    0, -1
                ];
                
                kernelY = [
                    0, 1,
                    -1, 0
                ];
                break;
            case 'sobel':
            default:
                kernelX = [
                    -1, 0, 1,
                    -2, 0, 2,
                    -1, 0, 1
                ];
                
                kernelY = [
                    -1, -2, -1,
                     0,  0,  0,
                     1,  2,  1
                ];
                break;
        }
        
        const kernelSize = method === 'roberts' ? 2 : 3;
        const offset = Math.floor(kernelSize / 2);
        
        // Apply convolution
        for (let y = offset; y < canvas.height - offset; y++) {
            for (let x = offset; x < canvas.width - offset; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                let pixelX = 0;
                let pixelY = 0;
                
                for (let ky = -offset; ky <= offset; ky++) {
                    for (let kx = -offset; kx <= offset; kx++) {
                        const kidx = ((y + ky) * canvas.width + (x + kx)) * 4;
                        const gray = (temp[kidx] + temp[kidx + 1] + temp[kidx + 2]) / 3;
                        
                        const weightX = kernelX[(ky + offset) * kernelSize + (kx + offset)];
                        const weightY = kernelY[(ky + offset) * kernelSize + (kx + offset)];
                        
                        pixelX += gray * weightX;
                        pixelY += gray * weightY;
                    }
                }
                
                const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                const edge = magnitude > threshold ? 255 : 0;
                
                data[idx] = edge;
                data[idx + 1] = edge;
                data[idx + 2] = edge;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply emboss effect with parameters
    applyEmbossEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        
        // Emboss kernel
        const kernel = [
            -2 * intensity, -1 * intensity, 0,
            -1 * intensity, 1 * intensity, 1 * intensity,
            0, 1 * intensity, 2 * intensity
        ];
        
        // Apply convolution
        for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                let r = 0, g = 0, b = 0;
                
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const kidx = ((y + ky) * canvas.width + (x + kx)) * 4;
                        const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                        
                        r += temp[kidx] * weight;
                        g += temp[kidx + 1] * weight;
                        b += temp[kidx + 2] * weight;
                    }
                }
                
                // Add 128 to make it gray
                data[idx] = Math.min(255, Math.max(0, r + 128));
                data[idx + 1] = Math.min(255, Math.max(0, g + 128));
                data[idx + 2] = Math.min(255, Math.max(0, b + 128));
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply oil painting effect with parameters
    applyOilPaintingEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Get parameters
        const radius = parameters.radius || 4;
        const intensity = parameters.intensity || 20;
        
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                // Initialize intensity count
                const intensityCount = new Array(intensity + 1).fill(0);
                const avgR = new Array(intensity + 1).fill(0);
                const avgG = new Array(intensity + 1).fill(0);
                const avgB = new Array(intensity + 1).fill(0);
                
                // Sample pixels in the radius
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const ny = y + dy;
                        const nx = x + dx;
                        
                        if (ny >= 0 && ny < canvas.height && nx >= 0 && nx < canvas.width) {
                            const nidx = (ny * canvas.width + nx) * 4;
                            
                            // Calculate intensity
                            const currR = temp[nidx];
                            const currG = temp[nidx + 1];
                            const currB = temp[nidx + 2];
                            const currIntensity = Math.round((currR + currG + currB) / 3 * intensity / 255);
                            
                            // Update counts and averages
                            intensityCount[currIntensity]++;
                            avgR[currIntensity] += currR;
                            avgG[currIntensity] += currG;
                            avgB[currIntensity] += currB;
                        }
                    }
                }
                
                // Find max intensity
                let maxIndex = 0;
                let maxCount = 0;
                
                for (let i = 0; i <= intensity; i++) {
                    if (intensityCount[i] > maxCount) {
                        maxCount = intensityCount[i];
                        maxIndex = i;
                    }
                }
                
                // Set pixel color
                data[idx] = avgR[maxIndex] / maxCount;
                data[idx + 1] = avgG[maxIndex] / maxCount;
                data[idx + 2] = avgB[maxIndex] / maxCount;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply cartoon effect with parameters
    applyCartoonEffect(canvas, ctx, parameters = {}) {
        // Save original image
        const originalCanvas = document.createElement('canvas');
        const originalCtx = originalCanvas.getContext('2d');
        originalCanvas.width = canvas.width;
        originalCanvas.height = canvas.height;
        originalCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const edgeThreshold = parameters.edgeThreshold || 50;
        const levels = parameters.levels || 4;
        
        // Apply edge detection to get edges
        this.applyEdgeDetectionEffect(canvas, ctx, { threshold: edgeThreshold });
        
        // Save edge data
        const edgeData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // Restore original image
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(originalCanvas, 0, 0);
        
        // Apply posterization to original image
        this.applyPosterizeEffect(canvas, ctx, { levels: levels });
        
        // Get posterized image data
        const posterizedData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const posterizedPixels = posterizedData.data;
        const edgePixels = edgeData.data;
        
        // Combine edges with posterized image
        for (let i = 0; i < posterizedPixels.length; i += 4) {
            // If edge pixel is white (edge detected), make it black
            if (edgePixels[i] > 200) { // Threshold for edge detection
                posterizedPixels[i] = 0;     // Red
                posterizedPixels[i + 1] = 0; // Green
                posterizedPixels[i + 2] = 0; // Blue
            }
            // Otherwise keep the posterized color
        }
        
        // Put the combined image back
        ctx.putImageData(posterizedData, 0, 0);
    }

    // Apply Ghibli-style effect with parameters
    applyGhibliEffect(canvas, ctx, parameters = {}) {
        // Save original image
        const originalCanvas = document.createElement('canvas');
        const originalCtx = originalCanvas.getContext('2d');
        originalCanvas.width = canvas.width;
        originalCanvas.height = canvas.height;
        originalCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const animationEnabled = parameters.animation !== false;
        
        // Step 1: Apply watercolor-style softening
        this.applyWatercolorEffect(canvas, ctx, parameters);
        
        // Step 2: Apply Ghibli color palette
        this.applyGhibliColorPalette(canvas, ctx, parameters);
        
        // Step 3: Add soft lighting effect
        this.applyGhibliLighting(canvas, ctx, parameters);
        
        // Step 4: Add subtle hand-drawn texture
        this.addHandDrawnTexture(canvas, ctx, parameters);
        
        // Step 5: Apply atmospheric perspective
        this.applyAtmosphericPerspective(canvas, ctx, parameters);
        
        // Step 6: Add animated elements if enabled
        if (animationEnabled) {
            this.addAnimatedGhibliElements(canvas, ctx, parameters);
        }
    }

    // Apply watercolor-style softening with parameters
    applyWatercolorEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create a temporary canvas for processing
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // Get parameters
        const blurAmount = parameters.blurAmount || 1;
        const blendAmount = parameters.blendAmount || 0.3;
        
        // Apply very subtle blur to soften edges
        tempCtx.filter = `blur(${blurAmount}px)`;
        tempCtx.drawImage(tempCanvas, 0, 0);
        tempCtx.filter = 'none';
        
        // Get the blurred image data
        const blurredData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const blurredPixels = blurredData.data;
        
        // Blend original and blurred for watercolor effect
        for (let i = 0; i < data.length; i += 4) {
            // Blend original with blurred
            data[i] = data[i] * (1 - blendAmount) + blurredPixels[i] * blendAmount;
            data[i + 1] = data[i + 1] * (1 - blendAmount) + blurredPixels[i + 1] * blendAmount;
            data[i + 2] = data[i + 2] * (1 - blendAmount) + blurredPixels[i + 2] * blendAmount;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply authentic Ghibli color palette with parameters
    applyGhibliColorPalette(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const blendAmount = parameters.blendAmount || 0.3;
        
        // Ghibli's signature colors: soft greens, blues, warm earth tones
        const ghibliPalette = [
            { r: 120, g: 170, b: 120 }, // Soft green
            { r: 100, g: 150, b: 200 }, // Sky blue
            { r: 220, g: 180, b: 140 }, // Warm beige
            { r: 180, g: 130, b: 100 }, // Earth brown
            { r: 150, g: 200, b: 180 }, // Mint green
            { r: 200, g: 160, b: 190 }, // Soft pink
            { r: 230, g: 210, b: 170 }, // Cream
            { r: 160, g: 190, b: 220 }  // Soft blue
        ];
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Find closest color in Ghibli palette
            let minDistance = Infinity;
            let closestColor = ghibliPalette[0];
            
            for (const color of ghibliPalette) {
                const distance = Math.sqrt(
                    Math.pow(r - color.r, 2) +
                    Math.pow(g - color.g, 2) +
                    Math.pow(b - color.b, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }
            
            // Blend original color with closest Ghibli color
            data[i] = r * (1 - blendAmount) + closestColor.r * blendAmount;
            data[i + 1] = g * (1 - blendAmount) + closestColor.g * blendAmount;
            data[i + 2] = b * (1 - blendAmount) + closestColor.b * blendAmount;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply Ghibli-style soft lighting with parameters
    applyGhibliLighting(canvas, ctx, parameters = {}) {
        // Create a soft gradient overlay for lighting
        const gradientCanvas = document.createElement('canvas');
        const gradientCtx = gradientCanvas.getContext('2d');
        gradientCanvas.width = canvas.width;
        gradientCanvas.height = canvas.height;
        
        // Get parameters
        const lightPosition = parameters.lightPosition || { x: 0.5, y: 0.33 }; // Default: upper center
        const lightRadius = parameters.lightRadius || 0.8;
        const lightIntensity = parameters.lightIntensity || 0.4;
        
        // Create radial gradient for soft lighting
        const centerX = canvas.width * lightPosition.x;
        const centerY = canvas.height * lightPosition.y;
        const radius = Math.max(canvas.width, canvas.height) * lightRadius;
        
        const gradient = gradientCtx.createRadialGradient(
            centerX, centerY, 0,
            centerX, centerY, radius
        );
        
        gradient.addColorStop(0, `rgba(255, 255, 220, ${lightIntensity})`); // Warm light center
        gradient.addColorStop(0.5, `rgba(255, 255, 200, ${lightIntensity * 0.5})`); // Mid-light
        gradient.addColorStop(1, 'rgba(200, 200, 180, 0)'); // Fade to transparent
        
        gradientCtx.fillStyle = gradient;
        gradientCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply lighting with soft-light blend mode
        ctx.globalCompositeOperation = 'soft-light';
        ctx.drawImage(gradientCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Add subtle hand-drawn texture with parameters
    addHandDrawnTexture(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create texture canvas
        const textureCanvas = document.createElement('canvas');
        const textureCtx = textureCanvas.getContext('2d');
        textureCanvas.width = canvas.width;
        textureCanvas.height = canvas.height;
        
        // Get parameters
        const paperTexture = parameters.paperTexture !== false;
        const pencilMarks = parameters.pencilMarks !== false;
        const textureIntensity = parameters.textureIntensity || 0.03;
        
        // Add subtle paper texture
        if (paperTexture) {
            textureCtx.fillStyle = `rgba(255, 255, 255, ${textureIntensity})`;
            textureCtx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Add very subtle pencil-like marks
        if (pencilMarks) {
            const markCount = parameters.markCount || 100;
            const markOpacity = parameters.markOpacity || 0.02;
            
            for (let i = 0; i < markCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const length = 5 + Math.random() * 15;
                const angle = Math.random() * Math.PI * 2;
                
                textureCtx.beginPath();
                textureCtx.moveTo(x, y);
                textureCtx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                
                textureCtx.strokeStyle = `rgba(100, 100, 100, ${markOpacity})`;
                textureCtx.lineWidth = 0.5;
                textureCtx.stroke();
            }
        }
        
        // Apply texture with overlay blend mode
        ctx.globalCompositeOperation = 'overlay';
        ctx.drawImage(textureCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Apply atmospheric perspective effect with parameters
    applyAtmosphericPerspective(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create a subtle blue haze for distant elements
        const hazeCanvas = document.createElement('canvas');
        const hazeCtx = hazeCanvas.getContext('2d');
        hazeCanvas.width = canvas.width;
        hazeCanvas.height = canvas.height;
        
        // Get parameters
        const hazeColor = parameters.hazeColor || { r: 180, g: 200, b: 220 };
        const hazeIntensity = parameters.hazeIntensity || 0.1;
        const direction = parameters.direction || 'vertical'; // 'vertical' or 'horizontal'
        
        // Create gradient for atmospheric perspective
        let gradient;
        
        if (direction === 'horizontal') {
            gradient = hazeCtx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, `rgba(${hazeColor.r}, ${hazeColor.g}, ${hazeColor.b}, 0)`);
            gradient.addColorStop(1, `rgba(${hazeColor.r}, ${hazeColor.g}, ${hazeColor.b}, ${hazeIntensity})`);
        } else {
            gradient = hazeCtx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, `rgba(${hazeColor.r}, ${hazeColor.g}, ${hazeColor.b}, ${hazeIntensity})`);
            gradient.addColorStop(1, `rgba(${hazeColor.r}, ${hazeColor.g}, ${hazeColor.b}, 0)`);
        }
        
        hazeCtx.fillStyle = gradient;
        hazeCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply haze with screen blend mode
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(hazeCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Add animated Ghibli-style elements with parameters
    addAnimatedGhibliElements(canvas, ctx, parameters = {}) {
        // Create a new canvas for animated elements
        const animationCanvas = document.createElement('canvas');
        const animationCtx = animationCanvas.getContext('2d');
        animationCanvas.width = canvas.width;
        animationCanvas.height = canvas.height;
        
        // Get parameters
        const sparklesEnabled = parameters.sparkles !== false;
        const cloudsEnabled = parameters.clouds !== false;
        const leavesEnabled = parameters.leaves !== false;
        
        // Function to draw animated elements
        const drawAnimation = (time) => {
            // Clear animation canvas
            animationCtx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
            
            // Draw animated sparkles (like Totoro's dust particles)
            if (sparklesEnabled) {
                this.drawAnimatedSparkles(animationCtx, animationCanvas.width, animationCanvas.height, time, parameters);
            }
            
            // Draw animated clouds
            if (cloudsEnabled) {
                this.drawAnimatedClouds(animationCtx, animationCanvas.width, animationCanvas.height, time, parameters);
            }
            
            // Draw animated leaves or petals
            if (leavesEnabled) {
                this.drawAnimatedLeaves(animationCtx, animationCanvas.width, animationCanvas.height, time, parameters);
            }
            
            // Apply animation to main canvas
            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(animationCanvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
            
            // Continue animation
            requestAnimationFrame(drawAnimation);
        };
        
        // Start animation
        requestAnimationFrame(drawAnimation);
    }

    // Draw animated sparkles with parameters
    drawAnimatedSparkles(ctx, width, height, time, parameters = {}) {
        // Get parameters
        const sparkleCount = parameters.sparkleCount || 20;
        const sparkleSize = parameters.sparkleSize || 3;
        const sparkleSpeed = parameters.sparkleSpeed || 0.002;
        
        for (let i = 0; i < sparkleCount; i++) {
            // Create pseudo-random but consistent positions based on i
            const x = (Math.sin(i * 12.9898 + 78.233) * 43758.5453) % 1 * width;
            const y = (Math.sin(i * 78.233 + 12.9898) * 43758.5453) % 1 * height;
            
            // Animate opacity
            const opacity = 0.3 + 0.7 * Math.abs(Math.sin(time * sparkleSpeed + i));
            
            // Draw sparkle
            ctx.beginPath();
            ctx.arc(x, y, sparkleSize, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 200, ${opacity})`;
            ctx.fill();
            
            // Draw sparkle rays
            ctx.beginPath();
            ctx.moveTo(x - sparkleSize * 2, y);
            ctx.lineTo(x + sparkleSize * 2, y);
            ctx.moveTo(x, y - sparkleSize * 2);
            ctx.lineTo(x, y + sparkleSize * 2);
            ctx.strokeStyle = `rgba(255, 255, 200, ${opacity * 0.7})`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Draw animated clouds with parameters
    drawAnimatedClouds(ctx, width, height, time, parameters = {}) {
        // Get parameters
        const cloudCount = parameters.cloudCount || 3;
        const cloudSpeed = parameters.cloudSpeed || 0.0005;
        const cloudOpacity = parameters.cloudOpacity || 0.2;
        
        for (let i = 0; i < cloudCount; i++) {
            // Base position
            const baseX = (width / (cloudCount + 1)) * (i + 1);
            const baseY = height * 0.2;
            
            // Animate position
            const x = baseX + Math.sin(time * cloudSpeed + i) * 20;
            const y = baseY + Math.cos(time * cloudSpeed * 0.6 + i) * 5;
            
            // Draw cloud
            ctx.beginPath();
            
            // Cloud is made of several overlapping circles
            const cloudWidth = 60;
            const cloudHeight = 30;
            
            ctx.arc(x, y, cloudHeight, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth * 0.25, y - cloudHeight * 0.25, cloudHeight * 0.8, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth * 0.5, y, cloudHeight * 0.9, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth * 0.75, y - cloudHeight * 0.15, cloudHeight * 0.7, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth, y, cloudHeight * 0.8, 0, Math.PI * 2);
            
            // Semi-transparent white
            ctx.fillStyle = `rgba(255, 255, 255, ${cloudOpacity})`;
            ctx.fill();
        }
    }

    // Draw animated leaves/petals with parameters
    drawAnimatedLeaves(ctx, width, height, time, parameters = {}) {
        // Get parameters
        const leafCount = parameters.leafCount || 8;
        const fallSpeed = parameters.fallSpeed || 0.0001;
        const swayAmount = parameters.swayAmount || 30;
        const leafColor = parameters.leafColor || { r: 100, g: 150, b: 50 };
        
        for (let i = 0; i < leafCount; i++) {
            // Starting position (top of image)
            const startX = (width / (leafCount + 1)) * (i + 1);
            const startY = -20;
            
            // Calculate position based on time (falling motion)
            const fallProgress = ((time * fallSpeed + i * 0.2) % 1);
            const x = startX + Math.sin(fallProgress * Math.PI * 4) * swayAmount;
            const y = startY + (height + 40) * fallProgress;
            
            // Rotation
            const rotation = fallProgress * Math.PI * 2;
            
            // Draw leaf
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.bezierCurveTo(5, -5, 5, 5, 0, 10);
            ctx.bezierCurveTo(-5, 5, -5, -5, 0, -10);
            
            // Green with some variation
            const greenValue = leafColor.g + Math.sin(i) * 30;
            ctx.fillStyle = `rgba(${leafColor.r}, ${greenValue}, ${leafColor.b}, 0.6)`;
            ctx.fill();
            
            ctx.restore();
        }
    }

    // Apply mirror effect with parameters
    applyMirrorEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const direction = parameters.direction || 'horizontal'; // 'horizontal' or 'vertical'
        
        ctx.save();
        
        if (direction === 'horizontal') {
            // Flip horizontally
            ctx.scale(-1, 1);
            ctx.drawImage(tempCanvas, -canvas.width, 0);
        } else {
            // Flip vertically
            ctx.scale(1, -1);
            ctx.drawImage(tempCanvas, 0, -canvas.height);
        }
        
        ctx.restore();
    }

    // Apply rotate effect with parameters
    applyRotateEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const angle = parameters.rotation || parameters.angle || 90; // in degrees
        const radians = angle * Math.PI / 180;
        
        // Calculate new dimensions for rotated canvas
        const newWidth = Math.abs(canvas.width * Math.cos(radians)) + Math.abs(canvas.height * Math.sin(radians));
        const newHeight = Math.abs(canvas.width * Math.sin(radians)) + Math.abs(canvas.height * Math.cos(radians));
        
        // Resize canvas
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        // Rotate and draw
        ctx.save();
        ctx.translate(newWidth / 2, newHeight / 2);
        ctx.rotate(radians);
        ctx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);
        ctx.restore();
    }

    // Apply crop effect with parameters
    applyCropEffect(canvas, ctx, parameters = {}) {
        // Get parameters
        const aspectRatio = parameters.aspectRatio || '1:1'; // Default to square
        const position = parameters.position || 'center'; // 'center', 'top', 'bottom', 'left', 'right'
        
        let cropWidth, cropHeight, cropX, cropY;
        
        // Calculate dimensions based on aspect ratio
        if (aspectRatio === 'original') {
            cropWidth = canvas.width;
            cropHeight = canvas.height;
        } else {
            const ratioParts = aspectRatio.split(':');
            const ratioW = parseInt(ratioParts[0]);
            const ratioH = parseInt(ratioParts[1]);
            
            if (canvas.width / canvas.height > ratioW / ratioH) {
                // Image is wider than ratio
                cropHeight = canvas.height;
                cropWidth = cropHeight * ratioW / ratioH;
            } else {
                // Image is taller than ratio
                cropWidth = canvas.width;
                cropHeight = cropWidth * ratioH / ratioW;
            }
        }
        
        // Calculate position based on parameter
        switch (position) {
            case 'top':
                cropX = (canvas.width - cropWidth) / 2;
                cropY = 0;
                break;
            case 'bottom':
                cropX = (canvas.width - cropWidth) / 2;
                cropY = canvas.height - cropHeight;
                break;
            case 'left':
                cropX = 0;
                cropY = (canvas.height - cropHeight) / 2;
                break;
            case 'right':
                cropX = canvas.width - cropWidth;
                cropY = (canvas.height - cropHeight) / 2;
                break;
            case 'center':
            default:
                cropX = (canvas.width - cropWidth) / 2;
                cropY = (canvas.height - cropHeight) / 2;
                break;
        }
        
        // Get the cropped image data
        const imageData = ctx.getImageData(cropX, cropY, cropWidth, cropHeight);
        
        // Resize canvas
        canvas.width = cropWidth;
        canvas.height = cropHeight;
        
        // Put the cropped image data back
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply vignette effect with parameters
    applyVignetteEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const strength = parameters.strength || parameters.vignetteStrength || 0.8;
        const radius = parameters.radius || 1.0;
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY) * radius;
        
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate vignette factor (1 at center, 0 at corners)
                const vignette = 1 - Math.pow(distance / maxDistance, 2) * strength;
                
                // Apply vignette
                const idx = (y * canvas.width + x) * 4;
                data[idx] *= vignette;
                data[idx + 1] *= vignette;
                data[idx + 2] *= vignette;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply noise effect with parameters
    applyNoiseEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const amount = parameters.noiseAmount || parameters.amount || 50; // Noise amount
        
        for (let i = 0; i < data.length; i += 4) {
            const noise = Math.random() * amount - amount / 2;
            
            data[i] = Math.min(255, Math.max(0, data[i] + noise));     // Red
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise)); // Green
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply posterize effect with parameters
    applyPosterizeEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const levels = parameters.levels || parameters.colorLevels || 4; // Number of color levels
        
        const step = 255 / (levels - 1);
        
        for (let i = 0; i < data.length; i += 4) {
            // Posterize each channel
            data[i] = Math.round(data[i] / step) * step;     // Red
            data[i + 1] = Math.round(data[i + 1] / step) * step; // Green
            data[i + 2] = Math.round(data[i + 2] / step) * step; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply solarize effect with parameters
    applySolarizeEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const threshold = parameters.threshold || 128; // Solarization threshold
        
        for (let i = 0; i < data.length; i += 4) {
            // Solarize each channel
            data[i] = data[i] < threshold ? data[i] : 255 - data[i];     // Red
            data[i + 1] = data[i + 1] < threshold ? data[i + 1] : 255 - data[i + 1]; // Green
            data[i + 2] = data[i + 2] < threshold ? data[i + 2] : 255 - data[i + 2]; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // NEW EFFECTS IMPLEMENTATION

    // Apply bokeh effect
    applyBokehEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const intensity = parameters.intensity || 0.7;
        const size = parameters.size || 15;
        const amount = parameters.amount || 30;
        
        // Apply blur to create depth of field
        this.applyBlurEffect(canvas, ctx, { blurAmount: size * 0.5 });
        
        // Get the blurred image data
        const blurredData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const blurredPixels = blurredData.data;
        
        // Restore original image
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(tempCanvas, 0, 0);
        
        // Get original image data
        const originalData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const originalPixels = originalData.data;
        
        // Create bokeh circles (simulated)
        for (let i = 0; i < amount; i++) {
            const x = Math.floor(Math.random() * canvas.width);
            const y = Math.floor(Math.random() * canvas.height);
            const radius = Math.random() * size + 5;
            
            // Create gradient for bokeh circle
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Blend original and blurred with bokeh
        for (let i = 0; i < originalPixels.length; i += 4) {
            originalPixels[i] = originalPixels[i] * (1 - intensity) + blurredPixels[i] * intensity;
            originalPixels[i + 1] = originalPixels[i + 1] * (1 - intensity) + blurredPixels[i + 1] * intensity;
            originalPixels[i + 2] = originalPixels[i + 2] * (1 - intensity) + blurredPixels[i + 2] * intensity;
        }
        
        ctx.putImageData(originalData, 0, 0);
    }

    // Apply lens flare effect
    applyLensFlareEffect(canvas, ctx, parameters = {}) {
        // Get parameters
        const position = parameters.position || { x: 0.7, y: 0.3 }; // Default position
        const intensity = parameters.intensity || 0.8;
        const color = parameters.color || '#ffffff'; // Default white
        
        // Create lens flare overlay
        const flareCanvas = document.createElement('canvas');
        const flareCtx = flareCanvas.getContext('2d');
        flareCanvas.width = canvas.width;
        flareCanvas.height = canvas.height;
        
        // Calculate flare position
        const flareX = canvas.width * position.x;
        const flareY = canvas.height * position.y;
        
        // Parse color
        let r, g, b;
        if (color.startsWith('#')) {
            r = parseInt(color.substr(1, 2), 16);
            g = parseInt(color.substr(3, 2), 16);
            b = parseInt(color.substr(5, 2), 16);
        } else {
            r = g = b = 255; // Default to white
        }
        
        // Draw main flare point
        const mainGradient = flareCtx.createRadialGradient(flareX, flareY, 0, flareX, flareY, 50);
        mainGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${intensity})`);
        mainGradient.addColorStop(0.2, `rgba(${r}, ${g}, ${b}, ${intensity * 0.5})`);
        mainGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
        
        flareCtx.fillStyle = mainGradient;
        flareCtx.beginPath();
        flareCtx.arc(flareX, flareY, 50, 0, Math.PI * 2);
        flareCtx.fill();
        
        // Draw additional flare elements
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const distance = 100 + i * 30;
            const elementX = flareX + Math.cos(angle) * distance;
            const elementY = flareY + Math.sin(angle) * distance;
            const elementSize = 10 + i * 2;
            
            const elementGradient = flareCtx.createRadialGradient(
                elementX, elementY, 0,
                elementX, elementY, elementSize
            );
            elementGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${intensity * 0.7})`);
            elementGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            
            flareCtx.fillStyle = elementGradient;
            flareCtx.beginPath();
            flareCtx.arc(elementX, elementY, elementSize, 0, Math.PI * 2);
            flareCtx.fill();
        }
        
        // Draw flare streaks
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const length = 200 + Math.random() * 100;
            const endX = flareX + Math.cos(angle) * length;
            const endY = flareY + Math.sin(angle) * length;
            
            const streakGradient = flareCtx.createLinearGradient(flareX, flareY, endX, endY);
            streakGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${intensity * 0.5})`);
            streakGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            
            flareCtx.strokeStyle = streakGradient;
            flareCtx.lineWidth = 2 + Math.random() * 3;
            flareCtx.beginPath();
            flareCtx.moveTo(flareX, flareY);
            flareCtx.lineTo(endX, endY);
            flareCtx.stroke();
        }
        
        // Apply flare to main canvas with screen blend mode
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(flareCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Apply HDR effect
    applyHDREffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.5;
        const radius = parameters.radius || 15;
        
        // Create temporary canvas for Gaussian blur
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // Apply Gaussian blur
        tempCtx.filter = `blur(${radius}px)`;
        tempCtx.drawImage(tempCanvas, 0, 0);
        
        // Get blurred image data
        const blurredData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const blurredPixels = blurredData.data;
        
        // Apply HDR effect
        for (let i = 0; i < data.length; i += 4) {
            // Get original and blurred pixel values
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            const blurR = blurredPixels[i];
            const blurG = blurredPixels[i + 1];
            const blurB = blurredPixels[i + 2];
            
            // Calculate detail (original - blurred)
            const detailR = r - blurR;
            const detailG = g - blurG;
            const detailB = b - blurB;
            
            // Apply HDR (original + detail * intensity)
            data[i] = Math.min(255, Math.max(0, r + detailR * intensity));
            data[i + 1] = Math.min(255, Math.max(0, g + detailG * intensity));
            data[i + 2] = Math.min(255, Math.max(0, b + detailB * intensity));
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply tilt shift effect
    applyTiltShiftEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const focusPosition = parameters.focusPosition || 0.5; // 0 to 1, position of focus line
        const focusSize = parameters.focusSize || 0.2; // 0 to 1, size of focus area
        const blurAmount = parameters.blurAmount || 10;
        const direction = parameters.direction || 'horizontal'; // 'horizontal' or 'vertical'
        
        // Create gradient mask for tilt shift
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');
        maskCanvas.width = canvas.width;
        maskCanvas.height = canvas.height;
        
        let gradient;
        
        if (direction === 'horizontal') {
            const focusY = canvas.height * focusPosition;
            const focusHeight = canvas.height * focusSize;
            
            gradient = maskCtx.createLinearGradient(0, focusY - focusHeight, 0, focusY + focusHeight);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.25, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.75, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
        } else {
            const focusX = canvas.width * focusPosition;
            const focusWidth = canvas.width * focusSize;
            
            gradient = maskCtx.createLinearGradient(focusX - focusWidth, 0, focusX + focusWidth, 0);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.25, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.75, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
        }
        
        maskCtx.fillStyle = gradient;
        maskCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply blur to entire image
        this.applyBlurEffect(canvas, ctx, { blurAmount: blurAmount });
        
        // Use mask to restore focus area
        ctx.globalCompositeOperation = 'destination-out';
        ctx.drawImage(maskCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
        
        // Draw original image in focus area
        ctx.save();
        ctx.globalCompositeOperation = 'destination-in';
        ctx.drawImage(maskCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(tempCanvas, 0, 0);
        ctx.restore();
    }

    // Apply watercolor effect (standalone version)
    applyWatercolorEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 0.7;
        const smoothing = parameters.smoothing || 3;
        
        // Create temporary canvas for processing
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // Apply blur to soften edges
        tempCtx.filter = `blur(${smoothing}px)`;
        tempCtx.drawImage(tempCanvas, 0, 0);
        tempCtx.filter = 'none';
        
        // Get the blurred image data
        const blurredData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const blurredPixels = blurredData.data;
        
        // Create watercolor paper texture
        const textureCanvas = document.createElement('canvas');
        const textureCtx = textureCanvas.getContext('2d');
        textureCanvas.width = canvas.width;
        textureCanvas.height = canvas.height;
        
        // Add paper texture
        for (let i = 0; i < 1000; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 2;
            
            textureCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.05})`;
            textureCtx.beginPath();
            textureCtx.arc(x, y, size, 0, Math.PI * 2);
            textureCtx.fill();
        }
        
        // Blend original and blurred for watercolor effect
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i] * (1 - intensity) + blurredPixels[i] * intensity;
            data[i + 1] = data[i + 1] * (1 - intensity) + blurredPixels[i + 1] * intensity;
            data[i + 2] = data[i + 2] * (1 - intensity) + blurredPixels[i + 2] * intensity;
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Apply texture with overlay blend mode
        ctx.globalCompositeOperation = 'overlay';
        ctx.drawImage(textureCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Apply sketch effect
    applySketchEffect(canvas, ctx, parameters = {}) {
        // Save original image
        const originalCanvas = document.createElement('canvas');
        const originalCtx = originalCanvas.getContext('2d');
        originalCanvas.width = canvas.width;
        originalCanvas.height = canvas.height;
        originalCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        const method = parameters.method || 'pencil'; // 'pencil', 'charcoal'
        
        // Convert to grayscale
        this.applyGrayscaleEffect(canvas, ctx);
        
        // Invert colors
        this.applyInvertEffect(canvas, ctx);
        
        // Apply blur
        this.applyBlurEffect(canvas, ctx, { blurAmount: 5 });
        
        // Get the processed image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Apply color dodge blending with original
        const originalData = originalCtx.getImageData(0, 0, canvas.width, canvas.height);
        const original = originalData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            // Color dodge formula
            data[i] = original[i] === 255 ? 255 : Math.min(255, (data[i] * 255) / (255 - original[i]));
            data[i + 1] = original[i + 1] === 255 ? 255 : Math.min(255, (data[i + 1] * 255) / (255 - original[i + 1]));
            data[i + 2] = original[i + 2] === 255 ? 255 : Math.min(255, (data[i + 2] * 255) / (255 - original[i + 2]));
            
            // Adjust for sketch effect
            if (method === 'charcoal') {
                // Charcoal effect is darker with more contrast
                data[i] = Math.min(255, data[i] * intensity * 0.8);
                data[i + 1] = Math.min(255, data[i + 1] * intensity * 0.8);
                data[i + 2] = Math.min(255, data[i + 2] * intensity * 0.8);
            } else {
                // Pencil effect
                data[i] = Math.min(255, data[i] * intensity);
                data[i + 1] = Math.min(255, data[i + 1] * intensity);
                data[i + 2] = Math.min(255, data[i + 2] * intensity);
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Add paper texture for more realistic sketch
        const textureCanvas = document.createElement('canvas');
        const textureCtx = textureCanvas.getContext('2d');
        textureCanvas.width = canvas.width;
        textureCanvas.height = canvas.height;
        
        // Add paper texture
        for (let i = 0; i < 500; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 1.5;
            
            textureCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.1})`;
            textureCtx.beginPath();
            textureCtx.arc(x, y, size, 0, Math.PI * 2);
            textureCtx.fill();
        }
        
        // Apply texture with overlay blend mode
        ctx.globalCompositeOperation = 'overlay';
        ctx.drawImage(textureCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Apply double exposure effect
    applyDoubleExposureEffect(canvas, ctx, parameters = {}) {
        // Get parameters
        const blendMode = parameters.blendMode || 'screen'; // 'screen', 'multiply', 'overlay'
        const secondImage = parameters.secondImage || null;
        
        if (!secondImage) {
            // If no second image is provided, create a pattern
            const patternCanvas = document.createElement('canvas');
            const patternCtx = patternCanvas.getContext('2d');
            patternCanvas.width = canvas.width;
            patternCanvas.height = canvas.height;
            
            // Create a pattern (e.g., trees, mountains, etc.)
            const patternType = parameters.patternType || 'mountains';
            
            switch (patternType) {
                case 'mountains':
                    this.drawMountainPattern(patternCtx, patternCanvas.width, patternCanvas.height);
                    break;
                case 'trees':
                    this.drawTreePattern(patternCtx, patternCanvas.width, patternCanvas.height);
                    break;
                case 'city':
                    this.drawCityPattern(patternCtx, patternCanvas.width, patternCanvas.height);
                    break;
                default:
                    this.drawMountainPattern(patternCtx, patternCanvas.width, patternCanvas.height);
            }
            
            // Apply pattern with blend mode
            ctx.globalCompositeOperation = blendMode;
            ctx.drawImage(patternCanvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
        } else {
            // If a second image is provided, use it
            const img = new Image();
            img.onload = () => {
                // Scale second image to fit canvas
                const scale = Math.max(canvas.width / img.width, canvas.height / img.height);
                const width = img.width * scale;
                const height = img.height * scale;
                const x = (canvas.width - width) / 2;
                const y = (canvas.height - height) / 2;
                
                // Apply second image with blend mode
                ctx.globalCompositeOperation = blendMode;
                ctx.drawImage(img, x, y, width, height);
                ctx.globalCompositeOperation = 'source-over';
            };
            img.src = secondImage;
        }
    }

    // Draw mountain pattern for double exposure
    drawMountainPattern(ctx, width, height) {
        // Create gradient for sky
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
        skyGradient.addColorStop(0, '#1a237e');
        skyGradient.addColorStop(1, '#4a148c');
        
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);
        
        // Draw mountains
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.moveTo(0, height * 0.7);
        
        // First mountain range
        for (let x = 0; x <= width; x += 20) {
            const y = height * 0.7 - Math.sin(x * 0.01) * height * 0.3;
            ctx.lineTo(x, y);
        }
        
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.fill();
        
        // Second mountain range
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(0, height * 0.8);
        
        for (let x = 0; x <= width; x += 20) {
            const y = height * 0.8 - Math.sin(x * 0.02 + 1) * height * 0.2;
            ctx.lineTo(x, y);
        }
        
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.fill();
        
        // Add stars
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height * 0.6;
            const size = Math.random() * 2;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Draw tree pattern for double exposure
    drawTreePattern(ctx, width, height) {
        // Create gradient for sky
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
        skyGradient.addColorStop(0, '#0d47a1');
        skyGradient.addColorStop(1, '#1b5e20');
        
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);
        
        // Draw trees
        const treeCount = 15;
        
        for (let i = 0; i < treeCount; i++) {
            const x = (width / treeCount) * i + Math.random() * (width / treeCount);
            const treeHeight = height * 0.3 + Math.random() * height * 0.4;
            const treeWidth = treeHeight * 0.3;
            
            // Draw trunk
            ctx.fillStyle = '#3e2723';
            ctx.fillRect(x - treeWidth * 0.1, height - treeHeight * 0.3, treeWidth * 0.2, treeHeight * 0.3);
            
            // Draw leaves
            ctx.fillStyle = '#1b5e20';
            ctx.beginPath();
            ctx.moveTo(x, height - treeHeight);
            ctx.lineTo(x - treeWidth, height - treeHeight * 0.7);
            ctx.lineTo(x - treeWidth * 0.5, height - treeHeight * 0.7);
            ctx.lineTo(x - treeWidth * 0.7, height - treeHeight * 0.4);
            ctx.lineTo(x, height - treeHeight * 0.3);
            ctx.lineTo(x + treeWidth * 0.7, height - treeHeight * 0.4);
            ctx.lineTo(x + treeWidth * 0.5, height - treeHeight * 0.7);
            ctx.lineTo(x + treeWidth, height - treeHeight * 0.7);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Draw city pattern for double exposure
    drawCityPattern(ctx, width, height) {
        // Create gradient for sky
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
        skyGradient.addColorStop(0, '#263238');
        skyGradient.addColorStop(1, '#000');
        
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);
        
        // Draw buildings
        const buildingCount = 20;
        const maxHeight = height * 0.8;
        
        for (let i = 0; i < buildingCount; i++) {
            const buildingWidth = width / buildingCount + Math.random() * 10;
            const x = (width / buildingCount) * i;
            const buildingHeight = Math.random() * maxHeight;
            
            // Draw building
            ctx.fillStyle = '#212121';
            ctx.fillRect(x, height - buildingHeight, buildingWidth, buildingHeight);
            
            // Draw windows
            const windowRows = Math.floor(buildingHeight / 20);
            const windowCols = Math.floor(buildingWidth / 10);
            
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    if (Math.random() > 0.3) { // 70% chance of lit window
                        ctx.fillStyle = '#ffeb3b';
                        ctx.fillRect(
                            x + col * 10 + 2,
                            height - buildingHeight + row * 20 + 5,
                            6,
                            10
                        );
                    }
                }
            }
        }
    }

    // Apply color pop effect
    applyColorPopEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const colorToPop = parameters.color || '#ff0000'; // Default red
        const tolerance = parameters.tolerance || 30; // Color matching tolerance
        const desaturationAmount = parameters.desaturationAmount || 0.8; // How much to desaturate other colors
        
        // Parse the color to pop
        let r, g, b;
        if (colorToPop.startsWith('#')) {
            r = parseInt(colorToPop.substr(1, 2), 16);
            g = parseInt(colorToPop.substr(3, 2), 16);
            b = parseInt(colorToPop.substr(5, 2), 16);
        } else {
            r = g = b = 255; // Default to white if invalid color
        }
        
        // Convert to grayscale first
        for (let i = 0; i < data.length; i += 4) {
            // Calculate grayscale using luminance formula
            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
            
            // Apply partial desaturation
            data[i] = data[i] * (1 - desaturationAmount) + gray * desaturationAmount;
            data[i + 1] = data[i + 1] * (1 - desaturationAmount) + gray * desaturationAmount;
            data[i + 2] = data[i + 2] * (1 - desaturationAmount) + gray * desaturationAmount;
        }
        
        // Restore the selected color
        for (let i = 0; i < data.length; i += 4) {
            // Check if pixel matches the color to pop within tolerance
            const pixelR = data[i];
            const pixelG = data[i + 1];
            const pixelB = data[i + 2];
            
            const distance = Math.sqrt(
                Math.pow(pixelR - r, 2) +
                Math.pow(pixelG - g, 2) +
                Math.pow(pixelB - b, 2)
            );
            
            if (distance < tolerance) {
                // Restore original color (we don't have it anymore, so use the target color)
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply retro effect
    applyRetroEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const colorPalette = parameters.colorPalette || 'warm'; // 'warm', 'cool', 'vintage'
        const scanLines = parameters.scanLines !== false;
        const vignette = parameters.vignette !== false;
        const noise = parameters.noise !== false;
        
        // Define color palettes
        let palette;
        
        switch (colorPalette) {
            case 'cool':
                palette = [
                    { r: 50, g: 100, b: 150 },
                    { r: 100, g: 150, b: 200 },
                    { r: 150, g: 200, b: 220 },
                    { r: 200, g: 220, b: 240 }
                ];
                break;
            case 'vintage':
                palette = [
                    { r: 180, g: 140, b: 100 },
                    { r: 200, g: 170, b: 130 },
                    { r: 220, g: 190, b: 150 },
                    { r: 240, g: 210, b: 170 }
                ];
                break;
            case 'warm':
            default:
                palette = [
                    { r: 200, g: 100, b: 50 },
                    { r: 220, g: 130, b: 80 },
                    { r: 240, g: 160, b: 110 },
                    { r: 255, g: 190, b: 140 }
                ];
                break;
        }
        
        // Apply color palette
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Find closest color in palette
            let minDistance = Infinity;
            let closestColor = palette[0];
            
            for (const color of palette) {
                const distance = Math.sqrt(
                    Math.pow(r - color.r, 2) +
                    Math.pow(g - color.g, 2) +
                    Math.pow(b - color.b, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }
            
            // Apply closest color
            data[i] = closestColor.r;
            data[i + 1] = closestColor.g;
            data[i + 2] = closestColor.b;
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Add scan lines
        if (scanLines) {
            const scanLineCanvas = document.createElement('canvas');
            const scanLineCtx = scanLineCanvas.getContext('2d');
            scanLineCanvas.width = canvas.width;
            scanLineCanvas.height = canvas.height;
            
            // Draw scan lines
            scanLineCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            scanLineCtx.lineWidth = 1;
            
            for (let y = 0; y < canvas.height; y += 3) {
                scanLineCtx.beginPath();
                scanLineCtx.moveTo(0, y);
                scanLineCtx.lineTo(canvas.width, y);
                scanLineCtx.stroke();
            }
            
            // Apply scan lines
            ctx.globalCompositeOperation = 'overlay';
            ctx.drawImage(scanLineCanvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
        }
        
        // Add vignette
        if (vignette) {
            this.applyVignetteEffect(canvas, ctx, { strength: 0.8 });
        }
        
        // Add noise
        if (noise) {
            this.applyNoiseEffect(canvas, ctx, { amount: 20 });
        }
    }

    // Create edited filename with effect suffix
    createEditedFilename(originalFilename, effect) {
        // Extract filename without extension
        const nameParts = originalFilename.split('.');
        const name = nameParts.slice(0, -1).join('.');
        const extension = nameParts.length > 1 ? nameParts[nameParts.length - 1] : 'jpg';
        
        // Add effect suffix
        return `${name}_${effect}.${extension}`;
    }

    // Download edited image automatically
    downloadEditedImage(canvas, filename) {
        try {
            // Convert canvas to blob
            canvas.toBlob((blob) => {
                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }, 'image/jpeg', 0.9);
            
        } catch (error) {
            console.error("Download Error:", error);
            // Fallback to manual download
            this.fallbackDownload(canvas, filename);
        }
    }

    // Fallback download method
    fallbackDownload(canvas, filename) {
        // Convert to data URL
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        
        // Create download link
        const downloadLink = document.createElement('a');
        downloadLink.href = dataUrl;
        downloadLink.download = filename;
        downloadLink.textContent = `Download ${filename}`;
        downloadLink.className = 'download-button';
        downloadLink.style.cssText = `
            display: inline-block;
            background: #2196F3;
            color: white;
            padding: 10px 15px;
            text-decoration: none;
            border-radius: 4px;
            margin-top: 10px;
        `;
        
        // Add to chat
        botReply("Your edited image is ready:");
        const messageContainer = document.createElement('div');
        messageContainer.appendChild(downloadLink);
        document.querySelector('.chat-messages').appendChild(messageContainer);
        
        // Scroll to bottom
        document.querySelector('.chat-container').scrollTop = document.querySelector('.chat-container').scrollHeight;
    }

    // Show download notification
    showDownloadNotification(filename) {
        this.downloadNotification.innerHTML = `
            <div style="display: flex; align-items: center;">
                <svg style="width:24px; height:24px; margin-right:10px;" fill="white" viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
                <div>
                    <div style="font-weight: bold;">Download Complete!</div>
                    <div style="font-size: 0.9em;">${filename}</div>
                </div>
            </div>
        `;
        
        this.downloadNotification.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            this.downloadNotification.style.display = 'none';
        }, 5000);
    }

    // Auto-enhancement function
    autoEnhance(canvas, ctx) {
        // Get image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Apply auto-levels
        this.autoAdjustLevels(data);
        
        // Put enhanced data back
        ctx.putImageData(imageData, 0, 0);
    }

    // Auto-levels adjustment
    autoAdjustLevels(data) {
        // Calculate histogram
        const histogram = { r: [], g: [], b: [] };
        
        // Initialize histogram arrays
        for (let i = 0; i < 256; i++) {
            histogram.r[i] = 0;
            histogram.g[i] = 0;
            histogram.b[i] = 0;
        }
        
        // Populate histogram
        for (let i = 0; i < data.length; i += 4) {
            histogram.r[data[i]]++;
            histogram.g[data[i + 1]]++;
            histogram.b[data[i + 2]]++;
        }
        
        // Find min and max for each channel
        const findMinMax = (hist) => {
            let min = 0;
            let max = 255;
            
            // Find min (ignore 1% of pixels)
            const totalPixels = data.length / 4;
            const ignoreCount = totalPixels * 0.01;
            let count = 0;
            
            for (let i = 0; i < 256; i++) {
                count += hist[i];
                if (count > ignoreCount) {
                    min = i;
                    break;
                }
            }
            
            // Find max (ignore 1% of pixels)
            count = 0;
            for (let i = 255; i >= 0; i--) {
                count += hist[i];
                if (count > ignoreCount) {
                    max = i;
                    break;
                }
            }
            
            return { min, max };
        };
        
        const rMinMax = findMinMax(histogram.r);
        const gMinMax = findMinMax(histogram.g);
        const bMinMax = findMinMax(histogram.b);
        
        // Apply levels adjustment
        for (let i = 0; i < data.length; i += 4) {
            // Red channel
            data[i] = this.adjustLevel(data[i], rMinMax.min, rMinMax.max);
            
            // Green channel
            data[i + 1] = this.adjustLevel(data[i + 1], gMinMax.min, gMinMax.max);
            
            // Blue channel
            data[i + 2] = this.adjustLevel(data[i + 2], bMinMax.min, bMinMax.max);
        }
    }

    // Adjust single color level
    adjustLevel(value, min, max) {
        if (min === max) return value;
        return Math.min(255, Math.max(0, (value - min) * 255 / (max - min)));
    }
}


// Initialize photo editor
const photoEditor = new PhotoEditor();

// Trigger photo editing when user requests it
if (/edit photo/i.test(userInputRaw)) {
    photoEditor.triggerPhotoEdit(userInputRaw);
    return;
}




class CalculatorScreen {
    constructor() {
        this.calculator = {
            name: 'ADVANCED CALCULATOR',
            instructions: 'Perform basic and advanced calculations including GST, tax, square root, and more.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.display = null;
        this.expressionDisplay = null;
        this.currentValue = '0';
        this.previousValue = '';
        this.operation = null;
        this.waitingForOperand = false;
        this.activeButton = null;
        this.memory = 0; // For memory functions
        this.gstRates = {
            gst1: 5,    // 5% GST
            gst2: 12,   // 12% GST
            gst3: 18,   // 18% GST
            gst4: 28    // 28% GST
        };
    }
    
    /**
     * Load the Calculator
     */
    loadCalculator() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.calculator.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Create calculator
        this.createCalculator();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the calculator
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.calculator.name} loaded! ${this.calculator.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the Calculator UI
     */
    createCalculator() {
        // Create calculator container
        const calculatorContainer = document.createElement('div');
        calculatorContainer.style.cssText = `
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 360px;
            max-width: 90vw;
        `;
        
        // Create display container
        const displayContainer = document.createElement('div');
        displayContainer.style.cssText = `
            background-color: #222;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: right;
            color: white;
            font-family: 'Courier New', monospace;
        `;
        
        // Create expression display (shows the operation)
        this.expressionDisplay = document.createElement('div');
        this.expressionDisplay.style.cssText = `
            font-size: 16px;
            color: #aaa;
            min-height: 20px;
            margin-bottom: 5px;
        `;
        this.expressionDisplay.textContent = '';
        
        // Create main display (shows current number)
        this.display = document.createElement('div');
        this.display.style.cssText = `
            font-size: 28px;
            font-weight: bold;
            min-height: 30px;
            word-wrap: break-word;
            word-break: break-all;
        `;
        this.display.textContent = this.currentValue;
        
        displayContainer.appendChild(this.expressionDisplay);
        displayContainer.appendChild(this.display);
        calculatorContainer.appendChild(displayContainer);
        
        // Create buttons grid
        const buttonsGrid = document.createElement('div');
        buttonsGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-gap: 8px;
        `;
        
        // Define buttons
        const buttons = [
            // Row 1
            { label: 'C', action: 'clear', className: 'btn-clear' },
            { label: '⌫', action: 'backspace', className: 'btn-backspace' },
            { label: '√', action: 'sqrt', className: 'btn-advanced' },
            { label: 'x²', action: 'square', className: 'btn-advanced' },
            { label: '÷', action: 'divide', className: 'btn-operator' },
            
            // Row 2
            { label: '7', action: 'number', className: 'btn-number' },
            { label: '8', action: 'number', className: 'btn-number' },
            { label: '9', action: 'number', className: 'btn-number' },
            { label: '%', action: 'percent', className: 'btn-advanced' },
            { label: '×', action: 'multiply', className: 'btn-operator' },
            
            // Row 3
            { label: '4', action: 'number', className: 'btn-number' },
            { label: '5', action: 'number', className: 'btn-number' },
            { label: '6', action: 'number', className: 'btn-number' },
            { label: '1/x', action: 'reciprocal', className: 'btn-advanced' },
            { label: '-', action: 'subtract', className: 'btn-operator' },
            
            // Row 4
            { label: '1', action: 'number', className: 'btn-number' },
            { label: '2', action: 'number', className: 'btn-number' },
            { label: '3', action: 'number', className: 'btn-number' },
            { label: 'Tax', action: 'tax', className: 'btn-advanced' },
            { label: '+', action: 'add', className: 'btn-operator' },
            
            // Row 5
            { label: '0', action: 'number', className: 'btn-number', colSpan: 2 },
            { label: '.', action: 'decimal', className: 'btn-number' },
            { label: '=', action: 'equals', className: 'btn-equals', rowSpan: 2 },
            
            // Row 6 (GST buttons)
            { label: 'GST1', action: 'gst1', className: 'btn-gst' },
            { label: 'GST2', action: 'gst2', className: 'btn-gst' },
            { label: 'GST3', action: 'gst3', className: 'btn-gst' },
            { label: 'GST4', action: 'gst4', className: 'btn-gst' },
        ];
        
        // Create buttons
        buttons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.label;
            btn.className = button.className;
            btn.style.cssText = this.getButtonStyle(button);
            
            // Set grid row/column span if specified
            if (button.rowSpan) {
                btn.style.gridRow = `span ${button.rowSpan}`;
            }
            if (button.colSpan) {
                btn.style.gridColumn = `span ${button.colSpan}`;
            }
            
            // Add event listeners for better responsiveness
            this.addButtonEventListeners(btn, button.action, button.label);
            
            buttonsGrid.appendChild(btn);
        });
        
        calculatorContainer.appendChild(buttonsGrid);
        this.gameContainer.appendChild(calculatorContainer);
        
        // Add keyboard event listeners
        this.setupKeyboardEvents();
    }
    
    /**
     * Add event listeners to buttons for better responsiveness
     */
    addButtonEventListeners(button, action, label) {
        // Use both mousedown and touchstart for immediate response
        const handleInteraction = (e) => {
            e.preventDefault(); // Prevent default to avoid delays
            this.handleButtonClick(action, label);
            
            // Visual feedback
            this.activeButton = button;
            button.style.transform = 'scale(0.95)';
            button.style.opacity = '0.8';
        };
        
        const handleRelease = () => {
            if (this.activeButton === button) {
                button.style.transform = '';
                button.style.opacity = '';
                this.activeButton = null;
            }
        };
        
        // Mouse events
        button.addEventListener('mousedown', handleInteraction);
        button.addEventListener('mouseup', handleRelease);
        button.addEventListener('mouseleave', handleRelease);
        
        // Touch events
        button.addEventListener('touchstart', handleInteraction, { passive: false });
        button.addEventListener('touchend', handleRelease);
        button.addEventListener('touchcancel', handleRelease);
    }
    
    /**
     * Get button style based on button type
     */
    getButtonStyle(button) {
        const baseStyle = `
            padding: 18px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        `;
        
        switch (button.className) {
            case 'btn-clear':
            case 'btn-backspace':
                return baseStyle + `
                    background-color: #f44336;
                    color: white;
                `;
            case 'btn-operator':
                return baseStyle + `
                    background-color: #ff9800;
                    color: white;
                `;
            case 'btn-equals':
                return baseStyle + `
                    background-color: #4CAF50;
                    color: white;
                `;
            case 'btn-advanced':
                return baseStyle + `
                    background-color: #9c27b0;
                    color: white;
                `;
            case 'btn-gst':
                return baseStyle + `
                    background-color: #3f51b5;
                    color: white;
                `;
            case 'btn-number':
            default:
                return baseStyle + `
                    background-color: #555;
                    color: white;
                `;
        }
    }
    
    /**
     * Handle button click
     */
    handleButtonClick(action, label) {
        // Add a small delay to prevent double-taps from registering twice
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        this.buttonTimeout = setTimeout(() => {
            switch (action) {
                case 'number':
                    this.inputNumber(label);
                    break;
                case 'decimal':
                    this.inputDecimal();
                    break;
                case 'clear':
                    this.clear();
                    break;
                case 'backspace':
                    this.backspace();
                    break;
                case 'add':
                    this.setOperation('+');
                    break;
                case 'subtract':
                    this.setOperation('-');
                    break;
                case 'multiply':
                    this.setOperation('*');
                    break;
                case 'divide':
                    this.setOperation('/');
                    break;
                case 'equals':
                    this.calculate();
                    break;
                // Advanced functions
                case 'sqrt':
                    this.squareRoot();
                    break;
                case 'square':
                    this.square();
                    break;
                case 'percent':
                    this.percent();
                    break;
                case 'reciprocal':
                    this.reciprocal();
                    break;
                case 'tax':
                    this.applyTax();
                    break;
                // GST functions
                case 'gst1':
                    this.applyGST('gst1');
                    break;
                case 'gst2':
                    this.applyGST('gst2');
                    break;
                case 'gst3':
                    this.applyGST('gst3');
                    break;
                case 'gst4':
                    this.applyGST('gst4');
                    break;
            }
            this.buttonTimeout = null;
        }, 10);
    }
    
    /**
     * Input a number
     */
    inputNumber(num) {
        if (this.waitingForOperand) {
            this.currentValue = num;
            this.waitingForOperand = false;
        } else {
            this.currentValue = this.currentValue === '0' ? num : this.currentValue + num;
        }
        this.updateDisplay();
    }
    
    /**
     * Input a decimal point
     */
    inputDecimal() {
        if (this.waitingForOperand) {
            this.currentValue = '0.';
            this.waitingForOperand = false;
        } else if (this.currentValue.indexOf('.') === -1) {
            this.currentValue += '.';
        }
        this.updateDisplay();
    }
    
    /**
     * Clear the calculator
     */
    clear() {
        this.currentValue = '0';
        this.previousValue = '';
        this.operation = null;
        this.waitingForOperand = false;
        this.updateDisplay();
        this.updateExpressionDisplay();
    }
    
    /**
     * Backspace - remove last digit
     */
    backspace() {
        if (this.currentValue.length > 1) {
            this.currentValue = this.currentValue.slice(0, -1);
        } else {
            this.currentValue = '0';
        }
        this.updateDisplay();
    }
    
    /**
     * Set the operation
     */
    setOperation(nextOperation) {
        const inputValue = parseFloat(this.currentValue);
        
        if (this.previousValue === '') {
            this.previousValue = inputValue;
        } else if (this.operation) {
            const currentValue = this.previousValue || 0;
            const newValue = this.performCalculation();
            
            this.currentValue = String(newValue);
            this.previousValue = newValue;
            this.updateDisplay();
        }
        
        this.waitingForOperand = true;
        this.operation = nextOperation;
        this.updateExpressionDisplay();
    }
    
    /**
     * Perform the calculation
     */
    calculate() {
        const inputValue = parseFloat(this.currentValue);
        
        if (this.previousValue !== '' && this.operation) {
            const newValue = this.performCalculation();
            this.currentValue = String(newValue);
            this.previousValue = '';
            this.operation = null;
            this.waitingForOperand = true;
            this.updateDisplay();
            this.updateExpressionDisplay();
        }
    }
    
    /**
     * Perform the actual calculation
     */
    performCalculation() {
        const prev = parseFloat(this.previousValue);
        const current = parseFloat(this.currentValue);
        
        switch (this.operation) {
            case '+':
                return prev + current;
            case '-':
                return prev - current;
            case '*':
                return prev * current;
            case '/':
                if (current === 0) {
                    this.showError('Error: Division by zero');
                    return 0;
                }
                return prev / current;
            default:
                return current;
        }
    }
    
    /**
     * Square root function
     */
    squareRoot() {
        const value = parseFloat(this.currentValue);
        if (value < 0) {
            this.showError('Error: Negative number');
            return;
        }
        this.currentValue = String(Math.sqrt(value));
        this.updateDisplay();
    }
    
    /**
     * Square function
     */
    square() {
        const value = parseFloat(this.currentValue);
        this.currentValue = String(value * value);
        this.updateDisplay();
    }
    
    /**
     * Percent function
     */
    percent() {
        const value = parseFloat(this.currentValue);
        this.currentValue = String(value / 100);
        this.updateDisplay();
    }
    
    /**
     * Reciprocal function (1/x)
     */
    reciprocal() {
        const value = parseFloat(this.currentValue);
        if (value === 0) {
            this.showError('Error: Division by zero');
            return;
        }
        this.currentValue = String(1 / value);
        this.updateDisplay();
    }
    
    /**
     * Apply tax (10%)
     */
    applyTax() {
        const value = parseFloat(this.currentValue);
        this.currentValue = String(value * 1.1);
        this.updateDisplay();
    }
    
    /**
     * Apply GST
     */
    applyGST(gstType) {
        const value = parseFloat(this.currentValue);
        const rate = this.gstRates[gstType] / 100;
        this.currentValue = String(value * (1 + rate));
        this.updateDisplay();
        
        // Show which GST rate was applied
        botReply(`Applied ${this.gstRates[gstType]}% GST`);
    }
    
    /**
     * Show error message
     */
    showError(message) {
        this.display.textContent = message;
        this.display.style.color = '#ff5252';
        
        // Reset after 2 seconds
        setTimeout(() => {
            this.display.style.color = '';
            this.currentValue = '0';
            this.updateDisplay();
        }, 2000);
    }
    
    /**
     * Update the main display
     */
    updateDisplay() {
        // Format large numbers with commas
        const formattedValue = this.formatNumber(this.currentValue);
        this.display.textContent = formattedValue;
    }
    
    /**
     * Update the expression display
     */
    updateExpressionDisplay() {
        let expression = '';
        
        if (this.previousValue !== '') {
            expression += this.formatNumber(this.previousValue);
        }
        
        if (this.operation) {
            let operatorSymbol = '';
            switch (this.operation) {
                case '+': operatorSymbol = ' + '; break;
                case '-': operatorSymbol = ' - '; break;
                case '*': operatorSymbol = ' × '; break;
                case '/': operatorSymbol = ' ÷ '; break;
            }
            expression += operatorSymbol;
        }
        
        this.expressionDisplay.textContent = expression;
    }
    
    /**
     * Format number with commas for thousands
     */
    formatNumber(num) {
        // Handle very large or small numbers with scientific notation
        if (Math.abs(parseFloat(num)) >= 1e10 || (Math.abs(parseFloat(num)) < 1e-6 && parseFloat(num) !== 0)) {
            return parseFloat(num).toExponential(6);
        }
        
        // Format with commas for thousands
        const parts = num.toString().split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        return parts.join('.');
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        // Handle calculator keys
        if (event.key >= '0' && event.key <= '9') {
            this.inputNumber(event.key);
        } else if (event.key === '.') {
            this.inputDecimal();
        } else if (event.key === '+' || event.key === '-' || event.key === '*' || event.key === '/') {
            this.setOperation(event.key);
        } else if (event.key === 'Enter' || event.key === '=') {
            this.calculate();
        } else if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.key === 'Backspace') {
            this.backspace();
        } else if (event.key === 'Delete' || event.key === 'c' || event.key === 'C') {
            this.clear();
        } else if (event.key === 'r' || event.key === 'R') {
            this.squareRoot();
        } else if (event.key === 's' || event.key === 'S') {
            this.square();
        } else if (event.key === '%') {
            this.percent();
        } else if (event.key === 't' || event.key === 'T') {
            this.applyTax();
        } else if (event.key === 'g' || event.key === 'G') {
            this.applyGST('gst3'); // Default to 18% GST
        }
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Clear any pending button timeout
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.display = null;
        this.expressionDisplay = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.currentValue = '0';
        this.previousValue = '';
        this.operation = null;
        this.waitingForOperand = false;
        this.activeButton = null;
        this.buttonTimeout = null;
        this.memory = 0;
        
        botReply("Advanced Calculator closed. Thank you!");
    }
}

// Create a singleton instance
const calculatorScreen = new CalculatorScreen();

// Add this to your AI's command handling
if (/calculator|calc|calculate/i.test(userInputRaw)) {
    calculatorScreen.loadCalculator();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    calculatorScreen.closeGame();
    return;
}


class VideoEditorScreen {
    constructor() {
        this.videoEditor = {
            name: 'VIDEO EDITOR',
            instructions: 'Edit your videos with professional tools like Kinemaster and Capcut.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.videoPreview = null;
        this.timeline = null;
        this.currentVideo = null;
        this.videoDuration = 0;
        this.currentTime = 0;
        this.playing = false;
        this.tracks = [];
        this.selectedTrack = null;
        this.selectedTool = 'select';
        this.selectedClip = null;
        this.zoomLevel = 1;
        this.volume = 0.8;
        this.playbackRate = 1;
        this.timeDisplay = null;
        this.playhead = null;
        this.clips = [];
        this.buttonTimeout = null;
        this.activeButton = null;
        this.projectInfo = null;
        this.uploadArea = null;
        this.effectsPanel = null;
        this.textPanel = null;
        this.transitionPanel = null;
        this.settingsPanel = null;
        this.exportPanel = null;
        this.trimPanel = null;
        this.canvas = null;
        this.ctx = null;
        this.textOverlays = [];
        this.effects = [];
        this.transitions = [];
        this.trimStart = 0;
        this.trimEnd = 0;
        this.leftToolbar = null;
        this.layersPanel = null;
        this.propertiesPanel = null;
        this.speedPanel = null;
        this.audioPanel = null;
        this.colorPanel = null;
        this.animationPanel = null;
        this.keyframePanel = null;
        this.chromaKeyPanel = null;
        this.stickers = [];
        this.animations = [];
        this.keyframes = [];
    }
    
    /**
     * Load the Video Editor
     */
    loadVideoEditor() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.videoEditor.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Create video editor
        this.createVideoEditor();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the video editor
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.videoEditor.name} loaded! ${this.videoEditor.instructions}`);
        botReply("Click 'Import' to upload a video file or press 'i' key.");
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
        `;
    }
    
    /**
     * Create the Video Editor UI
     */
    createVideoEditor() {
        // Create editor container
        const editorContainer = document.createElement('div');
        editorContainer.style.cssText = `
            background-color: #222;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 90vw;
            height: 90vh;
            max-width: 1400px;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background-color: #333;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.videoEditor.name;
        title.style.cssText = `
            font-size: 18px;
            font-weight: bold;
        `;
        
        this.projectInfo = document.createElement('div');
        this.projectInfo.textContent = 'New Project';
        this.projectInfo.style.cssText = `
            font-size: 14px;
            color: #aaa;
        `;
        
        header.appendChild(title);
        header.appendChild(this.projectInfo);
        editorContainer.appendChild(header);
        
        // Create main content area with left toolbar
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex: 1;
            overflow: hidden;
        `;
        
        // Create left toolbar
        this.createLeftToolbar();
        mainContent.appendChild(this.leftToolbar);
        
        // Create center content area
        const centerContent = document.createElement('div');
        centerContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        `;
        
        // Create preview area
        const previewArea = document.createElement('div');
        previewArea.style.cssText = `
            background-color: #111;
            height: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border-bottom: 1px solid #444;
        `;
        
        // Create canvas for video and effects
        this.canvas = document.createElement('canvas');
        this.canvas.style.cssText = `
            max-width: 100%;
            max-height: 100%;
            background-color: #000;
            z-index: 1;
        `;
        this.ctx = this.canvas.getContext('2d');
        
        // Create video preview element (hidden, used as source)
        this.videoPreview = document.createElement('video');
        this.videoPreview.style.cssText = `
            display: none;
        `;
        this.videoPreview.crossOrigin = 'anonymous';
        this.videoPreview.addEventListener('loadedmetadata', () => {
            this.videoDuration = this.videoPreview.duration;
            this.trimEnd = this.videoDuration;
            this.canvas.width = this.videoPreview.videoWidth;
            this.canvas.height = this.videoPreview.videoHeight;
            this.updateTimeline();
            this.renderFrame();
        });
        this.videoPreview.addEventListener('timeupdate', () => {
            this.currentTime = this.videoPreview.currentTime;
            this.updateTimelinePosition();
            this.renderFrame();
        });
        this.videoPreview.addEventListener('ended', () => {
            this.playing = false;
            this.updatePlayButton();
        });
        
        // Create upload area (shown when no video is loaded)
        this.uploadArea = document.createElement('div');
        this.uploadArea.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 10;
        `;
        
        const uploadIcon = document.createElement('div');
        uploadIcon.innerHTML = '📁';
        uploadIcon.style.cssText = `
            font-size: 48px;
            margin-bottom: 15px;
        `;
        
        const uploadText = document.createElement('div');
        uploadText.textContent = 'No video loaded';
        uploadText.style.cssText = `
            font-size: 18px;
            margin-bottom: 10px;
        `;
        
        const uploadSubtext = document.createElement('div');
        uploadSubtext.textContent = 'Click "Import" button or press "i" to upload a video';
        uploadSubtext.style.cssText = `
            font-size: 14px;
            color: #aaa;
            margin-bottom: 20px;
        `;
        
        const uploadButton = document.createElement('button');
        uploadButton.textContent = 'Upload Video';
        uploadButton.style.cssText = this.getButtonStyle('btn-tool-import');
        uploadButton.addEventListener('click', () => this.importMedia());
        
        this.uploadArea.appendChild(uploadIcon);
        this.uploadArea.appendChild(uploadText);
        this.uploadArea.appendChild(uploadSubtext);
        this.uploadArea.appendChild(uploadButton);
        
        previewArea.appendChild(this.canvas);
        previewArea.appendChild(this.videoPreview);
        previewArea.appendChild(this.uploadArea);
        
        // Create playback controls
        const playbackControls = document.createElement('div');
        playbackControls.style.cssText = `
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 5px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 5;
        `;
        
        // Define playback buttons
        const playbackButtons = [
            { label: '⏮', action: 'skipBackward', title: 'Skip Backward' },
            { label: '⏪', action: 'rewind', title: 'Rewind' },
            { label: '▶', action: 'playPause', title: 'Play/Pause', id: 'play-pause-btn' },
            { label: '⏩', action: 'fastForward', title: 'Fast Forward' },
            { label: '⏭', action: 'skipForward', title: 'Skip Forward' },
            { label: '🔊', action: 'volume', title: 'Volume' },
            { label: '✂️', action: 'trim', title: 'Trim' }
        ];
        
        // Create playback buttons
        playbackButtons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.label;
            btn.title = button.title;
            if (button.id) btn.id = button.id;
            btn.style.cssText = this.getButtonStyle('btn-playback');
            this.addButtonEventListeners(btn, button.action, button.label);
            playbackControls.appendChild(btn);
        });
        
        // Create time display
        const timeDisplay = document.createElement('div');
        timeDisplay.style.cssText = `
            color: white;
            font-size: 12px;
            font-family: monospace;
            min-width: 100px;
            text-align: center;
        `;
        timeDisplay.textContent = '00:00 / 00:00';
        this.timeDisplay = timeDisplay;
        
        playbackControls.appendChild(timeDisplay);
        previewArea.appendChild(playbackControls);
        centerContent.appendChild(previewArea);
        
        // Create timeline area
        const timelineArea = document.createElement('div');
        timelineArea.style.cssText = `
            background-color: #1a1a1a;
            height: 50%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        // Create timeline header
        const timelineHeader = document.createElement('div');
        timelineHeader.style.cssText = `
            background-color: #2a2a2a;
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            border-bottom: 1px solid #444;
        `;
        
        const timelineTitle = document.createElement('div');
        timelineTitle.textContent = 'Timeline';
        timelineTitle.style.cssText = `
            font-size: 14px;
            font-weight: bold;
        `;
        
        // Create timeline controls
        const timelineControls = document.createElement('div');
        timelineControls.style.cssText = `
            display: flex;
            gap: 5px;
        `;
        
        // Define timeline control buttons
        const timelineControlButtons = [
            { label: '+', action: 'zoomIn', title: 'Zoom In' },
            { label: '-', action: 'zoomOut', title: 'Zoom Out' },
            { label: '↔', action: 'fitToScreen', title: 'Fit to Screen' }
        ];
        
        // Create timeline control buttons
        timelineControlButtons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.label;
            btn.title = button.title;
            btn.style.cssText = this.getButtonStyle('btn-timeline-control');
            this.addButtonEventListeners(btn, button.action, button.label);
            timelineControls.appendChild(btn);
        });
        
        timelineHeader.appendChild(timelineTitle);
        timelineHeader.appendChild(timelineControls);
        timelineArea.appendChild(timelineHeader);
        
        // Create timeline tracks container
        const tracksContainer = document.createElement('div');
        tracksContainer.style.cssText = `
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        `;
        
        // Create timeline ruler
        const timelineRuler = document.createElement('div');
        timelineRuler.style.cssText = `
            height: 30px;
            background-color: #333;
            position: relative;
            border-bottom: 1px solid #444;
        `;
        
        // Create playhead
        this.playhead = document.createElement('div');
        this.playhead.style.cssText = `
            position: absolute;
            left: 0;
            top: 0;
            width: 2px;
            height: 100%;
            background-color: #ff5252;
            z-index: 100;
            pointer-events: none;
        `;
        timelineRuler.appendChild(this.playhead);
        
        // Create timeline ruler marks (simplified)
        for (let i = 0; i < 60; i++) {
            const mark = document.createElement('div');
            mark.style.cssText = `
                position: absolute;
                left: ${i * 50}px;
                top: 0;
                height: ${i % 5 === 0 ? '15px' : '8px'};
                width: 1px;
                background-color: #666;
            `;
            timelineRuler.appendChild(mark);
            
            if (i % 5 === 0) {
                const label = document.createElement('div');
                label.textContent = `${i}s`;
                label.style.cssText = `
                    position: absolute;
                    left: ${i * 50}px;
                    top: 15px;
                    font-size: 10px;
                    color: #aaa;
                    width: 40px;
                    text-align: center;
                `;
                timelineRuler.appendChild(label);
            }
        }
        
        tracksContainer.appendChild(timelineRuler);
        
        // Create timeline tracks area
        this.timeline = document.createElement('div');
        this.timeline.style.cssText = `
            background-color: #2a2a2a;
            min-height: 200px;
            position: relative;
        `;
        
        // Create initial tracks
        this.createTrack('Video', 'video');
        this.createTrack('Audio', 'audio');
        this.createTrack('Text', 'text');
        this.createTrack('Effects', 'effects');
        
        tracksContainer.appendChild(this.timeline);
        timelineArea.appendChild(tracksContainer);
        
        // Create bottom toolbar
        const bottomToolbar = document.createElement('div');
        bottomToolbar.style.cssText = `
            background-color: #333;
            padding: 8px 15px;
            display: flex;
            gap: 10px;
            overflow-x: auto;
            border-top: 1px solid #444;
        `;
        
        // Define tool buttons
        const toolButtons = [
            { label: 'Import', action: 'import', className: 'btn-tool-import' },
            { label: 'Export', action: 'export', className: 'btn-tool-export' }
        ];
        
        // Create tool buttons
        toolButtons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.label;
            btn.style.cssText = this.getButtonStyle(button.className);
            this.addButtonEventListeners(btn, button.action, button.label);
            bottomToolbar.appendChild(btn);
        });
        
        timelineArea.appendChild(bottomToolbar);
        centerContent.appendChild(timelineArea);
        mainContent.appendChild(centerContent);
        editorContainer.appendChild(mainContent);
        this.gameContainer.appendChild(editorContainer);
        
        // Add keyboard event listeners
        this.setupKeyboardEvents();
    }
    
    /**
     * Create left toolbar with all editing tools
     */
    createLeftToolbar() {
        this.leftToolbar = document.createElement('div');
        this.leftToolbar.style.cssText = `
            width: 60px;
            background-color: #2a2a2a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            border-right: 1px solid #444;
        `;
        
        // Define all editing tools
        const editingTools = [
            { label: '↖', action: 'select', title: 'Select Tool', className: 'btn-tool' },
            { label: '✂️', action: 'cut', title: 'Cut/Split', className: 'btn-tool' },
            { label: 'T', action: 'text', title: 'Text', className: 'btn-tool' },
            { label: '🏷️', action: 'sticker', title: 'Stickers', className: 'btn-tool' },
            { label: '🔄', action: 'transition', title: 'Transitions', className: 'btn-tool' },
            { label: '✨', action: 'effects', title: 'Effects', className: 'btn-tool' },
            { label: '🎨', action: 'filter', title: 'Filters', className: 'btn-tool' },
            { label: '🔊', action: 'audio', title: 'Audio', className: 'btn-tool' },
            { label: '⚡', action: 'speed', title: 'Speed Control', className: 'btn-tool' },
            { label: '🎬', action: 'animation', title: 'Animation', className: 'btn-tool' },
            { label: '🔑', action: 'keyframe', title: 'Keyframes', className: 'btn-tool' },
            { label: '🎭', action: 'chromaKey', title: 'Chroma Key', className: 'btn-tool' },
            { label: '🎚️', action: 'color', title: 'Color Adjust', className: 'btn-tool' },
            { label: '📐', action: 'transform', title: 'Transform', className: 'btn-tool' },
            { label: '🖼️', action: 'layers', title: 'Layers', className: 'btn-tool' },
            { label: '⚙️', action: 'properties', title: 'Properties', className: 'btn-tool' }
        ];
        
        // Create tool buttons
        editingTools.forEach(tool => {
            const btn = document.createElement('button');
            btn.textContent = tool.label;
            btn.title = tool.title;
            btn.style.cssText = this.getButtonStyle(tool.className);
            this.addButtonEventListeners(btn, tool.action, tool.label);
            this.leftToolbar.appendChild(btn);
        });
    }
    
    /**
     * Create a new track
     */
    createTrack(name, type) {
        const trackId = `track-${Date.now()}`;
        const track = {
            id: trackId,
            name: name,
            type: type,
            clips: []
        };
        
        const trackElement = document.createElement('div');
        trackElement.id = trackId;
        trackElement.style.cssText = `
            height: 60px;
            background-color: #333;
            border-bottom: 1px solid #444;
            position: relative;
            display: flex;
            align-items: center;
        `;
        
        const trackLabel = document.createElement('div');
        trackLabel.style.cssText = `
            width: 80px;
            padding: 0 10px;
            color: white;
            font-size: 12px;
            text-align: right;
            border-right: 1px solid #444;
        `;
        trackLabel.textContent = name;
        
        const trackContent = document.createElement('div');
        trackContent.style.cssText = `
            flex: 1;
            height: 100%;
            position: relative;
            overflow: hidden;
        `;
        
        trackElement.appendChild(trackLabel);
        trackElement.appendChild(trackContent);
        
        trackElement.addEventListener('click', () => {
            this.selectTrack(trackId);
        });
        
        this.timeline.appendChild(trackElement);
        this.tracks.push(track);
        
        return track;
    }
    
    /**
     * Select a track
     */
    selectTrack(trackId) {
        // Deselect all tracks
        this.tracks.forEach(track => {
            const trackElement = document.getElementById(track.id);
            if (trackElement) {
                trackElement.style.backgroundColor = '#333';
            }
        });
        
        // Select the specified track
        this.selectedTrack = trackId;
        const trackElement = document.getElementById(trackId);
        if (trackElement) {
            trackElement.style.backgroundColor = '#3a3a3a';
        }
    }
    
    /**
     * Add event listeners to buttons for better responsiveness
     */
    addButtonEventListeners(button, action, label) {
        const handleInteraction = (e) => {
            e.preventDefault();
            this.handleButtonClick(action, label);
            
            // Visual feedback
            this.activeButton = button;
            button.style.transform = 'scale(0.95)';
            button.style.opacity = '0.8';
        };
        
        const handleRelease = () => {
            if (this.activeButton === button) {
                button.style.transform = '';
                button.style.opacity = '';
                this.activeButton = null;
            }
        };
        
        // Mouse events
        button.addEventListener('mousedown', handleInteraction);
        button.addEventListener('mouseup', handleRelease);
        button.addEventListener('mouseleave', handleRelease);
        
        // Touch events
        button.addEventListener('touchstart', handleInteraction, { passive: false });
        button.addEventListener('touchend', handleRelease);
        button.addEventListener('touchcancel', handleRelease);
    }
    
    /**
     * Get button style based on button type
     */
    getButtonStyle(buttonType) {
        const baseStyle = `
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap;
        `;
        
        switch (buttonType) {
            case 'btn-playback':
                return baseStyle + `
                    background-color: rgba(255, 255, 255, 0.1);
                    color: white;
                    width: 36px;
                    height: 36px;
                    border-radius: 50%;
                    padding: 0;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
            case 'btn-timeline-control':
                return baseStyle + `
                    background-color: rgba(255, 255, 255, 0.1);
                    color: white;
                    width: 30px;
                    height: 30px;
                    border-radius: 4px;
                    padding: 0;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
            case 'btn-tool':
                return baseStyle + `
                    background-color: #444;
                    color: white;
                    width: 44px;
                    height: 44px;
                    border-radius: 8px;
                    margin: 5px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 18px;
                `;
            case 'btn-tool-import':
                return baseStyle + `
                    background-color: #2196F3;
                    color: white;
                `;
            case 'btn-tool-export':
                return baseStyle + `
                    background-color: #4CAF50;
                    color: white;
                `;
            default:
                return baseStyle + `
                    background-color: #555;
                    color: white;
                `;
        }
    }
    
    /**
     * Handle button click
     */
    handleButtonClick(action, label) {
        // Add a small delay to prevent double-taps from registering twice
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        this.buttonTimeout = setTimeout(() => {
            switch (action) {
                // Playback controls
                case 'playPause':
                    this.togglePlayPause();
                    break;
                case 'skipBackward':
                    this.skipBackward();
                    break;
                case 'skipForward':
                    this.skipForward();
                    break;
                case 'rewind':
                    this.rewind();
                    break;
                case 'fastForward':
                    this.fastForward();
                    break;
                case 'volume':
                    this.adjustVolume();
                    break;
                case 'trim':
                    this.openTrimTool();
                    break;
                    
                // Timeline controls
                case 'zoomIn':
                    this.zoomIn();
                    break;
                case 'zoomOut':
                    this.zoomOut();
                    break;
                case 'fitToScreen':
                    this.fitToScreen();
                    break;
                    
                // Tools
                case 'select':
                    this.selectTool('select');
                    break;
                case 'cut':
                    this.cutTool();
                    break;
                case 'text':
                    this.addText();
                    break;
                case 'sticker':
                    this.addSticker();
                    break;
                case 'transition':
                    this.addTransition();
                    break;
                case 'effects':
                    this.addEffect();
                    break;
                case 'filter':
                    this.addFilter();
                    break;
                case 'audio':
                    this.openAudioTool();
                    break;
                case 'speed':
                    this.openSpeedTool();
                    break;
                case 'animation':
                    this.openAnimationTool();
                    break;
                case 'keyframe':
                    this.openKeyframeTool();
                    break;
                case 'chromaKey':
                    this.openChromaKeyTool();
                    break;
                case 'color':
                    this.openColorTool();
                    break;
                case 'transform':
                    this.openTransformTool();
                    break;
                case 'layers':
                    this.openLayersTool();
                    break;
                case 'properties':
                    this.openPropertiesTool();
                    break;
                case 'import':
                    this.importMedia();
                    break;
                case 'export':
                    this.exportVideo();
                    break;
            }
            this.buttonTimeout = null;
        }, 10);
    }
    
    /**
     * Render frame with all effects and overlays
     */
    renderFrame() {
        if (!this.videoPreview || !this.ctx || this.videoPreview.readyState < 2) return;
        
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw video frame
        this.ctx.drawImage(this.videoPreview, 0, 0, this.canvas.width, this.canvas.height);
        
        // Apply filters
        this.applyFilters();
        
        // Draw text overlays
        this.drawTextOverlays();
        
        // Draw stickers
        this.drawStickers();
    }
    
    /**
     * Apply filters to the video
     */
    applyFilters() {
        if (this.effects.length === 0) return;
        
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;
        
        // Apply each effect
        this.effects.forEach(effect => {
            switch (effect.type) {
                case 'brightness':
                    this.applyBrightness(data, effect.intensity);
                    break;
                case 'contrast':
                    this.applyContrast(data, effect.intensity);
                    break;
                case 'saturation':
                    this.applySaturation(data, effect.intensity);
                    break;
                case 'blur':
                    // Blur is applied using CSS filter for simplicity
                    break;
                case 'grayscale':
                    this.applyGrayscale(data);
                    break;
                case 'sepia':
                    this.applySepia(data);
                    break;
                case 'invert':
                    this.applyInvert(data);
                    break;
            }
        });
        
        this.ctx.putImageData(imageData, 0, 0);
        
        // Apply CSS filters for effects that are easier to implement that way
        let cssFilter = '';
        this.effects.forEach(effect => {
            if (effect.type === 'blur') {
                cssFilter += `blur(${effect.intensity / 20}px) `;
            }
        });
        
        if (cssFilter) {
            this.canvas.style.filter = cssFilter;
        } else {
            this.canvas.style.filter = 'none';
        }
    }
    
    /**
     * Apply brightness effect
     */
    applyBrightness(data, intensity) {
        const factor = intensity / 50; // Convert to 0-2 range
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i] * factor;     // Red
            data[i + 1] = data[i + 1] * factor; // Green
            data[i + 2] = data[i + 2] * factor; // Blue
        }
    }
    
    /**
     * Apply contrast effect
     */
    applyContrast(data, intensity) {
        const factor = (259 * (intensity + 255)) / (255 * (259 - intensity));
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = factor * (data[i] - 128) + 128;     // Red
            data[i + 1] = factor * (data[i + 1] - 128) + 128; // Green
            data[i + 2] = factor * (data[i + 2] - 128) + 128; // Blue
        }
    }
    
    /**
     * Apply saturation effect
     */
    applySaturation(data, intensity) {
        const factor = intensity / 50; // Convert to 0-2 range
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
            
            data[i] = gray + factor * (r - gray);     // Red
            data[i + 1] = gray + factor * (g - gray); // Green
            data[i + 2] = gray + factor * (b - gray); // Blue
        }
    }
    
    /**
     * Apply grayscale effect
     */
    applyGrayscale(data) {
        for (let i = 0; i < data.length; i += 4) {
            const gray = 0.2989 * data[i] + 0.5870 * data[i + 1] + 0.1140 * data[i + 2];
            data[i] = gray;     // Red
            data[i + 1] = gray; // Green
            data[i + 2] = gray; // Blue
        }
    }
    
    /**
     * Apply sepia effect
     */
    applySepia(data) {
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));     // Red
            data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168)); // Green
            data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131)); // Blue
        }
    }
    
    /**
     * Apply invert effect
     */
    applyInvert(data) {
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i];         // Red
            data[i + 1] = 255 - data[i + 1]; // Green
            data[i + 2] = 255 - data[i + 2]; // Blue
        }
    }
    
    /**
     * Draw text overlays
     */
    drawTextOverlays() {
        this.textOverlays.forEach(text => {
            if (this.currentTime >= text.startTime && this.currentTime <= text.endTime) {
                this.ctx.save();
                
                // Set font properties
                this.ctx.font = `${text.fontSize}px Arial`;
                this.ctx.fillStyle = text.color;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Add shadow for better visibility
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                this.ctx.shadowBlur = 4;
                this.ctx.shadowOffsetX = 2;
                this.ctx.shadowOffsetY = 2;
                
                // Calculate position based on alignment
                let x = this.canvas.width * text.positionX;
                let y = this.canvas.height * text.positionY;
                
                // Draw text
                this.ctx.fillText(text.content, x, y);
                
                this.ctx.restore();
            }
        });
    }
    
    /**
     * Draw stickers
     */
    drawStickers() {
        // This would draw sticker overlays
        // Implementation depends on how stickers are stored
        this.stickers.forEach(sticker => {
            if (this.currentTime >= sticker.startTime && this.currentTime <= sticker.endTime) {
                this.ctx.save();
                
                // Calculate position and size
                const x = this.canvas.width * sticker.positionX;
                const y = this.canvas.height * sticker.positionY;
                const size = sticker.size;
                
                // Draw sticker (simplified - would use actual images in a real implementation)
                this.ctx.font = `${size}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(sticker.emoji, x, y);
                
                this.ctx.restore();
            }
        });
    }
    
    /**
     * Toggle play/pause
     */
    togglePlayPause() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        if (this.playing) {
            this.videoPreview.pause();
            this.playing = false;
        } else {
            this.videoPreview.play();
            this.playing = true;
        }
        
        this.updatePlayButton();
        this.updateTimeDisplay();
    }
    
    /**
     * Update play button icon
     */
    updatePlayButton() {
        const playButton = document.getElementById('play-pause-btn');
        if (playButton) {
            playButton.textContent = this.playing ? '⏸' : '▶';
        }
    }
    
    /**
     * Skip backward
     */
    skipBackward() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        this.videoPreview.currentTime = Math.max(this.trimStart, this.currentTime - 10);
    }
    
    /**
     * Skip forward
     */
    skipForward() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        this.videoPreview.currentTime = Math.min(this.trimEnd, this.currentTime + 10);
    }
    
    /**
     * Rewind
     */
    rewind() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        this.playbackRate = Math.max(0.5, this.playbackRate - 0.5);
        this.videoPreview.playbackRate = this.playbackRate;
        botReply(`Playback rate: ${this.playbackRate}x`);
    }
    
    /**
     * Fast forward
     */
    fastForward() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        this.playbackRate = Math.min(4, this.playbackRate + 0.5);
        this.videoPreview.playbackRate = this.playbackRate;
        botReply(`Playback rate: ${this.playbackRate}x`);
    }
    
    /**
     * Adjust volume
     */
    adjustVolume() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Simple volume toggle between 0.8 and 0
        this.volume = this.volume > 0 ? 0 : 0.8;
        this.videoPreview.volume = this.volume;
        botReply(`Volume: ${this.volume > 0 ? 'On' : 'Muted'}`);
    }
    
    /**
     * Open trim tool
     */
    openTrimTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create trim panel
        this.trimPanel = document.createElement('div');
        this.trimPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 400px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Trim Video';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Start time control
        const startControl = document.createElement('div');
        startControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const startLabel = document.createElement('label');
        startLabel.textContent = 'Start Time:';
        startLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const startSlider = document.createElement('input');
        startSlider.type = 'range';
        startSlider.min = '0';
        startSlider.max = this.videoDuration.toString();
        startSlider.step = '0.1';
        startSlider.value = this.trimStart.toString();
        startSlider.style.cssText = `
            width: 100%;
        `;
        
        const startValue = document.createElement('div');
        startValue.textContent = this.formatTime(this.trimStart);
        startValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        startSlider.addEventListener('input', (e) => {
            this.trimStart = parseFloat(e.target.value);
            startValue.textContent = this.formatTime(this.trimStart);
        });
        
        startControl.appendChild(startLabel);
        startControl.appendChild(startSlider);
        startControl.appendChild(startValue);
        
        // End time control
        const endControl = document.createElement('div');
        endControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const endLabel = document.createElement('label');
        endLabel.textContent = 'End Time:';
        endLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const endSlider = document.createElement('input');
        endSlider.type = 'range';
        endSlider.min = '0';
        endSlider.max = this.videoDuration.toString();
        endSlider.step = '0.1';
        endSlider.value = this.trimEnd.toString();
        endSlider.style.cssText = `
            width: 100%;
        `;
        
        const endValue = document.createElement('div');
        endValue.textContent = this.formatTime(this.trimEnd);
        endValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        endSlider.addEventListener('input', (e) => {
            this.trimEnd = parseFloat(e.target.value);
            endValue.textContent = this.formatTime(this.trimEnd);
        });
        
        endControl.appendChild(endLabel);
        endControl.appendChild(endSlider);
        endControl.appendChild(endValue);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply Trim';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            // Apply trim by setting video start and end points
            this.videoPreview.currentTime = this.trimStart;
            
            // Create a new clip with trimmed duration
            const videoTrack = this.tracks.find(t => t.type === 'video');
            if (videoTrack && videoTrack.clips.length > 0) {
                const clip = videoTrack.clips[0];
                clip.start = this.trimStart;
                clip.end = this.trimEnd;
                
                // Update the timeline
                this.updateTimelineClips();
                
                botReply(`Video trimmed from ${this.formatTime(this.trimStart)} to ${this.formatTime(this.trimEnd)}`);
            }
            
            // Close the panel
            if (this.trimPanel) {
                this.trimPanel.remove();
                this.trimPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.trimPanel) {
                this.trimPanel.remove();
                this.trimPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.trimPanel.appendChild(title);
        this.trimPanel.appendChild(startControl);
        this.trimPanel.appendChild(endControl);
        this.trimPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.trimPanel);
    }
    
    /**
     * Zoom in timeline
     */
    zoomIn() {
        this.zoomLevel = Math.min(5, this.zoomLevel + 0.5);
        this.updateTimelineZoom();
        botReply(`Timeline zoom: ${this.zoomLevel}x`);
    }
    
    /**
     * Zoom out timeline
     */
    zoomOut() {
        this.zoomLevel = Math.max(0.5, this.zoomLevel - 0.5);
        this.updateTimelineZoom();
        botReply(`Timeline zoom: ${this.zoomLevel}x`);
    }
    
    /**
     * Fit timeline to screen
     */
    fitToScreen() {
        this.zoomLevel = 1;
        this.updateTimelineZoom();
        botReply('Timeline zoom: 1x (Fit to screen)');
    }
    
    /**
     * Update timeline zoom
     */
    updateTimelineZoom() {
        const timelineElements = this.timeline.querySelectorAll('div');
        timelineElements.forEach(element => {
            if (element.style.transform) {
                element.style.transform = `scaleX(${this.zoomLevel})`;
            }
        });
    }
    
    /**
     * Select a tool
     */
    selectTool(tool) {
        this.selectedTool = tool;
        this.closeAllPanels();
        botReply(`Selected tool: ${tool}`);
    }
    
    /**
     * Cut tool - Split clip at current time
     */
    cutTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Find the video track
        const videoTrack = this.tracks.find(t => t.type === 'video');
        if (!videoTrack || videoTrack.clips.length === 0) {
            this.showError('No video clip found');
            return;
        }
        
        // Get the main video clip
        const clip = videoTrack.clips[0];
        
        // Check if current time is within clip bounds
        if (this.currentTime <= clip.start || this.currentTime >= clip.end) {
            this.showError('Position cursor within the clip to cut');
            return;
        }
        
        // Create a new clip from the current time to the end of the original clip
        const newClip = {
            id: `clip-${Date.now()}`,
            name: `${clip.name} (part 2)`,
            url: clip.url,
            start: this.currentTime,
            end: clip.end,
            track: clip.track,
            type: 'video'
        };
        
        // Update the original clip to end at the current time
        clip.end = this.currentTime;
        clip.name = `${clip.name} (part 1)`;
        
        // Add the new clip to the tracks and clips array
        videoTrack.clips.push(newClip);
        this.clips.push(newClip);
        
        // Update the UI
        this.updateTimelineClips();
        
        botReply(`Clip cut at ${this.formatTime(this.currentTime)}`);
    }
    
    /**
     * Add text overlay
     */
    addText() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create text panel
        this.textPanel = document.createElement('div');
        this.textPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Text';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const textInput = document.createElement('input');
        textInput.type = 'text';
        textInput.placeholder = 'Enter text here';
        textInput.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const fontSizeControl = document.createElement('div');
        fontSizeControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const fontSizeLabel = document.createElement('label');
        fontSizeLabel.textContent = 'Font Size:';
        fontSizeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const fontSizeSlider = document.createElement('input');
        fontSizeSlider.type = 'range';
        fontSizeSlider.min = '12';
        fontSizeSlider.max = '72';
        fontSizeSlider.value = '24';
        fontSizeSlider.style.cssText = `
            width: 100%;
        `;
        
        const fontSizeValue = document.createElement('div');
        fontSizeValue.textContent = '24px';
        fontSizeValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        fontSizeSlider.addEventListener('input', (e) => {
            fontSizeValue.textContent = `${e.target.value}px`;
        });
        
        fontSizeControl.appendChild(fontSizeLabel);
        fontSizeControl.appendChild(fontSizeSlider);
        fontSizeControl.appendChild(fontSizeValue);
        
        const colorControl = document.createElement('div');
        colorControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const colorLabel = document.createElement('label');
        colorLabel.textContent = 'Text Color:';
        colorLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.value = '#ffffff';
        colorPicker.style.cssText = `
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 4px;
        `;
        
        colorControl.appendChild(colorLabel);
        colorControl.appendChild(colorPicker);
        
        const positionControl = document.createElement('div');
        positionControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const positionLabel = document.createElement('label');
        positionLabel.textContent = 'Position:';
        positionLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const positionSelect = document.createElement('select');
        positionSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const positions = [
            { value: 'top-left', text: 'Top Left' },
            { value: 'top-center', text: 'Top Center' },
            { value: 'top-right', text: 'Top Right' },
            { value: 'center-left', text: 'Center Left' },
            { value: 'center', text: 'Center' },
            { value: 'center-right', text: 'Center Right' },
            { value: 'bottom-left', text: 'Bottom Left' },
            { value: 'bottom-center', text: 'Bottom Center' },
            { value: 'bottom-right', text: 'Bottom Right' }
        ];
        
        positions.forEach(pos => {
            const option = document.createElement('option');
            option.value = pos.value;
            option.textContent = pos.text;
            positionSelect.appendChild(option);
        });
        
        positionControl.appendChild(positionLabel);
        positionControl.appendChild(positionSelect);
        
        const durationControl = document.createElement('div');
        durationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const durationLabel = document.createElement('label');
        durationLabel.textContent = 'Duration (seconds):';
        durationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const durationInput = document.createElement('input');
        durationInput.type = 'number';
        durationInput.min = '1';
        durationInput.max = '60';
        durationInput.value = '5';
        durationInput.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        durationControl.appendChild(durationLabel);
        durationControl.appendChild(durationInput);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const addButton = document.createElement('button');
        addButton.textContent = 'Add Text';
        addButton.style.cssText = this.getButtonStyle('btn-tool-export');
        addButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        addButton.addEventListener('click', () => {
            const text = textInput.value.trim();
            if (text) {
                // Get position values
                let positionX = 0.5;
                let positionY = 0.5;
                
                switch (positionSelect.value) {
                    case 'top-left':
                        positionX = 0.1;
                        positionY = 0.1;
                        break;
                    case 'top-center':
                        positionX = 0.5;
                        positionY = 0.1;
                        break;
                    case 'top-right':
                        positionX = 0.9;
                        positionY = 0.1;
                        break;
                    case 'center-left':
                        positionX = 0.1;
                        positionY = 0.5;
                        break;
                    case 'center':
                        positionX = 0.5;
                        positionY = 0.5;
                        break;
                    case 'center-right':
                        positionX = 0.9;
                        positionY = 0.5;
                        break;
                    case 'bottom-left':
                        positionX = 0.1;
                        positionY = 0.9;
                        break;
                    case 'bottom-center':
                        positionX = 0.5;
                        positionY = 0.9;
                        break;
                    case 'bottom-right':
                        positionX = 0.9;
                        positionY = 0.9;
                        break;
                }
                
                // Create text overlay
                const textOverlay = {
                    id: `text-${Date.now()}`,
                    content: text,
                    fontSize: parseInt(fontSizeSlider.value),
                    color: colorPicker.value,
                    positionX: positionX,
                    positionY: positionY,
                    startTime: this.currentTime,
                    endTime: this.currentTime + parseInt(durationInput.value)
                };
                
                this.textOverlays.push(textOverlay);
                
                // Create a text track if it doesn't exist
                let textTrack = this.tracks.find(t => t.type === 'text');
                if (!textTrack) {
                    textTrack = this.createTrack('Text', 'text');
                }
                
                // Add text clip to timeline
                const textClip = {
                    id: `clip-${Date.now()}`,
                    name: `Text: ${text}`,
                    url: null,
                    start: this.currentTime,
                    end: this.currentTime + parseInt(durationInput.value),
                    track: textTrack.id,
                    type: 'text',
                    textOverlay: textOverlay
                };
                
                textTrack.clips.push(textClip);
                this.clips.push(textClip);
                
                // Update the UI
                this.updateTimelineClips();
                
                botReply(`Added text: "${text}" from ${this.formatTime(this.currentTime)} to ${this.formatTime(this.currentTime + parseInt(durationInput.value))}`);
                
                // Close the panel
                if (this.textPanel) {
                    this.textPanel.remove();
                    this.textPanel = null;
                }
            } else {
                this.showError('Please enter some text');
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.textPanel) {
                this.textPanel.remove();
                this.textPanel = null;
            }
        });
        
        buttonsContainer.appendChild(addButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.textPanel.appendChild(title);
        this.textPanel.appendChild(textInput);
        this.textPanel.appendChild(fontSizeControl);
        this.textPanel.appendChild(colorControl);
        this.textPanel.appendChild(positionControl);
        this.textPanel.appendChild(durationControl);
        this.textPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.textPanel);
    }
    
    /**
     * Add sticker overlay
     */
    addSticker() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create sticker panel
        const stickerPanel = document.createElement('div');
        stickerPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 400px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Sticker';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Create sticker grid
        const stickerGrid = document.createElement('div');
        stickerGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Define sticker emojis
        const stickerEmojis = [
            '😀', '😂', '😍', '🤩', '😎', '🥳', '😡', '😭',
            '❤️', '💔', '🔥', '⭐', '👍', '👎', '👏', '🙏',
            '🎉', '🎈', '🎁', '🏆', '💯', '✨', '💫', '💥',
            '🌟', '🌈', '☀️', '🌙', '⛅', '🌧️', '⛈️', '❄️'
        ];
        
        // Create sticker buttons
        stickerEmojis.forEach(emoji => {
            const stickerBtn = document.createElement('button');
            stickerBtn.textContent = emoji;
            stickerBtn.style.cssText = `
                font-size: 24px;
                padding: 10px;
                background-color: #444;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
            `;
            
            stickerBtn.addEventListener('mouseover', () => {
                stickerBtn.style.backgroundColor = '#555';
                stickerBtn.style.transform = 'scale(1.1)';
            });
            
            stickerBtn.addEventListener('mouseout', () => {
                stickerBtn.style.backgroundColor = '#444';
                stickerBtn.style.transform = 'scale(1)';
            });
            
            stickerBtn.addEventListener('click', () => {
                this.addStickerToVideo(emoji);
                if (stickerPanel) {
                    stickerPanel.remove();
                }
            });
            
            stickerGrid.appendChild(stickerBtn);
        });
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-tool');
        closeButton.style.width = '100%';
        
        closeButton.addEventListener('click', () => {
            if (stickerPanel) {
                stickerPanel.remove();
            }
        });
        
        stickerPanel.appendChild(title);
        stickerPanel.appendChild(stickerGrid);
        stickerPanel.appendChild(closeButton);
        
        this.gameContainer.appendChild(stickerPanel);
    }
    
    /**
     * Add sticker to video
     */
    addStickerToVideo(emoji) {
        // Create sticker overlay
        const sticker = {
            id: `sticker-${Date.now()}`,
            emoji: emoji,
            size: 60,
            positionX: 0.5,
            positionY: 0.5,
            startTime: this.currentTime,
            endTime: this.currentTime + 5 // Default 5 seconds
        };
        
        this.stickers.push(sticker);
        
        // Create a text track for stickers if it doesn't exist
        let stickerTrack = this.tracks.find(t => t.type === 'text');
        if (!stickerTrack) {
            stickerTrack = this.createTrack('Text', 'text');
        }
        
        // Add sticker clip to timeline
        const stickerClip = {
            id: `clip-${Date.now()}`,
            name: `Sticker: ${emoji}`,
            url: null,
            start: this.currentTime,
            end: this.currentTime + 5,
            track: stickerTrack.id,
            type: 'sticker',
            sticker: sticker
        };
        
        stickerTrack.clips.push(stickerClip);
        this.clips.push(stickerClip);
        
        // Update the UI
        this.updateTimelineClips();
        
        botReply(`Added sticker: ${emoji} from ${this.formatTime(this.currentTime)} to ${this.formatTime(this.currentTime + 5)}`);
    }
    
    /**
     * Add transition between clips
     */
    addTransition() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create transition panel
        this.transitionPanel = document.createElement('div');
        this.transitionPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Transition';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const transitionTypes = document.createElement('select');
        transitionTypes.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const options = [
            { value: 'fade', text: 'Fade' },
            { value: 'slide', text: 'Slide' },
            { value: 'dissolve', text: 'Dissolve' },
            { value: 'wipe', text: 'Wipe' },
            { value: 'zoom', text: 'Zoom' },
            { value: 'spin', text: 'Spin' }
        ];
        
        options.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value;
            optionElement.textContent = option.text;
            transitionTypes.appendChild(optionElement);
        });
        
        const durationControl = document.createElement('div');
        durationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const durationLabel = document.createElement('label');
        durationLabel.textContent = 'Duration (seconds):';
        durationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const durationSlider = document.createElement('input');
        durationSlider.type = 'range';
        durationSlider.min = '0.5';
        durationSlider.max = '3';
        durationSlider.step = '0.5';
        durationSlider.value = '1';
        durationSlider.style.cssText = `
            width: 100%;
        `;
        
        const durationValue = document.createElement('div');
        durationValue.textContent = '1s';
        durationValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        durationSlider.addEventListener('input', (e) => {
            durationValue.textContent = `${e.target.value}s`;
        });
        
        durationControl.appendChild(durationLabel);
        durationControl.appendChild(durationSlider);
        durationControl.appendChild(durationValue);
        
        const directionControl = document.createElement('div');
        directionControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const directionLabel = document.createElement('label');
        directionLabel.textContent = 'Direction:';
        directionLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const directionSelect = document.createElement('select');
        directionSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const directions = [
            { value: 'left', text: 'Left to Right' },
            { value: 'right', text: 'Right to Left' },
            { value: 'up', text: 'Bottom to Top' },
            { value: 'down', text: 'Top to Bottom' }
        ];
        
        directions.forEach(dir => {
            const option = document.createElement('option');
            option.value = dir.value;
            option.textContent = dir.text;
            directionSelect.appendChild(option);
        });
        
        directionControl.appendChild(directionLabel);
        directionControl.appendChild(directionSelect);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const addButton = document.createElement('button');
        addButton.textContent = 'Add Transition';
        addButton.style.cssText = this.getButtonStyle('btn-tool-export');
        addButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        addButton.addEventListener('click', () => {
            const transitionType = transitionTypes.value;
            const duration = parseFloat(durationSlider.value);
            const direction = directionSelect.value;
            
            // Create transition
            const transition = {
                id: `transition-${Date.now()}`,
                type: transitionType,
                duration: duration,
                direction: direction,
                startTime: this.currentTime
            };
            
            this.transitions.push(transition);
            
            // Create a transition track if it doesn't exist
            let transitionTrack = this.tracks.find(t => t.type === 'transition');
            if (!transitionTrack) {
                transitionTrack = this.createTrack('Transition', 'transition');
            }
            
            // Add transition clip to timeline
            const transitionClip = {
                id: `clip-${Date.now()}`,
                name: `Transition: ${transitionType}`,
                url: null,
                start: this.currentTime,
                end: this.currentTime + duration,
                track: transitionTrack.id,
                type: 'transition',
                transition: transition
            };
            
            transitionTrack.clips.push(transitionClip);
            this.clips.push(transitionClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply(`Added ${transitionType} transition with duration ${duration}s`);
            
            // Close the panel
            if (this.transitionPanel) {
                this.transitionPanel.remove();
                this.transitionPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.transitionPanel) {
                this.transitionPanel.remove();
                this.transitionPanel = null;
            }
        });
        
        buttonsContainer.appendChild(addButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.transitionPanel.appendChild(title);
        this.transitionPanel.appendChild(transitionTypes);
        this.transitionPanel.appendChild(durationControl);
        this.transitionPanel.appendChild(directionControl);
        this.transitionPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.transitionPanel);
    }
    
    /**
     * Add effect to video
     */
    addEffect() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create effects panel
        this.effectsPanel = document.createElement('div');
        this.effectsPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Effect';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const effectTypes = document.createElement('select');
        effectTypes.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const effects = [
            { value: 'brightness', text: 'Brightness' },
            { value: 'contrast', text: 'Contrast' },
            { value: 'saturation', text: 'Saturation' },
            { value: 'blur', text: 'Blur' },
            { value: 'grayscale', text: 'Grayscale' },
            { value: 'sepia', text: 'Sepia' },
            { value: 'invert', text: 'Invert' }
        ];
        
        effects.forEach(effect => {
            const optionElement = document.createElement('option');
            optionElement.value = effect.value;
            optionElement.textContent = effect.text;
            effectTypes.appendChild(optionElement);
        });
        
        const intensityControl = document.createElement('div');
        intensityControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const intensityLabel = document.createElement('label');
        intensityLabel.textContent = 'Intensity:';
        intensityLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const intensitySlider = document.createElement('input');
        intensitySlider.type = 'range';
        intensitySlider.min = '0';
        intensitySlider.max = '100';
        intensitySlider.value = '50';
        intensitySlider.style.cssText = `
            width: 100%;
        `;
        
        const intensityValue = document.createElement('div');
        intensityValue.textContent = '50%';
        intensityValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        intensitySlider.addEventListener('input', (e) => {
            intensityValue.textContent = `${e.target.value}%`;
        });
        
        intensityControl.appendChild(intensityLabel);
        intensityControl.appendChild(intensitySlider);
        intensityControl.appendChild(intensityValue);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const addButton = document.createElement('button');
        addButton.textContent = 'Add Effect';
        addButton.style.cssText = this.getButtonStyle('btn-tool-export');
        addButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        addButton.addEventListener('click', () => {
            const effectType = effectTypes.value;
            const intensity = parseInt(intensitySlider.value);
            
            // Add effect to global effects array
            const effect = {
                id: `effect-${Date.now()}`,
                type: effectType,
                intensity: intensity
            };
            
            this.effects.push(effect);
            
            // Create an effects track if it doesn't exist
            let effectsTrack = this.tracks.find(t => t.type === 'effects');
            if (!effectsTrack) {
                effectsTrack = this.createTrack('Effects', 'effects');
            }
            
            // Add effect clip to timeline
            const effectClip = {
                id: `clip-${Date.now()}`,
                name: `Effect: ${effectType}`,
                url: null,
                start: 0,
                end: this.videoDuration,
                track: effectsTrack.id,
                type: 'effect',
                effect: effect
            };
            
            effectsTrack.clips.push(effectClip);
            this.clips.push(effectClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            // Render frame with new effect
            this.renderFrame();
            
            botReply(`Added ${effectType} effect with intensity ${intensity}%`);
            
            // Close the panel
            if (this.effectsPanel) {
                this.effectsPanel.remove();
                this.effectsPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.effectsPanel) {
                this.effectsPanel.remove();
                this.effectsPanel = null;
            }
        });
        
        buttonsContainer.appendChild(addButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.effectsPanel.appendChild(title);
        this.effectsPanel.appendChild(effectTypes);
        this.effectsPanel.appendChild(intensityControl);
        this.effectsPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.effectsPanel);
    }
    
    /**
     * Add filter to video
     */
    addFilter() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create filter panel
        const filterPanel = document.createElement('div');
        filterPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Filter';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Create filter presets grid
        const filterGrid = document.createElement('div');
        filterGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Define filter presets
        const filterPresets = [
            { name: 'Normal', value: 'none' },
            { name: 'Vintage', value: 'sepia(100%) contrast(120%) brightness(90%)' },
            { name: 'Cold', value: 'hue-rotate(180deg) saturate(120%)' },
            { name: 'Warm', value: 'sepia(50%) saturate(120%) hue-rotate(-10deg)' },
            { name: 'Dramatic', value: 'contrast(150%) brightness(90%) grayscale(50%)' },
            { name: 'Noir', value: 'grayscale(100%) contrast(150%)' }
        ];
        
        // Create filter buttons
        filterPresets.forEach(filter => {
            const filterBtn = document.createElement('button');
            filterBtn.textContent = filter.name;
            filterBtn.style.cssText = `
                padding: 10px;
                background-color: #444;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                color: white;
                font-size: 12px;
            `;
            
            filterBtn.addEventListener('mouseover', () => {
                filterBtn.style.backgroundColor = '#555';
                filterBtn.style.transform = 'scale(1.05)';
            });
            
            filterBtn.addEventListener('mouseout', () => {
                filterBtn.style.backgroundColor = '#444';
                filterBtn.style.transform = 'scale(1)';
            });
            
            filterBtn.addEventListener('click', () => {
                // Apply filter to canvas
                this.canvas.style.filter = filter.value;
                
                // Add filter to effects array
                const effect = {
                    id: `effect-${Date.now()}`,
                    type: 'filter',
                    value: filter.value,
                    name: filter.name
                };
                
                this.effects.push(effect);
                
                // Create an effects track if it doesn't exist
                let effectsTrack = this.tracks.find(t => t.type === 'effects');
                if (!effectsTrack) {
                    effectsTrack = this.createTrack('Effects', 'effects');
                }
                
                // Add effect clip to timeline
                const effectClip = {
                    id: `clip-${Date.now()}`,
                    name: `Filter: ${filter.name}`,
                    url: null,
                    start: 0,
                    end: this.videoDuration,
                    track: effectsTrack.id,
                    type: 'filter',
                    effect: effect
                };
                
                effectsTrack.clips.push(effectClip);
                this.clips.push(effectClip);
                
                // Update the UI
                this.updateTimelineClips();
                
                botReply(`Applied ${filter.name} filter`);
                
                // Close the panel
                if (filterPanel) {
                    filterPanel.remove();
                }
            });
            
            filterGrid.appendChild(filterBtn);
        });
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-tool');
        closeButton.style.width = '100%';
        
        closeButton.addEventListener('click', () => {
            if (filterPanel) {
                filterPanel.remove();
            }
        });
        
        filterPanel.appendChild(title);
        filterPanel.appendChild(filterGrid);
        filterPanel.appendChild(closeButton);
        
        this.gameContainer.appendChild(filterPanel);
    }
    
    /**
     * Open audio tool
     */
    openAudioTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create audio panel
        this.audioPanel = document.createElement('div');
        this.audioPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Audio Tools';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Volume control
        const volumeControl = document.createElement('div');
        volumeControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const volumeLabel = document.createElement('label');
        volumeLabel.textContent = 'Volume:';
        volumeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const volumeSlider = document.createElement('input');
        volumeSlider.type = 'range';
        volumeSlider.min = '0';
        volumeSlider.max = '1';
        volumeSlider.step = '0.1';
        volumeSlider.value = this.volume.toString();
        volumeSlider.style.cssText = `
            width: 100%;
        `;
        
        const volumeValue = document.createElement('div');
        volumeValue.textContent = `${Math.round(this.volume * 100)}%`;
        volumeValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        volumeSlider.addEventListener('input', (e) => {
            this.volume = parseFloat(e.target.value);
            this.videoPreview.volume = this.volume;
            volumeValue.textContent = `${Math.round(this.volume * 100)}%`;
        });
        
        volumeControl.appendChild(volumeLabel);
        volumeControl.appendChild(volumeSlider);
        volumeControl.appendChild(volumeValue);
        
        // Fade in/out control
        const fadeControl = document.createElement('div');
        fadeControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const fadeLabel = document.createElement('label');
        fadeLabel.textContent = 'Fade Duration:';
        fadeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const fadeSlider = document.createElement('input');
        fadeSlider.type = 'range';
        fadeSlider.min = '0';
        fadeSlider.max = '5';
        fadeSlider.step = '0.5';
        fadeSlider.value = '0';
        fadeSlider.style.cssText = `
            width: 100%;
        `;
        
        const fadeValue = document.createElement('div');
        fadeValue.textContent = '0s';
        fadeValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        fadeSlider.addEventListener('input', (e) => {
            fadeValue.textContent = `${e.target.value}s`;
        });
        
        fadeControl.appendChild(fadeLabel);
        fadeControl.appendChild(fadeSlider);
        fadeControl.appendChild(fadeValue);
        
        // Audio effects
        const audioEffectsLabel = document.createElement('label');
        audioEffectsLabel.textContent = 'Audio Effects:';
        audioEffectsLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const audioEffectsSelect = document.createElement('select');
        audioEffectsSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const audioEffects = [
            { value: 'none', text: 'None' },
            { value: 'echo', text: 'Echo' },
            { value: 'reverb', text: 'Reverb' },
            { value: 'pitch', text: 'Pitch Shift' },
            { value: 'robot', text: 'Robot Voice' }
        ];
        
        audioEffects.forEach(effect => {
            const option = document.createElement('option');
            option.value = effect.value;
            option.textContent = effect.text;
            audioEffectsSelect.appendChild(option);
        });
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const fadeDuration = parseFloat(fadeSlider.value);
            const audioEffect = audioEffectsSelect.value;
            
            if (fadeDuration > 0) {
                botReply(`Applied ${fadeDuration}s fade to audio`);
            }
            
            if (audioEffect !== 'none') {
                botReply(`Applied ${audioEffect} audio effect`);
            }
            
            // Close the panel
            if (this.audioPanel) {
                this.audioPanel.remove();
                this.audioPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.audioPanel) {
                this.audioPanel.remove();
                this.audioPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.audioPanel.appendChild(title);
        this.audioPanel.appendChild(volumeControl);
        this.audioPanel.appendChild(fadeControl);
        this.audioPanel.appendChild(audioEffectsLabel);
        this.audioPanel.appendChild(audioEffectsSelect);
        this.audioPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.audioPanel);
    }
    
    /**
     * Open speed tool
     */
    openSpeedTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create speed panel
        this.speedPanel = document.createElement('div');
        this.speedPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Speed Control';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Speed presets
        const speedPresetsLabel = document.createElement('label');
        speedPresetsLabel.textContent = 'Speed Presets:';
        speedPresetsLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
        `;
        
        const speedPresetsContainer = document.createElement('div');
        speedPresetsContainer.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        `;
        
        const speedPresets = [
            { label: '0.25x', value: 0.25 },
            { label: '0.5x', value: 0.5 },
            { label: '1x', value: 1 },
            { label: '1.5x', value: 1.5 },
            { label: '2x', value: 2 }
        ];
        
        speedPresets.forEach(preset => {
            const presetBtn = document.createElement('button');
            presetBtn.textContent = preset.label;
            presetBtn.style.cssText = `
                padding: 8px;
                background-color: #444;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
                color: white;
                font-size: 12px;
                width: 60px;
            `;
            
            presetBtn.addEventListener('mouseover', () => {
                presetBtn.style.backgroundColor = '#555';
            });
            
            presetBtn.addEventListener('mouseout', () => {
                presetBtn.style.backgroundColor = '#444';
            });
            
            presetBtn.addEventListener('click', () => {
                this.playbackRate = preset.value;
                this.videoPreview.playbackRate = this.playbackRate;
                customSpeedSlider.value = preset.value.toString();
                customSpeedValue.textContent = `${preset.value}x`;
            });
            
            speedPresetsContainer.appendChild(presetBtn);
        });
        
        // Custom speed control
        const customSpeedControl = document.createElement('div');
        customSpeedControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const customSpeedLabel = document.createElement('label');
        customSpeedLabel.textContent = 'Custom Speed:';
        customSpeedLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const customSpeedSlider = document.createElement('input');
        customSpeedSlider.type = 'range';
        customSpeedSlider.min = '0.25';
        customSpeedSlider.max = '4';
        customSpeedSlider.step = '0.25';
        customSpeedSlider.value = this.playbackRate.toString();
        customSpeedSlider.style.cssText = `
            width: 100%;
        `;
        
        const customSpeedValue = document.createElement('div');
        customSpeedValue.textContent = `${this.playbackRate}x`;
        customSpeedValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        customSpeedSlider.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            this.playbackRate = speed;
            this.videoPreview.playbackRate = speed;
            customSpeedValue.textContent = `${speed}x`;
        });
        
        customSpeedControl.appendChild(customSpeedLabel);
        customSpeedControl.appendChild(customSpeedSlider);
        customSpeedControl.appendChild(customSpeedValue);
        
        // Maintain pitch control
        const maintainPitchControl = document.createElement('div');
        maintainPitchControl.style.cssText = `
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        `;
        
        const maintainPitchCheckbox = document.createElement('input');
        maintainPitchCheckbox.type = 'checkbox';
        maintainPitchCheckbox.id = 'maintain-pitch';
        maintainPitchCheckbox.style.cssText = `
            margin-right: 10px;
        `;
        
        const maintainPitchLabel = document.createElement('label');
        maintainPitchLabel.htmlFor = 'maintain-pitch';
        maintainPitchLabel.textContent = 'Maintain Audio Pitch';
        
        maintainPitchControl.appendChild(maintainPitchCheckbox);
        maintainPitchControl.appendChild(maintainPitchLabel);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            botReply(`Applied ${this.playbackRate}x speed to video`);
            
            // Close the panel
            if (this.speedPanel) {
                this.speedPanel.remove();
                this.speedPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.speedPanel) {
                this.speedPanel.remove();
                this.speedPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.speedPanel.appendChild(title);
        this.speedPanel.appendChild(speedPresetsLabel);
        this.speedPanel.appendChild(speedPresetsContainer);
        this.speedPanel.appendChild(customSpeedControl);
        this.speedPanel.appendChild(maintainPitchControl);
        this.speedPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.speedPanel);
    }
    
    /**
     * Open animation tool
     */
    openAnimationTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create animation panel
        this.animationPanel = document.createElement('div');
        this.animationPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Animation';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const animationTypesLabel = document.createElement('label');
        animationTypesLabel.textContent = 'Animation Type:';
        animationTypesLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const animationTypes = document.createElement('select');
        animationTypes.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const animations = [
            { value: 'fade-in', text: 'Fade In' },
            { value: 'fade-out', text: 'Fade Out' },
            { value: 'slide-in-left', text: 'Slide In Left' },
            { value: 'slide-in-right', text: 'Slide In Right' },
            { value: 'slide-in-top', text: 'Slide In Top' },
            { value: 'slide-in-bottom', text: 'Slide In Bottom' },
            { value: 'zoom-in', text: 'Zoom In' },
            { value: 'zoom-out', text: 'Zoom Out' },
            { value: 'rotate', text: 'Rotate' },
            { value: 'bounce', text: 'Bounce' }
        ];
        
        animations.forEach(animation => {
            const option = document.createElement('option');
            option.value = animation.value;
            option.textContent = animation.text;
            animationTypes.appendChild(option);
        });
        
        // Duration control
        const durationControl = document.createElement('div');
        durationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const durationLabel = document.createElement('label');
        durationLabel.textContent = 'Duration (seconds):';
        durationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const durationInput = document.createElement('input');
        durationInput.type = 'number';
        durationInput.min = '0.5';
        durationInput.max = '10';
        durationInput.step = '0.5';
        durationInput.value = '2';
        durationInput.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        durationControl.appendChild(durationLabel);
        durationControl.appendChild(durationInput);
        
        // Target selection
        const targetLabel = document.createElement('label');
        targetLabel.textContent = 'Apply To:';
        targetLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const targetSelect = document.createElement('select');
        targetSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const targets = [
            { value: 'video', text: 'Video' },
            { value: 'text', text: 'Text Overlays' },
            { value: 'stickers', text: 'Stickers' }
        ];
        
        targets.forEach(target => {
            const option = document.createElement('option');
            option.value = target.value;
            option.textContent = target.text;
            targetSelect.appendChild(option);
        });
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const animationType = animationTypes.value;
            const duration = parseFloat(durationInput.value);
            const target = targetSelect.value;
            
            // Create animation
            const animation = {
                id: `animation-${Date.now()}`,
                type: animationType,
                duration: duration,
                target: target,
                startTime: this.currentTime
            };
            
            this.animations.push(animation);
            
            // Create an animation track if it doesn't exist
            let animationTrack = this.tracks.find(t => t.type === 'animation');
            if (!animationTrack) {
                animationTrack = this.createTrack('Animation', 'animation');
            }
            
            // Add animation clip to timeline
            const animationClip = {
                id: `clip-${Date.now()}`,
                name: `Animation: ${animationType}`,
                url: null,
                start: this.currentTime,
                end: this.currentTime + duration,
                track: animationTrack.id,
                type: 'animation',
                animation: animation
            };
            
            animationTrack.clips.push(animationClip);
            this.clips.push(animationClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply(`Added ${animationType} animation to ${target} for ${duration}s`);
            
            // Close the panel
            if (this.animationPanel) {
                this.animationPanel.remove();
                this.animationPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.animationPanel) {
                this.animationPanel.remove();
                this.animationPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.animationPanel.appendChild(title);
        this.animationPanel.appendChild(animationTypesLabel);
        this.animationPanel.appendChild(animationTypes);
        this.animationPanel.appendChild(durationControl);
        this.animationPanel.appendChild(targetLabel);
        this.animationPanel.appendChild(targetSelect);
        this.animationPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.animationPanel);
    }
    
    /**
     * Open keyframe tool
     */
    openKeyframeTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create keyframe panel
        this.keyframePanel = document.createElement('div');
        this.keyframePanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Keyframe Animation';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const infoText = document.createElement('div');
        infoText.textContent = 'Add keyframes to animate properties over time';
        infoText.style.cssText = `
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            color: #aaa;
        `;
        
        // Property selection
        const propertyLabel = document.createElement('label');
        propertyLabel.textContent = 'Property to Animate:';
        propertyLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const propertySelect = document.createElement('select');
        propertySelect.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const properties = [
            { value: 'position', text: 'Position' },
            { value: 'scale', text: 'Scale' },
            { value: 'rotation', text: 'Rotation' },
            { value: 'opacity', text: 'Opacity' },
            { value: 'color', text: 'Color' }
        ];
        
        properties.forEach(property => {
            const option = document.createElement('option');
            option.value = property.value;
            option.textContent = property.text;
            propertySelect.appendChild(option);
        });
        
        // Value control
        const valueControl = document.createElement('div');
        valueControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const valueLabel = document.createElement('label');
        valueLabel.textContent = 'Value:';
        valueLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const valueInput = document.createElement('input');
        valueInput.type = 'text';
        valueInput.placeholder = 'Enter value';
        valueInput.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        valueControl.appendChild(valueLabel);
        valueControl.appendChild(valueInput);
        
        // Easing selection
        const easingLabel = document.createElement('label');
        easingLabel.textContent = 'Easing:';
        easingLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const easingSelect = document.createElement('select');
        easingSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const easings = [
            { value: 'linear', text: 'Linear' },
            { value: 'ease-in', text: 'Ease In' },
            { value: 'ease-out', text: 'Ease Out' },
            { value: 'ease-in-out', text: 'Ease In Out' },
            { value: 'bounce', text: 'Bounce' },
            { value: 'elastic', text: 'Elastic' }
        ];
        
        easings.forEach(easing => {
            const option = document.createElement('option');
            option.value = easing.value;
            option.textContent = easing.text;
            easingSelect.appendChild(option);
        });
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const addButton = document.createElement('button');
        addButton.textContent = 'Add Keyframe';
        addButton.style.cssText = this.getButtonStyle('btn-tool-export');
        addButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        addButton.addEventListener('click', () => {
            const property = propertySelect.value;
            const value = valueInput.value.trim();
            const easing = easingSelect.value;
            
            if (!value) {
                this.showError('Please enter a value');
                return;
            }
            
            // Create keyframe
            const keyframe = {
                id: `keyframe-${Date.now()}`,
                property: property,
                value: value,
                time: this.currentTime,
                easing: easing
            };
            
            this.keyframes.push(keyframe);
            
            // Create a keyframe track if it doesn't exist
            let keyframeTrack = this.tracks.find(t => t.type === 'keyframe');
            if (!keyframeTrack) {
                keyframeTrack = this.createTrack('Keyframe', 'keyframe');
            }
            
            // Add keyframe clip to timeline
            const keyframeClip = {
                id: `clip-${Date.now()}`,
                name: `Keyframe: ${property}`,
                url: null,
                start: this.currentTime,
                end: this.currentTime,
                track: keyframeTrack.id,
                type: 'keyframe',
                keyframe: keyframe
            };
            
            keyframeTrack.clips.push(keyframeClip);
            this.clips.push(keyframeClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply(`Added keyframe for ${property} at ${this.formatTime(this.currentTime)}`);
            
            // Close the panel
            if (this.keyframePanel) {
                this.keyframePanel.remove();
                this.keyframePanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.keyframePanel) {
                this.keyframePanel.remove();
                this.keyframePanel = null;
            }
        });
        
        buttonsContainer.appendChild(addButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.keyframePanel.appendChild(title);
        this.keyframePanel.appendChild(infoText);
        this.keyframePanel.appendChild(propertyLabel);
        this.keyframePanel.appendChild(propertySelect);
        this.keyframePanel.appendChild(valueControl);
        this.keyframePanel.appendChild(easingLabel);
        this.keyframePanel.appendChild(easingSelect);
        this.keyframePanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.keyframePanel);
    }
    
    /**
     * Open chroma key tool
     */
    openChromaKeyTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create chroma key panel
        this.chromaKeyPanel = document.createElement('div');
        this.chromaKeyPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Chroma Key (Green Screen)';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const infoText = document.createElement('div');
        infoText.textContent = 'Remove a specific color from the video';
        infoText.style.cssText = `
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            color: #aaa;
        `;
        
        // tion
        const colorLabel = document.createElement('label');
        colorLabel.textContent = 'Color to Remove:';
        colorLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.value = '#00ff00'; // Default to green
        colorPicker.style.cssText = `
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 4px;
            margin-bottom: 15px;
        `;
        
        // Tolerance control
        const toleranceControl = document.createElement('div');
        toleranceControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const toleranceLabel = document.createElement('label');
        toleranceLabel.textContent = 'Tolerance:';
        toleranceLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const toleranceSlider = document.createElement('input');
        toleranceSlider.type = 'range';
        toleranceSlider.min = '0';
        toleranceSlider.max = '100';
        toleranceSlider.value = '30';
        toleranceSlider.style.cssText = `
            width: 100%;
        `;
        
        const toleranceValue = document.createElement('div');
        toleranceValue.textContent = '30%';
        toleranceValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        toleranceSlider.addEventListener('input', (e) => {
            toleranceValue.textContent = `${e.target.value}%`;
        });
        
        toleranceControl.appendChild(toleranceLabel);
        toleranceControl.appendChild(toleranceSlider);
        toleranceControl.appendChild(toleranceValue);
        
        // Edge feather control
        const featherControl = document.createElement('div');
        featherControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const featherLabel = document.createElement('label');
        featherLabel.textContent = 'Edge Feather:';
        featherLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const featherSlider = document.createElement('input');
        featherSlider.type = 'range';
        featherSlider.min = '0';
        featherSlider.max = '20';
        featherSlider.value = '5';
        featherSlider.style.cssText = `
            width: 100%;
        `;
        
        const featherValue = document.createElement('div');
        featherValue.textContent = '5px';
        featherValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        featherSlider.addEventListener('input', (e) => {
            featherValue.textContent = `${e.target.value}px`;
        });
        
        featherControl.appendChild(featherLabel);
        featherControl.appendChild(featherSlider);
        featherControl.appendChild(featherValue);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const color = colorPicker.value;
            const tolerance = parseInt(toleranceSlider.value);
            const feather = parseInt(featherSlider.value);
            
            // Add chroma key effect
            const effect = {
                id: `effect-${Date.now()}`,
                type: 'chromaKey',
                color: color,
                tolerance: tolerance,
                feather: feather
            };
            
            this.effects.push(effect);
            
            // Create an effects track if it doesn't exist
            let effectsTrack = this.tracks.find(t => t.type === 'effects');
            if (!effectsTrack) {
                effectsTrack = this.createTrack('Effects', 'effects');
            }
            
            // Add effect clip to timeline
            const effectClip = {
                id: `clip-${Date.now()}`,
                name: 'Chroma Key',
                url: null,
                start: 0,
                end: this.videoDuration,
                track: effectsTrack.id,
                type: 'effect',
                effect: effect
            };
            
            effectsTrack.clips.push(effectClip);
            this.clips.push(effectClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply(`Applied chroma key effect for color ${color}`);
            
            // Close the panel
            if (this.chromaKeyPanel) {
                this.chromaKeyPanel.remove();
                this.chromaKeyPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.chromaKeyPanel) {
                this.chromaKeyPanel.remove();
                this.chromaKeyPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.chromaKeyPanel.appendChild(title);
        this.chromaKeyPanel.appendChild(infoText);
        this.chromaKeyPanel.appendChild(colorLabel);
        this.chromaKeyPanel.appendChild(colorPicker);
        this.chromaKeyPanel.appendChild(toleranceControl);
        this.chromaKeyPanel.appendChild(featherControl);
        this.chromaKeyPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.chromaKeyPanel);
    }
    
    /**
     * Open color tool
     */
    openColorTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create color panel
        this.colorPanel = document.createElement('div');
        this.colorPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Color Adjustment';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Brightness control
        const brightnessControl = document.createElement('div');
        brightnessControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const brightnessLabel = document.createElement('label');
        brightnessLabel.textContent = 'Brightness:';
        brightnessLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const brightnessSlider = document.createElement('input');
        brightnessSlider.type = 'range';
        brightnessSlider.min = '-100';
        brightnessSlider.max = '100';
        brightnessSlider.value = '0';
        brightnessSlider.style.cssText = `
            width: 100%;
        `;
        
        const brightnessValue = document.createElement('div');
        brightnessValue.textContent = '0';
        brightnessValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        brightnessSlider.addEventListener('input', (e) => {
            brightnessValue.textContent = e.target.value;
        });
        
        brightnessControl.appendChild(brightnessLabel);
        brightnessControl.appendChild(brightnessSlider);
        brightnessControl.appendChild(brightnessValue);
        
        // Contrast control
        const contrastControl = document.createElement('div');
        contrastControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const contrastLabel = document.createElement('label');
        contrastLabel.textContent = 'Contrast:';
        contrastLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const contrastSlider = document.createElement('input');
        contrastSlider.type = 'range';
        contrastSlider.min = '-100';
        contrastSlider.max = '100';
        contrastSlider.value = '0';
        contrastSlider.style.cssText = `
            width: 100%;
        `;
        
        const contrastValue = document.createElement('div');
        contrastValue.textContent = '0';
        contrastValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        contrastSlider.addEventListener('input', (e) => {
            contrastValue.textContent = e.target.value;
        });
        
        contrastControl.appendChild(contrastLabel);
        contrastControl.appendChild(contrastSlider);
        contrastControl.appendChild(contrastValue);
        
        // Saturation control
        const saturationControl = document.createElement('div');
        saturationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const saturationLabel = document.createElement('label');
        saturationLabel.textContent = 'Saturation:';
        saturationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const saturationSlider = document.createElement('input');
        saturationSlider.type = 'range';
        saturationSlider.min = '-100';
        saturationSlider.max = '100';
        saturationSlider.value = '0';
        saturationSlider.style.cssText = `
            width: 100%;
        `;
        
        const saturationValue = document.createElement('div');
        saturationValue.textContent = '0';
        saturationValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        saturationSlider.addEventListener('input', (e) => {
            saturationValue.textContent = e.target.value;
        });
        
        saturationControl.appendChild(saturationLabel);
        saturationControl.appendChild(saturationSlider);
        saturationControl.appendChild(saturationValue);
        
        // Hue control
        const hueControl = document.createElement('div');
        hueControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const hueLabel = document.createElement('label');
        hueLabel.textContent = 'Hue:';
        hueLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const hueSlider = document.createElement('input');
        hueSlider.type = 'range';
        hueSlider.min = '-180';
        hueSlider.max = '180';
        hueSlider.value = '0';
        hueSlider.style.cssText = `
            width: 100%;
        `;
        
        const hueValue = document.createElement('div');
        hueValue.textContent = '0°';
        hueValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        hueSlider.addEventListener('input', (e) => {
            hueValue.textContent = `${e.target.value}°`;
        });
        
        hueControl.appendChild(hueLabel);
        hueControl.appendChild(hueSlider);
        hueControl.appendChild(hueValue);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const resetButton = document.createElement('button');
        resetButton.textContent = 'Reset';
        resetButton.style.cssText = this.getButtonStyle('btn-tool');
        resetButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const brightness = parseInt(brightnessSlider.value);
            const contrast = parseInt(contrastSlider.value);
            const saturation = parseInt(saturationSlider.value);
            const hue = parseInt(hueSlider.value);
            
            // Create color adjustment effect
            const effect = {
                id: `effect-${Date.now()}`,
                type: 'colorAdjust',
                brightness: brightness,
                contrast: contrast,
                saturation: saturation,
                hue: hue
            };
            
            this.effects.push(effect);
            
            // Create an effects track if it doesn't exist
            let effectsTrack = this.tracks.find(t => t.type === 'effects');
            if (!effectsTrack) {
                effectsTrack = this.createTrack('Effects', 'effects');
            }
            
            // Add effect clip to timeline
            const effectClip = {
                id: `clip-${Date.now()}`,
                name: 'Color Adjustment',
                url: null,
                start: 0,
                end: this.videoDuration,
                track: effectsTrack.id,
                type: 'effect',
                effect: effect
            };
            
            effectsTrack.clips.push(effectClip);
            this.clips.push(effectClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply('Applied color adjustment');
            
            // Close the panel
            if (this.colorPanel) {
                this.colorPanel.remove();
                this.colorPanel = null;
            }
        });
        
        resetButton.addEventListener('click', () => {
            brightnessSlider.value = '0';
            brightnessValue.textContent = '0';
            contrastSlider.value = '0';
            contrastValue.textContent = '0';
            saturationSlider.value = '0';
            saturationValue.textContent = '0';
            hueSlider.value = '0';
            hueValue.textContent = '0°';
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(resetButton);
        
        this.colorPanel.appendChild(title);
        this.colorPanel.appendChild(brightnessControl);
        this.colorPanel.appendChild(contrastControl);
        this.colorPanel.appendChild(saturationControl);
        this.colorPanel.appendChild(hueControl);
        this.colorPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.colorPanel);
    }
    
    /**
     * Open transform tool
     */
    openTransformTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create transform panel
        const transformPanel = document.createElement('div');
        transformPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Transform';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Position X control
        const posXControl = document.createElement('div');
        posXControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const posXLabel = document.createElement('label');
        posXLabel.textContent = 'Position X:';
        posXLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const posXSlider = document.createElement('input');
        posXSlider.type = 'range';
        posXSlider.min = '-100';
        posXSlider.max = '100';
        posXSlider.value = '0';
        posXSlider.style.cssText = `
            width: 100%;
        `;
        
        const posXValue = document.createElement('div');
        posXValue.textContent = '0';
        posXValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        posXSlider.addEventListener('input', (e) => {
            posXValue.textContent = e.target.value;
        });
        
        posXControl.appendChild(posXLabel);
        posXControl.appendChild(posXSlider);
        posXControl.appendChild(posXValue);
        
        // Position Y control
        const posYControl = document.createElement('div');
        posYControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const posYLabel = document.createElement('label');
        posYLabel.textContent = 'Position Y:';
        posYLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const posYSlider = document.createElement('input');
        posYSlider.type = 'range';
        posYSlider.min = '-100';
        posYSlider.max = '100';
        posYSlider.value = '0';
        posYSlider.style.cssText = `
            width: 100%;
        `;
        
        const posYValue = document.createElement('div');
        posYValue.textContent = '0';
        posYValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        posYSlider.addEventListener('input', (e) => {
            posYValue.textContent = e.target.value;
        });
        
        posYControl.appendChild(posYLabel);
        posYControl.appendChild(posYSlider);
        posYControl.appendChild(posYValue);
        
        // Scale control
        const scaleControl = document.createElement('div');
        scaleControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const scaleLabel = document.createElement('label');
        scaleLabel.textContent = 'Scale:';
        scaleLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const scaleSlider = document.createElement('input');
        scaleSlider.type = 'range';
        scaleSlider.min = '10';
        scaleSlider.max = '200';
        scaleSlider.value = '100';
        scaleSlider.style.cssText = `
            width: 100%;
        `;
        
        const scaleValue = document.createElement('div');
        scaleValue.textContent = '100%';
        scaleValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        scaleSlider.addEventListener('input', (e) => {
            scaleValue.textContent = `${e.target.value}%`;
        });
        
        scaleControl.appendChild(scaleLabel);
        scaleControl.appendChild(scaleSlider);
        scaleControl.appendChild(scaleValue);
        
        // Rotation control
        const rotationControl = document.createElement('div');
        rotationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const rotationLabel = document.createElement('label');
        rotationLabel.textContent = 'Rotation:';
        rotationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const rotationSlider = document.createElement('input');
        rotationSlider.type = 'range';
        rotationSlider.min = '-180';
        rotationSlider.max = '180';
        rotationSlider.value = '0';
        rotationSlider.style.cssText = `
            width: 100%;
        `;
        
        const rotationValue = document.createElement('div');
        rotationValue.textContent = '0°';
        rotationValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        rotationSlider.addEventListener('input', (e) => {
            rotationValue.textContent = `${e.target.value}°`;
        });
        
        rotationControl.appendChild(rotationLabel);
        rotationControl.appendChild(rotationSlider);
        rotationControl.appendChild(rotationValue);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const resetButton = document.createElement('button');
        resetButton.textContent = 'Reset';
        resetButton.style.cssText = this.getButtonStyle('btn-tool');
        resetButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const posX = parseInt(posXSlider.value);
            const posY = parseInt(posYSlider.value);
            const scale = parseInt(scaleSlider.value);
            const rotation = parseInt(rotationSlider.value);
            
            // Create transform effect
            const effect = {
                id: `effect-${Date.now()}`,
                type: 'transform',
                posX: posX,
                posY: posY,
                scale: scale,
                rotation: rotation
            };
            
            this.effects.push(effect);
            
            // Create an effects track if it doesn't exist
            let effectsTrack = this.tracks.find(t => t.type === 'effects');
            if (!effectsTrack) {
                effectsTrack = this.createTrack('Effects', 'effects');
            }
            
            // Add effect clip to timeline
            const effectClip = {
                id: `clip-${Date.now()}`,
                name: 'Transform',
                url: null,
                start: 0,
                end: this.videoDuration,
                track: effectsTrack.id,
                type: 'effect',
                effect: effect
            };
            
            effectsTrack.clips.push(effectClip);
            this.clips.push(effectClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply('Applied transform effect');
            
            // Close the panel
            if (transformPanel) {
                transformPanel.remove();
                transformPanel = null;
            }
        });
        
        resetButton.addEventListener('click', () => {
            posXSlider.value = '0';
            posXValue.textContent = '0';
            posYSlider.value = '0';
            posYValue.textContent = '0';
            scaleSlider.value = '100';
            scaleValue.textContent = '100%';
            rotationSlider.value = '0';
            rotationValue.textContent = '0°';
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(resetButton);
        
        transformPanel.appendChild(title);
        transformPanel.appendChild(posXControl);
        transformPanel.appendChild(posYControl);
        transformPanel.appendChild(scaleControl);
        transformPanel.appendChild(rotationControl);
        transformPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(transformPanel);
    }
    
    /**
     * Open layers tool
     */
    openLayersTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create layers panel
        this.layersPanel = document.createElement('div');
        this.layersPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Layers';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Create layers list
        const layersList = document.createElement('div');
        layersList.style.cssText = `
            margin-bottom: 15px;
        `;
        
        // Add video layer
        const videoLayer = document.createElement('div');
        videoLayer.style.cssText = `
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #444;
            border-radius: 4px;
            margin-bottom: 5px;
        `;
        
        const videoLayerIcon = document.createElement('div');
        videoLayerIcon.textContent = '🎬';
        videoLayerIcon.style.cssText = `
            margin-right: 10px;
            font-size: 18px;
        `;
        
        const videoLayerName = document.createElement('div');
        videoLayerName.textContent = 'Video';
        videoLayerName.style.cssText = `
            flex: 1;
        `;
        
        const videoLayerVisible = document.createElement('input');
        videoLayerVisible.type = 'checkbox';
        videoLayerVisible.checked = true;
        videoLayerVisible.style.cssText = `
            margin-right: 5px;
        `;
        
        videoLayer.appendChild(videoLayerIcon);
        videoLayer.appendChild(videoLayerName);
        videoLayer.appendChild(videoLayerVisible);
        
        layersList.appendChild(videoLayer);
        
        // Add text layers
        this.textOverlays.forEach((text, index) => {
            const textLayer = document.createElement('div');
            textLayer.style.cssText = `
                display: flex;
                align-items: center;
                padding: 10px;
                background-color: #444;
                border-radius: 4px;
                margin-bottom: 5px;
            `;
            
            const textLayerIcon = document.createElement('div');
            textLayerIcon.textContent = 'T';
            textLayerIcon.style.cssText = `
                margin-right: 10px;
                font-size: 18px;
            `;
            
            const textLayerName = document.createElement('div');
            textLayerName.textContent = text.content.length > 15 ? text.content.substring(0, 15) + '...' : text.content;
            textLayerName.style.cssText = `
                flex: 1;
            `;
            
            const textLayerVisible = document.createElement('input');
            textLayerVisible.type = 'checkbox';
            textLayerVisible.checked = true;
            textLayerVisible.style.cssText = `
                margin-right: 5px;
            `;
            
            const textLayerDelete = document.createElement('button');
            textLayerDelete.textContent = '❌';
            textLayerDelete.style.cssText = `
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 16px;
            `;
            
            textLayerDelete.addEventListener('click', () => {
                // Remove text overlay
                this.textOverlays.splice(index, 1);
                
                // Remove from timeline
                const clipIndex = this.clips.findIndex(c => c.textOverlay && c.textOverlay.id === text.id);
                if (clipIndex !== -1) {
                    this.clips.splice(clipIndex, 1);
                    
                    // Remove from track
                    const track = this.tracks.find(t => t.id === text.track);
                    if (track) {
                        const trackClipIndex = track.clips.findIndex(c => c.id === text.id);
                        if (trackClipIndex !== -1) {
                            track.clips.splice(trackClipIndex, 1);
                        }
                    }
                    
                    // Update UI
                    this.updateTimelineClips();
                }
                
                // Rebuild layers panel
                if (this.layersPanel) {
                    this.layersPanel.remove();
                    this.openLayersTool();
                }
            });
            
            textLayer.appendChild(textLayerIcon);
            textLayer.appendChild(textLayerName);
            textLayer.appendChild(textLayerVisible);
            textLayer.appendChild(textLayerDelete);
            
            layersList.appendChild(textLayer);
        });
        
        // Add sticker layers
        this.stickers.forEach((sticker, index) => {
            const stickerLayer = document.createElement('div');
            stickerLayer.style.cssText = `
                display: flex;
                align-items: center;
                padding: 10px;
                background-color: #444;
                border-radius: 4px;
                margin-bottom: 5px;
            `;
            
            const stickerLayerIcon = document.createElement('div');
            stickerLayerIcon.textContent = '🏷️';
            stickerLayerIcon.style.cssText = `
                margin-right: 10px;
                font-size: 18px;
            `;
            
            const stickerLayerName = document.createElement('div');
            stickerLayerName.textContent = `Sticker: ${sticker.emoji}`;
            stickerLayerName.style.cssText = `
                flex: 1;
            `;
            
            const stickerLayerVisible = document.createElement('input');
            stickerLayerVisible.type = 'checkbox';
            stickerLayerVisible.checked = true;
            stickerLayerVisible.style.cssText = `
                margin-right: 5px;
            `;
            
            const stickerLayerDelete = document.createElement('button');
            stickerLayerDelete.textContent = '❌';
            stickerLayerDelete.style.cssText = `
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 16px;
            `;
            
            stickerLayerDelete.addEventListener('click', () => {
                // Remove sticker
                this.stickers.splice(index, 1);
                
                // Remove from timeline
                const clipIndex = this.clips.findIndex(c => c.sticker && c.sticker.id === sticker.id);
                if (clipIndex !== -1) {
                    this.clips.splice(clipIndex, 1);
                    
                    // Remove from track
                    const track = this.tracks.find(t => t.id === sticker.track);
                    if (track) {
                        const trackClipIndex = track.clips.findIndex(c => c.id === sticker.id);
                        if (trackClipIndex !== -1) {
                            track.clips.splice(trackClipIndex, 1);
                        }
                    }
                    
                    // Update UI
                    this.updateTimelineClips();
                }
                
                // Rebuild layers panel
                if (this.layersPanel) {
                    this.layersPanel.remove();
                    this.openLayersTool();
                }
            });
            
            stickerLayer.appendChild(stickerLayerIcon);
            stickerLayer.appendChild(stickerLayerName);
            stickerLayer.appendChild(stickerLayerVisible);
            stickerLayer.appendChild(stickerLayerDelete);
            
            layersList.appendChild(stickerLayer);
        });
        
        // Add effect layers
        this.effects.forEach((effect, index) => {
            const effectLayer = document.createElement('div');
            effectLayer.style.cssText = `
                display: flex;
                align-items: center;
                padding: 10px;
                background-color: #444;
                border-radius: 4px;
                margin-bottom: 5px;
            `;
            
            const effectLayerIcon = document.createElement('div');
            effectLayerIcon.textContent = '✨';
            effectLayerIcon.style.cssText = `
                margin-right: 10px;
                font-size: 18px;
            `;
            
            const effectLayerName = document.createElement('div');
            effectLayerName.textContent = `Effect: ${effect.type}`;
            effectLayerName.style.cssText = `
                flex: 1;
            `;
            
            const effectLayerVisible = document.createElement('input');
            effectLayerVisible.type = 'checkbox';
            effectLayerVisible.checked = true;
            effectLayerVisible.style.cssText = `
                margin-right: 5px;
            `;
            
            const effectLayerDelete = document.createElement('button');
            effectLayerDelete.textContent = '❌';
            effectLayerDelete.style.cssText = `
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 16px;
            `;
            
            effectLayerDelete.addEventListener('click', () => {
                // Remove effect
                this.effects.splice(index, 1);
                
                // Remove from timeline
                const clipIndex = this.clips.findIndex(c => c.effect && c.effect.id === effect.id);
                if (clipIndex !== -1) {
                    this.clips.splice(clipIndex, 1);
                    
                    // Remove from track
                    const track = this.tracks.find(t => t.id === effect.track);
                    if (track) {
                        const trackClipIndex = track.clips.findIndex(c => c.id === effect.id);
                        if (trackClipIndex !== -1) {
                            track.clips.splice(trackClipIndex, 1);
                        }
                    }
                    
                    // Update UI
                    this.updateTimelineClips();
                }
                
                // Rebuild layers panel
                if (this.layersPanel) {
                    this.layersPanel.remove();
                    this.openLayersTool();
                }
            });
            
            effectLayer.appendChild(effectLayerIcon);
            effectLayer.appendChild(effectLayerName);
            effectLayer.appendChild(effectLayerVisible);
            effectLayer.appendChild(effectLayerDelete);
            
            layersList.appendChild(effectLayer);
        });
        
        // Close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-tool');
        closeButton.style.width = '100%';
        
        closeButton.addEventListener('click', () => {
            if (this.layersPanel) {
                this.layersPanel.remove();
                this.layersPanel = null;
            }
        });
        
        this.layersPanel.appendChild(title);
        this.layersPanel.appendChild(layersList);
        this.layersPanel.appendChild(closeButton);
        
        this.gameContainer.appendChild(this.layersPanel);
    }
    
    /**
     * Open properties tool
     */
    openPropertiesTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create properties panel
        this.propertiesPanel = document.createElement('div');
        this.propertiesPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Properties';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Video info
        const videoInfo = document.createElement('div');
        videoInfo.style.cssText = `
            margin-bottom: 15px;
            padding: 10px;
            background-color: #444;
            border-radius: 4px;
        `;
        
        const videoName = document.createElement('div');
        videoName.textContent = `Name: ${this.currentVideo.name}`;
        videoName.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const videoDuration = document.createElement('div');
        videoDuration.textContent = `Duration: ${this.formatTime(this.videoDuration)}`;
        videoDuration.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const videoDimensions = document.createElement('div');
        videoDimensions.textContent = `Dimensions: ${this.canvas.width}x${this.canvas.height}`;
        videoDimensions.style.cssText = `
            margin-bottom: 5px;
        `;
        
        videoInfo.appendChild(videoName);
        videoInfo.appendChild(videoDuration);
        videoInfo.appendChild(videoDimensions);
        
        // Project info
        const projectInfo = document.createElement('div');
        projectInfo.style.cssText = `
            margin-bottom: 15px;
            padding: 10px;
            background-color: #444;
            border-radius: 4px;
        `;
        
        const projectTitle = document.createElement('div');
        projectTitle.textContent = 'Project Settings';
        projectTitle.style.cssText = `
            font-weight: bold;
            margin-bottom: 10px;
        `;
        
        const fpsControl = document.createElement('div');
        fpsControl.style.cssText = `
            margin-bottom: 10px;
        `;
        
        const fpsLabel = document.createElement('label');
        fpsLabel.textContent = 'FPS:';
        fpsLabel.style.cssText = `
            display: inline-block;
            width: 80px;
        `;
        
        const fpsSelect = document.createElement('select');
        fpsSelect.style.cssText = `
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #555;
            color: white;
        `;
        
        const fpsOptions = [
            { value: '24', text: '24' },
            { value: '25', text: '25' },
            { value: '30', text: '30' },
            { value: '50', text: '50' },
            { value: '60', text: '60' }
        ];
        
        fpsOptions.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value;
            optionElement.textContent = option.text;
            fpsSelect.appendChild(optionElement);
        });
        
        fpsSelect.value = '30'; // Default to 30 FPS
        
        fpsControl.appendChild(fpsLabel);
        fpsControl.appendChild(fpsSelect);
        
        const resolutionControl = document.createElement('div');
        resolutionControl.style.cssText = `
            margin-bottom: 10px;
        `;
        
        const resolutionLabel = document.createElement('label');
        resolutionLabel.textContent = 'Resolution:';
        resolutionLabel.style.cssText = `
            display: inline-block;
            width: 80px;
        `;
        
        const resolutionSelect = document.createElement('select');
        resolutionSelect.style.cssText = `
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #555;
            color: white;
        `;
        
        const resolutionOptions = [
            { value: 'original', text: 'Original' },
            { value: '3840x2160', text: '4K (3840x2160)' },
            { value: '1920x1080', text: 'Full HD (1920x1080)' },
            { value: '1280x720', text: 'HD (1280x720)' },
            { value: '854x480', text: 'SD (854x480)' }
        ];
        
        resolutionOptions.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value;
            optionElement.textContent = option.text;
            resolutionSelect.appendChild(optionElement);
        });
        
        resolutionSelect.value = 'original'; // Default to original resolution
        
        resolutionControl.appendChild(resolutionLabel);
        resolutionControl.appendChild(resolutionSelect);
        
        projectInfo.appendChild(projectTitle);
        projectInfo.appendChild(fpsControl);
        projectInfo.appendChild(resolutionControl);
        
        // Statistics
        const statsInfo = document.createElement('div');
        statsInfo.style.cssText = `
            margin-bottom: 15px;
            padding: 10px;
            background-color: #444;
            border-radius: 4px;
        `;
        
        const statsTitle = document.createElement('div');
        statsTitle.textContent = 'Statistics';
        statsTitle.style.cssText = `
            font-weight: bold;
            margin-bottom: 10px;
        `;
        
        const clipsCount = document.createElement('div');
        clipsCount.textContent = `Clips: ${this.clips.length}`;
        clipsCount.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const textCount = document.createElement('div');
        textCount.textContent = `Text Overlays: ${this.textOverlays.length}`;
        textCount.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const stickerCount = document.createElement('div');
        stickerCount.textContent = `Stickers: ${this.stickers.length}`;
        stickerCount.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const effectsCount = document.createElement('div');
        effectsCount.textContent = `Effects: ${this.effects.length}`;
        effectsCount.style.cssText = `
            margin-bottom: 5px;
        `;
        
        statsInfo.appendChild(statsTitle);
        statsInfo.appendChild(clipsCount);
        statsInfo.appendChild(textCount);
        statsInfo.appendChild(stickerCount);
        statsInfo.appendChild(effectsCount);
        
        // Close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-tool');
        closeButton.style.width = '100%';
        
        closeButton.addEventListener('click', () => {
            if (this.propertiesPanel) {
                this.propertiesPanel.remove();
                this.propertiesPanel = null;
            }
        });
        
        this.propertiesPanel.appendChild(title);
        this.propertiesPanel.appendChild(videoInfo);
        this.propertiesPanel.appendChild(projectInfo);
        this.propertiesPanel.appendChild(statsInfo);
        this.propertiesPanel.appendChild(closeButton);
        
        this.gameContainer.appendChild(this.propertiesPanel);
    }
    
    /**
     * Import media - VIDEO UPLOAD FUNCTION
     */
    importMedia() {
        // Create a file input element
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'video/*,audio/*';
        fileInput.style.display = 'none';
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                this.loadVideo(fileURL, file.name);
                botReply(`Uploading ${file.name}...`);
            }
        });
        
        // Trigger the file input
        document.body.appendChild(fileInput);
        fileInput.click();
        document.body.removeChild(fileInput);
    }
    
    /**
     * Load a video
     */
    loadVideo(url, name) {
        // If there's already a video loaded, revoke its URL to prevent memory leaks
        if (this.currentVideo) {
            URL.revokeObjectURL(this.currentVideo.url);
        }
        
        // Clear existing effects, text overlays, and transitions
        this.effects = [];
        this.textOverlays = [];
        this.transitions = [];
        this.clips = [];
        this.stickers = [];
        this.animations = [];
        this.keyframes = [];
        
        // Clear tracks
        this.tracks.forEach(track => {
            const trackElement = document.getElementById(track.id);
            if (trackElement) {
                const trackContent = trackElement.querySelector('div:last-child');
                if (trackContent) {
                    trackContent.innerHTML = '';
                }
            }
            track.clips = [];
        });
        
        this.currentVideo = {
            url: url,
            name: name
        };
        
        this.videoPreview.src = url;
        this.projectInfo.textContent = name;
        
        // Hide the upload area once a video is loaded
        this.uploadArea.style.display = 'none';
        
        botReply(`Loaded video: ${name}`);
        
        // Add a clip to the timeline
        this.addClipToTimeline('video', name, url);
    }
    
    /**
     * Add a clip to the timeline
     */
    addClipToTimeline(trackType, name, url) {
        // Find or create a track of the specified type
        let track = this.tracks.find(t => t.type === trackType);
        
        if (!track) {
            track = this.createTrack(trackType.charAt(0).toUpperCase() + trackType.slice(1), trackType);
        }
        
        // Create a new clip
        const clip = {
            id: `clip-${Date.now()}`,
            name: name,
            url: url,
            start: 0,
            end: this.videoDuration || 10, // Default to 10 seconds if duration not available
            track: track.id,
            type: trackType
        };
        
        track.clips.push(clip);
        this.clips.push(clip);
        
        // Create the clip element in the timeline
        const trackElement = document.getElementById(track.id);
        const trackContent = trackElement.querySelector('div:last-child');
        
        const clipElement = document.createElement('div');
        clipElement.id = clip.id;
        clipElement.style.cssText = `
            position: absolute;
            left: ${clip.start * 50}px;
            top: 10px;
            width: ${(clip.end - clip.start) * 50}px;
            height: 40px;
            background-color: ${trackType === 'video' ? '#4a6fa5' : trackType === 'audio' ? '#5a9654' : trackType === 'text' ? '#9c27b0' : '#ff9800'};
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 0 10px;
            cursor: pointer;
        `;
        
        clipElement.textContent = name;
        clipElement.title = name;
        
        clipElement.addEventListener('click', () => {
            this.selectClip(clip.id);
        });
        
        trackContent.appendChild(clipElement);
        
        // Select the track
        this.selectTrack(track.id);
    }
    
    /**
     * Update timeline clips
     */
    updateTimelineClips() {
        // Clear all track contents
        this.tracks.forEach(track => {
            const trackElement = document.getElementById(track.id);
            if (trackElement) {
                const trackContent = trackElement.querySelector('div:last-child');
                if (trackContent) {
                    trackContent.innerHTML = '';
                }
            }
        });
        
        // Re-add all clips
        this.clips.forEach(clip => {
            const trackElement = document.getElementById(clip.track);
            if (trackElement) {
                const trackContent = trackElement.querySelector('div:last-child');
                if (trackContent) {
                    const clipElement = document.createElement('div');
                    clipElement.id = clip.id;
                    
                    // Set background color based on clip type
                    let bgColor = '#4a6fa5'; // Default video color
                    if (clip.type === 'audio') bgColor = '#5a9654';
                    else if (clip.type === 'text') bgColor = '#9c27b0';
                    else if (clip.type === 'transition') bgColor = '#ff5722';
                    else if (clip.type === 'effect') bgColor = '#ff9800';
                    else if (clip.type === 'sticker') bgColor = '#e91e63';
                    else if (clip.type === 'animation') bgColor = '#00bcd4';
                    else if (clip.type === 'keyframe') bgColor = '#8bc34a';
                    
                    clipElement.style.cssText = `
                        position: absolute;
                        left: ${clip.start * 50}px;
                        top: 10px;
                        width: ${(clip.end - clip.start) * 50}px;
                        height: 40px;
                        background-color: ${bgColor};
                        border-radius: 4px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-size: 12px;
                        overflow: hidden;
                        white-space: nowrap;
                        text-overflow: ellipsis;
                        padding: 0 10px;
                        cursor: pointer;
                        ${clip.effects && clip.effects.length > 0 ? 'box-shadow: 0 0 5px #ff9800;' : ''}
                    `;
                    
                    clipElement.textContent = clip.name;
                    clipElement.title = clip.name;
                    
                    clipElement.addEventListener('click', () => {
                        this.selectClip(clip.id);
                    });
                    
                    trackContent.appendChild(clipElement);
                }
            }
        });
    }
    
    /**
     * Select a clip
     */
    selectClip(clipId) {
        // Deselect all clips
        this.clips.forEach(clip => {
            const clipElement = document.getElementById(clip.id);
            if (clipElement) {
                clipElement.style.border = 'none';
            }
        });
        
        // Select the specified clip
        this.selectedClip = clipId;
        const clipElement = document.getElementById(clipId);
        if (clipElement) {
            clipElement.style.border = '2px solid #ff9800';
        }
        
        botReply(`Selected clip: ${clipId}`);
    }
    
    /**
     * Export video
     */
    exportVideo() {
        if (!this.currentVideo) {
            this.showError('No video to export');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create export panel
        this.exportPanel = document.createElement('div');
        this.exportPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Export Video';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const formatControl = document.createElement('div');
        formatControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const formatLabel = document.createElement('label');
        formatLabel.textContent = 'Format:';
        formatLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const formatSelect = document.createElement('select');
        formatSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const formats = [
            { value: 'mp4', text: 'MP4 (Recommended)' },
            { value: 'webm', text: 'WebM' },
            { value: 'mov', text: 'MOV' }
        ];
        
        formats.forEach(format => {
            const option = document.createElement('option');
            option.value = format.value;
            option.textContent = format.text;
            formatSelect.appendChild(option);
        });
        
        formatControl.appendChild(formatLabel);
        formatControl.appendChild(formatSelect);
        
        const qualityControl = document.createElement('div');
        qualityControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const qualityLabel = document.createElement('label');
        qualityLabel.textContent = 'Quality:';
        qualityLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const qualitySelect = document.createElement('select');
        qualitySelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const qualities = [
            { value: 'high', text: 'High (1080p)' },
            { value: 'medium', text: 'Medium (720p)' },
            { value: 'low', text: 'Low (480p)' }
        ];
        
        qualities.forEach(quality => {
            const option = document.createElement('option');
            option.value = quality.value;
            option.textContent = quality.text;
            qualitySelect.appendChild(option);
        });
        
        qualityControl.appendChild(qualityLabel);
        qualityControl.appendChild(qualitySelect);
        
        const resolutionControl = document.createElement('div');
        resolutionControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const resolutionLabel = document.createElement('label');
        resolutionLabel.textContent = 'Resolution:';
        resolutionLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const resolutionSelect = document.createElement('select');
        resolutionSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const resolutions = [
            { value: 'original', text: 'Original' },
            { value: '1920x1080', text: '1920x1080 (Full HD)' },
            { value: '1280x720', text: '1280x720 (HD)' },
            { value: '854x480', text: '854x480 (SD)' }
        ];
        
        resolutions.forEach(resolution => {
            const option = document.createElement('option');
            option.value = resolution.value;
            option.textContent = resolution.text;
            resolutionSelect.appendChild(option);
        });
        
        resolutionControl.appendChild(resolutionLabel);
        resolutionControl.appendChild(resolutionSelect);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const exportButton = document.createElement('button');
        exportButton.textContent = 'Export';
        exportButton.style.cssText = this.getButtonStyle('btn-tool-export');
        exportButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        exportButton.addEventListener('click', () => {
            const format = formatSelect.value;
            const quality = qualitySelect.value;
            const resolution = resolutionSelect.value;
            
            botReply(`Exporting video as ${format} with ${quality} quality at ${resolution} resolution...`);
            
            // Close the panel
            if (this.exportPanel) {
                this.exportPanel.remove();
                this.exportPanel = null;
            }
            
            // Simulate export process
            setTimeout(() => {
                botReply('Video exported successfully! In a full implementation, the video would be downloaded.');
            }, 2000);
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.exportPanel) {
                this.exportPanel.remove();
                this.exportPanel = null;
            }
        });
        
        buttonsContainer.appendChild(exportButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.exportPanel.appendChild(title);
        this.exportPanel.appendChild(formatControl);
        this.exportPanel.appendChild(qualityControl);
        this.exportPanel.appendChild(resolutionControl);
        this.exportPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.exportPanel);
    }
    
    /**
     * Update timeline
     */
    updateTimeline() {
        // Update timeline duration markers
        // In a real implementation, this would adjust the timeline to match the video duration
        this.updateTimeDisplay();
    }
    
    /**
     * Update timeline position
     */
    updateTimelinePosition() {
        // Update playhead position in timeline
        if (this.playhead) {
            const position = (this.currentTime / (this.videoDuration || 60)) * 3000; // 3000px is max width
            this.playhead.style.left = `${position}px`;
        }
        this.updateTimeDisplay();
    }
    
    /**
     * Update time display
     */
    updateTimeDisplay() {
        const currentTimeStr = this.formatTime(this.currentTime);
        const totalTimeStr = this.formatTime(this.videoDuration);
        this.timeDisplay.textContent = `${currentTimeStr} / ${totalTimeStr}`;
    }
    
    /**
     * Format time as MM:SS
     */
    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    /**
     * Close all panels
     */
    closeAllPanels() {
        if (this.effectsPanel) {
            this.effectsPanel.remove();
            this.effectsPanel = null;
        }
        
        if (this.textPanel) {
            this.textPanel.remove();
            this.textPanel = null;
        }
        
        if (this.transitionPanel) {
            this.transitionPanel.remove();
            this.transitionPanel = null;
        }
        
        if (this.settingsPanel) {
            this.settingsPanel.remove();
            this.settingsPanel = null;
        }
        
        if (this.exportPanel) {
            this.exportPanel.remove();
            this.exportPanel = null;
        }
        
        if (this.trimPanel) {
            this.trimPanel.remove();
            this.trimPanel = null;
        }
        
        if (this.audioPanel) {
            this.audioPanel.remove();
            this.audioPanel = null;
        }
        
        if (this.speedPanel) {
            this.speedPanel.remove();
            this.speedPanel = null;
        }
        
        if (this.animationPanel) {
            this.animationPanel.remove();
            this.animationPanel = null;
        }
        
        if (this.keyframePanel) {
            this.keyframePanel.remove();
            this.keyframePanel = null;
        }
        
        if (this.chromaKeyPanel) {
            this.chromaKeyPanel.remove();
            this.chromaKeyPanel = null;
        }
        
        if (this.colorPanel) {
            this.colorPanel.remove();
            this.colorPanel = null;
        }
        
        if (this.layersPanel) {
            this.layersPanel.remove();
            this.layersPanel = null;
        }
        
        if (this.propertiesPanel) {
            this.propertiesPanel.remove();
            this.propertiesPanel = null;
        }
    }
    
    /**
     * Show error message
     */
    showError(message) {
        botReply(message);
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        // Handle video editor keys
        switch (event.key) {
            case ' ':
                event.preventDefault();
                this.togglePlayPause();
                break;
            case 'ArrowLeft':
                event.preventDefault();
                this.skipBackward();
                break;
            case 'ArrowRight':
                event.preventDefault();
                this.skipForward();
                break;
            case 'Escape':
                // Close any open panels first
                if (this.effectsPanel || this.textPanel || this.transitionPanel || 
                    this.settingsPanel || this.exportPanel || this.trimPanel ||
                    this.audioPanel || this.speedPanel || this.animationPanel ||
                    this.keyframePanel || this.chromaKeyPanel || this.colorPanel ||
                    this.layersPanel || this.propertiesPanel) {
                    this.closeAllPanels();
                    return;
                }
                
                if (this.isFullscreen) {
                    this.exitFullscreen();
                } else {
                    this.closeGame();
                }
                break;
            case 'i':
                event.preventDefault();
                this.importMedia();
                break;
            case 'e':
                event.preventDefault();
                this.exportVideo();
                break;
            case 'c':
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.cutTool();
                }
                break;
            case 't':
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.addText();
                }
                break;
            case 's':
                if (event.ctrlKey) {
                    event.preventDefault();
                    botReply('Project would be saved in a full implementation');
                }
                break;
        }
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Close all panels
        this.closeAllPanels();
        
        // Pause video if playing
        if (this.playing && this.videoPreview) {
            this.videoPreview.pause();
        }
        
        // Revoke object URLs to prevent memory leaks
        if (this.currentVideo) {
            URL.revokeObjectURL(this.currentVideo.url);
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Clear any pending button timeout
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.videoPreview = null;
        this.timeline = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.currentVideo = null;
        this.videoDuration = 0;
        this.currentTime = 0;
        this.playing = false;
        this.tracks = [];
        this.selectedTrack = null;
        this.selectedTool = 'select';
        this.selectedClip = null;
        this.zoomLevel = 1;
        this.volume = 0.8;
        this.playbackRate = 1;
        this.buttonTimeout = null;
        this.activeButton = null;
        this.timeDisplay = null;
        this.playhead = null;
        this.clips = [];
        this.projectInfo = null;
        this.uploadArea = null;
        this.effectsPanel = null;
        this.textPanel = null;
        this.transitionPanel = null;
        this.settingsPanel = null;
        this.exportPanel = null;
        this.trimPanel = null;
        this.textOverlays = [];
        this.effects = [];
        this.transitions = [];
        this.trimStart = 0;
        this.trimEnd = 0;
        this.leftToolbar = null;
        this.layersPanel = null;
        this.propertiesPanel = null;
        this.speedPanel = null;
        this.audioPanel = null;
        this.colorPanel = null;
        this.animationPanel = null;
        this.keyframePanel = null;
        this.chromaKeyPanel = null;
        this.stickers = [];
        this.animations = [];
        this.keyframes = [];
        
        botReply("Video Editor closed. Thank you!");
    }
}

// Create a singleton instance
const videoEditorScreen = new VideoEditorScreen();

// Add this to your AI's command handling
if (/video editor|video edit|vedit/i.test(userInputRaw)) {
    videoEditorScreen.loadVideoEditor();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    videoEditorScreen.closeGame();
    return;
}


class RandomText {
    constructor() {
        this.randomText = {
            name: 'RANDOM TEXT GENERATOR',
            instructions: 'Generate random text with various styles and effects.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.leftToolbar = null;
        this.textDisplay = null;
        this.textArea = null;
        this.currentText = '';
        this.textStyle = {
            fontSize: 24,
            fontFamily: 'Arial',
            color: '#ffffff',
            backgroundColor: '#222222',
            textAlign: 'center',
            fontWeight: 'normal',
            fontStyle: 'normal',
            textDecoration: 'none',
            textShadow: 'none',
            padding: 20,
            borderRadius: 8,
            width: 80,
            height: 30
        };
        this.animationType = 'none';
        this.animationSpeed = 1;
        this.textCategories = [
            'lorem', 'quotes', 'funny', 'tech', 'philosophy', 'poetry'
        ];
        this.selectedCategory = 'lorem';
        this.textHistory = [];
        this.buttonTimeout = null;
        this.activeButton = null;
    }
    
    /**
     * Load the Random Text Generator
     */
    loadRandomText() {
        if (this.isActive) {
            botReply(`The ${this.randomText.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        this.createGameContainer();
        this.createRandomTextUI();
        this.setupActionButtons();
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.randomText.name} loaded! ${this.randomText.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
        `;
    }
    
    /**
     * Create the Random Text UI
     */
    createRandomTextUI() {
        const editorContainer = document.createElement('div');
        editorContainer.style.cssText = `
            background-color: #222;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 80vw;
            max-width: 800px;
            height: 80vh;
            max-height: 600px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background-color: #333;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.randomText.name;
        title.style.cssText = `
            font-size: 18px;
            font-weight: bold;
        `;
        
        header.appendChild(title);
        editorContainer.appendChild(header);
        
        // Create main content area with left toolbar
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex: 1;
            overflow: hidden;
        `;
        
        // Create left toolbar
        this.createLeftToolbar();
        mainContent.appendChild(this.leftToolbar);
        
        // Create center content area
        const centerContent = document.createElement('div');
        centerContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Create text display area
        this.textDisplay = document.createElement('div');
        this.textDisplay.style.cssText = `
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
            margin-bottom: 20px;
            border-radius: 8px;
            background-color: ${this.textStyle.backgroundColor};
            color: ${this.textStyle.color};
            font-size: ${this.textStyle.fontSize}px;
            font-family: ${this.textStyle.fontFamily};
            text-align: ${this.textStyle.textAlign};
            font-weight: ${this.textStyle.fontWeight};
            font-style: ${this.textStyle.fontStyle};
            text-decoration: ${this.textStyle.textDecoration};
            text-shadow: ${this.textStyle.textShadow};
            padding: ${this.textStyle.padding}px;
            width: ${this.textStyle.width}%;
            height: ${this.textStyle.height}%;
            word-wrap: break-word;
            transition: all 0.3s ease;
        `;
        
        this.textDisplay.textContent = 'Click "Generate" to create random text';
        
        // Create text area
        this.textArea = document.createElement('textarea');
        this.textArea.style.cssText = `
            width: 100%;
            height: 100px;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: white;
            font-family: monospace;
            resize: none;
            margin-bottom: 15px;
        `;
        
        this.textArea.placeholder = 'Generated text will appear here...';
        
        // Create control buttons
        const controlButtons = document.createElement('div');
        controlButtons.style.cssText = `
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        `;
        
        const generateButton = document.createElement('button');
        generateButton.textContent = 'Generate';
        generateButton.style.cssText = this.getButtonStyle('btn-primary');
        generateButton.addEventListener('click', () => this.generateRandomText());
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy';
        copyButton.style.cssText = this.getButtonStyle('btn-secondary');
        copyButton.addEventListener('click', () => this.copyToClipboard());
        
        controlButtons.appendChild(generateButton);
        controlButtons.appendChild(copyButton);
        
        centerContent.appendChild(this.textDisplay);
        centerContent.appendChild(this.textArea);
        centerContent.appendChild(controlButtons);
        mainContent.appendChild(centerContent);
        editorContainer.appendChild(mainContent);
        this.gameContainer.appendChild(editorContainer);
        
        // Add keyboard event listeners
        this.setupKeyboardEvents();
    }
    
    /**
     * Create left toolbar with text tools
     */
    createLeftToolbar() {
        this.leftToolbar = document.createElement('div');
        this.leftToolbar.style.cssText = `
            width: 60px;
            background-color: #2a2a2a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            border-right: 1px solid #444;
        `;
        
        // Define text tools
        const textTools = [
            { label: 'T', action: 'text', title: 'Text Style', className: 'btn-tool' },
            { label: '🎨', action: 'color', title: 'Text Color', className: 'btn-tool' },
            { label: '📐', action: 'size', title: 'Text Size', className: 'btn-tool' },
            { label: '🔤', action: 'font', title: 'Font Family', className: 'btn-tool' },
            { label: '⚙️', action: 'align', title: 'Text Alignment', className: 'btn-tool' },
            { label: '✨', action: 'effect', title: 'Text Effects', className: 'btn-tool' },
            { label: '🔄', action: 'animation', title: 'Animation', className: 'btn-tool' },
            { label: '📋', action: 'category', title: 'Text Category', className: 'btn-tool' },
            { label: '🎲', action: 'random', title: 'Random Style', className: 'btn-tool' }
        ];
        
        // Create tool buttons
        textTools.forEach(tool => {
            const btn = document.createElement('button');
            btn.textContent = tool.label;
            btn.title = tool.title;
            btn.style.cssText = this.getButtonStyle(tool.className);
            this.addButtonEventListeners(btn, tool.action, tool.label);
            this.leftToolbar.appendChild(btn);
        });
    }
    
    /**
     * Add event listeners to buttons
     */
    addButtonEventListeners(button, action, label) {
        const handleInteraction = (e) => {
            e.preventDefault();
            this.handleButtonClick(action, label);
            
            this.activeButton = button;
            button.style.transform = 'scale(0.95)';
            button.style.opacity = '0.8';
        };
        
        const handleRelease = () => {
            if (this.activeButton === button) {
                button.style.transform = '';
                button.style.opacity = '';
                this.activeButton = null;
            }
        };
        
        button.addEventListener('mousedown', handleInteraction);
        button.addEventListener('mouseup', handleRelease);
        button.addEventListener('mouseleave', handleRelease);
        
        button.addEventListener('touchstart', handleInteraction, { passive: false });
        button.addEventListener('touchend', handleRelease);
        button.addEventListener('touchcancel', handleRelease);
    }
    
    /**
     * Get button style
     */
    getButtonStyle(buttonType) {
        const baseStyle = `
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap;
        `;
        
        switch (buttonType) {
            case 'btn-tool':
                return baseStyle + `
                    background-color: #444;
                    color: white;
                    width: 44px;
                    height: 44px;
                    border-radius: 8px;
                    margin: 5px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 18px;
                `;
            case 'btn-primary':
                return baseStyle + `
                    background-color: #4CAF50;
                    color: white;
                    flex: 1;
                `;
            case 'btn-secondary':
                return baseStyle + `
                    background-color: #2196F3;
                    color: white;
                    flex: 1;
                `;
            default:
                return baseStyle + `
                    background-color: #555;
                    color: white;
                `;
        }
    }
    
    /**
     * Handle button click
     */
    handleButtonClick(action, label) {
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        this.buttonTimeout = setTimeout(() => {
            switch (action) {
                case 'text':
                    this.openTextStylePanel();
                    break;
                case 'color':
                    this.openColorPanel();
                    break;
                case 'size':
                    this.openSizePanel();
                    break;
                case 'font':
                    this.openFontPanel();
                    break;
                case 'align':
                    this.openAlignPanel();
                    break;
                case 'effect':
                    this.openEffectPanel();
                    break;
                case 'animation':
                    this.openAnimationPanel();
                    break;
                case 'category':
                    this.openCategoryPanel();
                    break;
                case 'random':
                    this.applyRandomStyle();
                    break;
            }
            this.buttonTimeout = null;
        }, 10);
    }
    
    /**
     * Generate random text
     */
    generateRandomText() {
        let text = '';
        
        switch (this.selectedCategory) {
            case 'lorem':
                text = this.generateLoremIpsum();
                break;
            case 'quotes':
                text = this.getRandomQuote();
                break;
            case 'funny':
                text = this.getFunnyText();
                break;
            case 'tech':
                text = this.getTechText();
                break;
            case 'philosophy':
                text = this.getPhilosophyText();
                break;
            case 'poetry':
                text = this.getPoetryText();
                break;
            default:
                text = this.generateLoremIpsum();
        }
        
        this.currentText = text;
        this.textDisplay.textContent = text;
        this.textArea.value = text;
        
        // Add to history
        this.textHistory.unshift({
            text: text,
            category: this.selectedCategory,
            style: { ...this.textStyle },
            timestamp: new Date()
        });
        
        // Apply animation if set
        if (this.animationType !== 'none') {
            this.applyAnimation();
        }
        
      /*  botReply(`Generated ${this.selectedCategory} text`);*/
    }
    
    /**
     * Generate Lorem Ipsum text
     */
    generateLoremIpsum() {
        const loremWords = [
            'lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit',
            'sed', 'do', 'eiusmod', 'tempor', 'incididunt', 'ut', 'labore', 'et', 'dolore',
            'magna', 'aliqua', 'enim', 'ad', 'minim', 'veniam', 'quis', 'nostrud',
            'exercitation', 'ullamco', 'laboris', 'nisi', 'aliquip', 'ex', 'ea', 'commodo',
            'consequat', 'duis', 'aute', 'irure', 'in', 'reprehenderit', 'voluptate',
            'velit', 'esse', 'cillum', 'fugiat', 'nulla', 'pariatur', 'excepteur', 'sint',
            'occaecat', 'cupidatat', 'non', 'proident', 'sunt', 'culpa', 'qui', 'officia',
            'deserunt', 'mollit', 'anim', 'id', 'est', 'laborum'
        ];
        
        const wordCount = Math.floor(Math.random() * 50) + 20;
        const words = [];
        
        for (let i = 0; i < wordCount; i++) {
            const randomIndex = Math.floor(Math.random() * loremWords.length);
            words.push(loremWords[randomIndex]);
        }
        
        // Capitalize first letter
        words[0] = words[0].charAt(0).toUpperCase() + words[0].slice(1);
        
        // Add period at the end
        let text = words.join(' ');
        text += '.';
        
        return text;
    }
    
    /**
     * Get random quote
     */
    getRandomQuote() {
        const quotes = [
            "The only way to do great work is to love what you do. - Steve Jobs",
            "Innovation distinguishes between a leader and a follower. - Steve Jobs",
            "Your time is limited, so don't waste it living someone else's life. - Steve Jobs",
            "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
            "It is during our darkest moments that we must focus to see the light. - Aristotle",
            "Whoever is happy will make others happy too. - Anne Frank",
            "Success is not final, failure is not fatal: It is the courage to continue that counts. - Winston Churchill",
            "The only impossible journey is the one you never begin. - Tony Robbins",
            "In the middle of difficulty lies opportunity. - Albert Einstein",
            "Believe you can and you're halfway there. - Theodore Roosevelt"
        ];
        
        return quotes[Math.floor(Math.random() * quotes.length)];
    }
    
    /**
     * Get funny text
     */
    getFunnyText() {
        const funnyTexts = [
            "I told my wife she was drawing her eyebrows too high. She looked surprised.",
            "Why don't scientists trust atoms? Because they make up everything!",
            "I used to hate facial hair, but then it grew on me.",
            "I'm reading a book about anti-gravity. It's impossible to put down!",
            "Did you hear about the mathematician who's afraid of negative numbers? He'll stop at nothing to avoid them.",
            "Why did the scarecrow win an award? Because he was outstanding in his field!",
            "I'm on a seafood diet. I see food and I eat it.",
            "Time flies like an arrow. Fruit flies like a banana.",
            "I used to play piano by ear, but now I use my hands.",
            "I wondered why the baseball was getting bigger. Then it hit me."
        ];
        
        return funnyTexts[Math.floor(Math.random() * funnyTexts.length)];
    }
    
    /**
     * Get tech text
     */
    getTechText() {
        const techTexts = [
            "Artificial intelligence is the simulation of human intelligence processes by machines, especially computer systems.",
            "Machine learning is a method of data analysis that automates analytical model building.",
            "Blockchain is a system of recording information in a way that makes it difficult or impossible to change, hack, or cheat the system.",
            "Cloud computing is the delivery of computing services over the Internet rather than from local servers.",
            "Cybersecurity is the practice of defending computers, servers, mobile devices, electronic systems, networks, and data from malicious attacks.",
            "The Internet of Things (IoT) describes the network of physical objects that are embedded with sensors, software, and other technologies.",
            "Quantum computing is a type of computation that harnesses the collective properties of quantum states, such as superposition, interference, and entanglement.",
            "Virtual reality is a computer-generated simulation of an environment or situation that can be interacted with in a seemingly real way.",
            "Augmented reality is an enhanced version of the real physical world that is achieved through the use of digital visual elements, sound, or other sensory stimuli.",
            "Big data refers to the large, diverse sets of information that grow at ever-increasing rates."
        ];
        
        return techTexts[Math.floor(Math.random() * techTexts.length)];
    }
    
    /**
     * Get philosophy text
     */
    getPhilosophyText() {
        const philosophyTexts = [
            "The only true wisdom is in knowing you know nothing. - Socrates",
            "I think, therefore I am. - René Descartes",
            "The unexamined life is not worth living. - Socrates",
            "Happiness is not something ready made. It comes from your own actions. - Dalai Lama",
            "The only thing we know for sure is that we know nothing at all. - Socrates",
            "We are what we repeatedly do. Excellence, then, is not an act, but a habit. - Aristotle",
            "He who has a why to live can bear almost any how. - Friedrich Nietzsche",
            "The greatest glory in living lies not in never falling, but in rising every time we fall. - Nelson Mandela",
            "Life is never made unbearable by circumstances, but only by lack of meaning and purpose. - Viktor Frankl",
            "The mind is everything. What you think you become. - Buddha"
        ];
        
        return philosophyTexts[Math.floor(Math.random() * philosophyTexts.length)];
    }
    
    /**
     * Get poetry text
     */
    getPoetryText() {
        const poetryTexts = [
            "Two roads diverged in a yellow wood, And sorry I could not travel both And be one traveler, long I stood And looked down one as far as I could To where it bent in the undergrowth; - Robert Frost",
            "Do not go gentle into that good night, Old age should burn and rave at close of day; Rage, rage against the dying of the light. - Dylan Thomas",
            "Because I could not stop for Death – He kindly stopped for me – The Carriage held but just Ourselves – And Immortality. - Emily Dickinson",
            "I wandered lonely as a cloud That floats on high o'er vales and hills, When all at once I saw a crowd, A host, of golden daffodils; - William Wordsworth",
            "Shall I compare thee to a summer's day? Thou art more lovely and more temperate: Rough winds do shake the darling buds of May, And summer's lease hath all too short a date; - William Shakespeare",
            "The woods are lovely, dark and deep, But I have promises to keep, And miles to go before I sleep, And miles to go before I sleep. - Robert Frost",
            "I carry your heart with me (I carry it in my heart) I am never without it (anywhere I go you go, my dear; - E.E. Cummings",
            "Hope is the thing with feathers That perches in the soul, And sings the tune without the words, And never stops at all, - Emily Dickinson",
            "Let us go then, you and I, When the evening is spread out against the sky Like a patient etherized upon a table; - T.S. Eliot",
            "So we beat on, boats against the current, borne back ceaselessly into the past. - F. Scott Fitzgerald"
        ];
        
        return poetryTexts[Math.floor(Math.random() * poetryTexts.length)];
    }
    
    /**
     * Copy text to clipboard
     */
    copyToClipboard() {
        if (!this.currentText) {
            botReply('No text to copy');
            return;
        }
        
        this.textArea.select();
        document.execCommand('copy');
        
        botReply('Text copied to clipboard!');
    }
    
    /**
     * Open text style panel
     */
    openTextStylePanel() {
        const panel = this.createPanel('Text Style');
        
        // Bold control
        const boldControl = this.createToggleControl(
            'Bold',
            this.textStyle.fontWeight === 'bold',
            (checked) => {
                this.textStyle.fontWeight = checked ? 'bold' : 'normal';
                this.updateTextStyle();
            }
        );
        
        // Italic control
        const italicControl = this.createToggleControl(
            'Italic',
            this.textStyle.fontStyle === 'italic',
            (checked) => {
                this.textStyle.fontStyle = checked ? 'italic' : 'normal';
                this.updateTextStyle();
            }
        );
        
        // Underline control
        const underlineControl = this.createToggleControl(
            'Underline',
            this.textStyle.textDecoration === 'underline',
            (checked) => {
                this.textStyle.textDecoration = checked ? 'underline' : 'none';
                this.updateTextStyle();
            }
        );
        
        panel.appendChild(boldControl);
        panel.appendChild(italicControl);
        panel.appendChild(underlineControl);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open color panel
     */
    openColorPanel() {
        const panel = this.createPanel('Text Color');
        
        // Text color picker
        const textColorLabel = document.createElement('label');
        textColorLabel.textContent = 'Text Color:';
        textColorLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const textColorPicker = document.createElement('input');
        textColorPicker.type = 'color';
        textColorPicker.value = this.textStyle.color;
        textColorPicker.style.cssText = 'width: 100%; height: 40px; border: none; border-radius: 4px; margin-bottom: 15px;';
        
        textColorPicker.addEventListener('change', (e) => {
            this.textStyle.color = e.target.value;
            this.updateTextStyle();
        });
        
        // Background color picker
        const bgColorLabel = document.createElement('label');
        bgColorLabel.textContent = 'Background Color:';
        bgColorLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const bgColorPicker = document.createElement('input');
        bgColorPicker.type = 'color';
        bgColorPicker.value = this.textStyle.backgroundColor;
        bgColorPicker.style.cssText = 'width: 100%; height: 40px; border: none; border-radius: 4px;';
        
        bgColorPicker.addEventListener('change', (e) => {
            this.textStyle.backgroundColor = e.target.value;
            this.updateTextStyle();
        });
        
        panel.appendChild(textColorLabel);
        panel.appendChild(textColorPicker);
        panel.appendChild(bgColorLabel);
        panel.appendChild(bgColorPicker);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open size panel
     */
    openSizePanel() {
        const panel = this.createPanel('Text Size');
        
        // Font size slider
        const fontSizeLabel = document.createElement('label');
        fontSizeLabel.textContent = 'Font Size:';
        fontSizeLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const fontSizeSlider = document.createElement('input');
        fontSizeSlider.type = 'range';
        fontSizeSlider.min = '12';
        fontSizeSlider.max = '72';
        fontSizeSlider.value = this.textStyle.fontSize;
        fontSizeSlider.style.cssText = 'width: 100%; margin-bottom: 10px;';
        
        const fontSizeValue = document.createElement('div');
        fontSizeValue.textContent = `${this.textStyle.fontSize}px`;
        fontSizeValue.style.cssText = 'text-align: center; margin-bottom: 15px; color: white;';
        
        fontSizeSlider.addEventListener('input', (e) => {
            const size = parseInt(e.target.value);
            this.textStyle.fontSize = size;
            fontSizeValue.textContent = `${size}px`;
            this.updateTextStyle();
        });
        
        // Padding slider
        const paddingLabel = document.createElement('label');
        paddingLabel.textContent = 'Padding:';
        paddingLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const paddingSlider = document.createElement('input');
        paddingSlider.type = 'range';
        paddingSlider.min = '0';
        paddingSlider.max = '50';
        paddingSlider.value = this.textStyle.padding;
        paddingSlider.style.cssText = 'width: 100%; margin-bottom: 10px;';
        
        const paddingValue = document.createElement('div');
        paddingValue.textContent = `${this.textStyle.padding}px`;
        paddingValue.style.cssText = 'text-align: center; margin-bottom: 15px; color: white;';
        
        paddingSlider.addEventListener('input', (e) => {
            const padding = parseInt(e.target.value);
            this.textStyle.padding = padding;
            paddingValue.textContent = `${padding}px`;
            this.updateTextStyle();
        });
        
        panel.appendChild(fontSizeLabel);
        panel.appendChild(fontSizeSlider);
        panel.appendChild(fontSizeValue);
        panel.appendChild(paddingLabel);
        panel.appendChild(paddingSlider);
        panel.appendChild(paddingValue);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open font panel
     */
    openFontPanel() {
        const panel = this.createPanel('Font Family');
        
        const fontSelect = document.createElement('select');
        fontSelect.style.cssText = 'width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #444; background-color: #444; color: white; margin-bottom: 15px;';
        
        const fonts = [
            { value: 'Arial', text: 'Arial' },
            { value: 'Verdana', text: 'Verdana' },
            { value: 'Georgia', text: 'Georgia' },
            { value: 'Times New Roman', text: 'Times New Roman' },
            { value: 'Courier New', text: 'Courier New' },
            { value: 'Impact', text: 'Impact' },
            { value: 'Comic Sans MS', text: 'Comic Sans MS' },
            { value: 'Trebuchet MS', text: 'Trebuchet MS' }
        ];
        
        fonts.forEach(font => {
            const option = document.createElement('option');
            option.value = font.value;
            option.textContent = font.text;
            fontSelect.appendChild(option);
        });
        
        fontSelect.value = this.textStyle.fontFamily;
        
        fontSelect.addEventListener('change', (e) => {
            this.textStyle.fontFamily = e.target.value;
            this.updateTextStyle();
        });
        
        panel.appendChild(fontSelect);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open align panel
     */
    openAlignPanel() {
        const panel = this.createPanel('Text Alignment');
        
        const alignButtons = document.createElement('div');
        alignButtons.style.cssText = 'display: flex; gap: 10px; margin-bottom: 15px;';
        
        const alignments = [
            { value: 'left', label: 'Left' },
            { value: 'center', label: 'Center' },
            { value: 'right', label: 'Right' },
            { value: 'justify', label: 'Justify' }
        ];
        
        alignments.forEach(align => {
            const btn = document.createElement('button');
            btn.textContent = align.label;
            btn.style.cssText = this.getButtonStyle('btn-secondary');
            btn.style.flex = '1';
            
            if (this.textStyle.textAlign === align.value) {
                btn.style.backgroundColor = '#4CAF50';
            }
            
            btn.addEventListener('click', () => {
                this.textStyle.textAlign = align.value;
                this.updateTextStyle();
                
                // Update button styles
                alignButtons.querySelectorAll('button').forEach(b => {
                    b.style.backgroundColor = '#2196F3';
                });
                btn.style.backgroundColor = '#4CAF50';
            });
            
            alignButtons.appendChild(btn);
        });
        
        panel.appendChild(alignButtons);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open effect panel
     */
    openEffectPanel() {
        const panel = this.createPanel('Text Effects');
        
        // Text shadow control
        const shadowControl = this.createToggleControl(
            'Text Shadow',
            this.textStyle.textShadow !== 'none',
            (checked) => {
                this.textStyle.textShadow = checked ? '2px 2px 4px rgba(0, 0, 0, 0.5)' : 'none';
                this.updateTextStyle();
            }
        );
        
        // Border radius control
        const borderRadiusLabel = document.createElement('label');
        borderRadiusLabel.textContent = 'Border Radius:';
        borderRadiusLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const borderRadiusSlider = document.createElement('input');
        borderRadiusSlider.type = 'range';
        borderRadiusSlider.min = '0';
        borderRadiusSlider.max = '20';
        borderRadiusSlider.value = this.textStyle.borderRadius;
        borderRadiusSlider.style.cssText = 'width: 100%; margin-bottom: 10px;';
        
        const borderRadiusValue = document.createElement('div');
        borderRadiusValue.textContent = `${this.textStyle.borderRadius}px`;
        borderRadiusValue.style.cssText = 'text-align: center; margin-bottom: 15px; color: white;';
        
        borderRadiusSlider.addEventListener('input', (e) => {
            const radius = parseInt(e.target.value);
            this.textStyle.borderRadius = radius;
            borderRadiusValue.textContent = `${radius}px`;
            this.updateTextStyle();
        });
        
        panel.appendChild(shadowControl);
        panel.appendChild(borderRadiusLabel);
        panel.appendChild(borderRadiusSlider);
        panel.appendChild(borderRadiusValue);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open animation panel
     */
    openAnimationPanel() {
        const panel = this.createPanel('Text Animation');
        
        // Animation type select
        const animTypeLabel = document.createElement('label');
        animTypeLabel.textContent = 'Animation Type:';
        animTypeLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const animTypeSelect = document.createElement('select');
        animTypeSelect.style.cssText = 'width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #444; background-color: #444; color: white; margin-bottom: 15px;';
        
        const animations = [
            { value: 'none', text: 'None' },
            { value: 'fadeIn', text: 'Fade In' },
            { value: 'slideIn', text: 'Slide In' },
            { value: 'bounce', text: 'Bounce' },
            { value: 'pulse', text: 'Pulse' }
        ];
        
        animations.forEach(anim => {
            const option = document.createElement('option');
            option.value = anim.value;
            option.textContent = anim.text;
            animTypeSelect.appendChild(option);
        });
        
        animTypeSelect.value = this.animationType;
        
        animTypeSelect.addEventListener('change', (e) => {
            this.animationType = e.target.value;
            if (this.currentText) {
                this.applyAnimation();
            }
        });
        
        // Animation speed slider
        const animSpeedLabel = document.createElement('label');
        animSpeedLabel.textContent = 'Animation Speed:';
        animSpeedLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const animSpeedSlider = document.createElement('input');
        animSpeedSlider.type = 'range';
        animSpeedSlider.min = '0.5';
        animSpeedSlider.max = '3';
        animSpeedSlider.step = '0.5';
        animSpeedSlider.value = this.animationSpeed;
        animSpeedSlider.style.cssText = 'width: 100%; margin-bottom: 10px;';
        
        const animSpeedValue = document.createElement('div');
        animSpeedValue.textContent = `${this.animationSpeed}s`;
        animSpeedValue.style.cssText = 'text-align: center; margin-bottom: 15px; color: white;';
        
        animSpeedSlider.addEventListener('input', (e) => {
            this.animationSpeed = parseFloat(e.target.value);
            animSpeedValue.textContent = `${this.animationSpeed}s`;
        });
        
        panel.appendChild(animTypeLabel);
        panel.appendChild(animTypeSelect);
        panel.appendChild(animSpeedLabel);
        panel.appendChild(animSpeedSlider);
        panel.appendChild(animSpeedValue);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open category panel
     */
    openCategoryPanel() {
        const panel = this.createPanel('Text Category');
        
        const categoryButtons = document.createElement('div');
        categoryButtons.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px;';
        
        this.textCategories.forEach(category => {
            const btn = document.createElement('button');
            btn.textContent = category.charAt(0).toUpperCase() + category.slice(1);
            btn.style.cssText = this.getButtonStyle('btn-secondary');
            
            if (this.selectedCategory === category) {
                btn.style.backgroundColor = '#4CAF50';
            }
            
            btn.addEventListener('click', () => {
                this.selectedCategory = category;
                
                // Update button styles
                categoryButtons.querySelectorAll('button').forEach(b => {
                    b.style.backgroundColor = '#2196F3';
                });
                btn.style.backgroundColor = '#4CAF50';
                
                botReply(`Selected category: ${category}`);
            });
            
            categoryButtons.appendChild(btn);
        });
        
        panel.appendChild(categoryButtons);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Apply random style
     */
    applyRandomStyle() {
        // Random color
        const randomColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
        this.textStyle.color = randomColor;
        
        // Random background color
        const randomBgColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
        this.textStyle.backgroundColor = randomBgColor;
        
        // Random font size
        this.textStyle.fontSize = Math.floor(Math.random() * 40) + 16;
        
        // Random font family
        const fonts = ['Arial', 'Verdana', 'Georgia', 'Times New Roman', 'Courier New', 'Impact'];
        this.textStyle.fontFamily = fonts[Math.floor(Math.random() * fonts.length)];
        
        // Random alignment
        const alignments = ['left', 'center', 'right'];
        this.textStyle.textAlign = alignments[Math.floor(Math.random() * alignments.length)];
        
        // Random bold/italic
        this.textStyle.fontWeight = Math.random() > 0.5 ? 'bold' : 'normal';
        this.textStyle.fontStyle = Math.random() > 0.5 ? 'italic' : 'normal';
        
        // Random text shadow
        this.textStyle.textShadow = Math.random() > 0.5 ? '2px 2px 4px rgba(0, 0, 0, 0.5)' : 'none';
        
        // Random border radius
        this.textStyle.borderRadius = Math.floor(Math.random() * 15);
        
        // Random animation
        const animations = ['none', 'fadeIn', 'slideIn', 'bounce', 'pulse'];
        this.animationType = animations[Math.floor(Math.random() * animations.length)];
        
        this.updateTextStyle();
        
        if (this.currentText) {
            this.applyAnimation();
        }
        
        botReply('Applied random style');
    }
    
    /**
     * Update text style
     */
    updateTextStyle() {
        this.textDisplay.style.color = this.textStyle.color;
        this.textDisplay.style.backgroundColor = this.textStyle.backgroundColor;
        this.textDisplay.style.fontSize = `${this.textStyle.fontSize}px`;
        this.textDisplay.style.fontFamily = this.textStyle.fontFamily;
        this.textDisplay.style.textAlign = this.textStyle.textAlign;
        this.textDisplay.style.fontWeight = this.textStyle.fontWeight;
        this.textDisplay.style.fontStyle = this.textStyle.fontStyle;
        this.textDisplay.style.textDecoration = this.textStyle.textDecoration;
        this.textDisplay.style.textShadow = this.textStyle.textShadow;
        this.textDisplay.style.padding = `${this.textStyle.padding}px`;
        this.textDisplay.style.borderRadius = `${this.textStyle.borderRadius}px`;
    }
    
    /**
     * Apply animation
     */
    applyAnimation() {
        // Remove existing animation classes
        this.textDisplay.className = '';
        
        if (this.animationType !== 'none') {
            // Apply animation
            this.textDisplay.style.animation = `${this.animationType} ${this.animationSpeed}s ease`;
            
            // Remove animation after it completes
            setTimeout(() => {
                this.textDisplay.style.animation = '';
            }, this.animationSpeed * 1000);
        }
    }
    
    /**
     * Create a panel
     */
    createPanel(title) {
        const panel = document.createElement('div');
        panel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 300px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const panelTitle = document.createElement('h3');
        panelTitle.textContent = title;
        panelTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        panel.appendChild(panelTitle);
        
        // Close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-secondary');
        closeButton.style.width = '100%';
        closeButton.style.marginTop = '15px';
        
        closeButton.addEventListener('click', () => {
            panel.remove();
        });
        
        panel.appendChild(closeButton);
        
        return panel;
    }
    
    /**
     * Create a toggle control
     */
    createToggleControl(label, isChecked, onChange) {
        const control = document.createElement('div');
        control.style.cssText = 'margin-bottom: 15px; display: flex; align-items: center;';
        
        const controlLabel = document.createElement('label');
        controlLabel.textContent = label;
        controlLabel.style.cssText = 'flex: 1; color: white;';
        
        const toggle = document.createElement('input');
        toggle.type = 'checkbox';
        toggle.checked = isChecked;
        toggle.style.cssText = 'width: 20px; height: 20px;';
        
        toggle.addEventListener('change', (e) => {
            onChange(e.target.checked);
        });
        
        control.appendChild(controlLabel);
        control.appendChild(toggle);
        
        return control;
    }
    
    /**
     * Set up action buttons
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        switch (event.key) {
            case 'Escape':
                if (this.isFullscreen) {
                    this.exitFullscreen();
                } else {
                    this.closeGame();
                }
                break;
            case 'g':
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.generateRandomText();
                }
                break;
            case 'c':
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.copyToClipboard();
                }
                break;
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.leftToolbar = null;
        this.textDisplay = null;
        this.textArea = null;
        this.currentText = '';
        this.textStyle = {
            fontSize: 24,
            fontFamily: 'Arial',
            color: '#ffffff',
            backgroundColor: '#222222',
            textAlign: 'center',
            fontWeight: 'normal',
            fontStyle: 'normal',
            textDecoration: 'none',
            textShadow: 'none',
            padding: 20,
            borderRadius: 8,
            width: 80,
            height: 30
        };
        this.animationType = 'none';
        this.animationSpeed = 1;
        this.textCategories = [
            'lorem', 'quotes', 'funny', 'tech', 'philosophy', 'poetry'
        ];
        this.selectedCategory = 'lorem';
        this.textHistory = [];
        this.buttonTimeout = null;
        this.activeButton = null;
        
        botReply("Random Text Generator closed. Thank you!");
    }
}

// Create a singleton instance
const randomText = new RandomText();

// Add this to your AI's command handling
if (/random text|text generator|randtext/i.test(userInputRaw)) {
    randomText.loadRandomText();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    randomText.closeGame();
    return;
}

class NetworkFinder {
    constructor() {
        this.appName = 'NETWORK FINDER';
        this.instructions = 'Identify the mobile network provider from a phone number.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.numberInput = null;
        this.resultDisplay = null;
        this.historyPanel = null;
        this.currentNumber = '';
        this.searchHistory = [];
        
        // Network prefix data for Indian mobile numbers
        this.networkData = {
            'Jio': {
                prefixes: ['6', '7', '8', '9'],
                color: '#0081ff',
                icon: '📡'
            },
            'Airtel': {
                prefixes: ['98', '99', '96', '95', '94', '93', '92', '91', '90', '89', '88', '87', '86', '85', '84', '83', '82', '81', '80', '70'],
                color: '#ef1a25',
                icon: '📱'
            },
            'Vi (Idea/Vodafone)': {
                prefixes: ['98', '99', '96', '95', '94', '93', '92', '91', '90', '89', '88', '87', '86', '85', '84', '83', '82', '81', '80', '79', '78', '77', '76', '75', '74', '73', '72', '71', '70'],
                color: '#ff5100',
                icon: '📶'
            },
            'BSNL': {
                prefixes: ['94', '95', '96', '97', '98', '99', '92', '93', '90', '91', '88', '89', '86', '87', '84', '85', '82', '83', '80', '81'],
                color: '#0051ba',
                icon: '📞'
            },
            'Vodafone': {
                prefixes: ['98', '99', '96', '95', '94', '93', '92', '91', '90', '89', '88', '87', '86', '85', '84', '83', '82', '81', '80', '79', '78', '77', '76', '75', '74', '73', '72', '71', '70'],
                color: '#e60000',
                icon: '🌐'
            }
        };
    }
    
    /**
     * Load the Network Finder
     */
    loadNetworkFinder() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        this.createAppContainer();
        this.createNetworkFinderUI();
        this.setupActionButtons();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
    }
    
    /**
     * Create the Network Finder UI with new design
     */
    createNetworkFinderUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 800px;
            height: 85vh;
            max-height: 700px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '🔍';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex: 1;
            overflow: hidden;
        `;
        
        // Create left panel for input
        const leftPanel = document.createElement('div');
        leftPanel.style.cssText = `
            width: 40%;
            padding: 30px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Input section
        const inputSection = document.createElement('div');
        inputSection.style.cssText = `
            margin-bottom: 30px;
        `;
        
        const inputLabel = document.createElement('div');
        inputLabel.textContent = 'Enter Mobile Number';
        inputLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: 500;
        `;
        
        this.numberInput = document.createElement('input');
        this.numberInput.type = 'tel';
        this.numberInput.placeholder = 'Enter 10-digit number';
        this.numberInput.style.cssText = `
            width: 100%;
            padding: 18px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 18px;
            margin-bottom: 20px;
            outline: none;
            transition: all 0.3s ease;
        `;
        
        // Add input validation
        this.numberInput.addEventListener('input', (e) => {
            // Remove non-numeric characters
            e.target.value = e.target.value.replace(/[^0-9]/g, '');
            
            // Limit to 10 digits
            if (e.target.value.length > 10) {
                e.target.value = e.target.value.slice(0, 10);
            }
        });
        
        // Add focus effect
        this.numberInput.addEventListener('focus', () => {
            this.numberInput.style.borderColor = 'rgba(255, 255, 255, 0.5)';
            this.numberInput.style.boxShadow = '0 0 0 3px rgba(255, 255, 255, 0.1)';
        });
        
        this.numberInput.addEventListener('blur', () => {
            this.numberInput.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            this.numberInput.style.boxShadow = 'none';
        });
        
        // Create action buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
        `;
        
        const findButton = document.createElement('button');
        findButton.textContent = 'Find Network';
        findButton.style.cssText = `
            flex: 1;
            padding: 15px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        `;
        
        findButton.addEventListener('mouseover', () => {
            findButton.style.transform = 'translateY(-2px)';
            findButton.style.boxShadow = '0 6px 20px rgba(76, 175, 80, 0.4)';
        });
        
        findButton.addEventListener('mouseout', () => {
            findButton.style.transform = 'translateY(0)';
            findButton.style.boxShadow = '0 4px 15px rgba(76, 175, 80, 0.3)';
        });
        
        findButton.addEventListener('click', () => this.findNetwork());
        
        const randomButton = document.createElement('button');
        randomButton.textContent = 'Random';
        randomButton.style.cssText = `
            padding: 15px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(90deg, #2196F3, #0b7dda);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        `;
        
        randomButton.addEventListener('mouseover', () => {
            randomButton.style.transform = 'translateY(-2px)';
            randomButton.style.boxShadow = '0 6px 20px rgba(33, 150, 243, 0.4)';
        });
        
        randomButton.addEventListener('mouseout', () => {
            randomButton.style.transform = 'translateY(0)';
            randomButton.style.boxShadow = '0 4px 15px rgba(33, 150, 243, 0.3)';
        });
        
        randomButton.addEventListener('click', () => this.generateRandomNumber());
        
        buttonContainer.appendChild(findButton);
        buttonContainer.appendChild(randomButton);
        
        // Create network info section
        const networkInfo = document.createElement('div');
        networkInfo.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        `;
        
        const infoTitle = document.createElement('div');
        infoTitle.textContent = 'Supported Networks';
        infoTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: 500;
        `;
        
        const networkList = document.createElement('div');
        networkList.style.cssText = `
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        `;
        
        Object.entries(this.networkData).forEach(([network, data]) => {
            const networkItem = document.createElement('div');
            networkItem.style.cssText = `
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px;
                border-radius: 8px;
                background-color: rgba(255, 255, 255, 0.03);
            `;
            
            const networkIcon = document.createElement('div');
            networkIcon.textContent = data.icon;
            networkIcon.style.cssText = `
                font-size: 18px;
            `;
            
            const networkName = document.createElement('div');
            networkName.textContent = network;
            networkName.style.cssText = `
                color: ${data.color};
                font-weight: 500;
            `;
            
            networkItem.appendChild(networkIcon);
            networkItem.appendChild(networkName);
            networkList.appendChild(networkItem);
        });
        
        networkInfo.appendChild(infoTitle);
        networkInfo.appendChild(networkList);
        
        inputSection.appendChild(inputLabel);
        inputSection.appendChild(this.numberInput);
        inputSection.appendChild(buttonContainer);
        leftPanel.appendChild(inputSection);
        leftPanel.appendChild(networkInfo);
        
        // Create right panel for results
        const rightPanel = document.createElement('div');
        rightPanel.style.cssText = `
            width: 60%;
            padding: 30px;
            display: flex;
            flex-direction: column;
        `;
        
        // Results section
        const resultsSection = document.createElement('div');
        resultsSection.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
        `;
        
        const resultsTitle = document.createElement('div');
        resultsTitle.textContent = 'Network Result';
        resultsTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            margin-bottom: 20px;
            font-weight: 500;
        `;
        
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 30px;
            min-height: 300px;
            transition: all 0.3s ease;
        `;
        
        const placeholderContent = document.createElement('div');
        placeholderContent.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        `;
        
        const placeholderIcon = document.createElement('div');
        placeholderIcon.textContent = '📱';
        placeholderIcon.style.cssText = `
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        `;
        
        const placeholderText = document.createElement('div');
        placeholderText.textContent = 'Enter a mobile number to identify its network';
        placeholderText.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 18px;
            max-width: 80%;
        `;
        
        placeholderContent.appendChild(placeholderIcon);
        placeholderContent.appendChild(placeholderText);
        this.resultDisplay.appendChild(placeholderContent);
        
        resultsSection.appendChild(resultsTitle);
        resultsSection.appendChild(this.resultDisplay);
        
        // History section
        const historySection = document.createElement('div');
        historySection.style.cssText = `
            margin-top: 30px;
        `;
        
        const historyHeader = document.createElement('div');
        historyHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const historyTitle = document.createElement('div');
        historyTitle.textContent = 'Recent Searches';
        historyTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            font-weight: 500;
        `;
        
        const clearHistoryBtn = document.createElement('button');
        clearHistoryBtn.textContent = 'Clear';
        clearHistoryBtn.style.cssText = `
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearHistoryBtn.addEventListener('mouseover', () => {
            clearHistoryBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        });
        
        clearHistoryBtn.addEventListener('mouseout', () => {
            clearHistoryBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
        });
        
        clearHistoryBtn.addEventListener('click', () => this.clearHistory());
        
        historyHeader.appendChild(historyTitle);
        historyHeader.appendChild(clearHistoryBtn);
        
        this.historyPanel = document.createElement('div');
        this.historyPanel.style.cssText = `
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding-bottom: 5px;
        `;
        
        this.updateHistoryPanel();
        
        historySection.appendChild(historyHeader);
        historySection.appendChild(this.historyPanel);
        
        rightPanel.appendChild(resultsSection);
        rightPanel.appendChild(historySection);
        
        mainContent.appendChild(leftPanel);
        mainContent.appendChild(rightPanel);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
        
        // Add keyboard event listeners
        this.setupKeyboardEvents();
    }
    
    /**
     * Update history panel with recent searches
     */
    updateHistoryPanel() {
        this.historyPanel.innerHTML = '';
        
        if (this.searchHistory.length === 0) {
            const noHistory = document.createElement('div');
            noHistory.textContent = 'No recent searches';
            noHistory.style.cssText = `
                color: rgba(255, 255, 255, 0.5);
                font-size: 14px;
                padding: 10px 0;
            `;
            this.historyPanel.appendChild(noHistory);
            return;
        }
        
        this.searchHistory.slice(0, 5).forEach((item) => {
            const historyItem = document.createElement('div');
            historyItem.style.cssText = `
                min-width: 120px;
                padding: 12px;
                border-radius: 10px;
                background-color: rgba(255, 255, 255, 0.05);
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                flex-direction: column;
                align-items: center;
            `;
            
            const networkColor = this.networkData[item.network]?.color || '#888888';
            
            const numberDisplay = document.createElement('div');
            numberDisplay.textContent = `${item.number.substring(0, 5)} ${item.number.substring(5)}`;
            numberDisplay.style.cssText = `
                font-weight: 600;
                margin-bottom: 5px;
            `;
            
            const networkDisplay = document.createElement('div');
            networkDisplay.textContent = item.network;
            networkDisplay.style.cssText = `
                color: ${networkColor};
                font-size: 12px;
                font-weight: 500;
            `;
            
            historyItem.appendChild(numberDisplay);
            historyItem.appendChild(networkDisplay);
            
            historyItem.addEventListener('click', () => {
                this.numberInput.value = item.number;
                this.findNetwork();
            });
            
            historyItem.addEventListener('mouseenter', () => {
                historyItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                historyItem.style.transform = 'translateY(-2px)';
            });
            
            historyItem.addEventListener('mouseleave', () => {
                historyItem.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
                historyItem.style.transform = 'translateY(0)';
            });
            
            this.historyPanel.appendChild(historyItem);
        });
    }
    
    /**
     * Clear search history
     */
    clearHistory() {
        this.searchHistory = [];
        this.updateHistoryPanel();
        botReply('Search history cleared');
    }
    
    /**
     * Find network for the entered number
     */
    findNetwork() {
        const number = this.numberInput.value.trim();
        
        if (!number) {
            this.displayResult('Please enter a mobile number');
            return;
        }
        
        if (number.length !== 10) {
            this.displayResult('Please enter a valid 10-digit mobile number');
            return;
        }
        
        this.currentNumber = number;
        const network = this.identifyNetwork(number);
        
        // Add to history
        this.searchHistory.unshift({
            number: number,
            network: network,
            timestamp: new Date()
        });
        
        // Keep only last 10 searches
        if (this.searchHistory.length > 10) {
            this.searchHistory = this.searchHistory.slice(0, 10);
        }
        
        this.updateHistoryPanel();
        this.displayResult(network, number);
    }
    
    /**
     * Identify network from mobile number
     */
 /**
 * Identify network from mobile number with corrected data
 */
identifyNetwork(number) {
    // More specific network identification based on first 4 digits
    const firstFourDigits = number.substring(0, 4);
    
    // More accurate prefix data for Indian mobile numbers
    const specificPrefixes = {
        'Jio': [
            '6001', '6002', '6003', '6004', '6005', '6006', '6007', '6008', '6009',
            '6101', '6102', '6103', '6104', '6105', '6106', '6107', '6108', '6109',
            '6201', '6202', '6203', '6204', '6205', '6206', '6207', '6208', '6209',
            '6301', '6302', '6303', '6304', '6305', '6306', '6307', '6308', '6309',
            '7001', '7002', '7003', '7004', '7005', '7006', '7007', '7008', '7009',
            '7901', '7902', '7903', '7904', '7905', '7906', '7907', '7908', '7909',
            '8001', '8002', '8003', '8004', '8005', '8006', '8007', '8008', '8009',
            '8101', '8102', '8103', '8104', '8105', '8106', '8107', '8108', '8109',
            '8201', '8202', '8203', '8204', '8205', '8206', '8207', '8208', '8209',
            '9001', '9002', '9003', '9004', '9005', '9006', '9007', '9008', '9009',
            '9101', '9102', '9103', '9104', '9105', '9106', '9107', '9108', '9109',
            '9201', '9202', '9203', '9204', '9205', '9206', '9207', '9208', '9209',
            '9301', '9302', '9303', '9304', '9305', '9306', '9307', '9308', '9309',
            '9401', '9402', '9403', '9404', '9405', '9406', '9407', '9408', '9409',
            '9501', '9502', '9503', '9504', '9505', '9506', '9507', '9508', '9509',
            '9601', '9602', '9603', '9604', '9605', '9606', '9607', '9608', '9609',
            '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709',
            '9801', '9802', '9803', '9804', '9805', '9806', '9807', '9808', '9809',
            '9901', '9902', '9903', '9904', '9905', '9906', '9907', '9908', '9909'
        ],
        'Airtel': [
            '9801', '9802', '9803', '9804', '9805', '9806', '9807', '9808', '9809',
            '9901', '9902', '9903', '9904', '9905', '9906', '9907', '9908', '9909',
            '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709',
            '9601', '9602', '9603', '9604', '9605', '9606', '9607', '9608', '9609',
            '9501', '9502', '9503', '9504', '9505', '9506', '9507', '9508', '9509',
            '9401', '9402', '9403', '9404', '9405', '9406', '9407', '9408', '9409',
            '9301', '9302', '9303', '9304', '9305', '9306', '9307', '9308', '9309',
            '9201', '9202', '9203', '9204', '9205', '9206', '9207', '9208', '9209',
            '9101', '9102', '9103', '9104', '9105', '9106', '9107', '9108', '9109',
            '9001', '9002', '9003', '9004', '9005', '9006', '9007', '9008', '9009'
        ],
        'Vi (Idea/Vodafone)': [
            '9801', '9802', '9803', '9804', '9805', '9806', '9807', '9808', '9809',
            '9901', '9902', '9903', '9904', '9905', '9906', '9907', '9908', '9909',
            '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709',
            '9601', '9602', '9603', '9604', '9605', '9606', '9607', '9608', '9609',
            '9501', '9502', '9503', '9504', '9505', '9506', '9507', '9508', '9509',
            '9401', '9402', '9403', '9404', '9405', '9406', '9407', '9408', '9409',
            '9301', '9302', '9303', '9304', '9305', '9306', '9307', '9308', '9309',
            '9201', '9202', '9203', '9204', '9205', '9206', '9207', '9208', '9209',
            '9101', '9102', '9103', '9104', '9105', '9106', '9107', '9108', '9109',
            '9001', '9002', '9003', '9004', '9005', '9006', '9007', '9008', '9009'
        ],
        'BSNL': [
            '9401', '9402', '9403', '9404', '9405', '9406', '9407', '9408', '9409',
            '9501', '9502', '9503', '9504', '9505', '9506', '9507', '9508', '9509',
            '9601', '9602', '9603', '9604', '9605', '9606', '9607', '9608', '9609',
            '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709',
            '9801', '9802', '9803', '9804', '9805', '9806', '9807', '9808', '9809',
            '9901', '9902', '9903', '9904', '9905', '9906', '9907', '9908', '9909'
        ],
        'Vodafone': [
            '9952', '9953', '9954', '9955', '9956', '9957', '9958', '9959',
            '9960', '9961', '9962', '9963', '9964', '9965', '9966', '9967', '9968', '9969',
            '9970', '9971', '9972', '9973', '9974', '9975', '9976', '9977', '9978', '9979',
            '9980', '9981', '9982', '9983', '9984', '9985', '9986', '9987', '9988', '9989',
            '9990', '9991', '9992', '9993', '9994', '9995', '9996', '9997', '9998', '9999'
        ]
    };
    
    // Check if the first 4 digits match any specific network prefix
    for (const [network, prefixes] of Object.entries(specificPrefixes)) {
        if (prefixes.includes(firstFourDigits)) {
            return network;
        }
    }
    
    // If not found in specific prefixes, check first 2 digits
    const firstTwoDigits = number.substring(0, 2);
    
    // Fallback to broader prefix matching
    const broaderPrefixes = {
        'Jio': ['6', '7'],
        'Airtel': ['98', '99', '96', '95', '94', '93', '92', '91', '90'],
        'Vi (Idea/Vodafone)': ['98', '99', '96', '95', '94', '93', '92', '91', '90'],
        'BSNL': ['94', '95', '96', '97', '98', '99'],
        'Vodafone': ['98', '99']
    };
    
    // Check for exact match with first 2 digits
    for (const [network, prefixes] of Object.entries(broaderPrefixes)) {
        if (prefixes.includes(firstTwoDigits)) {
            return network;
        }
    }
    
    // If still not found, check first digit
    const firstDigit = number.substring(0, 1);
    
    for (const [network, prefixes] of Object.entries(broaderPrefixes)) {
        if (prefixes.includes(firstDigit)) {
            return network;
        }
    }
    
    return 'Unknown';
}
    
    /**
     * Display the result with new design
     */
    displayResult(network, number) {
        this.resultDisplay.innerHTML = '';
        
        if (!number) {
            const errorContent = document.createElement('div');
            errorContent.style.cssText = `
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-align: center;
            `;
            
            const errorIcon = document.createElement('div');
            errorIcon.textContent = '⚠️';
            errorIcon.style.cssText = `
                font-size: 64px;
                margin-bottom: 20px;
            `;
            
            const errorText = document.createElement('div');
            errorText.textContent = network;
            errorText.style.cssText = `
                color: rgba(255, 255, 255, 0.8);
                font-size: 20px;
                max-width: 80%;
            `;
            
            errorContent.appendChild(errorIcon);
            errorContent.appendChild(errorText);
            this.resultDisplay.appendChild(errorContent);
            return;
        }
        
        // Format the number for display
        const formattedNumber = `${number.substring(0, 5)} ${number.substring(5)}`;
        
        // Get network data
        const networkData = this.networkData[network] || {
            color: '#888888',
            icon: '❓'
        };
        
        // Create result content
        const resultContent = document.createElement('div');
        resultContent.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            animation: fadeIn 0.5s ease;
        `;
        
        // Network icon
        const networkIcon = document.createElement('div');
        networkIcon.textContent = networkData.icon;
        networkIcon.style.cssText = `
            font-size: 80px;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px ${networkData.color}40);
        `;
        
        // Number display
        const numberDisplay = document.createElement('div');
        numberDisplay.textContent = formattedNumber;
        numberDisplay.style.cssText = `
            font-size: 32px;
            margin-bottom: 20px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        // Network display
        const networkDisplay = document.createElement('div');
        networkDisplay.textContent = network;
        networkDisplay.style.cssText = `
            font-size: 28px;
            font-weight: 700;
            color: ${networkData.color};
            padding: 12px 30px;
            border-radius: 30px;
            background-color: ${networkData.color}20;
            border: 2px solid ${networkData.color}40;
            margin-bottom: 20px;
        `;
        
        // Status message
        const statusMessage = document.createElement('div');
        statusMessage.textContent = 'Network identified successfully';
        statusMessage.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
        `;
        
        resultContent.appendChild(networkIcon);
        resultContent.appendChild(numberDisplay);
        resultContent.appendChild(networkDisplay);
        resultContent.appendChild(statusMessage);
        
        this.resultDisplay.appendChild(resultContent);
    }
    
    /**
     * Generate a random mobile number
     */
    generateRandomNumber() {
        // Generate a random 10-digit number starting with 6, 7, 8, or 9
        const firstDigit = Math.floor(Math.random() * 4) + 6;
        let randomNumber = firstDigit.toString();
        
        for (let i = 0; i < 9; i++) {
            randomNumber += Math.floor(Math.random() * 10);
        }
        
        this.numberInput.value = randomNumber;
        this.findNetwork();
    }
    
    /**
     * Set up action buttons
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0f3460, #16213e);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.fullscreenButton.addEventListener('mouseover', () => {
            this.fullscreenButton.style.transform = 'scale(1.1)';
        });
        
        this.fullscreenButton.addEventListener('mouseout', () => {
            this.fullscreenButton.style.transform = 'scale(1)';
        });
        
        this.fullscreenButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        });
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '✕';
        this.closeButton.style.cssText = `
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, #e53935, #c62828);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.closeButton.addEventListener('mouseover', () => {
            this.closeButton.style.transform = 'scale(1.1)';
        });
        
        this.closeButton.addEventListener('mouseout', () => {
            this.closeButton.style.transform = 'scale(1)';
        });
        
        this.closeButton.addEventListener('click', (e) => {
            e.stopPropagation();
            this.closeApp();
        });
        
        floatingButtons.appendChild(this.closeButton);
        
        this.appContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.appContainer) return;
        
        if (this.appContainer.requestFullscreen) {
            this.appContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.appContainer.webkitRequestFullscreen) {
            this.appContainer.webkitRequestFullscreen();
        } else if (this.appContainer.msRequestFullscreen) {
            this.appContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        switch (event.key) {
            case 'Escape':
                if (this.isFullscreen) {
                    this.exitFullscreen();
                } else {
                    this.closeApp();
                }
                break;
            case 'Enter':
                if (document.activeElement === this.numberInput) {
                    event.preventDefault();
                    this.findNetwork();
                }
                break;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        if (!this.isActive) return;
        
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        // Reset variables
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.numberInput = null;
        this.resultDisplay = null;
        this.historyPanel = null;
        this.currentNumber = '';
        this.searchHistory = [];
        
        botReply("Network Finder closed. Thank you!");
    }
}

// Create a singleton instance
const networkFinder = new NetworkFinder();

// Add this to your AI's command handling
if (/network finder|number finder|find network|network check/i.test(userInputRaw)) {
    networkFinder.loadNetworkFinder();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    networkFinder.closeApp();
    return;
}
/**
 * Advanced Code Error Fixing System - Enhanced Version
 * Detects and fixes errors in multiple programming languages with improved performance
 */
const AdvancedCodeFixer = {
    // Language detection patterns
    languagePatterns: {
        javascript: /(?:function|var|let|const|=>|console\.log|document\.getElementById)/,
        python: /(?:def |import |from |print\(|if __name__|:|\s{4})/,
        java: /(?:public class|public static void main|System\.out\.println|private|protected)/,
        html: /<!DOCTYPE html>|<html|<head|<body|<div|<span|<p>/,
        css: /(?:@media|{|}|:\s*;|#[a-fA-F0-9]{3,6}|rgb\(|rgba\()/,
        cpp: /#include|using namespace std|int main\(\)|cout|cin|std::/,
        csharp: /using System|namespace|public class|Console\.Write|static void Main/,
        php: /<\?php|\$\w+|echo|function |require_once|include_once/,
        ruby: /def |require |puts |if |end|@/,
        swift: /import UIKit|let |var |@IBOutlet|@IBAction|func /,
        typescript: /(?:interface|type|namespace|declare|private|public|protected|readonly|:)/,
        go: /(?:package main|import \(|func |fmt\.Print|go |defer )/,
        rust: /(?:fn |let |mut |use |extern crate|println!)/,
        kotlin: /(?:fun |val |var |: String|: Int|import kotlin)/
    },
    
    // Language cache for faster detection
    languageCache: new Map(),
    
    // Pre-compiled patterns cache
    compiledPatterns: {},
    
    // Initialize compiled patterns
    init: function() {
        // Pre-compile all regex patterns for better performance
        for (const [lang, patterns] of Object.entries(this.errorPatterns)) {
            this.compiledPatterns[lang] = patterns.map(p => ({
                ...p,
                compiledPattern: new RegExp(p.pattern.source, p.pattern.flags)
            }));
        }
    },
    
    // Common error patterns and fixes by language
    errorPatterns: {
        javascript: [
            {
                name: "Missing semicolon",
                pattern: /(\w+\s*[=+\-*/]?\s*[^(;{])$\n/gm,
                fix: "$1;",
                description: "Added missing semicolon"
            },
            {
                name: "Using assignment instead of comparison",
                pattern: /if\s*\(([^=]+)=([^=]+)\)/g,
                fix: "if ($1===$2)",
                description: "Changed assignment (=) to strict equality (===)"
            },
            {
                name: "Unmatched bracket",
                pattern: /(\{|\(|\[)([^}]*)$/gm,
                fix: (match, openBracket, content) => {
                    const closeBracket = openBracket === '{' ? '}' : openBracket === '(' ? ')' : ']';
                    return openBracket + content + closeBracket;
                },
                description: "Added missing closing bracket"
            },
            {
                name: "String concatenation instead of template literals",
                pattern: /console\.log\(\s*["'](.+?)["']\s*\+\s*(.+?)\s*\)/g,
                fix: "console.log(`$1${$2}`)",
                description: "Replaced string concatenation with template literals"
            },
            {
                name: "Var instead of let/const",
                pattern: /\bvar\s+(\w+)/g,
                fix: (match, varName) => {
                    // Simple heuristic: use const if the variable is only assigned once
                    return `const ${varName}`;
                },
                description: "Replaced 'var' with 'const'"
            },
            {
                name: "Missing return statement",
                pattern: /function\s+\w+\s*\([^)]*\)\s*\{[^}]*\}(?!\s*return)/g,
                fix: (match) => {
                    // Simple heuristic: add return if function doesn't already have one
                    if (!match.includes('return ')) {
                        return match.replace(/\}$/, '  return null;\n}');
                    }
                    return match;
                },
                description: "Added missing return statement"
            },
            {
                name: "Async function without await",
                pattern: /async\s+function\s+\w+\s*\([^)]*\)\s*\{(?![^}]*await)/g,
                fix: (match) => {
                    return match.replace('async function ', 'function ');
                },
                description: "Removed async keyword as no await was found"
            }
        ],
        python: [
            {
                name: "Missing colon",
                pattern: /(def |if |for |while |class )([^:]+)$/gm,
                fix: "$1$2:",
                description: "Added missing colon"
            },
            {
                name: "Indentation error",
                pattern: /^(\s+)(def |if |for |while |class )/gm,
                fix: (match, spaces, keyword) => {
                    // Ensure 4 spaces for indentation
                    const indent = "    ".repeat(Math.ceil(spaces.length / 4));
                    return indent + keyword;
                },
                description: "Fixed indentation to 4 spaces"
            },
            {
                name: "Print statement instead of function",
                pattern: /print\s+(.+)/g,
                fix: "print($1)",
                description: "Changed print statement to print function"
            },
            {
                name: "Missing self parameter",
                pattern: /def\s+(\w+)\s*\([^)]*self[^)]*\)/g,
                fix: (match, methodName) => {
                    if (!match.includes('self')) {
                        return match.replace(/\(([^)]*)\)/, '(self, $1)');
                    }
                    return match;
                },
                description: "Added missing self parameter to method"
            }
        ],
        java: [
            {
                name: "Missing semicolon",
                pattern: /(\w+\s*[=+\-*/]?\s*[^(;{])$\n/gm,
                fix: "$1;",
                description: "Added missing semicolon"
            },
            {
                name: "Class name convention",
                pattern: /class\s+([a-z][a-zA-Z0-9]*)/g,
                fix: (match, className) => {
                    // Capitalize first letter
                    return "class " + className.charAt(0).toUpperCase() + className.slice(1);
                },
                description: "Capitalized class name"
            },
            {
                name: "String concatenation",
                pattern: /System\.out\.print\(\s*"(.+?)"\s*\+\s*(.+?)\s*\)/g,
                fix: 'System.out.println("$1" + $2)',
                description: "Improved string concatenation formatting"
            },
            {
                name: "Missing public static void main",
                pattern: /class\s+\w+\s*\{[^}]*\}(?![^}]*public static void main)/g,
                fix: (match) => {
                    return match.replace(/\}$/, '\n    public static void main(String[] args) {\n        \n    }\n}');
                },
                description: "Added missing main method"
            }
        ],
        html: [
            {
                name: "Unclosed tag",
                pattern: /<([a-z]+)(\s+[^>]*)?>(?!.*<\/\1>)/gi,
                fix: (match, tag, attributes) => {
                    return match + `</${tag}>`;
                },
                description: "Added missing closing tag"
            },
            {
                name: "Missing DOCTYPE",
                pattern: /^(?!<!DOCTYPE)/,
                fix: (match) => {
                    return "<!DOCTYPE html>\n" + match;
                },
                description: "Added missing DOCTYPE declaration"
            },
            {
                name: "Improper nesting",
                pattern: /<([a-z]+)(\s+[^>]*)?><\/([a-z]+)>/gi,
                fix: (match, openTag, attributes, closeTag) => {
                    if (openTag !== closeTag) {
                        return `<${openTag}${attributes}></${openTag}>`;
                    }
                    return match;
                },
                description: "Fixed improperly nested tags"
            },
            {
                name: "Missing alt attribute",
                pattern: /<img\s+([^>]*?)>/gi,
                fix: (match, attributes) => {
                    if (!attributes.includes('alt=')) {
                        return `<img ${attributes} alt="">`;
                    }
                    return match;
                },
                description: "Added missing alt attribute to img tag"
            }
        ],
        css: [
            {
                name: "Missing colon",
                pattern: /([a-z-]+)\s*([^{;]+)$/gim,
                fix: "$1: $2;",
                description: "Added missing colon and semicolon"
            },
            {
                name: "Invalid color value",
                pattern: /:\s*#([a-fA-F0-9]{3,6})[^a-fA-F0-9;]/gi,
                fix: (match, color) => {
                    if (color.length === 3) {
                        return `: #${color};`;
                    } else if (color.length === 6) {
                        return `: #${color};`;
                    }
                    return match;
                },
                description: "Fixed invalid color value"
            },
            {
                name: "Missing units",
                pattern: /:\s*(\d+)\s*;/gi,
                fix: (match, value) => {
                    // Default to px for numeric values without units
                    return `: ${value}px;`;
                },
                description: "Added missing units (px)"
            },
            {
                name: "Missing vendor prefixes",
                pattern: /(transform|transition|animation|user-select|box-sizing):\s*([^;]+);/gi,
                fix: (match, property, value) => {
                    return `-webkit-${property}: ${value};\n-moz-${property}: ${value};\n-ms-${property}: ${value};\n${property}: ${value};`;
                },
                description: "Added vendor prefixes for better browser compatibility"
            }
        ],
        typescript: [
            {
                name: "Missing type annotation",
                pattern: /(function\s+\w+\s*\([^)]*\)|const\s+\w+\s*=|let\s+\w+\s*=)(?!\s*:\s*\w+)/g,
                fix: (match) => {
                    if (match.startsWith('function')) {
                        return match.replace(/\)/, '): any');
                    } else if (match.includes('const')) {
                        return match.replace('=', ': any =');
                    } else if (match.includes('let')) {
                        return match.replace('=', ': any =');
                    }
                    return match;
                },
                description: "Added missing type annotation"
            },
            {
                name: "Using var instead of let/const",
                pattern: /\bvar\s+(\w+)/g,
                fix: (match, varName) => {
                    return `let ${varName}`;
                },
                description: "Replaced 'var' with 'let'"
            }
        ]
    },
    
    /**
     * Detect the programming language of the provided code with caching
     * @param {string} code - The code to analyze
     * @returns {string} - The detected language
     */
    detectLanguage: function(code) {
        // Check cache first
        const cacheKey = code.substring(0, 100); // Use first 100 chars as key
        if (this.languageCache.has(cacheKey)) {
            return this.languageCache.get(cacheKey);
        }
        
        for (const [language, pattern] of Object.entries(this.languagePatterns)) {
            if (pattern.test(code)) {
                this.languageCache.set(cacheKey, language);
                return language;
            }
        }
        
        this.languageCache.set(cacheKey, "unknown");
        return "unknown";
    },
    
    /**
     * Fix errors in the provided code with optimized processing
     * @param {string} code - The code to fix
     * @param {string} language - Optional language hint
     * @returns {Object} - Result object with fixed code and issues found
     */
    fixCode: function(code, language = null) {
        // Detect language if not provided
        const detectedLanguage = language || this.detectLanguage(code);
        
        // Initialize result object
        const result = {
            originalCode: code,
            fixedCode: code,
            language: detectedLanguage,
            issues: [],
            fixesApplied: []
        };
        
        // If language is unknown or unsupported, return early
        if (detectedLanguage === "unknown" || !this.errorPatterns[detectedLanguage]) {
            result.issues.push({
                type: "warning",
                message: `Could not detect language or language '${detectedLanguage}' is not supported`
            });
            return result;
        }
        
        // Ensure patterns are compiled
        if (!this.compiledPatterns[detectedLanguage]) {
            this.init();
        }
        
        // Get compiled error patterns for the detected language
        const patterns = this.compiledPatterns[detectedLanguage];
        
        // Collect all fixes first, then apply them in batch
        const fixes = [];
        
        for (const pattern of patterns) {
            const matches = result.fixedCode.match(pattern.compiledPattern);
            
            if (matches) {
                // Add issue
                result.issues.push({
                    type: "error",
                    message: pattern.description,
                    pattern: pattern.name
                });
                
                // Collect fix
                fixes.push({
                    pattern: pattern.compiledPattern,
                    fix: pattern.fix,
                    name: pattern.name,
                    description: pattern.description
                });
            }
        }
        
        // Apply all fixes in a single pass
        let currentCode = result.fixedCode;
        for (const fix of fixes) {
            if (typeof fix.fix === "function") {
                currentCode = currentCode.replace(fix.pattern, fix.fix);
            } else {
                currentCode = currentCode.replace(fix.pattern, fix.fix);
            }
            
            result.fixesApplied.push({
                pattern: fix.name,
                description: fix.description
            });
        }
        
        result.fixedCode = currentCode;
        
        // Check for unmatched brackets, braces, or parentheses
        this.checkUnmatchedDelimiters(result);
        
        return result;
    },
    
    /**
     * Check for unmatched brackets, braces, or parentheses
     * @param {Object} result - The result object to update
     */
    checkUnmatchedDelimiters: function(result) {
        const delimiters = {
            '(': { count: 0, closer: ')' },
            '[': { count: 0, closer: ']' },
            '{': { count: 0, closer: '}' }
        };
        
        // Count opening and closing delimiters
        for (let i = 0; i < result.fixedCode.length; i++) {
            const char = result.fixedCode[i];
            
            if (delimiters[char]) {
                delimiters[char].count++;
            } else {
                // Check if this is a closing delimiter
                for (const [opener, info] of Object.entries(delimiters)) {
                    if (char === info.closer) {
                        delimiters[opener].count--;
                        break;
                    }
                }
            }
        }
        
        // Check for unmatched delimiters
        for (const [opener, info] of Object.entries(delimiters)) {
            if (info.count > 0) {
                result.issues.push({
                    type: "error",
                    message: `Unmatched '${opener}' - missing ${info.count} '${info.closer}'`,
                    pattern: "Unmatched delimiter"
                });
                
                // Add missing closing delimiters
                for (let i = 0; i < info.count; i++) {
                    result.fixedCode += info.closer;
                }
                
                result.fixesApplied.push({
                    pattern: "Unmatched delimiter",
                    description: `Added missing '${info.closer}' delimiter(s)`
                });
            } else if (info.count < 0) {
                result.issues.push({
                    type: "error",
                    message: `Too many '${info.closer}' - missing ${Math.abs(info.count)} '${opener}'`,
                    pattern: "Unmatched delimiter"
                });
            }
        }
    },
    
    /**
     * Format the result for display
     * @param {Object} result - The result object from fixCode
     * @returns {string} - Formatted result
     */
    formatResult: function(result) {
        let formatted = `Language detected: ${result.language}\n\n`;
        
        if (result.issues.length === 0) {
            formatted += "No issues detected in your code.\n";
        } else {
            formatted += "Issues found:\n";
            result.issues.forEach((issue, index) => {
                formatted += `${index + 1}. ${issue.message} (${issue.pattern})\n`;
            });
            
            formatted += "\nFixes applied:\n";
            result.fixesApplied.forEach((fix, index) => {
                formatted += `${index + 1}. ${fix.description}\n`;
            });
        }
        
        return formatted;
    },
    
    /**
     * Copy text to clipboard
     * @param {string} text - Text to copy
     */
    copyToClipboard: function(text) {
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    this.showNotification('Copied to clipboard!', '#4CAF50');
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    this.fallbackCopyToClipboard(text);
                });
        } else {
            this.fallbackCopyToClipboard(text);
        }
    },
    
    /**
     * Fallback method for copying to clipboard
     * @param {string} text - Text to copy
     */
    fallbackCopyToClipboard: function(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed'; // Prevent scrolling to bottom
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        try {
            document.execCommand('copy');
            this.showNotification('Copied to clipboard!', '#4CAF50');
        } catch (err) {
            console.error('Failed to copy: ', err);
            this.showNotification('Failed to copy', '#f44336');
        }
        
        document.body.removeChild(textarea);
    },
    
    /**
     * Show a notification message
     * @param {string} message - Message to display
     * @param {string} bgColor - Background color
     */
    showNotification: function(message, bgColor = '#4CAF50') {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.code-fixer-notification');
        existingNotifications.forEach(notification => {
            document.body.removeChild(notification);
        });
        
        const notification = document.createElement('div');
        notification.className = 'code-fixer-notification';
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.bottom = '20px';
        notification.style.right = '20px';
        notification.style.backgroundColor = bgColor;
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '2000';
        notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        notification.style.transition = 'opacity 0.5s ease';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 500);
        }, 2000);
    },
    
    /**
     * Share code
     * @param {string} code - Code to share
     */
    shareCode: function(code) {
        // Create a temporary URL with the code
        const encodedCode = encodeURIComponent(code);
        const shareUrl = `${window.location.origin}${window.location.pathname}?code=${encodedCode}`;
        
        // Copy to clipboard
        this.copyToClipboard(shareUrl);
        
        // Show notification
        this.showNotification('Share link copied to clipboard!', '#2196F3');
    },
    
    /**
     * Edit code
     * @param {string} code - Code to edit
     */
    editCode: function(code) {
        const inputTextarea = document.getElementById('code-input');
        if (inputTextarea) {
            inputTextarea.value = code;
            
            // Scroll to input
            inputTextarea.scrollIntoView({ behavior: 'smooth' });
            inputTextarea.focus();
            
            // Show notification
            this.showNotification('Code loaded in editor!', '#FF9800');
        }
    },
    
    /**
     * Highlight code with syntax
     * @param {string} code - Code to highlight
     * @param {string} language - Language of the code
     * @returns {string} - Highlighted HTML
     */
    highlightCode: function(code, language) {
        // Simple syntax highlighting based on language
        let highlighted = code;
        
        // Escape HTML entities
        highlighted = highlighted
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        
        // Apply language-specific highlighting
        switch (language) {
            case 'javascript':
            case 'typescript':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|var|let|const|if|else|for|while|return|async|await|class|import|export|from|default)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'python':
                highlighted = highlighted
                    .replace(/(#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\'\'\'[\s\S]*?\'\'\'|\"\"\"[\s\S]*?\"\"\")/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(def|if|else|elif|for|while|return|class|import|from|as|try|except|finally|with|pass|break|continue|lambda|and|or|not|in|is|True|False|None)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'java':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(public|private|protected|static|final|abstract|class|interface|enum|void|int|String|boolean|if|else|for|while|return|new|this|super|import|package|try|catch|finally|throws|extends|implements)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'html':
                highlighted = highlighted
                    .replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="code-comment">$1</span>')
                    .replace(/(&lt;\/?[a-zA-Z0-9]+)(\s+[^&gt;]*?)?&gt;/g, '<span class="code-tag">$1$2&gt;</span>')
                    .replace(/([a-zA-Z-]+)=["']([^"']*?)["']/g, '<span class="code-attribute">$1</span>=<span class="code-string">"$2"</span>');
                break;
                
            case 'css':
                highlighted = highlighted
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/([a-zA-Z-]+)\s*:/g, '<span class="code-property">$1</span>:')
                    .replace(/:\s*([a-zA-Z0-9#%]+);/g, ': <span class="code-value">$1</span>;')
                    .replace(/\b(\d+)px\b/g, '<span class="code-number">$1px</span>');
                break;
                
            default:
                // Generic highlighting for other languages
                highlighted = highlighted
                    .replace(/(\/\/.*|#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|if|else|for|while|return|class|def|import|from)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
        }
        
        return highlighted;
    },
    
    /**
     * Load the code fixer interface
     */
    loadCodeFixer: function() {
        // Initialize compiled patterns
        this.init();
        
        // Check if interface already exists
        if (document.getElementById('code-fixer-screen')) {
            return;
        }
        
        // Create the code fixer interface
        const codeFixerScreen = document.createElement('div');
        codeFixerScreen.id = 'code-fixer-screen';
        codeFixerScreen.style.position = 'fixed';
        codeFixerScreen.style.top = '0';
        codeFixerScreen.style.left = '0';
        codeFixerScreen.style.width = '100%';
        codeFixerScreen.style.height = '100%';
        codeFixerScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        codeFixerScreen.style.zIndex = '1000';
        codeFixerScreen.style.display = 'flex';
        codeFixerScreen.style.flexDirection = 'column';
        codeFixerScreen.style.padding = '20px';
        codeFixerScreen.style.boxSizing = 'border-box';
        
        // Create header
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.marginBottom = '20px';
        
        const title = document.createElement('h2');
        title.textContent = 'Advanced Code Error Fixer';
        title.style.color = 'white';
        title.style.margin = '0';
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.padding = '8px 16px';
        closeButton.style.backgroundColor = '#f44336';
        closeButton.style.color = 'white';
        closeButton.style.border = 'none';
        closeButton.style.borderRadius = '4px';
        closeButton.style.cursor = 'pointer';
        closeButton.onclick = () => this.closeGame();
        
        header.appendChild(title);
        header.appendChild(closeButton);
        
        // Create language selector
        const languageSelector = document.createElement('div');
        languageSelector.style.marginBottom = '20px';
        
        const languageLabel = document.createElement('label');
        languageLabel.textContent = 'Language: ';
        languageLabel.style.color = 'white';
        languageLabel.style.marginRight = '10px';
        
        const languageSelect = document.createElement('select');
        languageSelect.id = 'language-select';
        languageSelect.style.padding = '8px';
        languageSelect.style.borderRadius = '4px';
        languageSelect.style.border = 'none';
        
        const languages = ['auto', 'javascript', 'typescript', 'python', 'java', 'html', 'css', 'cpp', 'csharp', 'php', 'ruby', 'swift', 'go', 'rust', 'kotlin'];
        languages.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang;
            option.textContent = lang.charAt(0).toUpperCase() + lang.slice(1);
            languageSelect.appendChild(option);
        });
        
        languageSelector.appendChild(languageLabel);
        languageSelector.appendChild(languageSelect);
        
        // Create input textarea
        const inputContainer = document.createElement('div');
        inputContainer.style.marginBottom = '20px';
        
        const inputLabel = document.createElement('label');
        inputLabel.textContent = 'Code to fix:';
        inputLabel.style.color = 'white';
        inputLabel.style.display = 'block';
        inputLabel.style.marginBottom = '10px';
        
        const inputTextarea = document.createElement('textarea');
        inputTextarea.id = 'code-input';
        inputTextarea.style.width = '100%';
        inputTextarea.style.height = '200px';
        inputTextarea.style.padding = '10px';
        inputTextarea.style.borderRadius = '4px';
        inputTextarea.style.border = 'none';
        inputTextarea.style.fontFamily = 'monospace';
        inputTextarea.style.fontSize = '14px';
        inputTextarea.placeholder = 'Paste your code here...';
        
        inputContainer.appendChild(inputLabel);
        inputContainer.appendChild(inputTextarea);
        
        // Create fix button
        const fixButton = document.createElement('button');
        fixButton.textContent = 'Fix Code';
        fixButton.style.padding = '10px 20px';
        fixButton.style.backgroundColor = '#4CAF50';
        fixButton.style.color = 'white';
        fixButton.style.border = 'none';
        fixButton.style.borderRadius = '4px';
        fixButton.style.cursor = 'pointer';
        fixButton.style.marginBottom = '20px';
        fixButton.onclick = () => {
            const code = inputTextarea.value;
            if (!code.trim()) {
                this.showNotification('Please enter some code to fix', '#f44336');
                return;
            }
            
            const language = languageSelect.value === 'auto' ? null : languageSelect.value;
            
            // Show loading indicator
            const loadingIndicator = document.createElement('div');
            loadingIndicator.id = 'loading-indicator';
            loadingIndicator.textContent = 'Analyzing and fixing code...';
            loadingIndicator.style.position = 'absolute';
            loadingIndicator.style.top = '50%';
            loadingIndicator.style.left = '50%';
            loadingIndicator.style.transform = 'translate(-50%, -50%)';
            loadingIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            loadingIndicator.style.color = 'white';
            loadingIndicator.style.padding = '15px 30px';
            loadingIndicator.style.borderRadius = '4px';
            loadingIndicator.style.zIndex = '2000';
            document.body.appendChild(loadingIndicator);
            
            // Use setTimeout to allow UI to update before processing
            setTimeout(() => {
                try {
                    const result = this.fixCode(code, language);
                    
                    // Remove loading indicator
                    if (document.body.contains(loadingIndicator)) {
                        document.body.removeChild(loadingIndicator);
                    }
                    
                    // Create result container
                    const resultContainer = document.getElementById('result-container');
                    resultContainer.innerHTML = '';
                    
                    // Create issues section
                    const issuesSection = document.createElement('div');
                    issuesSection.style.marginBottom = '20px';
                    
                    const issuesTitle = document.createElement('h3');
                    issuesTitle.textContent = 'Analysis Results';
                    issuesTitle.style.marginTop = '0';
                    issuesTitle.style.marginBottom = '10px';
                    issuesSection.appendChild(issuesTitle);
                    
                    if (result.issues.length === 0) {
                        const noIssues = document.createElement('p');
                        noIssues.textContent = 'No issues detected in your code.';
                        issuesSection.appendChild(noIssues);
                    } else {
                        const issuesList = document.createElement('ul');
                        issuesList.style.paddingLeft = '20px';
                        
                        result.issues.forEach(issue => {
                            const issueItem = document.createElement('li');
                            issueItem.textContent = `${issue.message} (${issue.pattern})`;
                            issuesList.appendChild(issueItem);
                        });
                        
                        issuesSection.appendChild(issuesList);
                        
                        const fixesTitle = document.createElement('h4');
                        fixesTitle.textContent = 'Fixes Applied:';
                        fixesTitle.style.marginTop = '15px';
                        fixesTitle.style.marginBottom = '10px';
                        issuesSection.appendChild(fixesTitle);
                        
                        const fixesList = document.createElement('ul');
                        fixesList.style.paddingLeft = '20px';
                        
                        result.fixesApplied.forEach(fix => {
                            const fixItem = document.createElement('li');
                            fixItem.textContent = fix.description;
                            fixesList.appendChild(fixItem);
                        });
                        
                        issuesSection.appendChild(fixesList);
                    }
                    
                    resultContainer.appendChild(issuesSection);
                    
                    // Create fixed code section
                    const fixedCodeSection = document.createElement('div');
                    
                    const fixedCodeTitle = document.createElement('h3');
                    fixedCodeTitle.textContent = 'Fixed Code';
                    fixedCodeTitle.style.marginTop = '0';
                    fixedCodeTitle.style.marginBottom = '10px';
                    fixedCodeSection.appendChild(fixedCodeTitle);
                    
                    // Create code display
                    const codeDisplay = document.createElement('pre');
                    codeDisplay.style.backgroundColor = '#f5f5f5';
                    codeDisplay.style.padding = '15px';
                    codeDisplay.style.borderRadius = '4px';
                    codeDisplay.style.overflow = 'auto';
                    codeDisplay.style.maxHeight = '300px';
                    codeDisplay.style.whiteSpace = 'pre-wrap';
                    codeDisplay.style.fontFamily = 'monospace';
                    codeDisplay.style.fontSize = '14px';
                    
                    // Apply syntax highlighting
                    codeDisplay.innerHTML = this.highlightCode(result.fixedCode, result.language);
                    
                    fixedCodeSection.appendChild(codeDisplay);
                    
                    // Create button container
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.display = 'flex';
                    buttonContainer.style.justifyContent = 'space-between';
                    buttonContainer.style.marginTop = '15px';
                    buttonContainer.style.flexWrap = 'wrap';
                    buttonContainer.style.gap = '10px';
                    
                    // Copy button
                    const copyButton = document.createElement('button');
                    copyButton.textContent = 'Copy Code';
                    copyButton.style.padding = '8px 16px';
                    copyButton.style.backgroundColor = '#2196F3';
                    copyButton.style.color = 'white';
                    copyButton.style.border = 'none';
                    copyButton.style.borderRadius = '4px';
                    copyButton.style.cursor = 'pointer';
                    copyButton.style.flex = '1';
                    copyButton.onclick = () => this.copyToClipboard(result.fixedCode);
                    buttonContainer.appendChild(copyButton);
                    
                    // Share button
                    const shareButton = document.createElement('button');
                    shareButton.textContent = 'Share Code';
                    shareButton.style.padding = '8px 16px';
                    shareButton.style.backgroundColor = '#4CAF50';
                    shareButton.style.color = 'white';
                    shareButton.style.border = 'none';
                    shareButton.style.borderRadius = '4px';
                    shareButton.style.cursor = 'pointer';
                    shareButton.style.flex = '1';
                    shareButton.onclick = () => this.shareCode(result.fixedCode);
                    buttonContainer.appendChild(shareButton);
                    
                    // Edit button
                    const editButton = document.createElement('button');
                    editButton.textContent = 'Edit Code';
                    editButton.style.padding = '8px 16px';
                    editButton.style.backgroundColor = '#FF9800';
                    editButton.style.color = 'white';
                    editButton.style.border = 'none';
                    editButton.style.borderRadius = '4px';
                    editButton.style.cursor = 'pointer';
                    editButton.style.flex = '1';
                    editButton.onclick = () => this.editCode(result.fixedCode);
                    buttonContainer.appendChild(editButton);
                    
                    fixedCodeSection.appendChild(buttonContainer);
                    resultContainer.appendChild(fixedCodeSection);
                    
                    // Show success notification
                    if (result.fixesApplied.length > 0) {
                        this.showNotification(`Fixed ${result.fixesApplied.length} issue(s)!`, '#4CAF50');
                    }
                } catch (error) {
                    // Remove loading indicator
                    if (document.body.contains(loadingIndicator)) {
                        document.body.removeChild(loadingIndicator);
                    }
                    
                    console.error('Error fixing code:', error);
                    this.showNotification('An error occurred while fixing your code', '#f44336');
                }
            }, 100);
        };
        
        // Create result container
        const resultContainer = document.createElement('div');
        resultContainer.id = 'result-container';
        resultContainer.style.backgroundColor = 'white';
        resultContainer.style.padding = '20px';
        resultContainer.style.borderRadius = '4px';
        resultContainer.style.overflow = 'auto';
        resultContainer.style.flex = '1';
        resultContainer.innerHTML = '<p style="color: gray;">Results will appear here...</p>';
        
        // Add syntax highlighting styles
        const style = document.createElement('style');
        style.textContent = `
            .code-comment { color: #6a9955; }
            .code-keyword { color: #569cd6; font-weight: bold; }
            .code-number { color: #b5cea8; }
            .code-string { color: #ce9178; }
            .code-tag { color: #569cd6; }
            .code-attribute { color: #9cdcfe; }
            .code-property { color: #9cdcfe; }
            .code-value { color: #ce9178; }
        `;
        document.head.appendChild(style);
        
        // Assemble the interface
        codeFixerScreen.appendChild(header);
        codeFixerScreen.appendChild(languageSelector);
        codeFixerScreen.appendChild(inputContainer);
        codeFixerScreen.appendChild(fixButton);
        codeFixerScreen.appendChild(resultContainer);
        
        // Add to document
        document.body.appendChild(codeFixerScreen);
        
        // Check if there's a code parameter in the URL
        const urlParams = new URLSearchParams(window.location.search);
        const codeParam = urlParams.get('code');
        if (codeParam) {
            inputTextarea.value = decodeURIComponent(codeParam);
        }
    },
    
    /**
     * Close the code fixer interface
     */
    closeGame: function() {
        const codeFixerScreen = document.getElementById('code-fixer-screen');
        if (codeFixerScreen) {
            document.body.removeChild(codeFixerScreen);
        }
    }
};

// Initialize the compiled patterns
AdvancedCodeFixer.init();

// Create a singleton instance
const codeFixerScreen = AdvancedCodeFixer;

// Add this to your AI's command handling
if (/fix code|code fix|fix my code/i.test(userInputRaw)) {
    codeFixerScreen.loadCodeFixer();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    codeFixerScreen.closeGame();
    return;
}

/**
 * Code Display System - Shows formatted code in a nice box
 */
const CodeDisplay = {
    /**
     * Display code in a formatted box
     * @param {string} code - The code to display
     * @param {string} language - The programming language
     * @param {string} title - Optional title for the code box
     */
    displayCode: function(code, language, title = "Source Code") {
        // Remove any existing code displays
        const existingDisplays = document.querySelectorAll('.code-display-container');
        existingDisplays.forEach(display => {
            document.body.removeChild(display);
        });
        
        // Create the code display container
        const container = document.createElement('div');
        container.className = 'code-display-container';
        container.style.position = 'fixed';
        container.style.top = '0';
        container.style.left = '0';
        container.style.width = '100%';
        container.style.height = '100%';
        container.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        container.style.zIndex = '1000';
        container.style.display = 'flex';
        container.style.flexDirection = 'column';
        container.style.padding = '20px';
        container.style.boxSizing = 'border-box';
        
        // Create header
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.marginBottom = '20px';
        
        const titleElement = document.createElement('h2');
        titleElement.textContent = title;
        titleElement.style.color = 'white';
        titleElement.style.margin = '0';
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.padding = '8px 16px';
        closeButton.style.backgroundColor = '#f44336';
        closeButton.style.color = 'white';
        closeButton.style.border = 'none';
        closeButton.style.borderRadius = '4px';
        closeButton.style.cursor = 'pointer';
        closeButton.onclick = () => this.closeDisplay();
        
        header.appendChild(titleElement);
        header.appendChild(closeButton);
        
        // Create language indicator
        const languageIndicator = document.createElement('div');
        languageIndicator.style.marginBottom = '15px';
        
        const languageLabel = document.createElement('span');
        languageLabel.textContent = 'Language: ';
        languageLabel.style.color = '#aaa';
        
        const languageName = document.createElement('span');
        languageName.textContent = language.toUpperCase();
        languageName.style.color = '#4CAF50';
        languageName.style.fontWeight = 'bold';
        
        languageIndicator.appendChild(languageLabel);
        languageIndicator.appendChild(languageName);
        
        // Create code display
        const codeDisplay = document.createElement('pre');
        codeDisplay.style.backgroundColor = '#1e1e1e';
        codeDisplay.style.color = '#d4d4d4';
        codeDisplay.style.padding = '20px';
        codeDisplay.style.borderRadius = '8px';
        codeDisplay.style.overflow = 'auto';
        codeDisplay.style.flex = '1';
        codeDisplay.style.fontFamily = 'Consolas, Monaco, "Andale Mono", monospace';
        codeDisplay.style.fontSize = '14px';
        codeDisplay.style.lineHeight = '1.5';
        codeDisplay.style.whiteSpace = 'pre-wrap';
        codeDisplay.style.wordBreak = 'break-all';
        
        // Apply syntax highlighting
        codeDisplay.innerHTML = this.highlightCode(code, language);
        
        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.justifyContent = 'flex-end';
        buttonContainer.style.marginTop = '15px';
        buttonContainer.style.gap = '10px';
        
        // Copy button
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Code';
        copyButton.style.padding = '8px 16px';
        copyButton.style.backgroundColor = '#2196F3';
        copyButton.style.color = 'white';
        copyButton.style.border = 'none';
        copyButton.style.borderRadius = '4px';
        copyButton.style.cursor = 'pointer';
        copyButton.onclick = () => this.copyToClipboard(code);
        buttonContainer.appendChild(copyButton);
        
        // Add syntax highlighting styles
        this.addSyntaxHighlightingStyles();
        
        // Assemble the display
        container.appendChild(header);
        container.appendChild(languageIndicator);
        container.appendChild(codeDisplay);
        container.appendChild(buttonContainer);
        
        // Add to document
        document.body.appendChild(container);
    },
    
    /**
     * Highlight code with syntax
     * @param {string} code - Code to highlight
     * @param {string} language - Language of the code
     * @returns {string} - Highlighted HTML
     */
    highlightCode: function(code, language) {
        // Escape HTML entities
        let highlighted = code
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        
        // Apply language-specific highlighting
        switch (language.toLowerCase()) {
            case 'java':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(public|private|protected|static|final|abstract|class|interface|enum|void|int|String|boolean|if|else|for|while|return|new|this|super|import|package|try|catch|finally|throws|extends|implements)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'javascript':
            case 'typescript':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|var|let|const|if|else|for|while|return|async|await|class|import|export|from|default)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'python':
                highlighted = highlighted
                    .replace(/(#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\'\'\'[\s\S]*?\'\'\'|\"\"\"[\s\S]*?\"\"\")/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(def|if|else|elif|for|while|return|class|import|from|as|try|except|finally|with|pass|break|continue|lambda|and|or|not|in|is|True|False|None)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'html':
                highlighted = highlighted
                    .replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="code-comment">$1</span>')
                    .replace(/(&lt;\/?[a-zA-Z0-9]+)(\s+[^&gt;]*?)?&gt;/g, '<span class="code-tag">$1$2&gt;</span>')
                    .replace(/([a-zA-Z-]+)=["']([^"']*?)["']/g, '<span class="code-attribute">$1</span>=<span class="code-string">"$2"</span>');
                break;
                
            case 'css':
                highlighted = highlighted
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/([a-zA-Z-]+)\s*:/g, '<span class="code-property">$1</span>:')
                    .replace(/:\s*([a-zA-Z0-9#%]+);/g, ': <span class="code-value">$1</span>;')
                    .replace(/\b(\d+)px\b/g, '<span class="code-number">$1px</span>');
                break;
                
            default:
                // Generic highlighting for other languages
                highlighted = highlighted
                    .replace(/(\/\/.*|#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|if|else|for|while|return|class|def|import|from)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
        }
        
        return highlighted;
    },
    
    /**
     * Add syntax highlighting styles to the document
     */
    addSyntaxHighlightingStyles: function() {
        // Check if styles already exist
        if (document.getElementById('code-display-styles')) {
            return;
        }
        
        const style = document.createElement('style');
        style.id = 'code-display-styles';
        style.textContent = `
            .code-comment { color: #6a9955; font-style: italic; }
            .code-keyword { color: #569cd6; font-weight: bold; }
            .code-number { color: #b5cea8; }
            .code-string { color: #ce9178; }
            .code-tag { color: #569cd6; }
            .code-attribute { color: #9cdcfe; }
            .code-property { color: #9cdcfe; }
            .code-value { color: #ce9178; }
        `;
        document.head.appendChild(style);
    },
    
    /**
     * Copy text to clipboard
     * @param {string} text - Text to copy
     */
    copyToClipboard: function(text) {
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    this.showNotification('Copied to clipboard!', '#4CAF50');
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    this.fallbackCopyToClipboard(text);
                });
        } else {
            this.fallbackCopyToClipboard(text);
        }
    },
    
    /**
     * Fallback method for copying to clipboard
     * @param {string} text - Text to copy
     */
    fallbackCopyToClipboard: function(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        try {
            document.execCommand('copy');
            this.showNotification('Copied to clipboard!', '#4CAF50');
        } catch (err) {
            console.error('Failed to copy: ', err);
            this.showNotification('Failed to copy', '#f44336');
        }
        
        document.body.removeChild(textarea);
    },
    
    /**
     * Show a notification message
     * @param {string} message - Message to display
     * @param {string} bgColor - Background color
     */
    showNotification: function(message, bgColor = '#4CAF50') {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.code-display-notification');
        existingNotifications.forEach(notification => {
            document.body.removeChild(notification);
        });
        
        const notification = document.createElement('div');
        notification.className = 'code-display-notification';
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.bottom = '20px';
        notification.style.right = '20px';
        notification.style.backgroundColor = bgColor;
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '2000';
        notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        notification.style.transition = 'opacity 0.5s ease';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 500);
        }, 2000);
    },
    
    /**
     * Close the code display
     */
    closeDisplay: function() {
        const container = document.querySelector('.code-display-container');
        if (container) {
            document.body.removeChild(container);
        }
    }
};

// Create a singleton instance
const codeDisplay = CodeDisplay;

// Example usage:
// codeDisplay.displayCode(
//     `Toast.makeText(getApplicationContext(), "Hello World", Toast.LENGTH_SHORT).show();`,
//     "java",
//     "Android Java Toast Example"
// );

// Add this to your AI's command handling when you want to display code
// For example, when a user asks for source code:
// if (userAskedForCode) {
//     codeDisplay.displayCode(sourceCode, language, title);
//     return;
// }

// Add command to close the display
if (/close code|close display/i.test(userInputRaw)) {
    codeDisplay.closeDisplay();
    return;
}




class YouTubeScreenLoader {
    constructor() {
        this.youtube = {
            name: 'YOUTUBE PLAYER',
            instructions: 'Paste a YouTube link to watch videos in this player.'
        };
        
        this.gameContainer = null;
        this.iframe = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.inputContainer = null;
        this.videoId = null;
    }
    
    /**
     * Load the YouTube player
     */
    loadYouTube(url = null) {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.youtube.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // If URL is provided, load it directly
        if (url) {
            this.loadYouTubeVideo(url);
        } else {
            // Show input UI for URL
            this.showYouTubeInputUI();
        }
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the player
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.youtube.name} loaded! ${this.youtube.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Show YouTube URL input UI
     */
    showYouTubeInputUI() {
        // Create input container
        this.inputContainer = document.createElement('div');
        this.inputContainer.style.cssText = `
            background-color: #222;
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        `;
        
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'YouTube Player';
        title.style.cssText = `
            color: #ff0000;
            margin-bottom: 20px;
            font-size: 24px;
        `;
        this.inputContainer.appendChild(title);
        
        // Create instructions
        const instructions = document.createElement('p');
        instructions.textContent = 'Paste a YouTube URL below:';
        instructions.style.cssText = `
            color: #ccc;
            margin-bottom: 20px;
            font-size: 16px;
        `;
        this.inputContainer.appendChild(instructions);
        
        // Create input field
        const inputField = document.createElement('input');
        inputField.type = 'text';
        inputField.placeholder = 'https://www.youtube.com/watch?v=...';
        inputField.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 2px solid #444;
            border-radius: 5px;
            background-color: #333;
            color: white;
            font-size: 16px;
            margin-bottom: 20px;
            box-sizing: border-box;
        `;
        this.inputContainer.appendChild(inputField);
        
        // Create load button
        const loadButton = document.createElement('button');
        loadButton.textContent = 'Load Video';
        loadButton.style.cssText = `
            padding: 12px 24px;
            background-color: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        loadButton.addEventListener('click', () => {
            const url = inputField.value.trim();
            if (url) {
                this.loadYouTubeVideo(url);
            } else {
                this.showError('Please enter a YouTube URL');
            }
        });
        this.inputContainer.appendChild(loadButton);
        
        // Add paste button for mobile
        const pasteButton = document.createElement('button');
        pasteButton.textContent = 'Paste URL';
        pasteButton.style.cssText = `
            padding: 10px 20px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            margin-left: 10px;
            transition: all 0.2s ease;
        `;
        pasteButton.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                inputField.value = text;
            } catch (err) {
                this.showError('Failed to read clipboard');
            }
        });
        this.inputContainer.appendChild(pasteButton);
        
        // Add input container to game container
        this.gameContainer.appendChild(this.inputContainer);
        
        // Focus on input field
        setTimeout(() => inputField.focus(), 100);
    }
    
    /**
     * Load YouTube video from URL
     */
    loadYouTubeVideo(url) {
        // Extract video ID from URL
        this.videoId = this.extractYouTubeID(url);
        
        if (!this.videoId) {
            this.showError('Invalid YouTube URL');
            return;
        }
        
        // Remove input container if exists
        if (this.inputContainer && this.inputContainer.parentNode) {
            this.inputContainer.parentNode.removeChild(this.inputContainer);
            this.inputContainer = null;
        }
        
        // Create iframe for YouTube player
        this.iframe = document.createElement('iframe');
        this.iframe.src = `https://www.youtube.com/embed/${this.videoId}?autoplay=1&rel=0&modestbranding=1`;
        this.iframe.style.cssText = `
            width: 90%;
            max-width: 1200px;
            height: 70vh;
            max-height: 800px;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        `;
        
        // Handle iframe load event
        this.iframe.onload = () => {
            botReply('Video loaded successfully!');
        };
        
        // Handle iframe error event
        this.iframe.onerror = () => {
            botReply('Error loading the video. Please check the URL and try again.');
            this.closeGame();
        };
        
        // Add iframe to container
        this.gameContainer.appendChild(this.iframe);
    }
    
    /**
     * Extract YouTube video ID from URL - UPDATED to handle Shorts
     */
    extractYouTubeID(url) {
        // Clean the URL first
        url = url.trim();
        
        // Regular expressions to match YouTube URL patterns
        const regexPatterns = [
            // Standard watch URL
            /(?:youtube\.com\/watch\?v=|&v=)([^&\n?#]+)/,
            // Shortened URL
            /(?:youtu\.be\/)([^&\n?#]+)/,
            // Embed URL
            /(?:youtube\.com\/embed\/)([^&\n?#]+)/,
            // v URL
            /(?:youtube\.com\/v\/)([^&\n?#]+)/,
            // Shorts URL - NEW
            /(?:youtube\.com\/shorts\/)([^&\n?#]+)/,
            // Live URL
            /(?:youtube\.com\/live\/)([^&\n?#]+)/,
            // Fallback pattern
            /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=|shorts\/|live\/)([^#&?]*).*/
        ];
        
        for (const regex of regexPatterns) {
            const match = url.match(regex);
            if (match && match[1] && match[1].length === 11) {
                return match[1];
            }
        }
        
        // Special handling for shorts URLs with parameters
        if (url.includes('youtube.com/shorts/')) {
            const shortsMatch = url.match(/youtube\.com\/shorts\/([^&\n?#]+)/);
            if (shortsMatch && shortsMatch[1]) {
                // Extract just the ID part (before any parameters)
                const id = shortsMatch[1].split('?')[0];
                if (id.length === 11) {
                    return id;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Show error message
     */
    showError(message) {
        // Create error element
        const errorElement = document.createElement('div');
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        `;
        
        // Add to container
        this.gameContainer.appendChild(errorElement);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (errorElement.parentNode) {
                errorElement.parentNode.removeChild(errorElement);
            }
        }, 3000);
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #ff0000, #cc0000);
            border-radius: 4px;
            box-shadow: 0 0 10px #ff0000;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(255, 0, 0, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust iframe size based on fullscreen state
        if (this.iframe) {
            if (this.isFullscreen) {
                this.iframe.style.width = '98%';
                this.iframe.style.height = '95vh';
            } else {
                this.iframe.style.width = '90%';
                this.iframe.style.height = '70vh';
            }
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.iframe = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.inputContainer = null;
        this.videoId = null;
        
        botReply("YouTube Player closed. Thank you!");
    }
}

// Create a singleton instance
const youtubeScreenLoader = new YouTubeScreenLoader();

// Add this to your AI's command handling
if (/youtube|play youtube|watch youtube/i.test(userInputRaw)) {
    // Check if a URL was provided in the input
    const urlMatch = userInputRaw.match(/(https?:\/\/[^\s]+)/);
    if (urlMatch) {
        youtubeScreenLoader.loadYouTube(urlMatch[1]);
    } else {
        youtubeScreenLoader.loadYouTube();
    }
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    youtubeScreenLoader.closeGame();
    return;
}
class ModernImageViewer {
    constructor() {
        this.viewer = {
            name: 'VIPTEAMMOD AI 3.0 IMAGE VIEWER',
            instructions: 'Simply request an image by describing what you want to see.'
        };
        
        // Core elements
        this.container = null;
        this.imageWrapper = null;
        this.imageElement = null;
        this.controlsPanel = null;
        this.thumbnailsPanel = null;
        this.loader = null;
        this.notification = null;
        
        // State
        this.isActive = false;
        this.currentImageName = null;
        this.currentImageUrl = null;
        this.isLoading = false;
        this.thumbnailsVisible = false;
        
        // Zoom and pan state
        this.zoomLevel = 1;
        this.minZoom = 0.25;
        this.maxZoom = 5;
        this.zoomStep = 0.25;
        this.isPanning = false;
        this.panStartX = 0;
        this.panStartY = 0;
        this.translateX = 0;
        this.translateY = 0;
        
        // Available images
        this.availableImages = {
            "animal": {
                type: "array",
                urls: [
                    "ANIMAL/Animal1.png",
                    "ANIMAL/Animal2.png",
                    "ANIMAL/Animal3.png",
                    "ANIMAL/Animal4.png",
                    "ANIMAL/Animal5.png",
                    "ANIMAL/Animal6.png",
                    "ANIMAL/Animal7.png",
                    "ANIMAL/Animal8.png",
                    "ANIMAL/Animal9.png",
                    "ANIMAL/Animal10.png",
                    "ANIMAL/Animal11.png",
                    "ANIMAL/Animal12.png",
                    "ANIMAL/Animal13.png",
                    "ANIMAL/Animal14.png",
                    "ANIMAL/Animal15.png",
                    "ANIMAL/Animal16.png",
                    "ANIMAL/Animal17.png",
                    "ANIMAL/Animal18.png",
                    "ANIMAL/Animal19.png",
                    "ANIMAL/Animal20.png",
                    "ANIMAL/Animal21.png",
                    "ANIMAL/Animal22.png",
                    "ANIMAL/Animal23.png",
                    "ANIMAL/Animal24.png"
                ],
                description: "Various animals",
                category: "nature"
            },
            "cat": {
                type: "single",
                url: "ANIMAL/Animal1.png",
                description: "Cute cat",
                category: "animals"
            },
            "dog": {
                type: "single",
                url: "https://placedog.net/800/600",
                description: "Friendly dog",
                category: "animals"
            },
            "nature": {
                type: "single",
                url: "https://picsum.photos/seed/nature/800/600.jpg",
                description: "Beautiful nature scene",
                category: "nature"
            },
            "mountain": {
                type: "single",
                url: "https://picsum.photos/seed/mountain/800/600.jpg",
                description: "Majestic mountains",
                category: "landscape"
            },
            "beach": {
                type: "single",
                url: "https://picsum.photos/seed/beach/800/600.jpg",
                description: "Sunny beach",
                category: "landscape"
            },
            "forest": {
                type: "single",
                url: "https://picsum.photos/seed/forest/800/600.jpg",
                description: "Dense forest",
                category: "nature"
            },
            "sunset": {
                type: "single",
                url: "https://picsum.photos/seed/sunset/800/600.jpg",
                description: "Breathtaking sunset",
                category: "nature"
            },
            "bird": {
                type: "single",
                url: "https://picsum.photos/seed/bird/800/600.jpg",
                description: "Colorful bird",
                category: "animals"
            },
            "flower": {
                type: "single",
                url: "https://picsum.photos/seed/flower/800/600.jpg",
                description: "Beautiful flower",
                category: "nature"
            },
            "ocean": {
                type: "single",
                url: "https://picsum.photos/seed/ocean/800/600.jpg",
                description: "Vast ocean",
                category: "landscape"
            }
        };
        
        // Initialize or restore last shown animal image index
        // Use a more robust approach to handle index validation
        this.initializeAnimalIndex();
    }
    
    /**
     * Initialize the animal index with proper validation
     */
    initializeAnimalIndex() {
        try {
            // Get the stored index or default to 0
            const storedIndex = this.loadFromStorage("lastAnimalIndex", 0);
            
            // Check if we have the animal images array
            if (this.availableImages.animal && 
                this.availableImages.animal.urls && 
                Array.isArray(this.availableImages.animal.urls) && 
                this.availableImages.animal.urls.length > 0) {
                
                // Validate the index is within bounds
                const maxIndex = this.availableImages.animal.urls.length - 1;
                
                // If stored index is invalid, reset to 0
                if (isNaN(storedIndex) || storedIndex < 0 || storedIndex > maxIndex) {
                    this.lastAnimalIndex = 0;
                    this.saveToStorage("lastAnimalIndex", 0);
                    console.log("Reset animal index to 0 due to invalid stored value");
                } else {
                    this.lastAnimalIndex = storedIndex;
                }
            } else {
                // Fallback if animal array is not available
                this.lastAnimalIndex = 0;
                console.error("Animal images array not properly configured");
            }
        } catch (e) {
            console.error("Error initializing animal index:", e);
            this.lastAnimalIndex = 0;
        }
    }
    
    /**
     * Validate the animal index to ensure it's within bounds
     */
    validateAnimalIndex(index) {
        if (!this.availableImages.animal || 
            !this.availableImages.animal.urls || 
            !Array.isArray(this.availableImages.animal.urls)) {
            return 0;
        }
        
        const maxIndex = this.availableImages.animal.urls.length - 1;
        if (index < 0 || index > maxIndex || isNaN(index)) {
            return 0;
        }
        
        return index;
    }
    
    /**
     * Load data from localStorage
     */
    loadFromStorage(key, defaultValue) {
        if (typeof(Storage) !== "undefined") {
            try {
                const stored = localStorage.getItem(key);
                return stored !== null ? JSON.parse(stored) : defaultValue;
            } catch (e) {
                console.error("Error loading from localStorage:", e);
                return defaultValue;
            }
        }
        return defaultValue;
    }
    
    /**
     * Save data to localStorage
     */
    saveToStorage(key, value) {
        if (typeof(Storage) !== "undefined") {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.error("Error saving to localStorage:", e);
            }
        }
    }
    
    /**
     * Load the Image Viewer with a specific image
     */
    loadImage(imageName) {
        if (this.isActive) {
            botReply(`The ${this.viewer.name} is already running! Type 'close viewer' to exit first.`);
            return;
        }
        
        // Reset state
        this.resetViewerState();
        
        // Create UI
        this.createContainer();
        this.createHeader();
        this.createImageArea();
        this.createThumbnailsPanel();
        this.createLoader();
        
        // Hide thumbnails by default
        this.hideThumbnailsPanel();
        
        // Show the viewer
        this.displayViewer();
        
        // Load the image
        this.loadImageByName(imageName);
        
        // Set up event listeners
        this.setupEventListeners();
        
        this.isActive = true;
        botReply(`${this.viewer.name} loaded! Showing ${imageName} image.`);
    }
    
    /**
     * Reset viewer state
     */
    resetViewerState() {
        this.zoomLevel = 1;
        this.translateX = 0;
        this.translateY = 0;
        this.isPanning = false;
        this.panStartX = 0;
        this.panStartY = 0;
        this.isLoading = false;
        this.currentImageName = null;
        this.currentImageUrl = null;
        this.thumbnailsVisible = false;
    }
    
    /**
     * Create main container
     */
    createContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('modern-image-viewer');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.container = document.createElement('div');
        this.container.id = 'modern-image-viewer';
        this.container.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: ${this.theme.background};
            z-index: 10000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: ${this.theme.light};
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            animation: fadeIn 0.3s ease-out;
        `;
        
        // Add fade-in animation
        this.addGlobalStyles();
    }
    
    /**
     * Add global styles for animations
     */
    addGlobalStyles() {
        if (!document.getElementById('modern-viewer-styles')) {
            const styleElement = document.createElement('style');
            styleElement.id = 'modern-viewer-styles';
            styleElement.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                @keyframes slideIn {
                    from { transform: translateY(20px); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
                @keyframes slideInRight {
                    from { transform: translateX(20px); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes spin {
                    to { transform: rotate(360deg); }
                }
                @keyframes pulse {
                    0% { transform: scale(1); }
                    50% { transform: scale(1.05); }
                    100% { transform: scale(1); }
                }
                .thumbnail {
                    transition: all 0.2s ease;
                    cursor: pointer;
                }
                .thumbnail:hover {
                    transform: scale(1.05);
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                }
                .control-button {
                    transition: all 0.2s ease;
                    cursor: pointer;
                }
                .control-button:hover {
                    transform: scale(1.1);
                }
                .control-button:active {
                    transform: scale(0.95);
                }
                .notification {
                    animation: slideIn 0.3s ease-out;
                }
            `;
            document.head.appendChild(styleElement);
        }
    }
    
    /**
     * Create header - MODIFIED to include control buttons
     */
    createHeader() {
        const header = document.createElement('div');
        header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background-color: ${this.theme.panel};
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
        `;
        
        // Left side - Title and control buttons
        const leftContainer = document.createElement('div');
        leftContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        // Title
        const title = document.createElement('h1');
        title.textContent = this.viewer.name;
        title.style.cssText = `
            margin: 0;
            font-size: 24px;
            font-weight: 500;
            color: ${this.theme.primary};
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        `;
        leftContainer.appendChild(title);
        
        // Control buttons container
        const controlsContainer = document.createElement('div');
        controlsContainer.style.cssText = `
            display: flex;
            gap: 8px;
        `;
        
        // Zoom in button
        const zoomInButton = this.createControlButton('+', 'Zoom In');
        zoomInButton.addEventListener('click', () => this.zoomIn());
        controlsContainer.appendChild(zoomInButton);
        
        // Zoom out button
        const zoomOutButton = this.createControlButton('-', 'Zoom Out');
        zoomOutButton.addEventListener('click', () => this.zoomOut());
        controlsContainer.appendChild(zoomOutButton);
        
        // Reset view button
        const resetButton = this.createControlButton('⟲', 'Reset View');
        resetButton.addEventListener('click', () => this.resetView());
        controlsContainer.appendChild(resetButton);
        
        // Zoom indicator
        this.zoomIndicator = document.createElement('div');
        this.zoomIndicator.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
            font-size: 14px;
            font-weight: 500;
            color: ${this.theme.light};
        `;
        this.updateZoomIndicator();
        controlsContainer.appendChild(this.zoomIndicator);
        
        // Fullscreen button
        const fullscreenButton = this.createControlButton('⛶', 'Toggle Fullscreen');
        fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        controlsContainer.appendChild(fullscreenButton);
        
        // Download button
        const downloadButton = this.createControlButton('↓', 'Download Image');
        downloadButton.addEventListener('click', () => this.downloadImage());
        controlsContainer.appendChild(downloadButton);
        
        leftContainer.appendChild(controlsContainer);
        header.appendChild(leftContainer);
        
        // Right side - Close button
        const closeButton = this.createControlButton('✕', 'Close Viewer');
        closeButton.style.cssText = `
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: ${this.theme.accent};
            color: ${this.theme.dark};
            border: none;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        
        closeButton.addEventListener('click', () => this.closeViewer());
        header.appendChild(closeButton);
        
        this.container.appendChild(header);
    }
    
    /**
     * Create image area
     */
    createImageArea() {
        this.imageWrapper = document.createElement('div');
        this.imageWrapper.style.cssText = `
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            background-image: radial-gradient(circle, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        `;
        
        // Image element will be added when loading an image
        this.container.appendChild(this.imageWrapper);
    }
    
    /**
     * Create a control button
     */
    createControlButton(icon, tooltip) {
        const button = document.createElement('button');
        button.className = 'control-button';
        button.innerHTML = icon;
        button.title = tooltip;
        button.style.cssText = `
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: ${this.theme.secondary};
            color: ${this.theme.light};
            border: none;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        return button;
    }
    
    /**
     * Create thumbnails panel
     */
    createThumbnailsPanel() {
        this.thumbnailsPanel = document.createElement('div');
        this.thumbnailsPanel.style.cssText = `
            position: absolute;
            top: 80px;
            right: 20px;
            width: 200px;
            max-height: calc(100vh - 180px);
            background-color: ${this.theme.panel};
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transform: translateX(220px);
            opacity: 0;
            transition: all 0.3s ease;
        `;
        
        // Title
        const title = document.createElement('h3');
        title.textContent = 'Available Images';
        title.style.cssText = `
            margin: 0 0 10px 0;
            font-size: 16px;
            color: ${this.theme.primary};
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        this.thumbnailsPanel.appendChild(title);
        
        // Add thumbnails
        Object.keys(this.availableImages).forEach(imageName => {
            const imageData = this.availableImages[imageName];
            const thumbnail = this.createThumbnail(imageName, imageData);
            this.thumbnailsPanel.appendChild(thumbnail);
        });
        
        this.container.appendChild(this.thumbnailsPanel);
    }
    
    /**
     * Create a thumbnail
     */
    createThumbnail(imageName, imageData) {
        const thumbnail = document.createElement('div');
        thumbnail.className = 'thumbnail';
        thumbnail.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            border-radius: 8px;
            background-color: ${this.theme.hover};
            border: 1px solid transparent;
        `;
        
        // Image name
        const nameElement = document.createElement('div');
        nameElement.textContent = imageName.charAt(0).toUpperCase() + imageName.slice(1);
        nameElement.style.cssText = `
            font-weight: 500;
            font-size: 14px;
            color: ${this.theme.light};
        `;
        thumbnail.appendChild(nameElement);
        
        // Description
        const descElement = document.createElement('div');
        descElement.textContent = imageData.description || 'No description';
        descElement.style.cssText = `
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        `;
        thumbnail.appendChild(descElement);
        
        // Category badge
        const categoryBadge = document.createElement('span');
        categoryBadge.textContent = imageData.category || 'general';
        categoryBadge.style.cssText = `
            align-self: flex-start;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            background-color: ${this.theme.primary};
            color: ${this.theme.light};
        `;
        thumbnail.appendChild(categoryBadge);
        
        // Click handler
        thumbnail.addEventListener('click', () => {
            this.showLoader();
            this.loadImageByName(imageName);
        });
        
        return thumbnail;
    }
    
    /**
     * Toggle thumbnails panel
     */
    toggleThumbnailsPanel() {
        if (this.thumbnailsVisible) {
            this.hideThumbnailsPanel();
        } else {
            this.showThumbnailsPanel();
        }
    }
    
    /**
     * Show thumbnails panel
     */
    showThumbnailsPanel() {
        if (this.thumbnailsPanel) {
            this.thumbnailsPanel.style.transform = 'translateX(0)';
            this.thumbnailsPanel.style.opacity = '1';
            this.thumbnailsVisible = true;
        }
    }
    
    /**
     * Hide thumbnails panel
     */
    hideThumbnailsPanel() {
        if (this.thumbnailsPanel) {
            this.thumbnailsPanel.style.transform = 'translateX(220px)';
            this.thumbnailsPanel.style.opacity = '0';
            this.thumbnailsVisible = false;
        }
    }
    
    /**
     * Create loader
     */
    createLoader() {
        this.loader = document.createElement('div');
        this.loader.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top-color: ${this.theme.primary};
            animation: spin 1s ease-in-out infinite;
            z-index: 30;
            display: none;
        `;
        this.imageWrapper.appendChild(this.loader);
    }
    
    /**
     * Display the viewer
     */
    displayViewer() {
        document.body.appendChild(this.container);
        
        // Prevent accidental refresh
        window.addEventListener('beforeunload', this.handleBeforeUnload);
    }
    
    /**
     * Setup event listeners
     */
    setupEventListeners() {
        // Keyboard events
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Fullscreen change events
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Mouse wheel for zooming
        this.imageWrapper.addEventListener('wheel', this.handleWheel, { passive: false });
        
        // Touch events
        this.imageWrapper.addEventListener('touchstart', this.handleTouchStart, { passive: false });
        this.imageWrapper.addEventListener('touchmove', this.handleTouchMove, { passive: false });
        this.imageWrapper.addEventListener('touchend', this.handleTouchEnd, { passive: false });
    }
    
    /**
     * Load image by name - FIXED VERSION
     */
    loadImageByName(imageName) {
        // Convert to lowercase for case-insensitive matching
        imageName = imageName.toLowerCase();
        
        // Check if image exists
        if (!this.availableImages.hasOwnProperty(imageName)) {
            this.hideLoader();
            this.showNotification(`Image "${imageName}" not found. Please select from available images.`, 'error');
            return;
        }
        
        const imageData = this.availableImages[imageName];
        let imageUrl = '';
        let imageIndex = -1;
        
        // Handle array type (animal)
        if (imageData.type === 'array' && Array.isArray(imageData.urls)) {
            // Re-validate the current index to ensure it's still valid
            this.lastAnimalIndex = this.validateAnimalIndex(this.lastAnimalIndex);
            
            // Get the next index
            imageIndex = (this.lastAnimalIndex + 1) % imageData.urls.length;
            imageUrl = imageData.urls[imageIndex];
            
            // Debug logging
            console.log(`Loading animal image at index ${imageIndex}: ${imageUrl}`);
            
            // Store the index we're trying to load
            this.currentAnimalIndex = imageIndex;
        } else if (imageData.type === 'single') {
            imageUrl = imageData.url;
        }
        
        // Store current image info
        this.currentImageName = imageName;
        this.currentImageUrl = imageUrl;
        
        // Remove existing image if any
        if (this.imageElement && this.imageElement.parentNode) {
            this.imageElement.parentNode.removeChild(this.imageElement);
        }
        
        // Create new image element
        this.imageElement = document.createElement('img');
        this.imageElement.style.cssText = `
            max-width: 90%;
            max-height: 80vh;
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            object-fit: contain;
            transition: transform 0.1s ease-out;
            cursor: grab;
            user-select: none;
            display: none;
        `;
        
        // Handle image load
        this.imageElement.onload = () => {
            this.hideLoader();
            this.imageElement.style.display = 'block';
            this.updateZoomIndicator();
            this.showNotification(`Loaded: ${imageName}`, 'success');
            
            // Only update the stored index after successful load
            if (imageData.type === 'array' && Array.isArray(imageData.urls) && imageIndex >= 0) {
                this.lastAnimalIndex = imageIndex;
                this.saveToStorage("lastAnimalIndex", this.lastAnimalIndex);
                console.log(`Successfully loaded image, updated index to ${this.lastAnimalIndex}`);
            }
        };
        
        // Handle image error
        this.imageElement.onerror = () => {
            this.hideLoader();
            console.error(`Failed to load image: ${imageUrl}`);
            this.showNotification('Error loading image. Trying next available image...', 'error');
            
            // If animal image fails to load, try the next one
            if (imageData.type === 'array' && Array.isArray(imageData.urls)) {
                // Force index to move to next one
                this.lastAnimalIndex = (this.lastAnimalIndex + 1) % imageData.urls.length;
                this.saveToStorage("lastAnimalIndex", this.lastAnimalIndex);
                
                // Try loading the next image after a short delay
                setTimeout(() => {
                    this.loadImageByName(imageName);
                }, 1000);
            }
        };
        
        // Set image source
        this.imageElement.src = imageUrl;
        
        // Add to wrapper
        this.imageWrapper.appendChild(this.imageElement);
        
        // Add mouse events for panning
        this.imageElement.addEventListener('mousedown', this.handleMouseDown);
        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp);
    }
    
    /**
     * Show loader
     */
    showLoader() {
        if (this.loader) {
            this.loader.style.display = 'block';
            this.isLoading = true;
        }
    }
    
    /**
     * Hide loader
     */
    hideLoader() {
        if (this.loader) {
            this.loader.style.display = 'none';
            this.isLoading = false;
        }
    }
    
    /**
     * Show notification
     */
    showNotification(message, type = 'info') {
        // Remove existing notification
        if (this.notification && this.notification.parentNode) {
            this.notification.parentNode.removeChild(this.notification);
        }
        
        // Create notification
        this.notification = document.createElement('div');
        this.notification.className = 'notification';
        this.notification.textContent = message;
        
        // Set color based on type
        let bgColor = this.theme.secondary;
        if (type === 'error') bgColor = '#F44336';
        if (type === 'success') bgColor = this.theme.primary;
        
        this.notification.style.cssText = `
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: ${bgColor};
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 14px;
            font-weight: 500;
            z-index: 10001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
        `;
        
        // Add to container
        this.container.appendChild(this.notification);
        
        // Auto remove after 3 seconds
        setTimeout(() => {
            if (this.notification && this.notification.parentNode) {
                this.notification.style.opacity = '0';
                this.notification.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (this.notification && this.notification.parentNode) {
                        this.notification.parentNode.removeChild(this.notification);
                    }
                }, 500);
            }
        }, 3000);
    }
    
    /**
     * Zoom in
     */
    zoomIn() {
        if (this.isLoading || !this.imageElement) return;
        
        const newZoom = Math.min(this.zoomLevel + this.zoomStep, this.maxZoom);
        this.setZoom(newZoom);
    }
    
    /**
     * Zoom out
     */
    zoomOut() {
        if (this.isLoading || !this.imageElement) return;
        
        const newZoom = Math.max(this.zoomLevel - this.zoomStep, this.minZoom);
        this.setZoom(newZoom);
    }
    
    /**
     * Set zoom level
     */
    setZoom(level) {
        this.zoomLevel = level;
        this.updateImageTransform();
        this.updateZoomIndicator();
    }
    
    /**
     * Update image transform
     */
    updateImageTransform() {
        if (!this.imageElement) return;
        
        this.imageElement.style.transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.zoomLevel})`;
    }
    
    /**
     * Update zoom indicator
     */
    updateZoomIndicator() {
        if (this.zoomIndicator) {
            this.zoomIndicator.textContent = `${Math.round(this.zoomLevel * 100)}%`;
        }
    }
    
    /**
     * Reset view
     */
    resetView() {
        this.zoomLevel = 1;
        this.translateX = 0;
        this.translateY = 0;
        this.updateImageTransform();
        this.updateZoomIndicator();
        this.showNotification('View reset', 'info');
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!document.fullscreenElement) {
            this.enterFullscreen();
        } else {
            this.exitFullscreen();
        }
    }
    
    /**
     * Enter fullscreen
     */
    enterFullscreen() {
        if (this.container.requestFullscreen) {
            this.container.requestFullscreen();
        } else if (this.container.webkitRequestFullscreen) {
            this.container.webkitRequestFullscreen();
        } else if (this.container.msRequestFullscreen) {
            this.container.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen
     */
    exitFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }
    
    /**
     * Handle fullscreen change
     */
    handleFullscreenChange = () => {
        const isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        this.showNotification(isFullscreen ? 'Entered fullscreen' : 'Exited fullscreen', 'info');
    }
    
    /**
     * Download image
     */
    downloadImage() {
        if (!this.currentImageUrl) {
            this.showNotification('No image to download', 'error');
            return;
        }
        
        // Create a temporary link element
        const link = document.createElement('a');
        link.href = this.currentImageUrl;
        link.download = `${this.currentImageName || 'image'}.jpg`;
        
        // Append to body, click, and remove
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showNotification('Download started', 'success');
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (!this.isActive) return;
        
        switch (event.key) {
            case 'Escape':
                this.closeViewer();
                break;
            case '+':
            case '=':
                this.zoomIn();
                break;
            case '-':
            case '_':
                this.zoomOut();
                break;
            case '0':
                this.resetView();
                break;
            case 'f':
                this.toggleFullscreen();
                break;
            case 'd':
                this.downloadImage();
                break;
        }
    }
    
    /**
     * Handle mouse wheel
     */
    handleWheel = (event) => {
        if (!this.imageElement || this.isLoading) return;
        
        event.preventDefault();
        
        if (event.deltaY < 0) {
            this.zoomIn();
        } else {
            this.zoomOut();
        }
    }
    
    /**
     * Handle mouse down
     */
    handleMouseDown = (event) => {
        if (this.zoomLevel <= 1) return;
        
        this.isPanning = true;
        this.panStartX = event.clientX - this.translateX;
        this.panStartY = event.clientY - this.translateY;
        this.imageElement.style.cursor = 'grabbing';
        
        event.preventDefault();
    }
    
    /**
     * Handle mouse move
     */
    handleMouseMove = (event) => {
        if (!this.isPanning || !this.imageElement) return;
        
        this.translateX = event.clientX - this.panStartX;
        this.translateY = event.clientY - this.panStartY;
        this.updateImageTransform();
    }
    
    /**
     * Handle mouse up
     */
    handleMouseUp = () => {
        this.isPanning = false;
        if (this.imageElement) {
            this.imageElement.style.cursor = this.zoomLevel > 1 ? 'grab' : 'default';
        }
    }
    
    /**
     * Handle touch start
     */
    handleTouchStart = (event) => {
        if (event.touches.length === 1) {
            // Single touch - start panning
            this.isPanning = true;
            this.panStartX = event.touches[0].clientX - this.translateX;
            this.panStartY = event.touches[0].clientY - this.translateY;
        } else if (event.touches.length === 2) {
            // Two touches - start pinch to zoom
            this.isPanning = false;
            this.touchStartDistance = this.getTouchDistance(event.touches);
            this.touchStartZoom = this.zoomLevel;
        }
        
        event.preventDefault();
    }
    
    /**
     * Handle touch move
     */
    handleTouchMove = (event) => {
        if (event.touches.length === 1 && this.isPanning) {
            // Single touch - continue panning
            this.translateX = event.touches[0].clientX - this.panStartX;
            this.translateY = event.touches[0].clientY - this.panStartY;
            this.updateImageTransform();
        } else if (event.touches.length === 2) {
            // Two touches - pinch to zoom
            const currentDistance = this.getTouchDistance(event.touches);
            const scale = currentDistance / this.touchStartDistance;
            const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.touchStartZoom * scale));
            this.setZoom(newZoom);
        }
        
        event.preventDefault();
    }
    
    /**
     * Handle touch end
     */
    handleTouchEnd = (event) => {
        if (event.touches.length === 0) {
            this.isPanning = false;
        }
    }
    
    /**
     * Calculate distance between two touch points
     */
    getTouchDistance(touches) {
        if (touches.length < 2) return 0;
        
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * Handle before unload
     */
    handleBeforeUnload = (event) => {
        if (this.isActive) {
            event.preventDefault();
            event.returnValue = 'Are you sure you want to leave? Your image viewer session will be lost.';
            return event.returnValue;
        }
    }
    
    /**
     * Close the viewer
     */
    closeViewer() {
        if (!this.isActive) return;
        
        // Exit fullscreen if needed
        if (document.fullscreenElement) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        if (this.imageWrapper) {
            this.imageWrapper.removeEventListener('wheel', this.handleWheel);
            this.imageWrapper.removeEventListener('touchstart', this.handleTouchStart);
            this.imageWrapper.removeEventListener('touchmove', this.handleTouchMove);
            this.imageWrapper.removeEventListener('touchend', this.handleTouchEnd);
        }
        
        if (this.imageElement) {
            this.imageElement.removeEventListener('mousedown', this.handleMouseDown);
        }
        
        document.removeEventListener('mousemove', this.handleMouseMove);
        document.removeEventListener('mouseup', this.handleMouseUp);
        
        window.removeEventListener('beforeunload', this.handleBeforeUnload);
        
        // Remove container
        if (this.container && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
        
        // Reset state
        this.container = null;
        this.imageWrapper = null;
        this.imageElement = null;
        this.controlsPanel = null;
        this.thumbnailsPanel = null;
        this.loader = null;
        this.notification = null;
        this.isActive = false;
        
        botReply("Vipteammod Ai 3.0 Viewer closed. Thank you!");
    }
    
    // UI Theme
    theme = {
        primary: "#4CAF50",
        secondary: "#2196F3",
        accent: "#FFC107",
        dark: "#212121",
        light: "#FFFFFF",
        background: "rgba(18, 18, 18, 0.95)",
        panel: "rgba(33, 33, 33, 0.8)",
        hover: "rgba(66, 66, 66, 0.9)"
    };
}

// Create a singleton instance
const modernImageViewer = new ModernImageViewer();

// Function to extract exact image name from user input
function extractExactImageName(input) {
    const availableNames = Object.keys(modernImageViewer.availableImages);
    const lowerInput = input.toLowerCase();
    
    for (const name of availableNames) {
        if (lowerInput.includes(name)) {
            return name;
        }
    }
    
    return null;
}

// Pattern to match image requests
const imageRequestPattern = /(?:show me|display|view|get|I want|see)\s+(?:a|an|the)?\s*(.+?)\s*(?:photo|picture|image|pic)/i;

if (imageRequestPattern.test(userInputRaw)) {
    const match = userInputRaw.match(imageRequestPattern);
    if (match && match[1]) {
        const imageName = extractExactImageName(userInputRaw);
        
        if (imageName) {
            modernImageViewer.loadImage(imageName);
        } else {
            botReply("I don't have that image. Please try one of the available images: " + 
                     Object.keys(modernImageViewer.availableImages).join(", "));
        }
    }
    return;
}

// Add command to close the viewer
if (/close viewer|exit viewer/i.test(userInputRaw)) {
    modernImageViewer.closeViewer();
    return;
}

class ColorCameraScreenLoader {
    constructor() {
        this.camera = {
            name: 'COLOR CAMERA',
            instructions: 'Point your camera at objects to detect colors in real-time.'
        };
        
        this.gameContainer = null;
        this.video = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.colorDisplay = null;
        this.colorInfo = null;
        this.copyButton = null;
        this.stream = null;
        this.animationId = null;
        this.currentColor = {
            r: 0,
            g: 0,
            b: 0,
            hex: '#000000',
            hsl: { h: 0, s: 0, l: 0 },
            name: 'Black'
        };
    }
    
    /**
     * Load the Color Camera
     */
    loadColorCamera() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.camera.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Set up camera
        this.setupCamera();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the camera
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.camera.name} loaded! ${this.camera.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Set up the camera and canvas for color detection
     */
    async setupCamera() {
        try {
            // Create video element
            this.video = document.createElement('video');
            this.video.style.cssText = `
                width: 90%;
                max-width: 1200px;
                height: 70vh;
                max-height: 800px;
                border: none;
                border-radius: 8px;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
                object-fit: cover;
                display: block;
            `;
            this.video.autoplay = true;
            this.video.playsInline = true;
            
            // Create canvas for color analysis
            this.canvas = document.createElement('canvas');
            this.canvas.style.cssText = `
                display: none;
            `;
            this.ctx = this.canvas.getContext('2d');
            
            // Create color display container
            this.colorDisplay = document.createElement('div');
            this.colorDisplay.style.cssText = `
                width: 90%;
                max-width: 1200px;
                height: 60px;
                margin-top: 20px;
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 18px;
                font-weight: bold;
                text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
                transition: background-color 0.3s ease;
                background-color: #333;
            `;
            this.colorDisplay.textContent = 'Point camera at an object to detect color';
            
            // Create color info container
            this.colorInfo = document.createElement('div');
            this.colorInfo.style.cssText = `
                width: 90%;
                max-width: 1200px;
                margin-top: 15px;
                padding: 15px;
                border-radius: 8px;
                background-color: rgba(0, 0, 0, 0.6);
                color: white;
                font-size: 16px;
                text-align: center;
            `;
            this.colorInfo.textContent = 'RGB: - | HEX: - | HSL: -';
            
            // Add elements to container
            this.gameContainer.appendChild(this.video);
            this.gameContainer.appendChild(this.canvas);
            this.gameContainer.appendChild(this.colorDisplay);
            this.gameContainer.appendChild(this.colorInfo);
            
            // Get camera stream
            this.stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                } 
            });
            
            // Set video source
            this.video.srcObject = this.stream;
            
            // Start color detection when video is ready
            this.video.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                
                // Start color detection loop
                this.detectColors();
            };
            
        } catch (error) {
            console.error('Error accessing camera:', error);
            this.showError('Could not access camera. Please check permissions.');
            this.closeGame();
        }
    }
    
    /**
     * Detect colors from the video stream
     */
    detectColors() {
        if (!this.isActive) return;
        
        // Draw video frame to canvas
        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
        
        // Get center pixel data
        const centerX = Math.floor(this.canvas.width / 2);
        const centerY = Math.floor(this.canvas.height / 2);
        
        // Get a small sample area around the center for more stable readings
        const sampleSize = 20;
        const startX = centerX - Math.floor(sampleSize / 2);
        const startY = centerY - Math.floor(sampleSize / 2);
        
        const imageData = this.ctx.getImageData(startX, startY, sampleSize, sampleSize);
        const data = imageData.data;
        
        // Calculate average color from sample area
        let r = 0, g = 0, b = 0;
        const pixelCount = data.length / 4;
        
        for (let i = 0; i < data.length; i += 4) {
            r += data[i];
            g += data[i + 1];
            b += data[i + 2];
        }
        
        r = Math.floor(r / pixelCount);
        g = Math.floor(g / pixelCount);
        b = Math.floor(b / pixelCount);
        
        // Convert to hex
        const hex = this.rgbToHex(r, g, b);
        
        // Convert to HSL
        const hsl = this.rgbToHsl(r, g, b);
        
        // Find closest color name
        const colorName = this.findClosestColorName(r, g, b);
        
        // Update current color
        this.currentColor = { r, g, b, hex, hsl, name: colorName };
        
        // Update UI
        this.updateColorDisplay(r, g, b, hex, hsl, colorName);
        
        // Continue detection loop
        this.animationId = requestAnimationFrame(() => this.detectColors());
    }
    
    /**
     * Convert RGB to HEX
     */
    rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    
    /**
     * Convert RGB to HSL
     */
    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            
            h /= 6;
        }
        
        return {
            h: Math.round(h * 360),
            s: Math.round(s * 100),
            l: Math.round(l * 100)
        };
    }
    
    /**
     * Find the closest color name to the RGB values
     */
    findClosestColorName(r, g, b) {
        // Common color palette with RGB values
        const colors = [
            { name: 'Red', rgb: [255, 0, 0] },
            { name: 'Green', rgb: [0, 255, 0] },
            { name: 'Blue', rgb: [0, 0, 255] },
            { name: 'Yellow', rgb: [255, 255, 0] },
            { name: 'Cyan', rgb: [0, 255, 255] },
            { name: 'Magenta', rgb: [255, 0, 255] },
            { name: 'Orange', rgb: [255, 165, 0] },
            { name: 'Purple', rgb: [128, 0, 128] },
            { name: 'Pink', rgb: [255, 192, 203] },
            { name: 'Brown', rgb: [165, 42, 42] },
            { name: 'Black', rgb: [0, 0, 0] },
            { name: 'White', rgb: [255, 255, 255] },
            { name: 'Gray', rgb: [128, 128, 128] },
            { name: 'Lime', rgb: [0, 255, 0] },
            { name: 'Navy', rgb: [0, 0, 128] },
            { name: 'Teal', rgb: [0, 128, 128] },
            { name: 'Gold', rgb: [255, 215, 0] },
            { name: 'Silver', rgb: [192, 192, 192] },
            { name: 'Maroon', rgb: [128, 0, 0] },
            { name: 'Olive', rgb: [128, 128, 0] }
        ];
        
        let minDistance = Infinity;
        let closestColor = 'Unknown';
        
        // Calculate Euclidean distance to find closest color
        for (const color of colors) {
            const distance = Math.sqrt(
                Math.pow(r - color.rgb[0], 2) +
                Math.pow(g - color.rgb[1], 2) +
                Math.pow(b - color.rgb[2], 2)
            );
            
            if (distance < minDistance) {
                minDistance = distance;
                closestColor = color.name;
            }
        }
        
        return closestColor;
    }
    
    /**
     * Update the color display UI
     */
    updateColorDisplay(r, g, b, hex, hsl, colorName) {
        // Update color display background
        this.colorDisplay.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
        
        // Determine text color based on background brightness
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        this.colorDisplay.style.color = brightness > 125 ? 'black' : 'white';
        
        // Update color display text
        this.colorDisplay.textContent = colorName;
        
        // Update color info
        this.colorInfo.innerHTML = `
            RGB: ${r}, ${g}, ${b} | 
            HEX: ${hex} | 
            HSL: ${hsl.h}°, ${hsl.s}%, ${hsl.l}%
        `;
    }
    
    /**
     * Copy color information to clipboard
     */
    async copyColorInfo() {
        if (!this.currentColor) return;
        
        const { r, g, b, hex, hsl, name } = this.currentColor;
        const colorText = `Color: ${name}\nRGB: ${r}, ${g}, ${b}\nHEX: ${hex}\nHSL: ${hsl.h}°, ${hsl.s}%, ${hsl.l}%`;
        
        try {
            await navigator.clipboard.writeText(colorText);
            this.showNotification('Color information copied to clipboard!');
        } catch (err) {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = colorText;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            this.showNotification('Color information copied to clipboard!');
        }
    }
    
    /**
     * Show notification message
     */
    showNotification(message) {
        // Create notification element
        const notificationElement = document.createElement('div');
        notificationElement.textContent = message;
        notificationElement.style.cssText = `
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeInOut 2s ease-in-out forwards;
        `;
        
        // Add animation keyframes if not already added
        if (!document.getElementById('notification-animation')) {
            const style = document.createElement('style');
            style.id = 'notification-animation';
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                    20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Add to container
        this.gameContainer.appendChild(notificationElement);
        
        // Remove after animation completes
        setTimeout(() => {
            if (notificationElement.parentNode) {
                notificationElement.parentNode.removeChild(notificationElement);
            }
        }, 2000);
    }
    
    /**
     * Show error message
     */
    showError(message) {
        // Create error element
        const errorElement = document.createElement('div');
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        `;
        
        // Add to container
        this.gameContainer.appendChild(errorElement);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (errorElement.parentNode) {
                errorElement.parentNode.removeChild(errorElement);
            }
        }, 3000);
    }
    
    /**
     * Set up action buttons (fullscreen, copy, and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border-radius: 4px;
            box-shadow: 0 0 10px #4CAF50;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create copy button
        this.copyButton = document.createElement('button');
        this.copyButton.innerHTML = '📋';
        this.copyButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2196F3, #1976D2);
            border-radius: 4px;
            box-shadow: 0 0 10px #2196F3;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.copyButton.onmouseover = () => {
            this.copyButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.copyButton.style.transform = 'scale(1.1)';
        };
        
        this.copyButton.onmouseout = () => {
            this.copyButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.copyButton.style.transform = 'scale(1)';
        };
        
        this.copyButton.onclick = (e) => {
            e.stopPropagation();
            this.copyColorInfo();
        };
        
        floatingButtons.appendChild(this.copyButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.key === 'c' && (event.ctrlKey || event.metaKey)) {
            // Handle Ctrl+C or Cmd+C to copy color info
            this.copyColorInfo();
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust video size based on fullscreen state
        if (this.video) {
            if (this.isFullscreen) {
                this.video.style.width = '98%';
                this.video.style.height = '75vh';
            } else {
                this.video.style.width = '90%';
                this.video.style.height = '70vh';
            }
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Stop animation frame
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        // Stop camera stream
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.video = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.copyButton = null;
        this.colorDisplay = null;
        this.colorInfo = null;
        this.stream = null;
        this.animationId = null;
        this.currentColor = {
            r: 0,
            g: 0,
            b: 0,
            hex: '#000000',
            hsl: { h: 0, s: 0, l: 0 },
            name: 'Black'
        };
        
        botReply("Color Camera closed. Thank you!");
    }
}

// Create a singleton instance
const colorCameraScreenLoader = new ColorCameraScreenLoader();

// Add this to your AI's command handling
if (/color camera|camera color|detect color/i.test(userInputRaw)) {
    colorCameraScreenLoader.loadColorCamera();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    colorCameraScreenLoader.closeGame();
    return;
}
class MathSolverScreenLoader {
    constructor() {
        this.solver = {
            name: 'MATH SOLVER',
            instructions: 'Enter a math problem or equation to solve it step by step.'
        };
        
        this.gameContainer = null;
        this.inputArea = null;
        this.solutionArea = null;
        this.historyPanel = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.solveButton = null;
        this.clearButton = null;
        this.historyButton = null;
        this.copyButton = null;
        this.history = [];
        this.animationId = null;
        this.currentProblem = '';
        this.currentSolution = '';
    }
    
    /**
     * Load the Math Solver
     */
    loadMathSolver() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.solver.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Set up solver interface
        this.setupSolverInterface();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the solver
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.solver.name} loaded! ${this.solver.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }
    
    /**
     * Set up the solver interface
     */
    setupSolverInterface() {
        // Create title
        const title = document.createElement('h1');
        title.textContent = this.solver.name;
        title.style.cssText = `
            color: white;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        `;
        
        // Create input area
        this.inputArea = document.createElement('div');
        this.inputArea.style.cssText = `
            width: 90%;
            max-width: 800px;
            margin-bottom: 20px;
        `;
        
        // Create problem input
        const problemInput = document.createElement('input');
        problemInput.type = 'text';
        problemInput.placeholder = 'Enter a math problem (e.g., 2x + 5 = 15)';
        problemInput.style.cssText = `
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border-radius: 8px;
            border: none;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            margin-bottom: 15px;
        `;
        
        problemInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.solveProblem(problemInput.value);
            }
        });
        
        // Create solution area
        this.solutionArea = document.createElement('div');
        this.solutionArea.style.cssText = `
            width: 90%;
            max-width: 800px;
            min-height: 200px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            color: white;
            font-size: 18px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            max-height: 300px;
        `;
        
        this.solutionArea.textContent = 'Your solution will appear here...';
        
        // Create history panel (initially hidden)
        this.historyPanel = document.createElement('div');
        this.historyPanel.style.cssText = `
            width: 90%;
            max-width: 800px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            color: white;
            font-size: 16px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            max-height: 300px;
            display: none;
        `;
        
        const historyTitle = document.createElement('h3');
        historyTitle.textContent = 'Problem History';
        historyTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            color: #4CAF50;
        `;
        
        this.historyPanel.appendChild(historyTitle);
        
        // Add elements to input area
        this.inputArea.appendChild(problemInput);
        
        // Add all elements to container
        this.gameContainer.appendChild(title);
        this.gameContainer.appendChild(this.inputArea);
        this.gameContainer.appendChild(this.solutionArea);
        this.gameContainer.appendChild(this.historyPanel);
        
        // Store reference to problem input
        this.problemInput = problemInput;
    }
    
    /**
     * Solve the math problem
     */
    solveProblem(problem) {
        if (!problem || problem.trim() === '') {
            this.showError('Please enter a math problem to solve.');
            return;
        }
        
        this.currentProblem = problem;
        
        // Show solving message
        this.solutionArea.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center;">
                <div style="width: 30px; height: 30px; border: 3px solid rgba(255,255,255,0.3); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; margin-right: 15px;"></div>
                <span>Solving: ${problem}</span>
            </div>
            <style>
                @keyframes spin {
                    to { transform: rotate(360deg); }
                }
            </style>
        `;
        
        // Simulate solving delay for better UX
        setTimeout(() => {
            try {
                // In a real implementation, you would use a math solving library or API
                // For this example, we'll create a simple solver for basic operations
                const solution = this.calculateSolution(problem);
                
                // Display the solution
                this.displaySolution(problem, solution);
                
                // Add to history
                this.addToHistory(problem, solution);
                
            } catch (error) {
                console.error('Error solving problem:', error);
                this.showError('Could not solve the problem. Please check your input.');
            }
        }, 1000);
    }
    
    /**
     * Calculate the solution to the problem
     */
    calculateSolution(problem) {
        // Handle basic arithmetic with proper order of operations
        if (problem.includes('-') && problem.includes('+')) {
            // Split by operators while keeping them
            const parts = problem.split(/([+-])/).filter(p => p.trim() !== '');
            
            // Start with the first number
            let result = parseFloat(parts[0].trim());
            let steps = [`Problem: ${problem}`, `Start with: ${result}`];
            
            // Process each operator and number pair
            for (let i = 1; i < parts.length; i += 2) {
                const operator = parts[i].trim();
                const number = parseFloat(parts[i + 1].trim());
                
                if (operator === '+') {
                    result += number;
                    steps.push(`Add: ${result - number} + ${number} = ${result}`);
                } else if (operator === '-') {
                    result -= number;
                    steps.push(`Subtract: ${result + number} - ${number} = ${result}`);
                }
            }
            
            return {
                steps: steps,
                result: result
            };
        }
        
        // Handle basic addition
        if (problem.includes('+') && !problem.includes('-')) {
            const parts = problem.split('+').map(p => parseFloat(p.trim()));
            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                return {
                    steps: [
                        `Problem: ${problem}`,
                        `Add the numbers: ${parts[0]} + ${parts[1]}`,
                        `Result: ${parts[0] + parts[1]}`
                    ],
                    result: parts[0] + parts[1]
                };
            }
        }
        
        // Handle basic subtraction
        if (problem.includes('-') && !problem.includes('+')) {
            const parts = problem.split('-').map(p => parseFloat(p.trim()));
            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                return {
                    steps: [
                        `Problem: ${problem}`,
                        `Subtract the numbers: ${parts[0]} - ${parts[1]}`,
                        `Result: ${parts[0] - parts[1]}`
                    ],
                    result: parts[0] - parts[1]
                };
            }
        }
        
        // Handle multiplication
        if (problem.includes('*') || problem.includes('×')) {
            const parts = problem.split(/[*×]/).map(p => parseFloat(p.trim()));
            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                return {
                    steps: [
                        `Problem: ${problem}`,
                        `Multiply the numbers: ${parts[0]} × ${parts[1]}`,
                        `Result: ${parts[0] * parts[1]}`
                    ],
                    result: parts[0] * parts[1]
                };
            }
        }
        
        // Handle division
        if (problem.includes('/') || problem.includes('÷')) {
            const parts = problem.split(/[/÷]/).map(p => parseFloat(p.trim()));
            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                if (parts[1] === 0) {
                    throw new Error('Division by zero');
                }
                return {
                    steps: [
                        `Problem: ${problem}`,
                        `Divide the numbers: ${parts[0]} ÷ ${parts[1]}`,
                        `Result: ${parts[0] / parts[1]}`
                    ],
                    result: parts[0] / parts[1]
                };
            }
        }
        
        // Handle simple linear equations (e.g., 2x + 5 = 15)
        const equationMatch = problem.match(/([0-9.]*x)\s*([+-])\s*([0-9.]+)\s*=\s*([0-9.]+)/i);
        if (equationMatch) {
            const xCoeff = equationMatch[1].replace('x', '') || '1';
            const operator = equationMatch[2];
            const constant = parseFloat(equationMatch[3]);
            const result = parseFloat(equationMatch[4]);
            
            const a = parseFloat(xCoeff);
            const b = operator === '+' ? constant : -constant;
            
            // Solve for x: ax + b = result => x = (result - b) / a
            const x = (result - b) / a;
            
            return {
                steps: [
                    `Problem: ${problem}`,
                    `Isolate the variable term: ${a}x = ${result} ${operator === '+' ? '-' : '+'} ${constant}`,
                    `Simplify: ${a}x = ${result - b}`,
                    `Solve for x: x = ${(result - b)} ÷ ${a}`,
                    `Result: x = ${x}`
                ],
                result: `x = ${x}`
            };
        }
        
        // If no pattern matches, return a generic response
        return {
            steps: [
                `Problem: ${problem}`,
                `This problem requires advanced mathematical operations.`,
                `In a full implementation, this would connect to a math solving API.`,
                `For now, please try simpler arithmetic or linear equations.`
            ],
            result: 'Cannot solve with current implementation'
        };
    }
    
    /**
     * Display the solution
     */
    displaySolution(problem, solution) {
        this.currentSolution = solution;
        
        // Format solution steps
        const stepsHtml = solution.steps.map(step => `<div style="margin-bottom: 10px;">${step}</div>`).join('');
        
        // Display solution
        this.solutionArea.innerHTML = `
            <div style="margin-bottom: 15px;">
                <h3 style="margin-top: 0; color: #4CAF50;">Solution</h3>
                ${stepsHtml}
            </div>
            <div style="padding: 10px; background-color: rgba(76, 175, 80, 0.2); border-radius: 5px; font-weight: bold;">
                Final Answer: ${solution.result}
            </div>
        `;
    }
    
    /**
     * Add problem to history
     */
    addToHistory(problem, solution) {
        // Add to history array
        this.history.unshift({
            problem,
            solution: solution.result,
            timestamp: new Date().toLocaleTimeString()
        });
        
        // Limit history to 10 items
        if (this.history.length > 10) {
            this.history = this.history.slice(0, 10);
        }
        
        // Update history panel
        this.updateHistoryPanel();
    }
    
    /**
     * Update the history panel
     */
    updateHistoryPanel() {
        // Clear existing history items (except title)
        const historyItems = this.historyPanel.querySelectorAll('.history-item');
        historyItems.forEach(item => item.remove());
        
        // Add history items
        this.history.forEach(item => {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.style.cssText = `
                padding: 10px;
                margin-bottom: 10px;
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.2s;
            `;
            
            historyItem.innerHTML = `
                <div style="display: flex; justify-content: space-between;">
                    <span>${item.problem}</span>
                    <span style="color: #4CAF50;">${item.timestamp}</span>
                </div>
                <div style="font-size: 14px; color: #ccc; margin-top: 5px;">
                    Answer: ${item.solution}
                </div>
            `;
            
            // Add click event to restore problem
            historyItem.addEventListener('click', () => {
                this.problemInput.value = item.problem;
                this.problemInput.focus();
            });
            
            this.historyPanel.appendChild(historyItem);
        });
    }
    
    /**
     * Toggle history panel visibility
     */
    toggleHistory() {
        if (this.historyPanel.style.display === 'none') {
            this.historyPanel.style.display = 'block';
            this.updateHistoryPanel();
        } else {
            this.historyPanel.style.display = 'none';
        }
    }
    
    /**
     * Clear the current problem and solution
     */
    clearSolver() {
        this.problemInput.value = '';
        this.solutionArea.textContent = 'Your solution will appear here...';
        this.problemInput.focus();
    }
    
    /**
     * Copy solution to clipboard
     */
    async copySolution() {
        if (!this.currentSolution) return;
        
        const solutionText = `Problem: ${this.currentProblem}\n\nSolution:\n${this.currentSolution.steps.join('\n')}\n\nFinal Answer: ${this.currentSolution.result}`;
        
        try {
            await navigator.clipboard.writeText(solutionText);
            this.showNotification('Solution copied to clipboard!');
        } catch (err) {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = solutionText;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            this.showNotification('Solution copied to clipboard!');
        }
    }
    
    /**
     * Show notification message
     */
    showNotification(message) {
        // Create notification element
        const notificationElement = document.createElement('div');
        notificationElement.textContent = message;
        notificationElement.style.cssText = `
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeInOut 2s ease-in-out forwards;
        `;
        
        // Add animation keyframes if not already added
        if (!document.getElementById('notification-animation')) {
            const style = document.createElement('style');
            style.id = 'notification-animation';
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                    20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Add to container
        this.gameContainer.appendChild(notificationElement);
        
        // Remove after animation completes
        setTimeout(() => {
            if (notificationElement.parentNode) {
                notificationElement.parentNode.removeChild(notificationElement);
            }
        }, 2000);
    }
    
    /**
     * Show error message
     */
    showError(message) {
        // Create error element
        const errorElement = document.createElement('div');
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        `;
        
        // Add to container
        this.gameContainer.appendChild(errorElement);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (errorElement.parentNode) {
                errorElement.parentNode.removeChild(errorElement);
            }
        }, 3000);
    }
    
    /**
     * Set up action buttons (fullscreen, solve, clear, history, copy, and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border-radius: 4px;
            box-shadow: 0 0 10px #4CAF50;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create solve button
        this.solveButton = document.createElement('button');
        this.solveButton.innerHTML = '=';
        this.solveButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2196F3, #1976D2);
            border-radius: 4px;
            box-shadow: 0 0 10px #2196F3;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.solveButton.onmouseover = () => {
            this.solveButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.solveButton.style.transform = 'scale(1.1)';
        };
        
        this.solveButton.onmouseout = () => {
            this.solveButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.solveButton.style.transform = 'scale(1)';
        };
        
        this.solveButton.onclick = (e) => {
            e.stopPropagation();
            this.solveProblem(this.problemInput.value);
        };
        
        floatingButtons.appendChild(this.solveButton);
        
        // Create clear button
        this.clearButton = document.createElement('button');
        this.clearButton.innerHTML = '🧹';
        this.clearButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #FF9800, #F57C00);
            border-radius: 4px;
            box-shadow: 0 0 10px #FF9800;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.clearButton.onmouseover = () => {
            this.clearButton.style.backgroundColor = 'rgba(255, 152, 0, 1)';
            this.clearButton.style.transform = 'scale(1.1)';
        };
        
        this.clearButton.onmouseout = () => {
            this.clearButton.style.backgroundColor = 'rgba(255, 152, 0, 0.8)';
            this.clearButton.style.transform = 'scale(1)';
        };
        
        this.clearButton.onclick = (e) => {
            e.stopPropagation();
            this.clearSolver();
        };
        
        floatingButtons.appendChild(this.clearButton);
        
        // Create history button
        this.historyButton = document.createElement('button');
        this.historyButton.innerHTML = '📜';
        this.historyButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #9C27B0, #7B1FA2);
            border-radius: 4px;
            box-shadow: 0 0 10px #9C27B0;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.historyButton.onmouseover = () => {
            this.historyButton.style.backgroundColor = 'rgba(156, 39, 176, 1)';
            this.historyButton.style.transform = 'scale(1.1)';
        };
        
        this.historyButton.onmouseout = () => {
            this.historyButton.style.backgroundColor = 'rgba(156, 39, 176, 0.8)';
            this.historyButton.style.transform = 'scale(1)';
        };
        
        this.historyButton.onclick = (e) => {
            e.stopPropagation();
            this.toggleHistory();
        };
        
        floatingButtons.appendChild(this.historyButton);
        
        // Create copy button
        this.copyButton = document.createElement('button');
        this.copyButton.innerHTML = '📋';
        this.copyButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #607D8B, #455A64);
            border-radius: 4px;
            box-shadow: 0 0 10px #607D8B;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.copyButton.onmouseover = () => {
            this.copyButton.style.backgroundColor = 'rgba(96, 125, 139, 1)';
            this.copyButton.style.transform = 'scale(1.1)';
        };
        
        this.copyButton.onmouseout = () => {
            this.copyButton.style.backgroundColor = 'rgba(96, 125, 139, 0.8)';
            this.copyButton.style.transform = 'scale(1)';
        };
        
        this.copyButton.onclick = (e) => {
            e.stopPropagation();
            this.copySolution();
        };
        
        floatingButtons.appendChild(this.copyButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #f44336, #d32f2f);
            border-radius: 4px;
            box-shadow: 0 0 10px #f44336;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Focus on input
        this.problemInput.focus();
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.key === 'c' && (event.ctrlKey || event.metaKey)) {
            // Handle Ctrl+C or Cmd+C to copy solution
            this.copySolution();
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.inputArea = null;
        this.solutionArea = null;
        this.historyPanel = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.solveButton = null;
        this.clearButton = null;
        this.historyButton = null;
        this.copyButton = null;
        this.history = [];
        this.animationId = null;
        this.currentProblem = '';
        this.currentSolution = '';
        
        botReply("Math Solver closed. Thank you!");
    }
}

// Create a singleton instance
const mathSolverScreenLoader = new MathSolverScreenLoader();

// Add this to your AI's command handling
if (/math solver|solve math|mathematics/i.test(userInputRaw)) {
    mathSolverScreenLoader.loadMathSolver();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    mathSolverScreenLoader.closeGame();
    return;
}

class AutoObjectSizeCalculatorScreenLoader {
    constructor() {
        this.calculator = {
            name: 'AUTO OBJECT SIZE CALCULATOR',
            instructions: 'Point your camera at an object to automatically detect and measure its size.'
        };
        
        this.gameContainer = null;
        this.video = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.copyButton = null;
        this.calibrationButton = null;
        this.stream = null;
        this.animationId = null;
        
        // Measurement properties
        this.isCalibrated = false;
        this.calibrationDistance = 30; // Default distance in cm
        this.pixelsPerCm = 0;
        this.currentMeasurements = [];
        this.referenceObjectSize = 10; // Default reference object size in cm
        
        // UI elements
        this.measurementDisplay = null;
        this.calibrationPanel = null;
        this.instructionsPanel = null;
        this.detectionCanvas = null;
        this.detectionCtx = null;
        
        // Object detection properties
        this.isDetecting = false;
        this.detectedObjects = [];
        this.objectDetectionInterval = null;
    }
    
    /**
     * Load the Auto Object Size Calculator
     */
    loadAutoObjectSizeCalculator() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.calculator.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Set up camera
        this.setupCamera();
        
        // Set up UI elements
        this.setupUI();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the calculator
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.calculator.name} loaded! ${this.calculator.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Set up the camera
     */
    async setupCamera() {
        try {
            // Create video element
            this.video = document.createElement('video');
            this.video.style.cssText = `
                width: 90%;
                max-width: 1200px;
                height: 70vh;
                max-height: 800px;
                border: none;
                border-radius: 8px;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
                object-fit: cover;
                display: block;
            `;
            this.video.autoplay = true;
            this.video.playsInline = true;
            
            // Create canvas for processing
            this.canvas = document.createElement('canvas');
            this.canvas.style.cssText = `
                display: none;
            `;
            this.ctx = this.canvas.getContext('2d');
            
            // Create detection canvas for overlay
            this.detectionCanvas = document.createElement('canvas');
            this.detectionCanvas.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 90%;
                max-width: 1200px;
                height: 70vh;
                max-height: 800px;
                border-radius: 8px;
                pointer-events: none;
                z-index: 10000;
            `;
            this.detectionCtx = this.detectionCanvas.getContext('2d');
            
            // Add elements to container
            this.gameContainer.appendChild(this.video);
            this.gameContainer.appendChild(this.canvas);
            this.gameContainer.appendChild(this.detectionCanvas);
            
            // Get camera stream
            this.stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                } 
            });
            
            // Set video source
            this.video.srcObject = this.stream;
            
            // Start rendering when video is ready
            this.video.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                this.detectionCanvas.width = this.video.videoWidth;
                this.detectionCanvas.height = this.video.videoHeight;
                
                // Start rendering loop
                this.render();
            };
            
        } catch (error) {
            console.error('Error accessing camera:', error);
            this.showError('Could not access camera. Please check permissions.');
            this.closeGame();
        }
    }
    
    /**
     * Set up UI elements
     */
    setupUI() {
        // Create measurement display
        this.measurementDisplay = document.createElement('div');
        this.measurementDisplay.style.cssText = `
            width: 90%;
            max-width: 1200px;
            height: 60px;
            margin-top: 20px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
            transition: background-color 0.3s ease;
            background-color: #333;
        `;
        this.measurementDisplay.textContent = 'Calibrate first to detect objects';
        
        // Create calibration panel (initially hidden)
        this.calibrationPanel = document.createElement('div');
        this.calibrationPanel.style.cssText = `
            width: 90%;
            max-width: 1200px;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 16px;
            text-align: center;
            display: none;
        `;
        
        // Reference object size input
        const sizeInputContainer = document.createElement('div');
        sizeInputContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const sizeInputLabel = document.createElement('label');
        sizeInputLabel.textContent = 'Reference Object Size (cm):';
        sizeInputLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const sizeInput = document.createElement('input');
        sizeInput.type = 'number';
        sizeInput.value = this.referenceObjectSize;
        sizeInput.min = '0.1';
        sizeInput.step = '0.1';
        sizeInput.style.cssText = `
            width: 100px;
            padding: 8px;
            border-radius: 4px;
            border: none;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
        `;
        
        sizeInput.addEventListener('change', (e) => {
            this.referenceObjectSize = parseFloat(e.target.value);
        });
        
        sizeInputContainer.appendChild(sizeInputLabel);
        sizeInputContainer.appendChild(sizeInput);
        
        // Distance input
        const distanceInputContainer = document.createElement('div');
        distanceInputContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const distanceInputLabel = document.createElement('label');
        distanceInputLabel.textContent = 'Distance to Object (cm):';
        distanceInputLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const distanceInput = document.createElement('input');
        distanceInput.type = 'number';
        distanceInput.value = this.calibrationDistance;
        distanceInput.min = '1';
        distanceInput.step = '1';
        distanceInput.style.cssText = `
            width: 100px;
            padding: 8px;
            border-radius: 4px;
            border: none;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
        `;
        
        distanceInput.addEventListener('change', (e) => {
            this.calibrationDistance = parseFloat(e.target.value);
        });
        
        distanceInputContainer.appendChild(distanceInputLabel);
        distanceInputContainer.appendChild(distanceInput);
        
        // Calibration button
        const calibrateButton = document.createElement('button');
        calibrateButton.textContent = 'Calibrate';
        calibrateButton.style.cssText = `
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        `;
        
        calibrateButton.onmouseover = () => {
            calibrateButton.style.backgroundColor = '#388E3C';
        };
        
        calibrateButton.onmouseout = () => {
            calibrateButton.style.backgroundColor = '#4CAF50';
        };
        
        calibrateButton.onclick = () => {
            this.calibrateSize();
        };
        
        // Add elements to calibration panel
        this.calibrationPanel.appendChild(sizeInputContainer);
        this.calibrationPanel.appendChild(distanceInputContainer);
        this.calibrationPanel.appendChild(calibrateButton);
        
        // Create instructions panel
        this.instructionsPanel = document.createElement('div');
        this.instructionsPanel.style.cssText = `
            width: 90%;
            max-width: 1200px;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 16px;
            text-align: center;
        `;
        
        this.instructionsPanel.innerHTML = `
            <strong>Instructions:</strong><br>
            1. Click "Calibrate" and place a reference object of known size in front of the camera<br>
            2. Enter the reference object size and distance, then click "Calibrate"<br>
            3. The system will automatically detect objects and calculate their sizes<br>
            4. Detected objects will be outlined with their dimensions displayed
        `;
        
        // Add all elements to container
        this.gameContainer.appendChild(this.measurementDisplay);
        this.gameContainer.appendChild(this.calibrationPanel);
        this.gameContainer.appendChild(this.instructionsPanel);
    }
    
    /**
     * Set up action buttons
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10002;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border-radius: 4px;
            box-shadow: 0 0 10px #4CAF50;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create calibration button
        this.calibrationButton = document.createElement('button');
        this.calibrationButton.innerHTML = '📏';
        this.calibrationButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2196F3, #1976D2);
            border-radius: 4px;
            box-shadow: 0 0 10px #2196F3;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.calibrationButton.onmouseover = () => {
            this.calibrationButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.calibrationButton.style.transform = 'scale(1.1)';
        };
        
        this.calibrationButton.onmouseout = () => {
            this.calibrationButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.calibrationButton.style.transform = 'scale(1)';
        };
        
        this.calibrationButton.onclick = (e) => {
            e.stopPropagation();
            this.toggleCalibrationPanel();
        };
        
        floatingButtons.appendChild(this.calibrationButton);
        
        // Create copy button
        this.copyButton = document.createElement('button');
        this.copyButton.innerHTML = '📋';
        this.copyButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #607D8B, #455A64);
            border-radius: 4px;
            box-shadow: 0 0 10px #607D8B;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.copyButton.onmouseover = () => {
            this.copyButton.style.backgroundColor = 'rgba(96, 125, 139, 1)';
            this.copyButton.style.transform = 'scale(1.1)';
        };
        
        this.copyButton.onmouseout = () => {
            this.copyButton.style.backgroundColor = 'rgba(96, 125, 139, 0.8)';
            this.copyButton.style.transform = 'scale(1)';
        };
        
        this.copyButton.onclick = (e) => {
            e.stopPropagation();
            this.copyMeasurements();
        };
        
        floatingButtons.appendChild(this.copyButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #f44336, #d32f2f);
            border-radius: 4px;
            box-shadow: 0 0 10px #f44336;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Toggle calibration panel visibility
     */
    toggleCalibrationPanel() {
        if (this.calibrationPanel.style.display === 'none') {
            this.calibrationPanel.style.display = 'block';
            this.instructionsPanel.style.display = 'none';
            this.stopObjectDetection();
        } else {
            this.calibrationPanel.style.display = 'none';
            this.instructionsPanel.style.display = 'block';
            
            if (this.isCalibrated) {
                this.startObjectDetection();
            }
        }
    }
    
    /**
     * Calibrate size calculation
     */
    calibrateSize() {
        if (!this.calibrationDistance || this.calibrationDistance <= 0) {
            this.showError('Please enter a valid distance.');
            return;
        }
        
        // Calculate pixels per cm based on reference object size and distance
        // This is a simplified calculation - in reality, you'd need to account for camera focal length, etc.
        const referencePixels = Math.min(this.canvas.width, this.canvas.height) * 0.2; // Assume reference object is 20% of screen
        this.pixelsPerCm = referencePixels / this.referenceObjectSize;
        
        // Mark as calibrated
        this.isCalibrated = true;
        
        // Update UI
        this.measurementDisplay.textContent = `Calibrated! ${this.referenceObjectSize}cm at ${this.calibrationDistance}cm distance`;
        this.measurementDisplay.style.backgroundColor = '#4CAF50';
        
        // Hide calibration panel
        this.calibrationPanel.style.display = 'none';
        this.instructionsPanel.style.display = 'block';
        
        // Start object detection
        this.startObjectDetection();
        
        this.showNotification('Calibration successful! Object detection started.');
    }
    
    /**
     * Start object detection
     */
    startObjectDetection() {
        if (this.isDetecting) return;
        
        this.isDetecting = true;
        this.detectedObjects = [];
        
        // Set up interval for object detection
        this.objectDetectionInterval = setInterval(() => {
            this.detectObjects();
        }, 1000); // Detect objects every second
        
        this.measurementDisplay.textContent = 'Detecting objects...';
        this.measurementDisplay.style.backgroundColor = '#FF9800';
    }
    
    /**
     * Stop object detection
     */
    stopObjectDetection() {
        if (!this.isDetecting) return;
        
        this.isDetecting = false;
        
        // Clear detection interval
        if (this.objectDetectionInterval) {
            clearInterval(this.objectDetectionInterval);
            this.objectDetectionInterval = null;
        }
        
        // Clear detected objects
        this.detectedObjects = [];
        this.currentMeasurements = [];
        
        // Clear detection canvas
        this.detectionCtx.clearRect(0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
        
        this.measurementDisplay.textContent = 'Object detection stopped';
        this.measurementDisplay.style.backgroundColor = '#333';
    }
    
    /**
     * Detect objects in the video frame
     */
    detectObjects() {
        if (!this.isCalibrated || !this.video || !this.canvas) return;
        
        // Draw video frame to canvas
        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
        
        // Get image data
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;
        
        // Simple object detection using edge detection
        const edges = this.detectEdges(data, this.canvas.width, this.canvas.height);
        
        // Find contours in the edge image
        const contours = this.findContours(edges, this.canvas.width, this.canvas.height);
        
        // Filter and process contours
        this.processContours(contours);
        
        // Update display
        this.updateMeasurementDisplay();
        
        // Draw detected objects
        this.drawDetectedObjects();
    }
    
    /**
     * Detect edges in the image
     */
    detectEdges(data, width, height) {
        // Convert to grayscale
        const grayscale = new Uint8ClampedArray(width * height);
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            grayscale[i / 4] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        }
        
        // Apply Sobel operator for edge detection
        const edges = new Uint8ClampedArray(width * height);
        
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = y * width + x;
                
                // Sobel X
                const sobelX = 
                    -1 * grayscale[(y - 1) * width + (x - 1)] +
                    -2 * grayscale[y * width + (x - 1)] +
                    -1 * grayscale[(y + 1) * width + (x - 1)] +
                    1 * grayscale[(y - 1) * width + (x + 1)] +
                    2 * grayscale[y * width + (x + 1)] +
                    1 * grayscale[(y + 1) * width + (x + 1)];
                
                // Sobel Y
                const sobelY = 
                    -1 * grayscale[(y - 1) * width + (x - 1)] +
                    -2 * grayscale[(y - 1) * width + x] +
                    -1 * grayscale[(y - 1) * width + (x + 1)] +
                    1 * grayscale[(y + 1) * width + (x - 1)] +
                    2 * grayscale[(y + 1) * width + x] +
                    1 * grayscale[(y + 1) * width + (x + 1)];
                
                // Calculate magnitude
                const magnitude = Math.sqrt(sobelX * sobelX + sobelY * sobelY);
                
                // Threshold
                edges[idx] = magnitude > 50 ? 255 : 0;
            }
        }
        
        return edges;
    }
    
    /**
     * Find contours in the edge image
     */
    findContours(edges, width, height) {
        // Simple contour finding algorithm
        const visited = new Array(width * height).fill(false);
        const contours = [];
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                
                if (edges[idx] === 255 && !visited[idx]) {
                    const contour = this.traceContour(edges, width, height, x, y, visited);
                    if (contour.length > 20) { // Filter small contours
                        contours.push(contour);
                    }
                }
            }
        }
        
        return contours;
    }
    
    /**
     * Trace a contour starting from a given point
     */
    traceContour(edges, width, height, startX, startY, visited) {
        const contour = [];
        const stack = [{x: startX, y: startY}];
        
        while (stack.length > 0) {
            const {x, y} = stack.pop();
            const idx = y * width + x;
            
            if (x < 0 || x >= width || y < 0 || y >= height || visited[idx] || edges[idx] === 0) {
                continue;
            }
            
            visited[idx] = true;
            contour.push({x, y});
            
            // Check 8-connected neighbors
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    stack.push({x: x + dx, y: y + dy});
                }
            }
        }
        
        return contour;
    }
    
    /**
     * Process contours to find objects
     */
    processContours(contours) {
        this.detectedObjects = [];
        this.currentMeasurements = [];
        
        for (const contour of contours) {
            // Find bounding box
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            for (const point of contour) {
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            }
            
            // Calculate dimensions
            const width = maxX - minX;
            const height = maxY - minY;
            
            // Filter very small objects
            if (width < 20 || height < 20) continue;
            
            // Convert to real-world size
            const realWidth = width / this.pixelsPerCm;
            const realHeight = height / this.pixelsPerCm;
            
            // Store object information
            const object = {
                x: minX,
                y: minY,
                width: width,
                height: height,
                realWidth: realWidth,
                realHeight: realHeight,
                contour: contour
            };
            
            this.detectedObjects.push(object);
            this.currentMeasurements.push({
                width: realWidth,
                height: realHeight,
                area: realWidth * realHeight
            });
        }
    }
    
    /**
     * Update measurement display
     */
    updateMeasurementDisplay() {
        if (this.detectedObjects.length === 0) {
            this.measurementDisplay.textContent = 'No objects detected';
            this.measurementDisplay.style.backgroundColor = '#FF9800';
            return;
        }
        
        // Find the largest object
        let largestObject = this.detectedObjects[0];
        for (const obj of this.detectedObjects) {
            if (obj.realWidth * obj.realHeight > largestObject.realWidth * largestObject.realHeight) {
                largestObject = obj;
            }
        }
        
        this.measurementDisplay.textContent = 
            `Largest object: ${largestObject.realWidth.toFixed(1)}cm × ${largestObject.realHeight.toFixed(1)}cm`;
        this.measurementDisplay.style.backgroundColor = '#4CAF50';
    }
    
    /**
     * Draw detected objects on the overlay canvas
     */
    drawDetectedObjects() {
        // Clear canvas
        this.detectionCtx.clearRect(0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
        
        // Draw each detected object
        for (const obj of this.detectedObjects) {
            // Draw bounding box
            this.detectionCtx.strokeStyle = '#4CAF50';
            this.detectionCtx.lineWidth = 2;
            this.detectionCtx.strokeRect(obj.x, obj.y, obj.width, obj.height);
            
            // Draw dimensions
            this.detectionCtx.fillStyle = 'white';
            this.detectionCtx.strokeStyle = 'black';
            this.detectionCtx.lineWidth = 3;
            this.detectionCtx.font = '14px Arial';
            this.detectionCtx.textAlign = 'center';
            
            // Width label
            const widthText = `${obj.realWidth.toFixed(1)}cm`;
            const widthX = obj.x + obj.width / 2;
            const widthY = obj.y - 5;
            
            this.detectionCtx.strokeText(widthText, widthX, widthY);
            this.detectionCtx.fillText(widthText, widthX, widthY);
            
            // Height label
            const heightText = `${obj.realHeight.toFixed(1)}cm`;
            const heightX = obj.x + obj.width + 5;
            const heightY = obj.y + obj.height / 2;
            
            this.detectionCtx.save();
            this.detectionCtx.translate(heightX, heightY);
            this.detectionCtx.rotate(Math.PI / 2);
            this.detectionCtx.strokeText(heightText, 0, 0);
            this.detectionCtx.fillText(heightText, 0, 0);
            this.detectionCtx.restore();
        }
    }
    
    /**
     * Copy measurements to clipboard
     */
    async copyMeasurements() {
        if (this.currentMeasurements.length === 0) {
            this.showError('No measurements to copy.');
            return;
        }
        
        let measurementsText = `Detected Objects: ${this.currentMeasurements.length}\n\n`;
        
        this.currentMeasurements.forEach((measurement, index) => {
            measurementsText += `Object ${index + 1}:\n`;
            measurementsText += `  Width: ${measurement.width.toFixed(2)} cm\n`;
            measurementsText += `  Height: ${measurement.height.toFixed(2)} cm\n`;
            measurementsText += `  Area: ${measurement.area.toFixed(2)} cm²\n\n`;
        });
        
        try {
            await navigator.clipboard.writeText(measurementsText);
            this.showNotification('Measurements copied to clipboard!');
        } catch (err) {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = measurementsText;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            this.showNotification('Measurements copied to clipboard!');
        }
    }
    
    /**
     * Render the detection overlay
     */
    render() {
        if (!this.isActive) return;
        
        // Continue rendering loop
        this.animationId = requestAnimationFrame(() => this.render());
    }
    
    /**
     * Show notification message
     */
    showNotification(message) {
        // Create notification element
        const notificationElement = document.createElement('div');
        notificationElement.textContent = message;
        notificationElement.style.cssText = `
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 16px;
            z-index: 10003;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeInOut 2s ease-in-out forwards;
        `;
        
        // Add animation keyframes if not already added
        if (!document.getElementById('notification-animation')) {
            const style = document.createElement('style');
            style.id = 'notification-animation';
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                    20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Add to container
        this.gameContainer.appendChild(notificationElement);
        
        // Remove after animation completes
        setTimeout(() => {
            if (notificationElement.parentNode) {
                notificationElement.parentNode.removeChild(notificationElement);
            }
        }, 2000);
    }
    
    /**
     * Show error message
     */
    showError(message) {
        // Create error element
        const errorElement = document.createElement('div');
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10003;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        `;
        
        // Add to container
        this.gameContainer.appendChild(errorElement);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (errorElement.parentNode) {
                errorElement.parentNode.removeChild(errorElement);
            }
        }, 3000);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.key === 'c' && (event.ctrlKey || event.metaKey)) {
            // Handle Ctrl+C or Cmd+C to copy measurements
            this.copyMeasurements();
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust video size based on fullscreen state
        if (this.video) {
            if (this.isFullscreen) {
                this.video.style.width = '98%';
                this.video.style.height = '75vh';
                this.detectionCanvas.style.width = '98%';
                this.detectionCanvas.style.height = '75vh';
            } else {
                this.video.style.width = '90%';
                this.video.style.height = '70vh';
                this.detectionCanvas.style.width = '90%';
                this.detectionCanvas.style.height = '70vh';
            }
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Stop animation frame
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        // Stop object detection
        this.stopObjectDetection();
        
        // Stop camera stream
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.video = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.copyButton = null;
        this.calibrationButton = null;
        this.stream = null;
        this.animationId = null;
        this.isCalibrated = false;
        this.calibrationDistance = 30;
        this.pixelsPerCm = 0;
        this.currentMeasurements = [];
        this.referenceObjectSize = 10;
        this.measurementDisplay = null;
        this.calibrationPanel = null;
        this.instructionsPanel = null;
        this.detectionCanvas = null;
        this.detectionCtx = null;
        this.isDetecting = false;
        this.detectedObjects = [];
        this.objectDetectionInterval = null;
        
        botReply("Auto Object Size Calculator closed. Thank you!");
    }
}

// Create a singleton instance
const autoObjectSizeCalculatorScreenLoader = new AutoObjectSizeCalculatorScreenLoader();

// Add this to your AI's command handling
if (/auto size|auto measure|automatic object size/i.test(userInputRaw)) {
    autoObjectSizeCalculatorScreenLoader.loadAutoObjectSizeCalculator();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    autoObjectSizeCalculatorScreenLoader.closeGame();
    return;
}
class SimpleColorFinderScreenLoader {
    constructor() {
        this.finder = {
            name: 'COLOR FINDER',
            instructions: 'Select a color to find, then point your camera at objects. Objects containing the selected color will be highlighted.'
        };
        
        this.gameContainer = null;
        this.video = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.colorPickerButton = null;
        this.stream = null;
        this.animationId = null;
        
        // Color detection properties
        this.targetColor = { r: 255, g: 0, b: 0 }; // Default: red
        this.colorTolerance = 60; // Higher tolerance for better detection
        
        // UI elements
        this.colorDisplay = null;
        this.colorInfo = null;
        this.detectionCanvas = null;
        this.detectionCtx = null;
        this.colorPickerPanel = null;
        this.instructionsPanel = null;
        this.toleranceSlider = null;
    }
    
    /**
     * Load the Color Finder
     */
    loadColorFinder() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.finder.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Set up camera
        this.setupCamera();
        
        // Set up UI elements
        this.setupUI();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the finder
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.finder.name} loaded! ${this.finder.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Set up the camera
     */
    async setupCamera() {
        try {
            // Create video element
            this.video = document.createElement('video');
            this.video.style.cssText = `
                width: 90%;
                max-width: 1200px;
                height: 70vh;
                max-height: 800px;
                border: none;
                border-radius: 8px;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
                object-fit: cover;
                display: block;
            `;
            this.video.autoplay = true;
            this.video.playsInline = true;
            
            // Create canvas for processing
            this.canvas = document.createElement('canvas');
            this.canvas.style.cssText = `
                display: none;
            `;
            this.ctx = this.canvas.getContext('2d');
            
            // Create detection canvas for overlay
            this.detectionCanvas = document.createElement('canvas');
            this.detectionCanvas.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 90%;
                max-width: 1200px;
                height: 70vh;
                max-height: 800px;
                border-radius: 8px;
                pointer-events: none;
                z-index: 10000;
            `;
            this.detectionCtx = this.detectionCanvas.getContext('2d');
            
            // Add elements to container
            this.gameContainer.appendChild(this.video);
            this.gameContainer.appendChild(this.canvas);
            this.gameContainer.appendChild(this.detectionCanvas);
            
            // Get camera stream
            this.stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                } 
            });
            
            // Set video source
            this.video.srcObject = this.stream;
            
            // Start rendering when video is ready
            this.video.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                this.detectionCanvas.width = this.video.videoWidth;
                this.detectionCanvas.height = this.video.videoHeight;
                
                // Start rendering loop
                this.render();
            };
            
        } catch (error) {
            console.error('Error accessing camera:', error);
            this.showError('Could not access camera. Please check permissions.');
            this.closeGame();
        }
    }
    
    /**
     * Set up UI elements
     */
    setupUI() {
        // Create color display
        this.colorDisplay = document.createElement('div');
        this.colorDisplay.style.cssText = `
            width: 90%;
            max-width: 1200px;
            height: 60px;
            margin-top: 20px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
            transition: background-color 0.3s ease;
        `;
        this.updateColorDisplay();
        
        // Create color info
        this.colorInfo = document.createElement('div');
        this.colorInfo.style.cssText = `
            width: 90%;
            max-width: 1200px;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 16px;
            text-align: center;
        `;
        this.updateColorInfo();
        
        // Create color picker panel (initially hidden)
        this.colorPickerPanel = document.createElement('div');
        this.colorPickerPanel.style.cssText = `
            width: 90%;
            max-width: 1200px;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 16px;
            text-align: center;
            display: none;
        `;
        
        // Create color picker
        const colorPickerContainer = document.createElement('div');
        colorPickerContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const colorPickerLabel = document.createElement('label');
        colorPickerLabel.textContent = 'Select a color:';
        colorPickerLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
        `;
        
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.value = this.rgbToHex(this.targetColor.r, this.targetColor.g, this.targetColor.b);
        colorPicker.style.cssText = `
            width: 100px;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        `;
        
        colorPicker.addEventListener('change', (e) => {
            const hex = e.target.value;
            this.targetColor = this.hexToRgb(hex);
            this.updateColorDisplay();
            this.updateColorInfo();
        });
        
        colorPickerContainer.appendChild(colorPickerLabel);
        colorPickerContainer.appendChild(colorPicker);
        
        // Create tolerance slider
        const toleranceContainer = document.createElement('div');
        toleranceContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const toleranceLabel = document.createElement('label');
        toleranceLabel.textContent = 'Color Tolerance:';
        toleranceLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
        `;
        
        this.toleranceSlider = document.createElement('input');
        this.toleranceSlider.type = 'range';
        this.toleranceSlider.min = '10';
        this.toleranceSlider.max = '100';
        this.toleranceSlider.value = this.colorTolerance;
        this.toleranceSlider.style.cssText = `
            width: 200px;
        `;
        
        const toleranceValue = document.createElement('span');
        toleranceValue.textContent = this.colorTolerance;
        toleranceValue.style.cssText = `
            margin-left: 10px;
        `;
        
        this.toleranceSlider.addEventListener('input', (e) => {
            this.colorTolerance = parseInt(e.target.value);
            toleranceValue.textContent = this.colorTolerance;
        });
        
        toleranceContainer.appendChild(toleranceLabel);
        toleranceContainer.appendChild(this.toleranceSlider);
        toleranceContainer.appendChild(toleranceValue);
        
        // Create preset colors
        const presetColorsContainer = document.createElement('div');
        presetColorsContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const presetLabel = document.createElement('label');
        presetLabel.textContent = 'Preset Colors:';
        presetLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
        `;
        
        const presetColors = document.createElement('div');
        presetColors.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 10px;
        `;
        
        // Add preset color buttons
        const presets = [
            { name: 'Red', r: 255, g: 0, b: 0 },
            { name: 'Green', r: 0, g: 255, b: 0 },
            { name: 'Blue', r: 0, g: 0, b: 255 },
            { name: 'Yellow', r: 255, g: 255, b: 0 },
            { name: 'Orange', r: 255, g: 165, b: 0 },
            { name: 'Purple', r: 128, g: 0, b: 128 },
            { name: 'Pink', r: 255, g: 192, b: 203 },
            { name: 'Brown', r: 165, g: 42, b: 42 }
        ];
        
        presets.forEach(preset => {
            const colorButton = document.createElement('button');
            colorButton.style.cssText = `
                width: 30px;
                height: 30px;
                border-radius: 50%;
                border: 2px solid white;
                background-color: rgb(${preset.r}, ${preset.g}, ${preset.b});
                cursor: pointer;
                transition: transform 0.2s;
            `;
            
            colorButton.title = preset.name;
            
            colorButton.addEventListener('click', () => {
                this.targetColor = { r: preset.r, g: preset.g, b: preset.b };
                colorPicker.value = this.rgbToHex(preset.r, preset.g, preset.b);
                this.updateColorDisplay();
                this.updateColorInfo();
            });
            
            colorButton.addEventListener('mouseover', () => {
                colorButton.style.transform = 'scale(1.2)';
            });
            
            colorButton.addEventListener('mouseout', () => {
                colorButton.style.transform = 'scale(1)';
            });
            
            presetColors.appendChild(colorButton);
        });
        
        presetColorsContainer.appendChild(presetLabel);
        presetColorsContainer.appendChild(presetColors);
        
        // Add elements to color picker panel
        this.colorPickerPanel.appendChild(colorPickerContainer);
        this.colorPickerPanel.appendChild(toleranceContainer);
        this.colorPickerPanel.appendChild(presetColorsContainer);
        
        // Create instructions panel
        this.instructionsPanel = document.createElement('div');
        this.instructionsPanel.style.cssText = `
            width: 90%;
            max-width: 1200px;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 16px;
            text-align: center;
        `;
        
        this.instructionsPanel.innerHTML = `
            <strong>Instructions:</strong><br>
            1. Click "Color Picker" to select a color to find<br>
            2. Adjust the tolerance slider to control how closely colors must match<br>
            3. Point your camera at objects - areas containing the selected color will be highlighted<br>
            4. Higher tolerance values will detect more shades of the color
        `;
        
        // Add all elements to container
        this.gameContainer.appendChild(this.colorDisplay);
        this.gameContainer.appendChild(this.colorInfo);
        this.gameContainer.appendChild(this.colorPickerPanel);
        this.gameContainer.appendChild(this.instructionsPanel);
    }
    
    /**
     * Set up action buttons
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10002;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border-radius: 4px;
            box-shadow: 0 0 10px #4CAF50;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create color picker button
        this.colorPickerButton = document.createElement('button');
        this.colorPickerButton.innerHTML = '🎨';
        this.colorPickerButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2196F3, #1976D2);
            border-radius: 4px;
            box-shadow: 0 0 10px #2196F3;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.colorPickerButton.onmouseover = () => {
            this.colorPickerButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.colorPickerButton.style.transform = 'scale(1.1)';
        };
        
        this.colorPickerButton.onmouseout = () => {
            this.colorPickerButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.colorPickerButton.style.transform = 'scale(1)';
        };
        
        this.colorPickerButton.onclick = (e) => {
            e.stopPropagation();
            this.toggleColorPicker();
        };
        
        floatingButtons.appendChild(this.colorPickerButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #f44336, #d32f2f);
            border-radius: 4px;
            box-shadow: 0 0 10px #f44336;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Toggle color picker panel visibility
     */
    toggleColorPicker() {
        if (this.colorPickerPanel.style.display === 'none') {
            this.colorPickerPanel.style.display = 'block';
            this.instructionsPanel.style.display = 'none';
        } else {
            this.colorPickerPanel.style.display = 'none';
            this.instructionsPanel.style.display = 'block';
        }
    }
    
    /**
     * Simple color detection
     */
    detectColors() {
        if (!this.video || !this.canvas) return;
        
        // Draw video frame to canvas
        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
        
        // Get image data
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;
        
        // Clear detection canvas
        this.detectionCtx.clearRect(0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
        
        // Create a mask for the target color
        const mask = new Uint8ClampedArray(this.canvas.width * this.canvas.height);
        
        // Simple color matching
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Calculate color distance (simple Euclidean distance)
            const distance = Math.sqrt(
                Math.pow(r - this.targetColor.r, 2) +
                Math.pow(g - this.targetColor.g, 2) +
                Math.pow(b - this.targetColor.b, 2)
            );
            
            // Check if color is within tolerance
            const idx = i / 4;
            mask[idx] = distance <= this.colorTolerance ? 255 : 0;
        }
        
        // Draw the mask on the detection canvas with transparency
        const outputData = this.detectionCtx.createImageData(this.detectionCanvas.width, this.detectionCanvas.height);
        
        for (let i = 0; i < mask.length; i++) {
            const idx = i * 4;
            
            if (mask[i] === 255) {
                // Set pixel to semi-transparent target color
                outputData.data[idx] = this.targetColor.r;     // R
                outputData.data[idx + 1] = this.targetColor.g; // G
                outputData.data[idx + 2] = this.targetColor.b; // B
                outputData.data[idx + 3] = 120;                // Alpha (semi-transparent)
            } else {
                // Set pixel to transparent
                outputData.data[idx + 3] = 0; // Alpha (transparent)
            }
        }
        
        // Put the image data back to the detection canvas
        this.detectionCtx.putImageData(outputData, 0, 0);
        
        // Draw a border around the detection canvas to make it more visible
        this.detectionCtx.strokeStyle = 'white';
        this.detectionCtx.lineWidth = 2;
        this.detectionCtx.strokeRect(0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
        
        // Update color info
        this.updateColorInfo();
    }
    
    /**
     * Update color display
     */
    updateColorDisplay() {
        const hex = this.rgbToHex(this.targetColor.r, this.targetColor.g, this.targetColor.b);
        const colorName = this.getColorName(this.targetColor);
        
        this.colorDisplay.style.backgroundColor = hex;
        
        // Determine text color based on background brightness
        const brightness = (this.targetColor.r * 299 + this.targetColor.g * 587 + this.targetColor.b * 114) / 1000;
        this.colorDisplay.style.color = brightness > 125 ? 'black' : 'white';
        
        this.colorDisplay.textContent = `Finding: ${colorName}`;
    }
    
    /**
     * Update color info
     */
    updateColorInfo() {
        const hex = this.rgbToHex(this.targetColor.r, this.targetColor.g, this.targetColor.b);
        
        this.colorInfo.innerHTML = `
            RGB: ${this.targetColor.r}, ${this.targetColor.g}, ${this.targetColor.b} | 
            HEX: ${hex} | 
            Tolerance: ${this.colorTolerance}
        `;
    }
    
    /**
     * Get color name from RGB values
     */
    getColorName(rgb) {
        // Common color palette with RGB values
        const colors = [
            { name: 'Red', rgb: [255, 0, 0] },
            { name: 'Green', rgb: [0, 255, 0] },
            { name: 'Blue', rgb: [0, 0, 255] },
            { name: 'Yellow', rgb: [255, 255, 0] },
            { name: 'Cyan', rgb: [0, 255, 255] },
            { name: 'Magenta', rgb: [255, 0, 255] },
            { name: 'Orange', rgb: [255, 165, 0] },
            { name: 'Purple', rgb: [128, 0, 128] },
            { name: 'Pink', rgb: [255, 192, 203] },
            { name: 'Brown', rgb: [165, 42, 42] },
            { name: 'Black', rgb: [0, 0, 0] },
            { name: 'White', rgb: [255, 255, 255] },
            { name: 'Gray', rgb: [128, 128, 128] }
        ];
        
        let minDistance = Infinity;
        let closestColor = 'Unknown';
        
        // Calculate Euclidean distance to find closest color
        for (const color of colors) {
            const distance = Math.sqrt(
                Math.pow(rgb.r - color.rgb[0], 2) +
                Math.pow(rgb.g - color.rgb[1], 2) +
                Math.pow(rgb.b - color.rgb[2], 2)
            );
            
            if (distance < minDistance) {
                minDistance = distance;
                closestColor = color.name;
            }
        }
        
        return closestColor;
    }
    
    /**
     * Convert RGB to HEX
     */
    rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    
    /**
     * Convert HEX to RGB
     */
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
    }
    
    /**
     * Render the detection overlay
     */
    render() {
        if (!this.isActive) return;
        
        // Detect colors in the current frame
        this.detectColors();
        
        // Continue rendering loop
        this.animationId = requestAnimationFrame(() => this.render());
    }
    
    /**
     * Show notification message
     */
    showNotification(message) {
        // Create notification element
        const notificationElement = document.createElement('div');
        notificationElement.textContent = message;
        notificationElement.style.cssText = `
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 16px;
            z-index: 10003;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeInOut 2s ease-in-out forwards;
        `;
        
        // Add animation keyframes if not already added
        if (!document.getElementById('notification-animation')) {
            const style = document.createElement('style');
            style.id = 'notification-animation';
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                    20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Add to container
        this.gameContainer.appendChild(notificationElement);
        
        // Remove after animation completes
        setTimeout(() => {
            if (notificationElement.parentNode) {
                notificationElement.parentNode.removeChild(notificationElement);
            }
        }, 2000);
    }
    
    /**
     * Show error message
     */
    showError(message) {
        // Create error element
        const errorElement = document.createElement('div');
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10003;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        `;
        
        // Add to container
        this.gameContainer.appendChild(errorElement);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (errorElement.parentNode) {
                errorElement.parentNode.removeChild(errorElement);
            }
        }, 3000);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust video size based on fullscreen state
        if (this.video) {
            if (this.isFullscreen) {
                this.video.style.width = '98%';
                this.video.style.height = '75vh';
                this.detectionCanvas.style.width = '98%';
                this.detectionCanvas.style.height = '75vh';
            } else {
                this.video.style.width = '90%';
                this.video.style.height = '70vh';
                this.detectionCanvas.style.width = '90%';
                this.detectionCanvas.style.height = '70vh';
            }
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Stop animation frame
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        // Stop camera stream
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.video = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.colorPickerButton = null;
        this.stream = null;
        this.animationId = null;
        this.targetColor = { r: 255, g: 0, b: 0 };
        this.colorTolerance = 60;
        this.colorDisplay = null;
        this.colorInfo = null;
        this.detectionCanvas = null;
        this.detectionCtx = null;
        this.colorPickerPanel = null;
        this.instructionsPanel = null;
        this.toleranceSlider = null;
        
        botReply("Color Finder closed. Thank you!");
    }
}

// Create a singleton instance
const simpleColorFinderScreenLoader = new SimpleColorFinderScreenLoader();

// Add this to your AI's command handling
if (/color finder|find color|detect color/i.test(userInputRaw)) {
    simpleColorFinderScreenLoader.loadColorFinder();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    simpleColorFinderScreenLoader.closeGame();
    return;
}


class DocumentReaderScreenLoader {
    constructor() {
        this.finder = {
            name: 'DOCUMENT READER',
            instructions: 'Position a document within the frame. The app will detect edges and enhance the document for better readability.'
        };
        
        this.gameContainer = null;
        this.video = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.captureButton = null;
        this.stream = null;
        this.animationId = null;
        
        // Document detection properties
        this.documentCorners = null;
        this.isDocumentDetected = false;
        this.scannedDocument = null;
        this.detectionCanvas = null;
        this.detectionCtx = null;
        this.resultCanvas = null;
        this.resultCtx = null;
        this.processedImageData = null;
        
        // UI elements
        this.statusPanel = null;
        this.controlsPanel = null;
        this.resultPanel = null;
        this.filterButtons = {};
        this.currentFilter = 'none';
        
        // Document processing filters
        this.filters = {
            none: { name: 'Original', apply: (imageData) => imageData },
            grayscale: { name: 'Grayscale', apply: this.applyGrayscaleFilter.bind(this) },
            blackAndWhite: { name: 'B&W', apply: this.applyBlackAndWhiteFilter.bind(this) },
            enhance: { name: 'Enhance', apply: this.applyEnhanceFilter.bind(this) }
        };
    }
    
    /**
     * Load the Document Reader
     */
    loadDocumentReader() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.finder.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Set up camera
        this.setupCamera();
        
        // Set up UI elements
        this.setupUI();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the reader
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.finder.name} loaded! ${this.finder.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Set up the camera
     */
    async setupCamera() {
        try {
            // Create video element
            this.video = document.createElement('video');
            this.video.style.cssText = `
                width: 90%;
                max-width: 1200px;
                height: 60vh;
                max-height: 800px;
                border: none;
                border-radius: 8px;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
                object-fit: cover;
                display: block;
            `;
            this.video.autoplay = true;
            this.video.playsInline = true;
            
            // Create canvas for processing
            this.canvas = document.createElement('canvas');
            this.canvas.style.cssText = `
                display: none;
            `;
            this.ctx = this.canvas.getContext('2d');
            
            // Create detection canvas for overlay
            this.detectionCanvas = document.createElement('canvas');
            this.detectionCanvas.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 90%;
                max-width: 1200px;
                height: 60vh;
                max-height: 800px;
                border-radius: 8px;
                pointer-events: none;
                z-index: 10000;
            `;
            this.detectionCtx = this.detectionCanvas.getContext('2d');
            
            // Create result canvas for displaying processed document
            this.resultCanvas = document.createElement('canvas');
            this.resultCanvas.style.cssText = `
                display: none;
                width: 90%;
                max-width: 1200px;
                height: 60vh;
                max-height: 800px;
                border: none;
                border-radius: 8px;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
                object-fit: contain;
            `;
            this.resultCtx = this.resultCanvas.getContext('2d');
            
            // Add elements to container
            this.gameContainer.appendChild(this.video);
            this.gameContainer.appendChild(this.canvas);
            this.gameContainer.appendChild(this.detectionCanvas);
            this.gameContainer.appendChild(this.resultCanvas);
            
            // Get camera stream
            this.stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                } 
            });
            
            // Set video source
            this.video.srcObject = this.stream;
            
            // Start rendering when video is ready
            this.video.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                this.detectionCanvas.width = this.video.videoWidth;
                this.detectionCanvas.height = this.video.videoHeight;
                this.resultCanvas.width = this.video.videoWidth;
                this.resultCanvas.height = this.video.videoHeight;
                
                // Start rendering loop
                this.render();
            };
            
        } catch (error) {
            console.error('Error accessing camera:', error);
            this.showError('Could not access camera. Please check permissions.');
            this.closeGame();
        }
    }
    
    /**
     * Set up UI elements
     */
    setupUI() {
        // Create status panel
        this.statusPanel = document.createElement('div');
        this.statusPanel.style.cssText = `
            width: 90%;
            max-width: 1200px;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 16px;
            text-align: center;
        `;
        this.updateStatus();
        
        // Create controls panel (initially hidden)
        this.controlsPanel = document.createElement('div');
        this.controlsPanel.style.cssText = `
            width: 90%;
            max-width: 1200px;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 16px;
            text-align: center;
            display: none;
        `;
        
        // Create filter buttons
        const filterContainer = document.createElement('div');
        filterContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const filterLabel = document.createElement('label');
        filterLabel.textContent = 'Filters:';
        filterLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
        `;
        
        const filterButtonsContainer = document.createElement('div');
        filterButtonsContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        `;
        
        // Add filter buttons
        for (const [key, filter] of Object.entries(this.filters)) {
            const button = document.createElement('button');
            button.textContent = filter.name;
            button.style.cssText = `
                padding: 8px 15px;
                border-radius: 4px;
                background-color: ${key === 'none' ? 'rgba(76, 175, 80, 0.8)' : 'rgba(33, 150, 243, 0.8)'};
                color: white;
                border: none;
                cursor: pointer;
                transition: all 0.2s ease;
            `;
            
            button.addEventListener('click', () => {
                this.applyFilter(key);
                
                // Update button styles
                for (const [btnKey, btn] of Object.entries(this.filterButtons)) {
                    btn.style.backgroundColor = btnKey === key ? 'rgba(76, 175, 80, 0.8)' : 'rgba(33, 150, 243, 0.8)';
                }
            });
            
            button.addEventListener('mouseover', () => {
                button.style.transform = 'scale(1.05)';
            });
            
            button.addEventListener('mouseout', () => {
                button.style.transform = 'scale(1)';
            });
            
            this.filterButtons[key] = button;
            filterButtonsContainer.appendChild(button);
        }
        
        filterContainer.appendChild(filterLabel);
        filterContainer.appendChild(filterButtonsContainer);
        
        // Create action buttons for the controls panel
        const actionsContainer = document.createElement('div');
        actionsContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        `;
        
        // Save button
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save Document';
        saveButton.style.cssText = `
            padding: 10px 20px;
            border-radius: 4px;
            background-color: rgba(76, 175, 80, 0.8);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        saveButton.addEventListener('click', () => {
            this.saveDocument();
        });
        
        saveButton.addEventListener('mouseover', () => {
            saveButton.style.transform = 'scale(1.05)';
        });
        
        saveButton.addEventListener('mouseout', () => {
            saveButton.style.transform = 'scale(1)';
        });
        
        // Retake button
        const retakeButton = document.createElement('button');
        retakeButton.textContent = 'Retake';
        retakeButton.style.cssText = `
            padding: 10px 20px;
            border-radius: 4px;
            background-color: rgba(244, 67, 54, 0.8);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        retakeButton.addEventListener('click', () => {
            this.retakeDocument();
        });
        
        retakeButton.addEventListener('mouseover', () => {
            retakeButton.style.transform = 'scale(1.05)';
        });
        
        retakeButton.addEventListener('mouseout', () => {
            retakeButton.style.transform = 'scale(1)';
        });
        
        actionsContainer.appendChild(saveButton);
        actionsContainer.appendChild(retakeButton);
        
        // Add elements to controls panel
        this.controlsPanel.appendChild(filterContainer);
        this.controlsPanel.appendChild(actionsContainer);
        
        // Create result panel (initially hidden)
        this.resultPanel = document.createElement('div');
        this.resultPanel.style.cssText = `
            width: 90%;
            max-width: 1200px;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 16px;
            text-align: center;
            display: none;
        `;
        
        this.resultPanel.innerHTML = `
            <strong>Document Processing Complete!</strong><br>
            Use the filter options to enhance readability, then save your document.
        `;
        
        // Create instructions panel
        const instructionsPanel = document.createElement('div');
        instructionsPanel.style.cssText = `
            width: 90%;
            max-width: 1200px;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 16px;
            text-align: center;
        `;
        
        instructionsPanel.innerHTML = `
            <strong>Instructions:</strong><br>
            1. Position a document within the frame<br>
            2. Ensure the document is well-lit and all edges are visible<br>
            3. When the document edges are detected (green outline), click "Capture"<br>
            4. Apply filters to enhance readability<br>
            5. Save the processed document
        `;
        
        // Add all elements to container
        this.gameContainer.appendChild(this.statusPanel);
        this.gameContainer.appendChild(this.controlsPanel);
        this.gameContainer.appendChild(this.resultPanel);
        this.gameContainer.appendChild(instructionsPanel);
    }
    
    /**
     * Set up action buttons
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10002;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border-radius: 4px;
            box-shadow: 0 0 10px #4CAF50;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(76, 175, 80, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create capture button
        this.captureButton = document.createElement('button');
        this.captureButton.innerHTML = '📷';
        this.captureButton.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2196F3, #1976D2);
            border-radius: 4px;
            box-shadow: 0 0 10px #2196F3;
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.captureButton.onmouseover = () => {
            this.captureButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.captureButton.style.transform = 'scale(1.1)';
        };
        
        this.captureButton.onmouseout = () => {
            this.captureButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.captureButton.style.transform = 'scale(1)';
        };
        
        this.captureButton.onclick = (e) => {
            e.stopPropagation();
            this.captureDocument();
        };
        
        floatingButtons.appendChild(this.captureButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #f44336, #d32f2f);
            border-radius: 4px;
            box-shadow: 0 0 10px #f44336;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Update status panel
     */
    updateStatus() {
        if (this.isDocumentDetected) {
            this.statusPanel.innerHTML = `
                <strong>Status:</strong> Document Detected - Ready to Capture<br>
                <small>Click the camera button to capture the document</small>
            `;
            this.statusPanel.style.backgroundColor = 'rgba(76, 175, 80, 0.6)';
        } else {
            this.statusPanel.innerHTML = `
                <strong>Status:</strong> Looking for Document...<br>
                <small>Position a document within the frame</small>
            `;
            this.statusPanel.style.backgroundColor = 'rgba(33, 150, 243, 0.6)';
        }
    }
    
    /**
     * Simple document detection
     */
    detectDocument() {
        if (!this.video || !this.canvas) return;
        
        // Draw video frame to canvas
        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
        
        // Get image data
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        
        // Clear detection canvas
        this.detectionCtx.clearRect(0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
        
        // Simple document edge detection
        this.documentCorners = this.detectDocumentEdges(imageData);
        
        if (this.documentCorners) {
            // Draw detected edges
            this.drawDocumentEdges();
            this.isDocumentDetected = true;
        } else {
            this.isDocumentDetected = false;
        }
        
        // Update status
        this.updateStatus();
    }
    
    /**
     * Simple document edge detection
     */
    detectDocumentEdges(imageData) {
        // This is a simplified edge detection algorithm
        // In a real application, you would use more sophisticated techniques
        
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;
        
        // Convert to grayscale and apply edge detection
        const grayData = new Uint8ClampedArray(width * height);
        const edgeData = new Uint8ClampedArray(width * height);
        
        // Convert to grayscale
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            grayData[i / 4] = gray;
        }
        
        // Simple Sobel edge detection
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = y * width + x;
                
                // Sobel X
                const sobelX = 
                    -1 * grayData[(y - 1) * width + (x - 1)] +
                     1 * grayData[(y - 1) * width + (x + 1)] +
                    -2 * grayData[y * width + (x - 1)] +
                     2 * grayData[y * width + (x + 1)] +
                    -1 * grayData[(y + 1) * width + (x - 1)] +
                     1 * grayData[(y + 1) * width + (x + 1)];
                
                // Sobel Y
                const sobelY = 
                    -1 * grayData[(y - 1) * width + (x - 1)] +
                    -2 * grayData[(y - 1) * width + x] +
                    -1 * grayData[(y - 1) * width + (x + 1)] +
                     1 * grayData[(y + 1) * width + (x - 1)] +
                     2 * grayData[(y + 1) * width + x] +
                     1 * grayData[(y + 1) * width + (x + 1)];
                
                // Magnitude
                const magnitude = Math.sqrt(sobelX * sobelX + sobelY * sobelY);
                edgeData[idx] = magnitude > 50 ? 255 : 0;
            }
        }
        
        // Find document corners using Hough transform or contour detection
        // For simplicity, we'll use a basic approach to find the largest rectangle
        const corners = this.findDocumentCorners(edgeData, width, height);
        
        return corners;
    }
    
    /**
     * Find document corners from edge data
     */
    findDocumentCorners(edgeData, width, height) {
        // This is a simplified approach to find document corners
        // In a real application, you would use more sophisticated algorithms
        
        // Find the top, bottom, left, and right edges
        let topEdge = height;
        let bottomEdge = 0;
        let leftEdge = width;
        let rightEdge = 0;
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                if (edgeData[idx] === 255) {
                    if (y < topEdge) topEdge = y;
                    if (y > bottomEdge) bottomEdge = y;
                    if (x < leftEdge) leftEdge = x;
                    if (x > rightEdge) rightEdge = x;
                }
            }
        }
        
        // Check if we found a reasonable document shape
        if (rightEdge - leftEdge < width * 0.3 || bottomEdge - topEdge < height * 0.3) {
            return null;
        }
        
        // Add some padding
        const padding = 20;
        topEdge = Math.max(0, topEdge - padding);
        bottomEdge = Math.min(height - 1, bottomEdge + padding);
        leftEdge = Math.max(0, leftEdge - padding);
        rightEdge = Math.min(width - 1, rightEdge + padding);
        
        // Return the four corners
        return [
            { x: leftEdge, y: topEdge },
            { x: rightEdge, y: topEdge },
            { x: rightEdge, y: bottomEdge },
            { x: leftEdge, y: bottomEdge }
        ];
    }
    
    /**
     * Draw document edges
     */
    drawDocumentEdges() {
        if (!this.documentCorners) return;
        
        // Draw lines connecting the corners
        this.detectionCtx.strokeStyle = '#00FF00';
        this.detectionCtx.lineWidth = 3;
        this.detectionCtx.setLineDash([5, 5]);
        this.detectionCtx.beginPath();
        this.detectionCtx.moveTo(this.documentCorners[0].x, this.documentCorners[0].y);
        for (let i = 1; i < this.documentCorners.length; i++) {
            this.detectionCtx.lineTo(this.documentCorners[i].x, this.documentCorners[i].y);
        }
        this.detectionCtx.closePath();
        this.detectionCtx.stroke();
        this.detectionCtx.setLineDash([]);
        
        // Draw corner points
        this.detectionCtx.fillStyle = '#00FF00';
        for (const corner of this.documentCorners) {
            this.detectionCtx.beginPath();
            this.detectionCtx.arc(corner.x, corner.y, 5, 0, Math.PI * 2);
            this.detectionCtx.fill();
        }
    }
    
    /**
     * Capture the document
     */
    captureDocument() {
        if (!this.isDocumentDetected || !this.documentCorners) {
            this.showNotification('Please position a document within the frame');
            return;
        }
        
        // Draw video frame to canvas
        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
        
        // Get image data
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        
        // Apply perspective correction to get a flat document
        this.processedImageData = this.applyPerspectiveCorrection(imageData, this.documentCorners);
        
        // Display the processed document
        this.resultCtx.putImageData(this.processedImageData, 0, 0);
        
        // Show the result canvas and controls
        this.video.style.display = 'none';
        this.detectionCanvas.style.display = 'none';
        this.resultCanvas.style.display = 'block';
        this.controlsPanel.style.display = 'block';
        this.resultPanel.style.display = 'block';
        this.statusPanel.style.display = 'none';
        
        // Hide capture button
        this.captureButton.style.display = 'none';
        
        // Apply default filter
        this.applyFilter('none');
        
        this.showNotification('Document captured! Apply filters to enhance readability.');
    }
    
    /**
     * Apply perspective correction to the document
     */
    applyPerspectiveCorrection(imageData, corners) {
        // This is a simplified perspective correction
        // In a real application, you would use more sophisticated algorithms
        
        const width = imageData.width;
        const height = imageData.height;
        const data = imageData.data;
        
        // Calculate the dimensions of the corrected document
        const topLeft = corners[0];
        const topRight = corners[1];
        const bottomRight = corners[2];
        const bottomLeft = corners[3];
        
        // Calculate the width and height of the corrected document
        const docWidth = Math.max(
            Math.sqrt(Math.pow(topRight.x - topLeft.x, 2) + Math.pow(topRight.y - topLeft.y, 2)),
            Math.sqrt(Math.pow(bottomRight.x - bottomLeft.x, 2) + Math.pow(bottomRight.y - bottomLeft.y, 2))
        );
        
        const docHeight = Math.max(
            Math.sqrt(Math.pow(bottomLeft.x - topLeft.x, 2) + Math.pow(bottomLeft.y - topLeft.y, 2)),
            Math.sqrt(Math.pow(bottomRight.x - topRight.x, 2) + Math.pow(bottomRight.y - topRight.y, 2))
        );
        
        // Create a new image data for the corrected document
        const correctedImageData = this.ctx.createImageData(docWidth, docHeight);
        const correctedData = correctedImageData.data;
        
        // Simple perspective transformation
        for (let y = 0; y < docHeight; y++) {
            for (let x = 0; x < docWidth; x++) {
                // Calculate the source coordinates using bilinear interpolation
                const srcX = topLeft.x + (topRight.x - topLeft.x) * (x / docWidth) +
                            (bottomLeft.x - topLeft.x) * (y / docHeight) +
                            (bottomRight.x - topRight.x - bottomLeft.x + topLeft.x) * (x / docWidth) * (y / docHeight);
                
                const srcY = topLeft.y + (topRight.y - topLeft.y) * (x / docWidth) +
                            (bottomLeft.y - topLeft.y) * (y / docHeight) +
                            (bottomRight.y - topRight.y - bottomLeft.y + topLeft.y) * (x / docWidth) * (y / docHeight);
                
                // Get the pixel color from the source image
                const srcIdx = (Math.floor(srcY) * width + Math.floor(srcX)) * 4;
                const dstIdx = (y * docWidth + x) * 4;
                
                if (srcIdx >= 0 && srcIdx < data.length - 3) {
                    correctedData[dstIdx] = data[srcIdx];         // R
                    correctedData[dstIdx + 1] = data[srcIdx + 1]; // G
                    correctedData[dstIdx + 2] = data[srcIdx + 2]; // B
                    correctedData[dstIdx + 3] = 255;              // A
                } else {
                    correctedData[dstIdx] = 255;     // R
                    correctedData[dstIdx + 1] = 255; // G
                    correctedData[dstIdx + 2] = 255; // B
                    correctedData[dstIdx + 3] = 255; // A
                }
            }
        }
        
        return correctedImageData;
    }
    
    /**
     * Apply a filter to the processed document
     */
    applyFilter(filterType) {
        if (!this.processedImageData) return;
        
        this.currentFilter = filterType;
        
        // Apply the selected filter
        const filteredImageData = this.filters[filterType].apply(this.processedImageData);
        
        // Display the filtered image
        this.resultCtx.putImageData(filteredImageData, 0, 0);
    }
    
    /**
     * Apply grayscale filter
     */
    applyGrayscaleFilter(imageData) {
        const data = new Uint8ClampedArray(imageData.data);
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Calculate grayscale value
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            
            data[i] = gray;     // R
            data[i + 1] = gray; // G
            data[i + 2] = gray; // B
        }
        
        return new ImageData(data, imageData.width, imageData.height);
    }
    
    /**
     * Apply black and white filter
     */
    applyBlackAndWhiteFilter(imageData) {
        const data = new Uint8ClampedArray(imageData.data);
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Calculate grayscale value
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            
            // Apply threshold to create black and white image
            const threshold = 128;
            const value = gray > threshold ? 255 : 0;
            
            data[i] = value;     // R
            data[i + 1] = value; // G
            data[i + 2] = value; // B
        }
        
        return new ImageData(data, imageData.width, imageData.height);
    }
    
    /**
     * Apply enhancement filter
     */
    applyEnhanceFilter(imageData) {
        const data = new Uint8ClampedArray(imageData.data);
        
        // First convert to grayscale
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Calculate grayscale value
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            
            data[i] = gray;     // R
            data[i + 1] = gray; // G
            data[i + 2] = gray; // B
        }
        
        // Apply contrast enhancement
        const factor = 1.5;
        const intercept = 128 * (1 - factor);
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, Math.max(0, factor * data[i] + intercept));
            data[i + 1] = Math.min(255, Math.max(0, factor * data[i + 1] + intercept));
            data[i + 2] = Math.min(255, Math.max(0, factor * data[i + 2] + intercept));
        }
        
        return new ImageData(data, imageData.width, imageData.height);
    }
    
    /**
     * Save the document
     */
    saveDocument() {
        if (!this.resultCanvas) return;
        
        // Create a temporary link element to download the image
        const link = document.createElement('a');
        link.download = `document_${new Date().getTime()}.png`;
        link.href = this.resultCanvas.toDataURL('image/png');
        link.click();
        
        this.showNotification('Document saved!');
    }
    
    /**
     * Retake the document
     */
    retakeDocument() {
        // Show the video and detection canvas
        this.video.style.display = 'block';
        this.detectionCanvas.style.display = 'block';
        this.resultCanvas.style.display = 'none';
        this.controlsPanel.style.display = 'none';
        this.resultPanel.style.display = 'none';
        this.statusPanel.style.display = 'block';
        
        // Show capture button
        this.captureButton.style.display = 'flex';
        
        // Reset document detection
        this.isDocumentDetected = false;
        this.documentCorners = null;
        this.processedImageData = null;
        
        this.updateStatus();
    }
    
    /**
     * Render the detection overlay
     */
    render() {
        if (!this.isActive) return;
        
        // If we're not showing the result, detect document
        if (this.resultCanvas.style.display === 'none') {
            this.detectDocument();
        }
        
        // Continue rendering loop
        this.animationId = requestAnimationFrame(() => this.render());
    }
    
    /**
     * Show notification message
     */
    showNotification(message) {
        // Create notification element
        const notificationElement = document.createElement('div');
        notificationElement.textContent = message;
        notificationElement.style.cssText = `
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 16px;
            z-index: 10003;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeInOut 2s ease-in-out forwards;
        `;
        
        // Add animation keyframes if not already added
        if (!document.getElementById('notification-animation')) {
            const style = document.createElement('style');
            style.id = 'notification-animation';
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                    20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Add to container
        this.gameContainer.appendChild(notificationElement);
        
        // Remove after animation completes
        setTimeout(() => {
            if (notificationElement.parentNode) {
                notificationElement.parentNode.removeChild(notificationElement);
            }
        }, 2000);
    }
    
    /**
     * Show error message
     */
    showError(message) {
        // Create error element
        const errorElement = document.createElement('div');
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10003;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        `;
        
        // Add to container
        this.gameContainer.appendChild(errorElement);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (errorElement.parentNode) {
                errorElement.parentNode.removeChild(errorElement);
            }
        }, 3000);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust video size based on fullscreen state
        if (this.video) {
            if (this.isFullscreen) {
                this.video.style.width = '98%';
                this.video.style.height = '75vh';
                this.detectionCanvas.style.width = '98%';
                this.detectionCanvas.style.height = '75vh';
                this.resultCanvas.style.width = '98%';
                this.resultCanvas.style.height = '75vh';
            } else {
                this.video.style.width = '90%';
                this.video.style.height = '60vh';
                this.detectionCanvas.style.width = '90%';
                this.detectionCanvas.style.height = '60vh';
                this.resultCanvas.style.width = '90%';
                this.resultCanvas.style.height = '60vh';
            }
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Stop animation frame
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        // Stop camera stream
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.video = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.captureButton = null;
        this.stream = null;
        this.animationId = null;
        this.documentCorners = null;
        this.isDocumentDetected = false;
        this.scannedDocument = null;
        this.detectionCanvas = null;
        this.detectionCtx = null;
        this.resultCanvas = null;
        this.resultCtx = null;
        this.processedImageData = null;
        this.statusPanel = null;
        this.controlsPanel = null;
        this.resultPanel = null;
        this.filterButtons = {};
        this.currentFilter = 'none';
        
        botReply("Document Reader closed. Thank you!");
    }
}

// Create a singleton instance
const documentReaderScreenLoader = new DocumentReaderScreenLoader();

// Add this to your AI's command handling
if (/document reader|scan document|document scanner/i.test(userInputRaw)) {
    documentReaderScreenLoader.loadDocumentReader();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    documentReaderScreenLoader.closeGame();
    return;
}

class SituationUnderstandingCamera {
    constructor() {
        this.appName = 'SITUATION UNDERSTANDING CAMERA';
        this.instructions = 'Point your camera at a scene to understand what\'s happening.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.situationDisplay = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment'; // Start with back camera
        this.flashMode = 'off'; // off, on, auto
        this.situationHistory = [];
        this.isAnalyzing = false;
        this.animationId = null;
        this.detectedObjects = [];
        this.modelLoaded = false;
        this.continuousAnalysisId = null;
        this.model = null; // Store the loaded model
        
        // Performance optimization variables
        this.lastFrameTime = 0;
        this.frameSkipCount = 0;
        this.maxFPS = 5; // Reduced FPS for better performance
        this.minFrameInterval = 1000 / this.maxFPS;
        this.lastAnalysisTime = 0;
        this.analysisThrottle = 2000; // Minimum time between analyses in ms
        this.isProcessingFrame = false;
        this.pendingFrame = null;
        this.lastUIUpdate = 0;
        this.uiUpdateThrottle = 3000; // Update UI at most every 3 seconds
        
        // Situation understanding variables
        this.sceneContext = {
            location: 'unknown',
            lighting: 'unknown',
            timeOfDay: 'unknown',
            peopleCount: 0,
            objects: [],
            activities: [],
            emotions: [],
            overallSituation: 'analyzing...'
        };
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        this.hasObjectDetection = 'IntersectionObserver' in window || 
                                 (window.OffscreenCanvas && window.createImageBitmap);
        
        // Situation templates for common scenarios
        this.situationTemplates = {
            office: {
                keywords: ['computer', 'laptop', 'desk', 'chair', 'monitor', 'keyboard', 'mouse'],
                activities: ['working', 'typing', 'meeting', 'reading'],
                context: 'indoor work environment'
            },
            kitchen: {
                keywords: ['sink', 'stove', 'refrigerator', 'microwave', 'oven', 'counter'],
                activities: ['cooking', 'preparing food', 'cleaning'],
                context: 'food preparation area'
            },
            livingRoom: {
                keywords: ['couch', 'tv', 'coffee table', 'bookshelf', 'lamp'],
                activities: ['relaxing', 'watching tv', 'reading', 'socializing'],
                context: 'leisure and social space'
            },
            bedroom: {
                keywords: ['bed', 'pillow', 'dresser', 'nightstand', 'lamp'],
                activities: ['sleeping', 'resting', 'reading'],
                context: 'sleeping area'
            },
            outdoor: {
                keywords: ['tree', 'car', 'building', 'sky', 'road', 'sidewalk'],
                activities: ['walking', 'driving', 'playing', 'talking'],
                context: 'outside environment'
            },
            restaurant: {
                keywords: ['table', 'chair', 'food', 'drink', 'plate', 'utensils'],
                activities: ['eating', 'talking', 'serving'],
                context: 'dining establishment'
            },
            classroom: {
                keywords: ['desk', 'chair', 'board', 'projector', 'book'],
                activities: ['learning', 'teaching', 'writing', 'listening'],
                context: 'educational environment'
            },
            store: {
                keywords: ['shelf', 'product', 'cart', 'register', 'customer'],
                activities: ['shopping', 'browsing', 'paying'],
                context: 'retail environment'
            },
            transportation: {
                keywords: ['car', 'bus', 'train', 'road', 'traffic light', 'sign'],
                activities: ['driving', 'waiting', 'walking', 'commuting'],
                context: 'transit situation'
            },
            nature: {
                keywords: ['tree', 'plant', 'flower', 'grass', 'water', 'mountain'],
                activities: ['walking', 'hiking', 'relaxing', 'exploring'],
                context: 'natural environment'
            }
        };
    }
    
    /**
     * Load the Situation Understanding Camera
     */
    loadSituationUnderstandingCamera() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        // Preload ML model for better performance
        this.preloadModel();
        
        this.createAppContainer();
        this.createSituationUnderstandingUI();
        this.setupActionButtons();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Preload ML model for better performance
     */
    preloadModel() {
        // Try to load TensorFlow.js and Coco-SSD model
        if (typeof tf === 'undefined') {
            this.updateStatus('Loading TensorFlow.js...');
            this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js')
                .then(() => {
                    this.updateStatus('Loading COCO-SSD model...');
                    return this.loadScript('Model.js');
                })
                .then(() => {
                    // Load the actual model
                    return cocoSsd.load();
                })
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        } else if (typeof cocoSsd !== 'undefined') {
            // If TensorFlow is already loaded, just load the model
            cocoSsd.load()
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        }
    }
    
    /**
     * Dynamically load a script
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support camera access. Please try a different browser.');
            return false;
        }
        
        if (!this.hasObjectDetection) {
            botReply('Your browser has limited support for object detection. Using alternative method.');
        }
        
        return true;
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
        
        // Add CSS for animations
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); }
            }
            .situation-card {
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 15px;
                margin-bottom: 15px;
                border-left: 4px solid #4CAF50;
                animation: fadeIn 0.5s ease-in-out;
            }
            .situation-card h3 {
                margin: 0 0 10px 0;
                color: #4CAF50;
                font-size: 18px;
            }
            .situation-card p {
                margin: 0;
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
                line-height: 1.5;
            }
            .situation-tag {
                display: inline-block;
                background-color: rgba(76, 175, 80, 0.2);
                color: #4CAF50;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 12px;
                margin-right: 8px;
                margin-bottom: 8px;
            }
            .confidence-meter {
                width: 100%;
                height: 8px;
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin-top: 8px;
                overflow: hidden;
            }
            .confidence-fill {
                height: 100%;
                background-color: #4CAF50;
                border-radius: 4px;
                transition: width 0.3s ease;
            }
        `;
        document.head.appendChild(styleElement);
    }
    
    /**
     * Create the Situation Understanding UI
     */
    createSituationUnderstandingUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '🧠';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = '⛶';
        this.fullscreenButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;
        
        this.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = '✕';
        this.closeButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-left: 10px;
        `;
        
        this.closeButton.addEventListener('click', () => this.closeApp());
        
        header.appendChild(this.fullscreenButton);
        header.appendChild(this.closeButton);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Camera container
        this.cameraContainer = document.createElement('div');
        this.cameraContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 40%;
            border-radius: 16px;
            overflow: hidden;
            background-color: #000;
            margin-bottom: 20px;
        `;
        
        // Video element for camera feed
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        // Canvas element for image capture and object detection
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        `;
        
        // Camera controls
        const cameraControls = document.createElement('div');
        cameraControls.style.cssText = `
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        `;
        
        // Analyze button
        this.captureButton = document.createElement('button');
        this.captureButton.innerHTML = '🔍';
        this.captureButton.style.cssText = `
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(76, 175, 80, 0.9);
            border: 3px solid white;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.captureButton.addEventListener('click', () => this.analyzeSituation());
        
        // Switch camera button
        this.switchCameraButton = document.createElement('button');
        this.switchCameraButton.innerHTML = '🔄';
        this.switchCameraButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.switchCameraButton.addEventListener('click', () => this.switchCamera());
        
        // Flash button
        this.flashButton = document.createElement('button');
        this.flashButton.innerHTML = '⚡';
        this.flashButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.flashButton.addEventListener('click', () => this.toggleFlash());
        
        cameraControls.appendChild(this.switchCameraButton);
        cameraControls.appendChild(this.captureButton);
        cameraControls.appendChild(this.flashButton);
        
        this.cameraContainer.appendChild(this.videoElement);
        this.cameraContainer.appendChild(this.canvasElement);
        this.cameraContainer.appendChild(cameraControls);
        
        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        `;
        
        // Analysis mode options
        const modeLabel = document.createElement('div');
        modeLabel.textContent = 'Analysis Mode:';
        modeLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const modeOptions = document.createElement('div');
        modeOptions.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const singleShot = this.createToggleOption('Single Shot', true);
        const continuous = this.createToggleOption('Continuous', false);
        
        // Add event listeners for mode changes
        singleShot.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.stopContinuousAnalysis();
            }
        });
        
        continuous.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.startContinuousAnalysis();
            }
        });
        
        modeOptions.appendChild(singleShot);
        modeOptions.appendChild(continuous);
        
        settingsPanel.appendChild(modeLabel);
        settingsPanel.appendChild(modeOptions);
        
        // Situation understanding display
        const situationContainer = document.createElement('div');
        situationContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const situationHeader = document.createElement('div');
        situationHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const situationTitle = document.createElement('div');
        situationTitle.textContent = 'Situation Analysis';
        situationTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Analysis';
        copyButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        copyButton.addEventListener('click', () => this.copySituationAnalysis());
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearResults());
        
        actionButtons.appendChild(copyButton);
        actionButtons.appendChild(clearButton);
        
        situationHeader.appendChild(situationTitle);
        situationHeader.appendChild(actionButtons);
        
        // Situation info display
        this.situationDisplay = document.createElement('div');
        this.situationDisplay.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            overflow-y: auto;
            margin-bottom: 15px;
            min-height: 200px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        `;
        
        // Add custom scrollbar styling for Webkit browsers
        const scrollbarStyle = document.createElement('style');
        scrollbarStyle.textContent = `
            .situation-display::-webkit-scrollbar {
                width: 8px;
            }
            .situation-display::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 4px;
            }
            .situation-display::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 4px;
            }
            .situation-display::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.5);
            }
        `;
        document.head.appendChild(scrollbarStyle);
        
        // Add a class for easier styling
        this.situationDisplay.className = 'situation-display';
        
        this.situationDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at a scene and click analyze to understand the situation
            </div>
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Loading situation analysis model...';
        
        mainContent.appendChild(this.cameraContainer);
        mainContent.appendChild(settingsPanel);
        mainContent.appendChild(situationContainer);
        situationContainer.appendChild(situationHeader);
        situationContainer.appendChild(this.situationDisplay);
        situationContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
        
        // Initialize camera
        this.initializeCamera();
    }
    
    /**
     * Create a toggle option
     */
    createToggleOption(label, defaultValue) {
        const container = document.createElement('div');
        container.style.cssText = `
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'analysis-mode';
        radio.id = `mode-${label.replace(/\s+/g, '-').toLowerCase()}`;
        radio.checked = defaultValue;
        radio.style.cssText = `
            cursor: pointer;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.htmlFor = radio.id;
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            cursor: pointer;
        `;
        
        container.appendChild(radio);
        container.appendChild(labelElement);
        
        return container;
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Add hover effects to buttons
        const buttons = [this.captureButton, this.switchCameraButton, this.flashButton];
        
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'scale(1.1)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'scale(1)';
            });
        });
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
    }
    
    /**
     * Initialize the camera
     */
    async initializeCamera() {
        try {
            // Stop any existing stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Set up camera constraints
            const constraints = {
                video: {
                    facingMode: this.facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            
            // Add flash constraint if supported
            if (this.flashMode === 'on') {
                constraints.video.torch = true;
            }
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Set video source
            this.videoElement.srcObject = this.currentStream;
            
            // Wait for video to be ready
            this.videoElement.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvasElement.width = this.videoElement.videoWidth;
                this.canvasElement.height = this.videoElement.videoHeight;
                
                this.updateStatus('Camera ready. Point at a scene and click analyze.');
                
                // Start continuous analysis if enabled
                const continuousMode = document.getElementById('mode-continuous');
                if (continuousMode && continuousMode.checked) {
                    this.startContinuousAnalysis();
                }
            };
            
        } catch (error) {
            console.error('Error initializing camera:', error);
            this.updateStatus('Error accessing camera: ' + error.message);
        }
    }
    
    /**
     * Switch between front and back camera
     */
    async switchCamera() {
        this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
        this.updateStatus('Switching camera...');
        await this.initializeCamera();
    }
    
    /**
     * Toggle flash mode
     */
    async toggleFlash() {
        const flashModes = ['off', 'on', 'auto'];
        const currentIndex = flashModes.indexOf(this.flashMode);
        this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];
        
        // Update button appearance based on flash mode
        if (this.flashMode === 'on') {
            this.flashButton.style.backgroundColor = 'rgba(255, 235, 59, 0.7)';
        } else if (this.flashMode === 'auto') {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        }
        
        this.updateStatus(`Flash mode: ${this.flashMode}`);
        await this.initializeCamera();
    }
    
    /**
     * Analyze the current situation (original method for single shot)
     */
    async analyzeSituation() {
        if (this.isAnalyzing) {
            return;
        }
        
        this.isAnalyzing = true;
        this.updateStatus('Analyzing situation...');
        
        try {
            // Draw current video frame to canvas
            const context = this.canvasElement.getContext('2d');
            context.drawImage(this.videoElement, 0, 0, this.canvasElement.width, this.canvasElement.height);
            
            // Analyze the situation in the image
            await this.processImageForSituation();
            
        } catch (error) {
            console.error('Error analyzing situation:', error);
            this.updateStatus('Error analyzing situation: ' + error.message);
        } finally {
            this.isAnalyzing = false;
        }
    }
    
    /**
     * Start continuous situation analysis with performance optimizations
     */
    startContinuousAnalysis() {
        if (this.continuousAnalysisId) {
            clearInterval(this.continuousAnalysisId);
        }
        
        // Clear any pending animation frames
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        
        // Reset performance tracking variables
        this.lastFrameTime = 0;
        this.frameSkipCount = 0;
        this.lastAnalysisTime = 0;
        this.isProcessingFrame = false;
        this.pendingFrame = null;
        
        // Use requestAnimationFrame for maximum performance
        const analyzeFrame = async (timestamp) => {
            // Only run analysis at specified intervals to prevent overload
            if (timestamp - this.lastFrameTime > this.minFrameInterval && !this.isProcessingFrame) {
                this.lastFrameTime = timestamp;
                
                // Skip frames if we're falling behind
                if (this.frameSkipCount > 0) {
                    this.frameSkipCount--;
                    this.animationId = requestAnimationFrame(analyzeFrame);
                    return;
                }
                
                // Process the frame
                await this.analyzeSituationOptimized();
            }
            
            // Continue the animation loop if continuous analysis is still enabled
            if (this.continuousAnalysisId !== null) {
                this.animationId = requestAnimationFrame(analyzeFrame);
            }
        };
        
        // Start the animation loop
        this.continuousAnalysisId = "active"; // Using a string instead of numeric ID
        this.animationId = requestAnimationFrame(analyzeFrame);
        
        this.updateStatus('Optimized continuous analysis enabled');
    }
    
    /**
     * Stop continuous situation analysis
     */
    stopContinuousAnalysis() {
        // Clear the interval if it exists
        if (this.continuousAnalysisId && typeof this.continuousAnalysisId === 'number') {
            clearInterval(this.continuousAnalysisId);
        }
        
        // Cancel any pending animation frames
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        
        this.continuousAnalysisId = null;
        this.updateStatus('Continuous analysis stopped');
    }
    
    /**
     * Optimized situation analysis method for continuous mode
     */
    async analyzeSituationOptimized() {
        // Check if we're already processing a frame or if we need to throttle analysis
        if (this.isProcessingFrame || (Date.now() - this.lastAnalysisTime < this.analysisThrottle)) {
            return;
        }
        
        this.isProcessingFrame = true;
        this.lastAnalysisTime = Date.now();
        
        try {
            // Skip drawing to canvas if not needed for maximum performance
            if (this.modelLoaded && this.model) {
                // Direct analysis without canvas drawing for fastest processing
                await this.processVideoFrameForSituationOptimized();
            } else {
                // Fallback to simulated analysis if model isn't loaded
                const simulatedSituation = await this.simulateSituationAnalysis();
                if (simulatedSituation) {
                    this.displaySituationAnalysisOptimized(simulatedSituation);
                }
            }
        } catch (error) {
            console.error('Error analyzing situation:', error);
            // Don't update status on every error to reduce UI updates
        } finally {
            this.isProcessingFrame = false;
        }
    }
    
    /**
     * Highly optimized process video frame method for continuous analysis
     */
    async processVideoFrameForSituationOptimized() {
        try {
            // Only update status periodically to avoid UI lag
            if (!this.lastStatusUpdate || Date.now() - this.lastStatusUpdate > 3000) {
                this.updateStatus('Analyzing situation...');
                this.lastStatusUpdate = Date.now();
            }
            
            // Detect objects in the video frame directly
            const predictions = await this.model.detect(this.videoElement);
            
            if (predictions && predictions.length > 0) {
                // Convert predictions to our format
                const objects = predictions.map(prediction => ({
                    name: prediction.class,
                    confidence: Math.round(prediction.score * 100),
                    bbox: prediction.bbox
                }));
                
                // Analyze the situation based on detected objects
                const situationAnalysis = this.analyzeSituationFromObjects(objects);
                
                // Only update UI if situation has changed significantly
                if (!this.lastSituationAnalysis || !this.situationsAreSimilar(this.lastSituationAnalysis, situationAnalysis)) {
                    this.displaySituationAnalysisOptimized(situationAnalysis);
                    this.lastSituationAnalysis = situationAnalysis;
                }
            }
        } catch (error) {
            console.error('Error processing video frame for situation:', error);
            // Only show error message occasionally to prevent UI spam
            if (!this.lastErrorUpdate || Date.now() - this.lastErrorUpdate > 5000) {
                this.updateStatus('Error processing video');
                this.lastErrorUpdate = Date.now();
            }
        }
    }
    
    /**
     * Helper method to compare if two situations are similar
     */
    situationsAreSimilar(situation1, situation2) {
        if (!situation1 || !situation2) return false;
        
        // Compare location
        if (situation1.location !== situation2.location) return false;
        
        // Compare overall situation
        if (situation1.overallSituation !== situation2.overallSituation) return false;
        
        // Compare activities (at least some overlap)
        const activities1 = situation1.activities || [];
        const activities2 = situation2.activities || [];
        
        if (activities1.length === 0 && activities2.length > 0) return false;
        if (activities1.length > 0 && activities2.length === 0) return false;
        
        // Check if there's at least one common activity
        const hasCommonActivity = activities1.some(activity => 
            activities2.includes(activity)
        );
        
        if (!hasCommonActivity && activities1.length > 0) return false;
        
        return true;
    }
    
    /**
     * Process image for situation understanding (original method for single shot analysis)
     */
    async processImageForSituation() {
        try {
            // Check if the model is loaded
            if (!this.modelLoaded || !this.model) {
                // Fallback to simulated analysis if model isn't loaded
                const simulatedSituation = await this.simulateSituationAnalysis();
                if (simulatedSituation) {
                    this.displaySituationAnalysis(simulatedSituation);
                    return;
                }
                
                this.updateStatus('Situation analysis model not ready. Please try again later.');
                return;
            }
            
            // Use the loaded model for real analysis
            this.updateStatus('Analyzing situation with AI model...');
            
            // Detect objects in the video frame
            const predictions = await this.model.detect(this.videoElement);
            
            if (predictions && predictions.length > 0) {
                // Convert predictions to our format
                const objects = predictions.map(prediction => ({
                    name: prediction.class,
                    confidence: Math.round(prediction.score * 100),
                    bbox: prediction.bbox
                }));
                
                // Analyze the situation based on detected objects
                const situationAnalysis = this.analyzeSituationFromObjects(objects);
                
                this.displaySituationAnalysis(situationAnalysis);
            } else {
                this.updateStatus('No objects detected. Try pointing your camera at a scene with objects.');
            }
            
        } catch (error) {
            console.error('Error processing image for situation:', error);
            this.updateStatus('Error processing image: ' + error.message);
        }
    }
    
    /**
     * Analyze situation from detected objects
     */
    analyzeSituationFromObjects(objects) {
        // Reset scene context
        this.sceneContext = {
            location: 'unknown',
            lighting: 'unknown',
            timeOfDay: 'unknown',
            peopleCount: 0,
            objects: objects,
            activities: [],
            emotions: [],
            overallSituation: 'analyzing...'
        };
        
        // Count people
        this.sceneContext.peopleCount = objects.filter(obj => obj.name === 'person').length;
        
        // Extract object names for analysis
        const objectNames = objects.map(obj => obj.name.toLowerCase());
        
        // Determine location based on detected objects
        let locationScores = {};
        
        for (const [locationType, template] of Object.entries(this.situationTemplates)) {
            locationScores[locationType] = 0;
            
            // Score based on keyword matches
            for (const keyword of template.keywords) {
                if (objectNames.includes(keyword)) {
                    locationScores[locationType]++;
                }
            }
        }
        
        // Find the location with the highest score
        let bestLocation = 'unknown';
        let highestScore = 0;
        
        for (const [location, score] of Object.entries(locationScores)) {
            if (score > highestScore) {
                highestScore = score;
                bestLocation = location;
            }
        }
        
        this.sceneContext.location = bestLocation;
        
        // Determine possible activities based on location and objects
        if (bestLocation !== 'unknown' && this.situationTemplates[bestLocation]) {
            this.sceneContext.activities = [...this.situationTemplates[bestLocation].activities];
        }
        
        // Add specific activities based on detected objects
        if (objectNames.includes('book') && !this.sceneContext.activities.includes('reading')) {
            this.sceneContext.activities.push('reading');
        }
        
        if (objectNames.includes('laptop') && !this.sceneContext.activities.includes('working')) {
            this.sceneContext.activities.push('working');
        }
        
        if (objectNames.includes('food') || objectNames.includes('plate')) {
            if (!this.sceneContext.activities.includes('eating')) {
                this.sceneContext.activities.push('eating');
            }
        }
        
        if (objectNames.includes('cup') || objectNames.includes('mug')) {
            if (!this.sceneContext.activities.includes('drinking')) {
                this.sceneContext.activities.push('drinking');
            }
        }
        
        if (objectNames.includes('bed')) {
            if (!this.sceneContext.activities.includes('sleeping') && !this.sceneContext.activities.includes('resting')) {
                this.sceneContext.activities.push('resting');
            }
        }
        
        if (objectNames.includes('car') || objectNames.includes('bus')) {
            if (!this.sceneContext.activities.includes('driving') && !this.sceneContext.activities.includes('traveling')) {
                this.sceneContext.activities.push('traveling');
            }
        }
        
        // Estimate time of day based on lighting conditions (simplified)
        // In a real implementation, this would use actual image analysis
        this.sceneContext.timeOfDay = this.estimateTimeOfDay();
        
        // Estimate overall situation based on all factors
        this.sceneContext.overallSituation = this.generateSituationSummary();
        
        return this.sceneContext;
    }
    
    /**
     * Estimate time of day (simplified)
     */
    estimateTimeOfDay() {
        // In a real implementation, this would analyze the actual image for lighting conditions
        // For this example, we'll use the current time
        const hour = new Date().getHours();
        
        if (hour >= 6 && hour < 12) {
            return 'morning';
        } else if (hour >= 12 && hour < 18) {
            return 'afternoon';
        } else if (hour >= 18 && hour < 22) {
            return 'evening';
        } else {
            return 'night';
        }
    }
    
    /**
     * Generate a natural language summary of the situation
     */
    generateSituationSummary() {
        const { location, peopleCount, activities, timeOfDay } = this.sceneContext;
        
        let summary = '';
        
        // Start with location
        if (location !== 'unknown') {
            const locationName = location.replace(/([A-Z])/g, ' $1').trim();
            summary += `This appears to be a ${locationName}. `;
        }
        
        // Add people count
        if (peopleCount > 0) {
            summary += `There ${peopleCount === 1 ? 'is' : 'are'} ${peopleCount} person${peopleCount > 1 ? 's' : ''} present. `;
        }
        
        // Add activities
        if (activities.length > 0) {
            if (activities.length === 1) {
                summary += `The main activity appears to be ${activities[0]}.`;
            } else {
                summary += `Possible activities include: ${activities.slice(0, -1).join(', ')} and ${activities[activities.length - 1]}.`;
            }
        }
        
        // Add time of day
        summary += ` This is taking place during the ${timeOfDay}.`;
        
        return summary;
    }
    
    /**
     * Simulate situation analysis (for demonstration purposes)
     */
    async simulateSituationAnalysis() {
        try {
            this.updateStatus('Analyzing scene for situation understanding...');
            
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Common situations that might be detected
            const commonSituations = [
                {
                    location: 'office',
                    lighting: 'indoor',
                    timeOfDay: 'afternoon',
                    peopleCount: Math.floor(Math.random() * 5) + 1,
                    activities: ['working', 'typing', 'meeting'],
                    emotions: ['focused', 'busy'],
                    overallSituation: 'This appears to be an office environment with people working. It seems to be a typical workday afternoon.'
                },
                {
                    location: 'kitchen',
                    lighting: 'indoor',
                    timeOfDay: 'evening',
                    peopleCount: Math.floor(Math.random() * 3) + 1,
                    activities: ['cooking', 'preparing food'],
                    emotions: ['busy', 'content'],
                    overallSituation: 'This appears to be a kitchen where someone is preparing a meal, likely dinner time in the evening.'
                },
                {
                    location: 'livingRoom',
                    lighting: 'indoor',
                    timeOfDay: 'evening',
                    peopleCount: Math.floor(Math.random() * 4) + 1,
                    activities: ['relaxing', 'watching tv', 'socializing'],
                    emotions: ['relaxed', 'entertained'],
                    overallSituation: 'This appears to be a living room where people are relaxing, possibly watching TV or socializing in the evening.'
                },
                {
                    location: 'outdoor',
                    lighting: 'natural',
                    timeOfDay: 'afternoon',
                    peopleCount: Math.floor(Math.random() * 10) + 1,
                    activities: ['walking', 'talking', 'playing'],
                    emotions: ['active', 'Sara'],
                    overallSituation: 'This appears to be an outdoor scene with people engaged in various activities, likely a park or public space on a nice afternoon.'
                },
                {
                    location: 'restaurant',
                    lighting: 'indoor',
                    timeOfDay: 'evening',
                    peopleCount: Math.floor(Math.random() * 20) + 5,
                    activities: ['eating', 'talking', 'socializing'],
                    emotions: ['social', 'enjoying'],
                    overallSituation: 'This appears to be a restaurant setting with people dining and socializing, likely during dinner hours.'
                },
                {
                    location: 'classroom',
                    lighting: 'indoor',
                    timeOfDay: 'morning',
                    peopleCount: Math.floor(Math.random() * 30) + 10,
                    activities: ['learning', 'teaching', 'writing'],
                    emotions: ['focused', 'attentive'],
                    overallSituation: 'This appears to be a classroom setting with students engaged in learning activities, likely during morning class hours.'
                },
                {
                    location: 'store',
                    lighting: 'indoor',
                    timeOfDay: 'afternoon',
                    peopleCount: Math.floor(Math.random() * 15) + 5,
                    activities: ['shopping', 'browsing', 'paying'],
                    emotions: ['busy', 'focused'],
                    overallSituation: 'This appears to be a retail store with customers shopping and browsing products, likely during afternoon hours.'
                },
                {
                    location: 'transportation',
                    lighting: 'mixed',
                    timeOfDay: 'morning',
                    peopleCount: Math.floor(Math.random() * 50) + 10,
                    activities: ['commuting', 'driving', 'waiting'],
                    emotions: ['busy', 'rushed'],
                    overallSituation: 'This appears to be a transportation setting with people commuting, likely during morning rush hour.'
                },
                {
                    location: 'nature',
                    lighting: 'natural',
                    timeOfDay: 'afternoon',
                    peopleCount: Math.floor(Math.random() * 8) + 1,
                    activities: ['walking', 'hiking', 'relaxing'],
                    emotions: ['peaceful', 'relaxed'],
                    overallSituation: 'This appears to be a natural outdoor setting with people enjoying nature, likely a park or trail on a pleasant afternoon.'
                }
            ];
            
            // Randomly select a situation
            const randomSituation = commonSituations[Math.floor(Math.random() * commonSituations.length)];
            
            return randomSituation;
            
        } catch (error) {
            console.error('Simulated situation analysis error:', error);
            return null;
        }
    }
    
    /**
     * Display situation analysis (original method)
     */
    displaySituationAnalysis(situation) {
        if (!situation) {
            this.updateStatus('Could not analyze situation.');
            return;
        }
        
        // Clear previous results
        this.situationDisplay.innerHTML = '';
        
        // Create a container for the situation analysis
        const situationContainer = document.createElement('div');
        situationContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Create situation summary card
        const summaryCard = document.createElement('div');
        summaryCard.className = 'situation-card';
        
        const summaryTitle = document.createElement('h3');
        summaryTitle.textContent = 'Situation Summary';
        summaryCard.appendChild(summaryTitle);
        
        const summaryText = document.createElement('p');
        summaryText.textContent = situation.overallSituation;
        summaryCard.appendChild(summaryText);
        
        situationContainer.appendChild(summaryCard);
        
        // Create location card
        const locationCard = document.createElement('div');
        locationCard.className = 'situation-card';
        
        const locationTitle = document.createElement('h3');
        locationTitle.textContent = 'Location';
        locationCard.appendChild(locationTitle);
        
        const locationText = document.createElement('p');
        locationText.textContent = this.formatLocationName(situation.location);
        locationCard.appendChild(locationText);
        
        situationContainer.appendChild(locationCard);
        
        // Create time card
        const timeCard = document.createElement('div');
        timeCard.className = 'situation-card';
        
        const timeTitle = document.createElement('h3');
        timeTitle.textContent = 'Time of Day';
        timeCard.appendChild(timeTitle);
        
        const timeText = document.createElement('p');
        timeText.textContent = this.formatTimeOfDay(situation.timeOfDay);
        timeCard.appendChild(timeText);
        
        situationContainer.appendChild(timeCard);
        
        // Create people card
        const peopleCard = document.createElement('div');
        peopleCard.className = 'situation-card';
        
        const peopleTitle = document.createElement('h3');
        peopleTitle.textContent = 'People';
        peopleCard.appendChild(peopleTitle);
        
        const peopleText = document.createElement('p');
        peopleText.textContent = `${situation.peopleCount} person${situation.peopleCount !== 1 ? 's' : ''} detected`;
        peopleCard.appendChild(peopleText);
        
        situationContainer.appendChild(peopleCard);
        
        // Create activities card
        if (situation.activities && situation.activities.length > 0) {
            const activitiesCard = document.createElement('div');
            activitiesCard.className = 'situation-card';
            
            const activitiesTitle = document.createElement('h3');
            activitiesTitle.textContent = 'Activities';
            activitiesCard.appendChild(activitiesTitle);
            
            const activitiesContainer = document.createElement('div');
            activitiesContainer.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 8px;
            `;
            
            situation.activities.forEach(activity => {
                const activityTag = document.createElement('span');
                activityTag.className = 'situation-tag';
                activityTag.textContent = this.formatActivityName(activity);
                activitiesContainer.appendChild(activityTag);
            });
            
            activitiesCard.appendChild(activitiesContainer);
            situationContainer.appendChild(activitiesCard);
        }
        
        // Create confidence meter
        const confidenceCard = document.createElement('div');
        confidenceCard.className = 'situation-card';
        
        const confidenceTitle = document.createElement('h3');
        confidenceTitle.textContent = 'Analysis Confidence';
        confidenceCard.appendChild(confidenceTitle);
        
        const confidenceText = document.createElement('p');
        confidenceText.textContent = 'Based on detected objects and scene analysis';
        confidenceCard.appendChild(confidenceText);
        
        const confidenceMeter = document.createElement('div');
        confidenceMeter.className = 'confidence-meter';
        
        const confidenceFill = document.createElement('div');
        confidenceFill.className = 'confidence-fill';
        confidenceFill.style.width = '75%'; // Simulated confidence level
        
        confidenceMeter.appendChild(confidenceFill);
        confidenceCard.appendChild(confidenceMeter);
        
        situationContainer.appendChild(confidenceCard);
        
        this.situationDisplay.appendChild(situationContainer);
        
        // Add to history
        this.situationHistory.push({
            timestamp: new Date(),
            situation: situation
        });
        
        // Update status
        this.updateStatus('Situation analysis complete');
    }
    
    /**
     * Optimized display method that only updates when necessary (for continuous analysis)
     */
    displaySituationAnalysisOptimized(situation) {
        if (!situation) {
            // Only update status if no situation was detected previously
            if (this.lastSituationAnalysis) {
                this.updateStatus('Could not analyze situation.');
                this.lastSituationAnalysis = null;
            }
            return;
        }
        
        // Only update UI if enough time has passed since the last update
        if (Date.now() - this.lastUIUpdate < this.uiUpdateThrottle) {
            return;
        }
        
        this.lastUIUpdate = Date.now();
        
        // Clear previous results
        this.situationDisplay.innerHTML = '';
        
        // Create a container for the situation analysis
        const situationContainer = document.createElement('div');
        situationContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Create situation summary card
        const summaryCard = document.createElement('div');
        summaryCard.className = 'situation-card';
        
        const summaryTitle = document.createElement('h3');
        summaryTitle.textContent = 'Situation Summary';
        summaryCard.appendChild(summaryTitle);
        
        const summaryText = document.createElement('p');
        summaryText.textContent = situation.overallSituation;
        summaryCard.appendChild(summaryText);
        
        situationContainer.appendChild(summaryCard);
        
        // Create location card
        const locationCard = document.createElement('div');
        locationCard.className = 'situation-card';
        
        const locationTitle = document.createElement('h3');
        locationTitle.textContent = 'Location';
        locationCard.appendChild(locationTitle);
        
        const locationText = document.createElement('p');
        locationText.textContent = this.formatLocationName(situation.location);
        locationCard.appendChild(locationText);
        
        situationContainer.appendChild(locationCard);
        
        // Create time card
        const timeCard = document.createElement('div');
        timeCard.className = 'situation-card';
        
        const timeTitle = document.createElement('h3');
        timeTitle.textContent = 'Time of Day';
        timeCard.appendChild(timeTitle);
        
        const timeText = document.createElement('p');
        timeText.textContent = this.formatTimeOfDay(situation.timeOfDay);
        timeCard.appendChild(timeText);
        
        situationContainer.appendChild(timeCard);
        
        // Create people card
        const peopleCard = document.createElement('div');
        peopleCard.className = 'situation-card';
        
        const peopleTitle = document.createElement('h3');
        peopleTitle.textContent = 'People';
        peopleCard.appendChild(peopleTitle);
        
        const peopleText = document.createElement('p');
        peopleText.textContent = `${situation.peopleCount} person${situation.peopleCount !== 1 ? 's' : ''} detected`;
        peopleCard.appendChild(peopleText);
        
        situationContainer.appendChild(peopleCard);
        
        // Create activities card
        if (situation.activities && situation.activities.length > 0) {
            const activitiesCard = document.createElement('div');
            activitiesCard.className = 'situation-card';
            
            const activitiesTitle = document.createElement('h3');
            activitiesTitle.textContent = 'Activities';
            activitiesCard.appendChild(activitiesTitle);
            
            const activitiesContainer = document.createElement('div');
            activitiesContainer.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 8px;
            `;
            
            situation.activities.forEach(activity => {
                const activityTag = document.createElement('span');
                activityTag.className = 'situation-tag';
                activityTag.textContent = this.formatActivityName(activity);
                activitiesContainer.appendChild(activityTag);
            });
            
            activitiesCard.appendChild(activitiesContainer);
            situationContainer.appendChild(activitiesCard);
        }
        
        // Create confidence meter
        const confidenceCard = document.createElement('div');
        confidenceCard.className = 'situation-card';
        
        const confidenceTitle = document.createElement('h3');
        confidenceTitle.textContent = 'Analysis Confidence';
        confidenceCard.appendChild(confidenceTitle);
        
        const confidenceText = document.createElement('p');
        confidenceText.textContent = 'Based on detected objects and scene analysis';
        confidenceCard.appendChild(confidenceText);
        
        const confidenceMeter = document.createElement('div');
        confidenceMeter.className = 'confidence-meter';
        
        const confidenceFill = document.createElement('div');
        confidenceFill.className = 'confidence-fill';
        confidenceFill.style.width = '75%'; // Simulated confidence level
        
        confidenceMeter.appendChild(confidenceFill);
        confidenceCard.appendChild(confidenceMeter);
        
        situationContainer.appendChild(confidenceCard);
        
        this.situationDisplay.appendChild(situationContainer);
        
        // Add to history (limit history size to prevent memory issues)
        this.situationHistory.push({
            timestamp: new Date(),
            situation: situation
        });
        
        // Keep only the last 3 analyses to prevent memory issues
        if (this.situationHistory.length > 3) {
            this.situationHistory.shift();
        }
        
        // Update status only occasionally to prevent UI spam
        if (!this.lastStatusUpdate || Date.now() - this.lastStatusUpdate > 3000) {
            this.updateStatus('Situation analysis complete');
            this.lastStatusUpdate = Date.now();
        }
        
        // Auto-scroll to the bottom to show the latest results
        this.situationDisplay.scrollTop = this.situationDisplay.scrollHeight;
    }
    
    /**
     * Format location name for display
     */
    formatLocationName(location) {
        if (location === 'unknown') {
            return 'Unable to determine location';
        }
        
        // Convert camelCase to readable format
        return location.replace(/([A-Z])/g, ' $1').trim();
    }
    
    /**
     * Format time of day for display
     */
    formatTimeOfDay(timeOfDay) {
        if (timeOfDay === 'unknown') {
            return 'Unable to determine time of day';
        }
        
        // Capitalize first letter
        return timeOfDay.charAt(0).toUpperCase() + timeOfDay.slice(1);
    }
    
    /**
     * Format activity name for display
     */
    formatActivityName(activity) {
        // Capitalize first letter
        return activity.charAt(0).toUpperCase() + activity.slice(1);
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        if (this.resultDisplay) {
            this.resultDisplay.textContent = message;
        }
    }
    
    /**
     * Copy situation analysis to clipboard
     */
    copySituationAnalysis() {
        if (this.situationHistory.length === 0) {
            this.updateStatus('No situation analysis to copy.');
            return;
        }
        
        // Get the latest analysis
        const latestAnalysis = this.situationHistory[this.situationHistory.length - 1];
        const situation = latestAnalysis.situation;
        
        // Format the information
        let textToCopy = `Situation Analysis (${latestAnalysis.timestamp.toLocaleString()}):\n\n`;
        textToCopy += `Summary: ${situation.overallSituation}\n\n`;
        textToCopy += `Location: ${this.formatLocationName(situation.location)}\n`;
        textToCopy += `Time of Day: ${this.formatTimeOfDay(situation.timeOfDay)}\n`;
        textToCopy += `People: ${situation.peopleCount} person${situation.peopleCount !== 1 ? 's' : ''}\n`;
        
        if (situation.activities && situation.activities.length > 0) {
            textToCopy += `Activities: ${situation.activities.map(a => this.formatActivityName(a)).join(', ')}\n`;
        }
        
        // Copy to clipboard
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                this.updateStatus('Situation analysis copied to clipboard!');
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                this.updateStatus('Failed to copy situation analysis.');
            });
    }
    
    /**
     * Clear results
     */
    clearResults() {
        this.situationDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at a scene and click analyze to understand the situation
            </div>
        `;
        
        // Clear canvas
        const context = this.canvasElement.getContext('2d');
        context.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
        
        // Reset last situation analysis
        this.lastSituationAnalysis = null;
        
        this.updateStatus('Results cleared. Ready for new analysis.');
    }
    
    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.appContainer.requestFullscreen) {
                this.appContainer.requestFullscreen();
            } else if (this.appContainer.webkitRequestFullscreen) { /* Safari */
                this.appContainer.webkitRequestFullscreen();
            } else if (this.appContainer.msRequestFullscreen) { /* IE11 */
                this.appContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        // Stop continuous analysis
        this.stopContinuousAnalysis();
        
        // Stop camera stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        this.isActive = false;
        botReply('Situation Understanding Camera closed.');
    }
}

// Create a global instance of the app
const situationUnderstandingCamera = new SituationUnderstandingCamera();

// Add this to your AI's command handling
if (/situation understanding|scene analysis|understand camera/i.test(userInputRaw)) {
    situationUnderstandingCamera.loadSituationUnderstandingCamera();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    situationUnderstandingCamera.closeApp();
    return;
}


class SoundIdentificationApp {
    constructor() {
        this.appName = 'SOUND IDENTIFICATION';
        this.instructions = 'Use your microphone to identify specific sounds like dogs, people, vehicles, and more.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.visualizerContainer = null;
        this.canvasElement = null;
        this.resultDisplay = null;
        this.soundDisplay = null;
        this.startButton = null;
        this.switchMicButton = null;
        this.currentStream = null;
        this.audioContext = null;
        this.analyser = null;
        this.microphone = null;
        this.dataArray = null;
        this.source = null;
        this.animationId = null;
        this.soundHistory = [];
        this.isMonitoring = false;
        this.modelLoaded = false;
        
        // Performance optimization variables
        this.lastAnalysisTime = 0;
        this.analysisThrottle = 2000; // Minimum time between analyses in ms
        this.isProcessingFrame = false;
        this.lastUIUpdate = 0;
        this.uiUpdateThrottle = 3000; // Update UI at most every 3 seconds
        
        // Sound identification variables
        this.soundContext = {
            volume: 0,
            pitch: 0,
            dominantFrequency: 0,
            identifiedSounds: [],
            confidence: 0,
            environment: 'unknown',
            activities: [],
            overallSituation: 'analyzing...'
        };
        
        // Specific sound patterns for identification
        this.soundPatterns = {
            dog: {
                name: 'Dog Barking',
                frequencyRange: { min: 300, max: 3000 },
                volumeRange: { min: 50, max: 95 },
                patterns: ['rapid bursts', 'high pitch variations', 'irregular intervals'],
                keywords: ['bark', 'growl', 'whine'],
                confidenceThreshold: 70
            },
            cat: {
                name: 'Cat Meowing',
                frequencyRange: { min: 400, max: 2000 },
                volumeRange: { min: 30, max: 80 },
                patterns: ['sustained notes', 'medium pitch', 'varied tones'],
                keywords: ['meow', 'purr', 'hiss'],
                confidenceThreshold: 65
            },
            man: {
                name: 'Man Speaking',
                frequencyRange: { min: 85, max: 180 },
                volumeRange: { min: 40, max: 85 },
                patterns: ['rhythmic patterns', 'lower frequency', 'consistent volume'],
                keywords: ['speaking', 'talking', 'voice'],
                confidenceThreshold: 75
            },
            woman: {
                name: 'Woman Speaking',
                frequencyRange: { min: 165, max: 255 },
                volumeRange: { min: 35, max: 85 },
                patterns: ['rhythmic patterns', 'higher frequency', 'varied pitch'],
                keywords: ['speaking', 'talking', 'voice'],
                confidenceThreshold: 75
            },
            baby: {
                name: 'Baby Crying',
                frequencyRange: { min: 400, max: 2000 },
                volumeRange: { min: 60, max: 95 },
                patterns: ['sustained high pitch', 'irregular bursts', 'volume variations'],
                keywords: ['crying', 'fussing', 'whimpering'],
                confidenceThreshold: 80
            },
            car: {
                name: 'Car Engine',
                frequencyRange: { min: 50, max: 400 },
                volumeRange: { min: 40, max: 90 },
                patterns: ['low frequency rumble', 'consistent sound', 'mechanical noise'],
                keywords: ['engine', 'motor', 'vehicle'],
                confidenceThreshold: 70
            },
            siren: {
                name: 'Emergency Siren',
                frequencyRange: { min: 500, max: 3000 },
                volumeRange: { min: 70, max: 95 },
                patterns: ['oscillating frequency', 'high volume', 'distinctive pattern'],
                keywords: ['siren', 'alarm', 'emergency'],
                confidenceThreshold: 85
            },
            doorbell: {
                name: 'Doorbell',
                frequencyRange: { min: 800, max: 4000 },
                volumeRange: { min: 50, max: 85 },
                patterns: ['short duration', 'distinctive tone', 'single or double ring'],
                keywords: ['bell', 'chime', 'ding'],
                confidenceThreshold: 80
            },
            phone: {
                name: 'Phone Ringing',
                frequencyRange: { min: 400, max: 2000 },
                volumeRange: { min: 45, max: 85 },
                patterns: ['repeating pattern', 'medium pitch', 'regular intervals'],
                keywords: ['ring', 'telephone', 'call'],
                confidenceThreshold: 75
            },
            glass: {
                name: 'Glass Breaking',
                frequencyRange: { min: 2000, max: 8000 },
                volumeRange: { min: 60, max: 95 },
                patterns: ['sharp attack', 'quick decay', 'high frequency'],
                keywords: ['break', 'shatter', 'crash'],
                confidenceThreshold: 85
            },
            thunder: {
                name: 'Thunder',
                frequencyRange: { min: 20, max: 200 },
                volumeRange: { min: 60, max: 95 },
                patterns: ['low frequency', 'rumbling', 'long duration'],
                keywords: ['thunder', 'rumble', 'storm'],
                confidenceThreshold: 80
            },
            rain: {
                name: 'Rain',
                frequencyRange: { min: 1000, max: 8000 },
                volumeRange: { min: 20, max: 70 },
                patterns: ['consistent noise', 'high frequency', 'steady pattern'],
                keywords: ['rain', 'drizzle', 'precipitation'],
                confidenceThreshold: 75
            },
            fire: {
                name: 'Fire Crackling',
                frequencyRange: { min: 500, max: 5000 },
                volumeRange: { min: 25, max: 70 },
                patterns: ['irregular bursts', 'medium frequency', 'random pattern'],
                keywords: ['fire', 'crackle', 'flame'],
                confidenceThreshold: 70
            },
            footsteps: {
                name: 'Footsteps',
                frequencyRange: { min: 100, max: 1000 },
                volumeRange: { min: 20, max: 60 },
                patterns: ['repeating pattern', 'low to medium frequency', 'rhythmic'],
                keywords: ['steps', 'walking', 'footsteps'],
                confidenceThreshold: 65
            },
            applause: {
                name: 'Applause',
                frequencyRange: { min: 1000, max: 6000 },
                volumeRange: { min: 50, max: 90 },
                patterns: ['random noise', 'sustained sound', 'clapping pattern'],
                keywords: ['clapping', 'applause', 'cheering'],
                confidenceThreshold: 80
            },
            music: {
                name: 'Music',
                frequencyRange: { min: 50, max: 8000 },
                volumeRange: { min: 30, max: 90 },
                patterns: ['rhythmic patterns', 'multiple frequencies', 'structured sound'],
                keywords: ['music', 'song', 'melody'],
                confidenceThreshold: 70
            },
            vacuum: {
                name: 'Vacuum Cleaner',
                frequencyRange: { min: 100, max: 500 },
                volumeRange: { min: 60, max: 85 },
                patterns: ['consistent noise', 'low to medium frequency', 'mechanical'],
                keywords: ['vacuum', 'cleaner', 'hoover'],
                confidenceThreshold: 75
            }
        };
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        this.hasAudioContext = !!(window.AudioContext || window.webkitAudioContext);
    }
    
    /**
     * Load the Sound Identification App
     */
    loadSoundIdentificationApp() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        this.createAppContainer();
        this.createSoundIdentificationUI();
        this.setupActionButtons();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support microphone access. Please try a different browser.');
            return false;
        }
        
        if (!this.hasAudioContext) {
            botReply('Your browser has limited support for audio analysis. Using alternative method.');
        }
        
        return true;
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
        
        // Add CSS for animations
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); }
            }
            .sound-card {
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 15px;
                margin-bottom: 15px;
                border-left: 4px solid #4CAF50;
                animation: fadeIn 0.5s ease-in-out;
            }
            .sound-card h3 {
                margin: 0 0 10px 0;
                color: #4CAF50;
                font-size: 18px;
            }
            .sound-card p {
                margin: 0;
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
                line-height: 1.5;
            }
            .sound-tag {
                display: inline-block;
                background-color: rgba(76, 175, 80, 0.2);
                color: #4CAF50;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 12px;
                margin-right: 8px;
                margin-bottom: 8px;
            }
            .identified-sound {
                display: inline-block;
                background-color: rgba(33, 150, 243, 0.2);
                color: #2196F3;
                padding: 6px 12px;
                border-radius: 20px;
                font-size: 14px;
                margin-right: 8px;
                margin-bottom: 8px;
                font-weight: 500;
            }
            .volume-meter {
                width: 100%;
                height: 8px;
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin-top: 8px;
                overflow: hidden;
            }
            .volume-fill {
                height: 100%;
                background-color: #4CAF50;
                border-radius: 4px;
                transition: width 0.3s ease;
            }
            .confidence-meter {
                width: 100%;
                height: 8px;
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin-top: 8px;
                overflow: hidden;
            }
            .confidence-fill {
                height: 100%;
                background-color: #2196F3;
                border-radius: 4px;
                transition: width 0.3s ease;
            }
            .frequency-bar {
                display: inline-block;
                width: 4px;
                margin: 0 1px;
                background-color: #4CAF50;
                border-radius: 2px;
                transition: height 0.1s ease;
            }
        `;
        document.head.appendChild(styleElement);
    }
    
    /**
     * Create the Sound Identification UI
     */
    createSoundIdentificationUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '🔊';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = '⛶';
        this.fullscreenButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;
        
        this.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = '✕';
        this.closeButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-left: 10px;
        `;
        
        this.closeButton.addEventListener('click', () => this.closeApp());
        
        header.appendChild(this.fullscreenButton);
        header.appendChild(this.closeButton);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Visualizer container
        this.visualizerContainer = document.createElement('div');
        this.visualizerContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 30%;
            border-radius: 16px;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        
        // Canvas element for audio visualization
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.style.cssText = `
            width: 100%;
            height: 100%;
        `;
        
        // Placeholder text
        const placeholderText = document.createElement('div');
        placeholderText.textContent = 'Click Start to begin identifying sounds';
        placeholderText.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 18px;
            text-align: center;
            z-index: 1;
        `;
        
        this.visualizerContainer.appendChild(this.canvasElement);
        this.visualizerContainer.appendChild(placeholderText);
        
        // Controls
        const controlsContainer = document.createElement('div');
        controlsContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        `;
        
        // Start/Stop button
        this.startButton = document.createElement('button');
        this.startButton.innerHTML = '▶️';
        this.startButton.style.cssText = `
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(76, 175, 80, 0.9);
            border: 3px solid white;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.startButton.addEventListener('click', () => this.toggleMonitoring());
        
        // Switch microphone button
        this.switchMicButton = document.createElement('button');
        this.switchMicButton.innerHTML = '🔄';
        this.switchMicButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.switchMicButton.addEventListener('click', () => this.switchMicrophone());
        
        controlsContainer.appendChild(this.switchMicButton);
        controlsContainer.appendChild(this.startButton);
        
        // Sound identification display
        const soundContainer = document.createElement('div');
        soundContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const soundHeader = document.createElement('div');
        soundHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const soundTitle = document.createElement('div');
        soundTitle.textContent = 'Identified Sounds';
        soundTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Analysis';
        copyButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        copyButton.addEventListener('click', () => this.copySoundAnalysis());
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearResults());
        
        actionButtons.appendChild(copyButton);
        actionButtons.appendChild(clearButton);
        
        soundHeader.appendChild(soundTitle);
        soundHeader.appendChild(actionButtons);
        
        // Sound info display
        this.soundDisplay = document.createElement('div');
        this.soundDisplay.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            overflow-y: auto;
            margin-bottom: 15px;
            min-height: 200px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        `;
        
        // Add custom scrollbar styling for Webkit browsers
        const scrollbarStyle = document.createElement('style');
        scrollbarStyle.textContent = `
            .sound-display::-webkit-scrollbar {
                width: 8px;
            }
            .sound-display::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 4px;
            }
            .sound-display::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 4px;
            }
            .sound-display::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.5);
            }
        `;
        document.head.appendChild(scrollbarStyle);
        
        // Add a class for easier styling
        this.soundDisplay.className = 'sound-display';
        
        this.soundDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Click Start to begin identifying sounds like dogs, people, vehicles, and more
            </div>
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Ready to identify sounds';
        
        mainContent.appendChild(this.visualizerContainer);
        mainContent.appendChild(controlsContainer);
        mainContent.appendChild(soundContainer);
        soundContainer.appendChild(soundHeader);
        soundContainer.appendChild(this.soundDisplay);
        soundContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Add hover effects to buttons
        const buttons = [this.startButton, this.switchMicButton];
        
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'scale(1.1)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'scale(1)';
            });
        });
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
    }
    
    /**
     * Initialize audio context and microphone
     */
    async initializeAudio() {
        try {
            // Create audio context
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Get microphone stream
            this.currentStream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 44100
                } 
            });
            
            // Create analyser node
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048;
            this.analyser.smoothingTimeConstant = 0.8;
            
            // Create microphone source
            this.microphone = this.audioContext.createMediaStreamSource(this.currentStream);
            this.microphone.connect(this.analyser);
            
            // Create data array for frequency data
            const bufferLength = this.analyser.frequencyBinCount;
            this.dataArray = new Uint8Array(bufferLength);
            
            this.updateStatus('Microphone ready. Click Start to begin identifying sounds.');
            
        } catch (error) {
            console.error('Error initializing audio:', error);
            this.updateStatus('Error accessing microphone: ' + error.message);
        }
    }
    
    /**
     * Toggle monitoring on/off
     */
    toggleMonitoring() {
        if (this.isMonitoring) {
            this.stopMonitoring();
        } else {
            this.startMonitoring();
        }
    }
    
    /**
     * Start monitoring sounds
     */
    async startMonitoring() {
        if (this.isMonitoring) {
            return;
        }
        
        try {
            // Initialize audio if not already done
            if (!this.audioContext) {
                await this.initializeAudio();
            }
            
            this.isMonitoring = true;
            this.startButton.innerHTML = '⏹️';
            this.startButton.style.backgroundColor = 'rgba(244, 67, 54, 0.9)';
            
            // Hide placeholder text
            const placeholder = this.visualizerContainer.querySelector('div');
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            
            // Start visualization
            this.visualize();
            
            // Start continuous sound identification
            this.startContinuousIdentification();
            
            this.updateStatus('Identifying sounds...');
            
        } catch (error) {
            console.error('Error starting monitoring:', error);
            this.updateStatus('Error starting monitoring: ' + error.message);
        }
    }
    
    /**
     * Stop monitoring sounds
     */
    stopMonitoring() {
        if (!this.isMonitoring) {
            return;
        }
        
        this.isMonitoring = false;
        this.startButton.innerHTML = '▶️';
        this.startButton.style.backgroundColor = 'rgba(76, 175, 80, 0.9)';
        
        // Stop continuous identification
        this.stopContinuousIdentification();
        
        // Cancel animation frame
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        
        // Show placeholder text
        const placeholder = this.visualizerContainer.querySelector('div');
        if (placeholder) {
            placeholder.style.display = 'block';
        }
        
        this.updateStatus('Monitoring stopped');
    }
    
    /**
     * Switch microphone (if multiple are available)
     */
    async switchMicrophone() {
        if (!this.isMonitoring) {
            this.updateStatus('Start monitoring first to switch microphones');
            return;
        }
        
        try {
            // Stop current stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Get available microphones
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputs = devices.filter(device => device.kind === 'audioinput');
            
            if (audioInputs.length <= 1) {
                this.updateStatus('Only one microphone available');
                return;
            }
            
            // Find current microphone
            let currentMicIndex = 0;
            for (let i = 0; i < audioInputs.length; i++) {
                if (this.currentStream.getTracks()[0].label === audioInputs[i].label) {
                    currentMicIndex = i;
                    break;
                }
            }
            
            // Switch to next microphone
            const nextMicIndex = (currentMicIndex + 1) % audioInputs.length;
            const nextMicId = audioInputs[nextMicIndex].deviceId;
            
            // Get new microphone stream
            this.currentStream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    deviceId: nextMicId,
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 44100
                } 
            });
            
            // Recreate audio nodes
            this.microphone = this.audioContext.createMediaStreamSource(this.currentStream);
            this.microphone.connect(this.analyser);
            
            this.updateStatus(`Switched to: ${audioInputs[nextMicIndex].label || 'Microphone'}`);
            
        } catch (error) {
            console.error('Error switching microphone:', error);
            this.updateStatus('Error switching microphone: ' + error.message);
        }
    }
    
    /**
     * Visualize audio
     */
    visualize() {
        if (!this.isMonitoring) return;
        
        this.animationId = requestAnimationFrame(() => this.visualize());
        
        // Get frequency data
        this.analyser.getByteFrequencyData(this.dataArray);
        
        // Clear canvas
        const canvas = this.canvasElement;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        
        // Set canvas dimensions if needed
        if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        // Draw frequency bars
        const barWidth = (width / this.dataArray.length) * 2.5;
        let x = 0;
        
        for (let i = 0; i < this.dataArray.length; i++) {
            const barHeight = (this.dataArray[i] / 255) * height;
            
            // Create gradient for bars
            const gradient = ctx.createLinearGradient(0, height - barHeight, 0, height);
            gradient.addColorStop(0, '#4CAF50');
            gradient.addColorStop(1, '#1a237e');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, height - barHeight, barWidth, barHeight);
            
            x += barWidth + 1;
        }
    }
    
    /**
     * Start continuous sound identification
     */
    startContinuousIdentification() {
        // Analyze sound immediately
        this.identifySound();
        
        // Set up interval for continuous identification
        this.continuousIdentificationId = setInterval(() => {
            if (this.isMonitoring) {
                this.identifySound();
            }
        }, 3000); // Identify every 3 seconds
        
        this.updateStatus('Continuous sound identification enabled');
    }
    
    /**
     * Stop continuous sound identification
     */
    stopContinuousIdentification() {
        if (this.continuousIdentificationId) {
            clearInterval(this.continuousIdentificationId);
            this.continuousIdentificationId = null;
        }
        
        this.updateStatus('Sound identification stopped');
    }
    
    /**
     * Identify current sound
     */
    async identifySound() {
        if (!this.isMonitoring || !this.analyser) {
            return;
        }
        
        try {
            // Get frequency data
            this.analyser.getByteFrequencyData(this.dataArray);
            
            // Analyze the sound
            const soundAnalysis = this.analyzeSoundForIdentification(this.dataArray);
            
            // Display results
            this.displaySoundIdentification(soundAnalysis);
            
            // Add to history
            this.soundHistory.push({
                timestamp: new Date(),
                analysis: soundAnalysis
            });
            
            // Keep only the last 5 analyses to prevent memory issues
            if (this.soundHistory.length > 5) {
                this.soundHistory.shift();
            }
            
            this.updateStatus('Sound identification complete');
            
        } catch (error) {
            console.error('Error identifying sound:', error);
            this.updateStatus('Error identifying sound: ' + error.message);
        }
    }
    
    /**
     * Analyze sound data to identify specific sounds
     */
    analyzeSoundForIdentification(dataArray) {
        // Reset sound context
        this.soundContext = {
            volume: 0,
            pitch: 0,
            dominantFrequency: 0,
            identifiedSounds: [],
            confidence: 0,
            environment: 'unknown',
            activities: [],
            overallSituation: 'analyzing...'
        };
        
        // Calculate volume (RMS)
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i] * dataArray[i];
        }
        const rms = Math.sqrt(sum / dataArray.length);
        this.soundContext.volume = Math.min(100, Math.round((rms / 128) * 100));
        
        // Find dominant frequency
        let maxValue = 0;
        let maxIndex = 0;
        for (let i = 0; i < dataArray.length; i++) {
            if (dataArray[i] > maxValue) {
                maxValue = dataArray[i];
                maxIndex = i;
            }
        }
        
        // Convert index to frequency
        const nyquist = this.audioContext.sampleRate / 2;
        this.soundContext.dominantFrequency = Math.round((maxIndex / dataArray.length) * nyquist);
        
        // Estimate pitch (simplified)
        if (this.soundContext.dominantFrequency > 80 && this.soundContext.dominantFrequency < 2000) {
            this.soundContext.pitch = Math.round(this.soundContext.dominantFrequency);
        } else {
            this.soundContext.pitch = 0;
        }
        
        // Identify specific sounds
        this.soundContext.identifiedSounds = this.identifySpecificSounds(dataArray);
        
        // Determine environment based on identified sounds
        this.soundContext.environment = this.determineEnvironmentFromSounds();
        
        // Infer activities based on identified sounds
        this.soundContext.activities = this.inferActivitiesFromSounds();
        
        // Generate overall situation summary
        this.soundContext.overallSituation = this.generateSoundIdentificationSummary();
        
        return this.soundContext;
    }
    
    /**
     * Identify specific sounds based on frequency patterns
     */
    identifySpecificSounds(dataArray) {
        const identifiedSounds = [];
        
        // Analyze frequency distribution
        const bassRange = dataArray.slice(0, Math.floor(dataArray.length * 0.1));
        const midRange = dataArray.slice(Math.floor(dataArray.length * 0.1), Math.floor(dataArray.length * 0.5));
        const trebleRange = dataArray.slice(Math.floor(dataArray.length * 0.5));
        
        // Calculate average values for each range
        const bassAvg = bassRange.reduce((a, b) => a + b, 0) / bassRange.length;
        const midAvg = midRange.reduce((a, b) => a + b, 0) / midRange.length;
        const trebleAvg = trebleRange.reduce((a, b) => a + b, 0) / trebleRange.length;
        
        // Check each sound pattern
        for (const [soundKey, soundPattern] of Object.entries(this.soundPatterns)) {
            let matchScore = 0;
            let maxPossibleScore = 0;
            
            // Check frequency range
            maxPossibleScore += 2;
            if (this.soundContext.dominantFrequency >= soundPattern.frequencyRange.min && 
                this.soundContext.dominantFrequency <= soundPattern.frequencyRange.max) {
                matchScore += 2;
            }
            
            // Check volume range
            maxPossibleScore += 2;
            if (this.soundContext.volume >= soundPattern.volumeRange.min && 
                this.soundContext.volume <= soundPattern.volumeRange.max) {
                matchScore += 2;
            }
            
            // Check frequency distribution patterns
            maxPossibleScore += 1;
            if (soundPattern.name === 'Dog Barking' && bassAvg > midAvg && trebleAvg > midAvg) {
                matchScore += 1;
            } else if (soundPattern.name === 'Man Speaking' && midAvg > bassAvg && midAvg > trebleAvg && this.soundContext.dominantFrequency < 180) {
                matchScore += 1;
            } else if (soundPattern.name === 'Woman Speaking' && midAvg > bassAvg && midAvg > trebleAvg && this.soundContext.dominantFrequency > 165) {
                matchScore += 1;
            } else if (soundPattern.name === 'Baby Crying' && trebleAvg > midAvg && trebleAvg > bassAvg) {
                matchScore += 1;
            } else if (soundPattern.name === 'Car Engine' && bassAvg > midAvg && bassAvg > trebleAvg) {
                matchScore += 1;
            } else if (soundPattern.name === 'Siren' && midAvg > bassAvg && midAvg > trebleAvg) {
                matchScore += 1;
            } else if (soundPattern.name === 'Glass Breaking' && trebleAvg > midAvg * 1.5) {
                matchScore += 1;
            } else if (soundPattern.name === 'Thunder' && bassAvg > midAvg * 1.5 && bassAvg > trebleAvg * 1.5) {
                matchScore += 1;
            } else if (soundPattern.name === 'Rain' && trebleAvg > midAvg && trebleAvg > bassAvg) {
                matchScore += 1;
            }
            
            // Calculate confidence percentage
            const confidence = Math.round((matchScore / maxPossibleScore) * 100);
            
            // Add to identified sounds if confidence exceeds threshold
            if (confidence >= soundPattern.confidenceThreshold) {
                identifiedSounds.push({
                    name: soundPattern.name,
                    confidence: confidence
                });
            }
        }
        
        // Sort identified sounds by confidence (highest first)
        identifiedSounds.sort((a, b) => b.confidence - a.confidence);
        
        return identifiedSounds;
    }
    
    /**
     * Determine environment based on identified sounds
     */
    determineEnvironmentFromSounds() {
        const { identifiedSounds, volume } = this.soundContext;
        
        if (identifiedSounds.length === 0) {
            return 'unknown';
        }
        
        // Check for specific environment indicators
        const topSound = identifiedSounds[0].name;
        
        if (topSound === 'Dog Barking' || topSound === 'Cat Meowing') {
            return 'home with pets';
        } else if (topSound === 'Man Speaking' || topSound === 'Woman Speaking') {
            return 'social environment';
        } else if (topSound === 'Baby Crying') {
            return 'home with baby';
        } else if (topSound === 'Car Engine' || topSound === 'Siren') {
            return 'outdoors / transportation';
        } else if (topSound === 'Doorbell' || topSound === 'Phone Ringing') {
            return 'home or office';
        } else if (topSound === 'Glass Breaking') {
            return 'indoor environment';
        } else if (topSound === 'Thunder' || topSound === 'Rain') {
            return 'outdoors';
        } else if (topSound === 'Fire Crackling') {
            return 'indoor with fireplace';
        } else if (topSound === 'Footsteps') {
            return 'indoor or outdoor hallway';
        } else if (topSound === 'Applause') {
            return 'event or performance venue';
        } else if (topSound === 'Music') {
            return 'entertainment venue';
        } else if (topSound === 'Vacuum Cleaner') {
            return 'home or office';
        }
        
        return 'unknown';
    }
    
    /**
     * Infer activities based on identified sounds
     */
    inferActivitiesFromSounds() {
        const { identifiedSounds } = this.soundContext;
        
        if (identifiedSounds.length === 0) {
            return [];
        }
        
        const activities = [];
        
        // Add activities based on identified sounds
        identifiedSounds.forEach(sound => {
            switch (sound.name) {
                case 'Dog Barking':
                    if (!activities.includes('pet care')) activities.push('pet care');
                    break;
                case 'Man Speaking':
                case 'Woman Speaking':
                    if (!activities.includes('conversation')) activities.push('conversation');
                    break;
                case 'Baby Crying':
                    if (!activities.includes('childcare')) activities.push('childcare');
                    break;
                case 'Car Engine':
                    if (!activities.includes('driving')) activities.push('driving');
                    break;
                case 'Siren':
                    if (!activities.includes('emergency situation')) activities.push('emergency situation');
                    break;
                case 'Doorbell':
                    if (!activities.includes('receiving visitor')) activities.push('receiving visitor');
                    break;
                case 'Phone Ringing':
                    if (!activities.includes('phone call')) activities.push('phone call');
                    break;
                case 'Glass Breaking':
                    if (!activities.includes('accident')) activities.push('accident');
                    break;
                case 'Thunder':
                    if (!activities.includes('weather event')) activities.push('weather event');
                    break;
                case 'Rain':
                    if (!activities.includes('weather event')) activities.push('weather event');
                    break;
                case 'Fire Crackling':
                    if (!activities.includes('relaxing')) activities.push('relaxing');
                    break;
                case 'Footsteps':
                    if (!activities.includes('movement')) activities.push('movement');
                    break;
                case 'Applause':
                    if (!activities.includes('celebration')) activities.push('celebration');
                    break;
                case 'Music':
                    if (!activities.includes('entertainment')) activities.push('entertainment');
                    break;
                case 'Vacuum Cleaner':
                    if (!activities.includes('cleaning')) activities.push('cleaning');
                    break;
            }
        });
        
        return activities;
    }
    
    /**
     * Generate a natural language summary of the identified sounds
     */
    generateSoundIdentificationSummary() {
        const { identifiedSounds, volume, environment, activities } = this.soundContext;
        
        let summary = '';
        
        // Start with identified sounds
        if (identifiedSounds.length > 0) {
            if (identifiedSounds.length === 1) {
                summary += `I detected ${identifiedSounds[0].name.toLowerCase()} with ${identifiedSounds[0].confidence}% confidence. `;
            } else {
                summary += 'I detected several sounds: ';
                for (let i = 0; i < identifiedSounds.length; i++) {
                    if (i > 0 && i === identifiedSounds.length - 1) {
                        summary += ' and ';
                    } else if (i > 0) {
                        summary += ', ';
                    }
                    summary += `${identifiedSounds[i].name.toLowerCase()} (${identifiedSounds[i].confidence}% confidence)`;
                }
                summary += '. ';
            }
        } else {
            summary += 'I could not identify any specific sounds. ';
        }
        
        // Add volume information
        if (volume < 30) {
            summary += 'The environment is very quiet. ';
        } else if (volume < 60) {
            summary += 'The environment is moderately quiet. ';
        } else if (volume < 80) {
            summary += 'The environment is moderately loud. ';
        } else {
            summary += 'The environment is very loud. ';
        }
        
        // Add environment information
        if (environment !== 'unknown') {
            summary += `This appears to be a ${environment}. `;
        }
        
        // Add activities
        if (activities.length > 0) {
            if (activities.length === 1) {
                summary += `Possible activity: ${activities[0]}.`;
            } else {
                summary += `Possible activities include: ${activities.slice(0, -1).join(', ')} and ${activities[activities.length - 1]}.`;
            }
        }
        
        return summary;
    }
    
    /**
     * Display sound identification
     */
    displaySoundIdentification(analysis) {
        if (!analysis) {
            this.updateStatus('Could not identify sounds.');
            return;
        }
        
        // Clear previous results
        this.soundDisplay.innerHTML = '';
        
        // Create a container for the sound identification
        const soundContainer = document.createElement('div');
        soundContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Create summary card
        const summaryCard = document.createElement('div');
        summaryCard.className = 'sound-card';
        
        const summaryTitle = document.createElement('h3');
        summaryTitle.textContent = 'Sound Analysis';
        summaryCard.appendChild(summaryTitle);
        
        const summaryText = document.createElement('p');
        summaryText.textContent = analysis.overallSituation;
        summaryCard.appendChild(summaryText);
        
        soundContainer.appendChild(summaryCard);
        
        // Create identified sounds card
        const identifiedSoundsCard = document.createElement('div');
        identifiedSoundsCard.className = 'sound-card';
        
        const identifiedSoundsTitle = document.createElement('h3');
        identifiedSoundsTitle.textContent = 'Identified Sounds';
        identifiedSoundsCard.appendChild(identifiedSoundsTitle);
        
        if (analysis.identifiedSounds && analysis.identifiedSounds.length > 0) {
            const soundsContainer = document.createElement('div');
            soundsContainer.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 8px;
            `;
            
            analysis.identifiedSounds.forEach(sound => {
                const soundTag = document.createElement('span');
                soundTag.className = 'identified-sound';
                soundTag.textContent = `${sound.name} (${sound.confidence}%)`;
                soundsContainer.appendChild(soundTag);
            });
            
            identifiedSoundsCard.appendChild(soundsContainer);
        } else {
            const noSoundsText = document.createElement('p');
            noSoundsText.textContent = 'No specific sounds identified';
            identifiedSoundsCard.appendChild(noSoundsText);
        }
        
        soundContainer.appendChild(identifiedSoundsCard);
        
        // Create sound characteristics card
        const characteristicsCard = document.createElement('div');
        characteristicsCard.className = 'sound-card';
        
        const characteristicsTitle = document.createElement('h3');
        characteristicsTitle.textContent = 'Sound Characteristics';
        characteristicsCard.appendChild(characteristicsTitle);
        
        const volumeText = document.createElement('p');
        volumeText.textContent = `Volume: ${analysis.volume}/100`;
        characteristicsCard.appendChild(volumeText);
        
        const volumeMeter = document.createElement('div');
        volumeMeter.className = 'volume-meter';
        
        const volumeFill = document.createElement('div');
        volumeFill.className = 'volume-fill';
        volumeFill.style.width = `${analysis.volume}%`;
        
        volumeMeter.appendChild(volumeFill);
        characteristicsCard.appendChild(volumeMeter);
        
        if (analysis.pitch > 0) {
            const pitchText = document.createElement('p');
            pitchText.textContent = `Dominant Frequency: ${analysis.pitch} Hz`;
            characteristicsCard.appendChild(pitchText);
        }
        
        soundContainer.appendChild(characteristicsCard);
        
        // Create environment card
        const environmentCard = document.createElement('div');
        environmentCard.className = 'sound-card';
        
        const environmentTitle = document.createElement('h3');
        environmentTitle.textContent = 'Environment';
        environmentCard.appendChild(environmentTitle);
        
        const environmentText = document.createElement('p');
        environmentText.textContent = this.formatEnvironmentName(analysis.environment);
        environmentCard.appendChild(environmentText);
        
        soundContainer.appendChild(environmentCard);
        
        // Create activities card
        if (analysis.activities && analysis.activities.length > 0) {
            const activitiesCard = document.createElement('div');
            activitiesCard.className = 'sound-card';
            
            const activitiesTitle = document.createElement('h3');
            activitiesTitle.textContent = 'Possible Activities';
            activitiesCard.appendChild(activitiesTitle);
            
            const activitiesContainer = document.createElement('div');
            activitiesContainer.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 8px;
            `;
            
            analysis.activities.forEach(activity => {
                const activityTag = document.createElement('span');
                activityTag.className = 'sound-tag';
                activityTag.textContent = this.formatActivityName(activity);
                activitiesContainer.appendChild(activityTag);
            });
            
            activitiesCard.appendChild(activitiesContainer);
            soundContainer.appendChild(activitiesCard);
        }
        
        // Create timestamp
        const timestampCard = document.createElement('div');
        timestampCard.className = 'sound-card';
        
        const timestampTitle = document.createElement('h3');
        timestampTitle.textContent = 'Analysis Time';
        timestampCard.appendChild(timestampTitle);
        
        const timestampText = document.createElement('p');
        timestampText.textContent = new Date().toLocaleString();
        timestampCard.appendChild(timestampText);
        
        soundContainer.appendChild(timestampCard);
        
        this.soundDisplay.appendChild(soundContainer);
    }
    
    /**
     * Format environment name for display
     */
    formatEnvironmentName(environment) {
        if (environment === 'unknown') {
            return 'Unable to determine environment';
        }
        
        return environment;
    }
    
    /**
     * Format activity name for display
     */
    formatActivityName(activity) {
        // Capitalize first letter
        return activity.charAt(0).toUpperCase() + activity.slice(1);
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        if (this.resultDisplay) {
            this.resultDisplay.textContent = message;
        }
    }
    
    /**
     * Copy sound analysis to clipboard
     */
    copySoundAnalysis() {
        if (this.soundHistory.length === 0) {
            this.updateStatus('No sound analysis to copy.');
            return;
        }
        
        // Get the latest analysis
        const latestAnalysis = this.soundHistory[this.soundHistory.length - 1];
        const analysis = latestAnalysis.analysis;
        
        // Format the information
        let textToCopy = `Sound Identification (${latestAnalysis.timestamp.toLocaleString()}):\n\n`;
        textToCopy += `Summary: ${analysis.overallSituation}\n\n`;
        
        if (analysis.identifiedSounds && analysis.identifiedSounds.length > 0) {
            textToCopy += 'Identified Sounds:\n';
            analysis.identifiedSounds.forEach(sound => {
                textToCopy += `- ${sound.name}: ${sound.confidence}% confidence\n`;
            });
            textToCopy += '\n';
        }
        
        textToCopy += `Volume: ${analysis.volume}/100\n`;
        textToCopy += `Environment: ${this.formatEnvironmentName(analysis.environment)}\n`;
        
        if (analysis.pitch > 0) {
            textToCopy += `Dominant Frequency: ${analysis.pitch} Hz\n`;
        }
        
        if (analysis.activities && analysis.activities.length > 0) {
            textToCopy += `Possible Activities: ${analysis.activities.map(a => this.formatActivityName(a)).join(', ')}\n`;
        }
        
        // Copy to clipboard
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                this.updateStatus('Sound analysis copied to clipboard!');
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                this.updateStatus('Failed to copy sound analysis.');
            });
    }
    
    /**
     * Clear results
     */
    clearResults() {
        this.soundDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Click Start to begin identifying sounds like dogs, people, vehicles, and more
            </div>
        `;
        
        // Clear canvas
        const canvas = this.canvasElement;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        this.updateStatus('Results cleared. Ready for new identification.');
    }
    
    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.appContainer.requestFullscreen) {
                this.appContainer.requestFullscreen();
            } else if (this.appContainer.webkitRequestFullscreen) { /* Safari */
                this.appContainer.webkitRequestFullscreen();
            } else if (this.appContainer.msRequestFullscreen) { /* IE11 */
                this.appContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                this.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                this.msExitFullscreen();
            }
            this.isFullscreen = false;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        // Stop monitoring
        this.stopMonitoring();
        
        // Stop audio stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Close audio context
        if (this.audioContext) {
            this.audioContext.close();
        }
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        this.isActive = false;
        botReply('Sound Identification closed.');
    }
}

// Create a global instance of the app
const soundIdentificationApp = new SoundIdentificationApp();

// Add this to your AI's command handling
if (/sound identification|identify sounds|recognize sounds/i.test(userInputRaw)) {
    soundIdentificationApp.loadSoundIdentificationApp();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    soundIdentificationApp.closeApp();
    return;
}

class QRCodeGeneratorScanner {
    constructor() {
        this.appName = 'QR CODE GENERATOR & SCANNER';
        this.instructions = 'Generate QR codes or scan them with your camera.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.tabContainer = null;
        this.generatorTab = null;
        this.scannerTab = null;
        this.generatorContent = null;
        this.scannerContent = null;
        this.activeTab = 'generator';
        
        // Generator elements
        this.qrInput = null;
        this.generateButton = null;
        this.qrDisplay = null;
        this.downloadButton = null;
        this.qrSize = null;
        this.qrColor = null;
        this.qrBgColor = null;
        
        // Scanner elements
        this.videoElement = null;
        this.canvasElement = null;
        this.startScanButton = null;
        this.switchCameraButton = null;
        this.scanResult = null;
        this.copyResultButton = null;
        this.currentStream = null;
        this.facingMode = 'environment'; // 'user' for front, 'environment' for back
        this.isScanning = false;
        this.animationId = null;
        this.lastScanTime = 0;
        this.scanInterval = 500; // Scan every 500ms instead of every frame
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    }
    
    /**
     * Load the QR Code Generator & Scanner App
     */
    loadQRCodeGeneratorScanner() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        // Load QR code libraries
        this.loadQRLibraries();
        
        this.createAppContainer();
        this.createQRCodeUI();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support camera access. QR scanning may not work. Please try a different browser.');
            // Still allow the app to load, but warn about camera limitations
        }
        
        return true;
    }
    
    /**
     * Load QR code libraries
     */
    loadQRLibraries() {
        // Load qrcode.js for generating QR codes
        if (typeof QRCode === 'undefined') {
            const script1 = document.createElement('script');
            script1.src = 'https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js';
            script1.onload = () => console.log('QRCode library loaded');
            script1.onerror = () => console.error('Failed to load QRCode library');
            document.head.appendChild(script1);
        }
        
        // Load jsQR for scanning QR codes
        if (typeof jsQR === 'undefined') {
            const script2 = document.createElement('script');
            script2.src = 'https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js';
            script2.onload = () => console.log('jsQR library loaded');
            script2.onerror = () => console.error('Failed to load jsQR library');
            document.head.appendChild(script2);
        }
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
        
        // Add CSS for animations
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            .tab-button {
                padding: 12px 24px;
                background-color: rgba(255, 255, 255, 0.1);
                color: rgba(255, 255, 255, 0.7);
                border: none;
                border-radius: 8px 8px 0 0;
                cursor: pointer;
                font-size: 16px;
                font-weight: 500;
                transition: all 0.3s ease;
                margin-right: 5px;
            }
            .tab-button.active {
                background-color: rgba(76, 175, 80, 0.3);
                color: #4CAF50;
            }
            .tab-content {
                display: none;
                width: 100%;
                height: 100%;
                animation: fadeIn 0.5s ease-in-out;
            }
            .tab-content.active {
                display: flex;
                flex-direction: column;
            }
            .qr-card {
                background-color: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 20px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            .qr-card h3 {
                margin: 0 0 15px 0;
                color: #4CAF50;
                font-size: 18px;
            }
            .input-group {
                margin-bottom: 15px;
            }
            .input-group label {
                display: block;
                margin-bottom: 5px;
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
            }
            .input-group input, .input-group textarea {
                width: 100%;
                padding: 10px;
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.2);
                background-color: rgba(255, 255, 255, 0.1);
                color: white;
                font-size: 14px;
                box-sizing: border-box;
            }
            .input-group textarea {
                resize: vertical;
                min-height: 100px;
            }
            .button-group {
                display: flex;
                gap: 10px;
                margin-top: 15px;
            }
            .btn {
                padding: 10px 20px;
                border-radius: 8px;
                border: none;
                background-color: #4CAF50;
                color: white;
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            .btn:hover {
                background-color: #45a049;
            }
            .btn-secondary {
                background-color: rgba(255, 255, 255, 0.2);
            }
            .btn-secondary:hover {
                background-color: rgba(255, 255, 255, 0.3);
            }
            .qr-display {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
                background-color: white;
                border-radius: 12px;
                margin-bottom: 20px;
            }
            .qr-display canvas, .qr-display img {
                max-width: 100%;
                height: auto;
            }
            .camera-container {
                position: relative;
                width: 100%;
                height: 60%;
                border-radius: 12px;
                overflow: hidden;
                background-color: #000;
                margin-bottom: 20px;
            }
            .camera-container video {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }
            .camera-container canvas {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }
            .camera-controls {
                position: absolute;
                bottom: 15px;
                left: 0;
                right: 0;
                display: flex;
                justify-content: center;
                gap: 15px;
                padding: 0 20px;
            }
            .camera-button {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background-color: rgba(76, 175, 80, 0.9);
                border: 3px solid white;
                color: white;
                font-size: 20px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                transition: all 0.2s ease;
            }
            .camera-button:hover {
                transform: scale(1.1);
            }
            .camera-button.secondary {
                background-color: rgba(255, 255, 255, 0.2);
            }
            .scan-result {
                background-color: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                padding: 20px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                color: white;
                word-break: break-all;
            }
            .scan-result h3 {
                margin: 0 0 10px 0;
                color: #4CAF50;
                font-size: 18px;
            }
            .scan-result p {
                margin: 0;
                line-height: 1.5;
            }
            .color-input {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .color-input input[type="color"] {
                width: 40px;
                height: 40px;
                border: none;
                border-radius: 8px;
                cursor: pointer;
            }
            .range-input {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .range-input input[type="range"] {
                flex: 1;
            }
            .range-value {
                min-width: 40px;
                text-align: right;
                color: rgba(255, 255, 255, 0.8);
            }
            .notification {
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(76, 175, 80, 0.9);
                color: white;
                padding: 12px 24px;
                border-radius: 30px;
                font-size: 16px;
                z-index: 10001;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                animation: fadeInOut 2s ease-in-out forwards;
            }
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            }
        `;
        document.head.appendChild(styleElement);
    }
    
    /**
     * Create the QR Code UI
     */
    createQRCodeUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '📱';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = '⛶';
        this.fullscreenButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;
        
        this.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = '✕';
        this.closeButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-left: 10px;
        `;
        
        this.closeButton.addEventListener('click', () => this.closeApp());
        
        header.appendChild(this.fullscreenButton);
        header.appendChild(this.closeButton);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Create tab navigation
        this.tabContainer = document.createElement('div');
        this.tabContainer.style.cssText = `
            display: flex;
            margin-bottom: 20px;
        `;
        
        // Generator tab
        this.generatorTab = document.createElement('button');
        this.generatorTab.className = 'tab-button active';
        this.generatorTab.textContent = 'Generator';
        this.generatorTab.addEventListener('click', () => this.switchTab('generator'));
        
        // Scanner tab
        this.scannerTab = document.createElement('button');
        this.scannerTab.className = 'tab-button';
        this.scannerTab.textContent = 'Scanner';
        this.scannerTab.addEventListener('click', () => this.switchTab('scanner'));
        
        this.tabContainer.appendChild(this.generatorTab);
        this.tabContainer.appendChild(this.scannerTab);
        
        // Create generator content
        this.generatorContent = document.createElement('div');
        this.generatorContent.className = 'tab-content active';
        
        const generatorCard = document.createElement('div');
        generatorCard.className = 'qr-card';
        
        const generatorTitle = document.createElement('h3');
        generatorTitle.textContent = 'Generate QR Code';
        generatorCard.appendChild(generatorTitle);
        
        // Text input
        const textInputGroup = document.createElement('div');
        textInputGroup.className = 'input-group';
        
        const textLabel = document.createElement('label');
        textLabel.textContent = 'Text or URL';
        textInputGroup.appendChild(textLabel);
        
        this.qrInput = document.createElement('textarea');
        this.qrInput.placeholder = 'Enter text or URL to generate QR code';
        this.qrInput.addEventListener('input', () => {
            // Debounce the input to avoid excessive regeneration
            clearTimeout(this.qrInputTimeout);
            this.qrInputTimeout = setTimeout(() => {
                this.generateQRCode();
            }, 300);
        });
        textInputGroup.appendChild(this.qrInput);
        
        generatorCard.appendChild(textInputGroup);
        
        // Size input
        const sizeInputGroup = document.createElement('div');
        sizeInputGroup.className = 'input-group range-input';
        
        const sizeLabel = document.createElement('label');
        sizeLabel.textContent = 'Size';
        sizeInputGroup.appendChild(sizeLabel);
        
        const sizeContainer = document.createElement('div');
        sizeContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        
        this.qrSize = document.createElement('input');
        this.qrSize.type = 'range';
        this.qrSize.min = '128';
        this.qrSize.max = '512';
        this.qrSize.value = '256';
        this.qrSize.addEventListener('input', () => {
            document.getElementById('size-value').textContent = this.qrSize.value;
            this.generateQRCode();
        });
        
        const sizeValue = document.createElement('div');
        sizeValue.id = 'size-value';
        sizeValue.className = 'range-value';
        sizeValue.textContent = this.qrSize.value;
        
        sizeContainer.appendChild(this.qrSize);
        sizeContainer.appendChild(sizeValue);
        sizeInputGroup.appendChild(sizeContainer);
        
        generatorCard.appendChild(sizeInputGroup);
        
        // Color inputs
        const colorInputGroup = document.createElement('div');
        colorInputGroup.className = 'input-group';
        
        const colorLabel = document.createElement('label');
        colorLabel.textContent = 'Colors';
        colorInputGroup.appendChild(colorLabel);
        
        const colorsContainer = document.createElement('div');
        colorsContainer.style.cssText = `
            display: flex;
            gap: 20px;
        `;
        
        // Foreground color
        const fgColorContainer = document.createElement('div');
        fgColorContainer.className = 'color-input';
        
        const fgColorLabel = document.createElement('label');
        fgColorLabel.textContent = 'Foreground';
        fgColorLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        `;
        fgColorContainer.appendChild(fgColorLabel);
        
        this.qrColor = document.createElement('input');
        this.qrColor.type = 'color';
        this.qrColor.value = '#000000';
        this.qrColor.addEventListener('input', () => this.generateQRCode());
        fgColorContainer.appendChild(this.qrColor);
        
        // Background color
        const bgColorContainer = document.createElement('div');
        bgColorContainer.className = 'color-input';
        
        const bgColorLabel = document.createElement('label');
        bgColorLabel.textContent = 'Background';
        bgColorLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        `;
        bgColorContainer.appendChild(bgColorLabel);
        
        this.qrBgColor = document.createElement('input');
        this.qrBgColor.type = 'color';
        this.qrBgColor.value = '#FFFFFF';
        this.qrBgColor.addEventListener('input', () => this.generateQRCode());
        bgColorContainer.appendChild(this.qrBgColor);
        
        colorsContainer.appendChild(fgColorContainer);
        colorsContainer.appendChild(bgColorContainer);
        colorInputGroup.appendChild(colorsContainer);
        
        generatorCard.appendChild(colorInputGroup);
        
        // Buttons
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'button-group';
        
        this.generateButton = document.createElement('button');
        this.generateButton.className = 'btn';
        this.generateButton.textContent = 'Generate QR Code';
        this.generateButton.addEventListener('click', () => this.generateQRCode());
        
        this.downloadButton = document.createElement('button');
        this.downloadButton.className = 'btn btn-secondary';
        this.downloadButton.textContent = 'Download';
        this.downloadButton.addEventListener('click', () => this.downloadQRCode());
        
        buttonGroup.appendChild(this.generateButton);
        buttonGroup.appendChild(this.downloadButton);
        
        generatorCard.appendChild(buttonGroup);
        
        this.generatorContent.appendChild(generatorCard);
        
        // QR display
        this.qrDisplay = document.createElement('div');
        this.qrDisplay.className = 'qr-display';
        this.qrDisplay.innerHTML = `
            <div style="color: #666; text-align: center;">
                QR code will appear here
            </div>
        `;
        
        this.generatorContent.appendChild(this.qrDisplay);
        
        // Create scanner content
        this.scannerContent = document.createElement('div');
        this.scannerContent.className = 'tab-content';
        
        const scannerCard = document.createElement('div');
        scannerCard.className = 'qr-card';
        
        const scannerTitle = document.createElement('h3');
        scannerTitle.textContent = 'Scan QR Code';
        scannerCard.appendChild(scannerTitle);
        
        const scannerInstructions = document.createElement('p');
        scannerInstructions.textContent = 'Point your camera at a QR code to scan it.';
        scannerInstructions.style.cssText = `
            margin-bottom: 20px;
            color: rgba(255, 255, 255, 0.8);
        `;
        scannerCard.appendChild(scannerInstructions);
        
        this.scannerContent.appendChild(scannerCard);
        
        // Camera container
        const cameraContainer = document.createElement('div');
        cameraContainer.className = 'camera-container';
        
        // Video element for camera feed
        this.videoElement = document.createElement('video');
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        // Canvas element for QR scanning
        this.canvasElement = document.createElement('canvas');
        
        // Camera controls
        const cameraControls = document.createElement('div');
        cameraControls.className = 'camera-controls';
        
        // Start/Stop scan button
        this.startScanButton = document.createElement('button');
        this.startScanButton.className = 'camera-button';
        this.startScanButton.innerHTML = '▶️';
        this.startScanButton.addEventListener('click', () => this.toggleScanning());
        
        // Switch camera button
        this.switchCameraButton = document.createElement('button');
        this.switchCameraButton.className = 'camera-button secondary';
        this.switchCameraButton.innerHTML = '🔄';
        this.switchCameraButton.addEventListener('click', () => this.switchCamera());
        
        cameraControls.appendChild(this.switchCameraButton);
        cameraControls.appendChild(this.startScanButton);
        
        cameraContainer.appendChild(this.videoElement);
        cameraContainer.appendChild(this.canvasElement);
        cameraContainer.appendChild(cameraControls);
        
        this.scannerContent.appendChild(cameraContainer);
        
        // Scan result
        this.scanResult = document.createElement('div');
        this.scanResult.className = 'scan-result';
        this.scanResult.style.cssText = `
            display: none;
        `;
        
        const resultTitle = document.createElement('h3');
        resultTitle.textContent = 'Scan Result';
        this.scanResult.appendChild(resultTitle);
        
        const resultText = document.createElement('p');
        resultText.id = 'scan-result-text';
        this.scanResult.appendChild(resultText);
        
        // Copy result button
        this.copyResultButton = document.createElement('button');
        this.copyResultButton.className = 'btn';
        this.copyResultButton.textContent = 'Copy Result';
        this.copyResultButton.style.cssText = `
            margin-top: 15px;
        `;
        this.copyResultButton.addEventListener('click', () => this.copyScanResult());
        this.scanResult.appendChild(this.copyResultButton);
        
        this.scannerContent.appendChild(this.scanResult);
        
        // Add elements to main content
        mainContent.appendChild(this.tabContainer);
        mainContent.appendChild(this.generatorContent);
        mainContent.appendChild(this.scannerContent);
        
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
    }
    
    /**
     * Switch between generator and scanner tabs
     */
    switchTab(tab) {
        if (tab === 'generator') {
            this.activeTab = 'generator';
            this.generatorTab.classList.add('active');
            this.scannerTab.classList.remove('active');
            this.generatorContent.classList.add('active');
            this.scannerContent.classList.remove('active');
        } else {
            this.activeTab = 'scanner';
            this.scannerTab.classList.add('active');
            this.generatorTab.classList.remove('active');
            this.scannerContent.classList.add('active');
            this.generatorContent.classList.remove('active');
            
            // Initialize camera when switching to scanner tab
            if (!this.videoElement.srcObject) {
                this.initializeCamera();
            }
        }
    }
    
    /**
     * Generate QR Code
     */
    generateQRCode() {
        const text = this.qrInput.value.trim();
        
        if (!text) {
            return;
        }
        
        // Clear previous QR code
        this.qrDisplay.innerHTML = '';
        
        // Check if QRCode library is loaded
        if (typeof QRCode === 'undefined') {
            this.qrDisplay.innerHTML = `
                <div style="color: #f44336; text-align: center;">
                    QRCode library is still loading. Please try again in a moment.
                </div>
            `;
            return;
        }
        
        // Create a div to hold the QR code
        const qrDiv = document.createElement('div');
        qrDiv.style.cssText = `
            text-align: center;
        `;
        
        // Generate QR code using the library
        QRCode.toCanvas(text, {
            width: parseInt(this.qrSize.value),
            margin: 2,
            color: {
                dark: this.qrColor.value,
                light: this.qrBgColor.value
            }
        }, (error, canvas) => {
            if (error) {
                console.error('Error generating QR code:', error);
                qrDiv.innerHTML = `
                    <div style="color: #f44336; text-align: center;">
                        Error generating QR code
                    </div>
                `;
            } else {
                qrDiv.appendChild(canvas);
            }
            this.qrDisplay.appendChild(qrDiv);
        });
    }
    
    /**
     * Download QR Code
     */
    downloadQRCode() {
        const canvas = this.qrDisplay.querySelector('canvas');
        
        if (!canvas) {
            this.showNotification('No QR code to download');
            return;
        }
        
        // Create download link
        const link = document.createElement('a');
        link.download = 'qrcode.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        
        this.showNotification('QR code downloaded');
    }
    
    /**
     * Initialize camera for scanning
     */
    async initializeCamera() {
        try {
            // Stop any existing stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: this.facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                } 
            });
            
            // Set video source
            this.videoElement.srcObject = this.currentStream;
            
            // Wait for video to be ready
            this.videoElement.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvasElement.width = this.videoElement.videoWidth;
                this.canvasElement.height = this.videoElement.videoHeight;
            };
            
        } catch (error) {
            console.error('Error initializing camera:', error);
            this.showScanError('Could not access camera. Please check permissions.');
        }
    }
    
    /**
     * Toggle scanning on/off
     */
    toggleScanning() {
        if (this.isScanning) {
            this.stopScanning();
        } else {
            this.startScanning();
        }
    }
    
    /**
     * Start scanning QR codes
     */
    startScanning() {
        if (this.isScanning) {
            return;
        }
        
        this.isScanning = true;
        this.startScanButton.innerHTML = '⏹️';
        
        // Start scanning loop with throttling
        this.lastScanTime = 0;
        this.scanQRCode();
        
        this.showNotification('Scanning for QR codes...');
    }
    
    /**
     * Stop scanning QR codes
     */
    stopScanning() {
        this.isScanning = false;
        this.startScanButton.innerHTML = '▶️';
        
        // Cancel animation frame
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }
    
    /**
     * Scan QR code from video feed with throttling
     */
    scanQRCode() {
        if (!this.isScanning) {
            return;
        }
        
        // Throttle scanning to improve performance
        const now = Date.now();
        if (now - this.lastScanTime < this.scanInterval) {
            this.animationId = requestAnimationFrame(() => this.scanQRCode());
            return;
        }
        
        this.lastScanTime = now;
        
        // Check if video is ready
        if (this.videoElement.readyState !== this.videoElement.HAVE_ENOUGH_DATA) {
            this.animationId = requestAnimationFrame(() => this.scanQRCode());
            return;
        }
        
        // Draw video frame to canvas
        const canvas = this.canvasElement;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(this.videoElement, 0, 0, canvas.width, canvas.height);
        
        // Get image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // Check if jsQR library is loaded
        if (typeof jsQR === 'undefined') {
            this.animationId = requestAnimationFrame(() => this.scanQRCode());
            return;
        }
        
        // Scan for QR code
        const code = jsQR(imageData.data, imageData.width, imageData.height, {
            inversionAttempts: "dontInvert",
        });
        
        if (code) {
            // QR code found
            this.showScanResult(code.data);
            this.stopScanning();
        } else {
            // Continue scanning
            this.animationId = requestAnimationFrame(() => this.scanQRCode());
        }
    }
    
    /**
     * Show scan result
     */
    showScanResult(data) {
        this.scanResult.style.display = 'block';
        document.getElementById('scan-result-text').textContent = data;
        
        // Provide feedback based on the type of data
        let feedback = '';
        
        if (this.isURL(data)) {
            feedback = 'This QR code contains a URL. You can open it in your browser.';
        } else if (this.isEmail(data)) {
            feedback = 'This QR code contains an email address.';
        } else if (this.isPhoneNumber(data)) {
            feedback = 'This QR code contains a phone number.';
        } else if (this.isWiFi(data)) {
            feedback = 'This QR code contains WiFi credentials.';
        } else {
            feedback = 'This QR code contains text data.';
        }
        
        // Add feedback paragraph
        const feedbackElement = document.createElement('p');
        feedbackElement.textContent = feedback;
        feedbackElement.style.cssText = `
            margin-top: 10px;
            font-style: italic;
            color: rgba(255, 255, 255, 0.7);
        `;
        
        // Remove any existing feedback
        const existingFeedback = this.scanResult.querySelector('p[style*="font-style"]');
        if (existingFeedback) {
            existingFeedback.remove();
        }
        
        this.scanResult.appendChild(feedbackElement);
        
        this.showNotification('QR code scanned successfully!');
    }
    
    /**
     * Show scan error
     */
    showScanError(message) {
        this.scanResult.style.display = 'block';
        document.getElementById('scan-result-text').textContent = message;
        
        // Remove any existing feedback
        const existingFeedback = this.scanResult.querySelector('p[style*="font-style"]');
        if (existingFeedback) {
            existingFeedback.remove();
        }
    }
    
    /**
     * Copy scan result to clipboard
     */
    copyScanResult() {
        const resultText = document.getElementById('scan-result-text').textContent;
        
        if (!resultText) {
            this.showNotification('No result to copy');
            return;
        }
        
        navigator.clipboard.writeText(resultText)
            .then(() => {
                // Show temporary feedback
                const originalText = this.copyResultButton.textContent;
                this.copyResultButton.textContent = 'Copied!';
                setTimeout(() => {
                    this.copyResultButton.textContent = originalText;
                }, 2000);
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                this.showNotification('Failed to copy result');
            });
    }
    
    /**
     * Switch between front and back camera
     */
    async switchCamera() {
        if (!this.isScanning) {
            return;
        }
        
        // Toggle camera
        this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
        
        // Reinitialize camera
        await this.initializeCamera();
        
        this.showNotification('Camera switched');
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        // Remove any existing notifications
        const existingNotification = document.querySelector('.notification');
        if (existingNotification) {
            existingNotification.remove();
        }
        
        // Create notification element
        const notificationElement = document.createElement('div');
        notificationElement.className = 'notification';
        notificationElement.textContent = message;
        
        // Add to container
        this.appContainer.appendChild(notificationElement);
        
        // Remove after animation completes
        setTimeout(() => {
            if (notificationElement.parentNode) {
                notificationElement.parentNode.removeChild(notificationElement);
            }
        }, 2000);
    }
    
    /**
     * Check if string is a URL
     */
    isURL(str) {
        try {
            new URL(str);
            return true;
        } catch {
            return false;
        }
    }
    
    /**
     * Check if string is an email
     */
    isEmail(str) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(str);
    }
    
    /**
     * Check if string is a phone number
     */
    isPhoneNumber(str) {
        // Remove all non-digit characters
        const digits = str.replace(/\D/g, '');
        
        // Check if it's a valid phone number (10+ digits)
        return digits.length >= 10;
    }
    
    /**
     * Check if string is WiFi credentials
     */
    isWiFi(str) {
        // WiFi QR codes typically start with "WIFI:"
        return str.startsWith('WIFI:');
    }
    
    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.appContainer.requestFullscreen) {
                this.appContainer.requestFullscreen();
            } else if (this.appContainer.webkitRequestFullscreen) { /* Safari */
                this.appContainer.webkitRequestFullscreen();
            } else if (this.appContainer.msRequestFullscreen) { /* IE11 */
                this.appContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                this.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                this.msExitFullscreen();
            }
            this.isFullscreen = false;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        // Stop scanning
        this.stopScanning();
        
        // Stop camera stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        this.isActive = false;
        botReply('QR Code Generator & Scanner closed.');
    }
}

// Create a global instance of the app
const qrCodeGeneratorScanner = new QRCodeGeneratorScanner();

// Add this to your AI's command handling
if (/qr code|qr generator|qr scanner/i.test(userInputRaw)) {
    qrCodeGeneratorScanner.loadQRCodeGeneratorScanner();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    qrCodeGeneratorScanner.closeApp();
    return;
}

class ScreenDrawloader {
    constructor() {
        console.log("ScreenDrawloader constructor initialized");
        
        this.drawBoard = {
            name: 'DRAW BOARD',
            instructions: 'Draw on the canvas using your mouse or touch. Save your artwork when done!'
        };
        
        this.gameContainer = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.isDrawing = false;
        this.currentColor = '#000000';
        this.currentSize = 5;
        this.isEraser = false;
        this.fileName = 'my-drawing';
        this.isTextMode = false;
        
        // Firebase properties
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.isFirebaseInitialized = false;
        this.currentRoomId = null;
        this.drawMode = 'normal';
        this.userSessionId = this.generateSessionId();
        this.currentUsername = '';
        this.strokesRef = null;
        this.strokesListener = null;
        this.currentStroke = null;
        this.isLiveMode = false;
        
        // Drawing synchronization
        this.remoteStrokes = [];
        this.canvasSizeRef = null;
        this.lastStrokeUpdate = 0;
        this.strokeUpdateInterval = 100; // ms between stroke updates
        
        // User management
        this.usersRef = null;
        this.usersListener = null;
        this.usersList = [];
        this.roomCreatorId = null;
        
        console.log("ScreenDrawloader constructor completed");
    }
    
    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'drawer_' + Math.random().toString(36).substr(2, 9);
    }
    
    /**
     * Load the Draw Board
     */
    loadDrawBoard() {
        console.log("loadDrawBoard called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("Draw board already active");
                this.showNotification(`The ${this.drawBoard.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create mode selection screen
            this.createModeSelectionScreen();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the board
            this.displayGame();
            
            this.isActive = true;
            console.log("Draw board loaded successfully");
            this.showNotification(`${this.drawBoard.name} loaded! ${this.drawBoard.instructions}`);
        } catch (error) {
            console.error("Error in loadDrawBoard:", error);
            this.showNotification("Sorry, there was an error loading the drawing board. Please try again.");
        }
    }
    
    /**
     * Create Mode Selection Screen
     */
    createModeSelectionScreen() {
        const modeContainer = document.createElement('div');
        modeContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Select Drawing Mode';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        modeContainer.appendChild(title);
        
        // Normal Draw Button
        const normalDrawBtn = document.createElement('button');
        normalDrawBtn.textContent = 'Normal Draw';
        normalDrawBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        normalDrawBtn.addEventListener('click', () => {
            this.drawMode = 'normal';
            this.isLiveMode = false;
            this.gameContainer.innerHTML = '';
            this.createDrawBoard();
        });
        modeContainer.appendChild(normalDrawBtn);
        
        // Live Draw Button
        const liveDrawBtn = document.createElement('button');
        liveDrawBtn.textContent = 'Live Draw';
        liveDrawBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        liveDrawBtn.addEventListener('click', () => {
            this.drawMode = 'live';
            this.isLiveMode = true;
            this.gameContainer.innerHTML = '';
            this.createLiveDrawSetup();
        });
        modeContainer.appendChild(liveDrawBtn);
        
        this.gameContainer.appendChild(modeContainer);
    }
    
    /**
     * Create Live Draw Setup Screen
     */
    createLiveDrawSetup() {
        const setupContainer = document.createElement('div');
        setupContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Live Draw Setup';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        setupContainer.appendChild(title);
        
        // Username input
        const usernameContainer = document.createElement('div');
        usernameContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: left;
        `;
        
        const usernameLabel = document.createElement('label');
        usernameLabel.textContent = 'Your Name:';
        usernameLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        `;
        usernameContainer.appendChild(usernameLabel);
        
        const usernameInput = document.createElement('input');
        usernameInput.type = 'text';
        usernameInput.placeholder = 'Enter your name';
        usernameInput.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        `;
        usernameContainer.appendChild(usernameInput);
        setupContainer.appendChild(usernameContainer);
        
        // Room ID input
        const roomContainer = document.createElement('div');
        roomContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: left;
        `;
        
        const roomLabel = document.createElement('label');
        roomLabel.textContent = 'Room ID (leave empty to create new room):';
        roomLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        `;
        roomContainer.appendChild(roomLabel);
        
        const roomInput = document.createElement('input');
        roomInput.type = 'text';
        roomInput.placeholder = 'Enter room ID or leave empty';
        roomInput.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        `;
        roomContainer.appendChild(roomInput);
        setupContainer.appendChild(roomContainer);
        
        // Start Live Draw Button
        const startBtn = document.createElement('button');
        startBtn.textContent = 'Start Live Draw';
        startBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        startBtn.addEventListener('click', () => {
            const username = usernameInput.value.trim();
            if (!username) {
                this.showNotification('Please enter your name');
                return;
            }
            
            this.currentUsername = username;
            
            const roomId = roomInput.value.trim();
            if (roomId) {
                this.currentRoomId = roomId;
            } else {
                // Generate a new room ID
                this.currentRoomId = 'room_' + Date.now();
                this.roomCreatorId = this.userSessionId;
                this.showNotification(`New room created: ${this.currentRoomId}`);
            }
            
            // Initialize Firebase
            this.initializeFirebase(() => {
                this.gameContainer.innerHTML = '';
                this.createDrawBoard();
                this.setupLiveDrawing();
            });
        });
        setupContainer.appendChild(startBtn);
        
        this.gameContainer.appendChild(setupContainer);
    }
    
    /**
     * Initialize Firebase
     */
    initializeFirebase(callback) {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase(callback);
                });
            });
        } else {
            this.setupFirebase(callback);
        }
    }
    
    /**
     * Setup Firebase
     */
    setupFirebase(callback) {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            this.isFirebaseInitialized = true;
            
            if (callback) {
                callback();
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.showNotification('Error initializing Firebase. Please try again.');
        }
    }
    
    /**
     * Load external script
     */
    loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
    }
    
    /**
     * Setup Live Drawing
     */
    setupLiveDrawing() {
        if (!this.isFirebaseInitialized || !this.currentRoomId) return;
        
        // Create a reference to the strokes in this room
        this.strokesRef = this.db.ref(`drawings/${this.currentRoomId}/strokes`);
        
        // Create a reference for canvas size synchronization
        this.canvasSizeRef = this.db.ref(`drawings/${this.currentRoomId}/canvasSize`);
        
        // Create a reference for users in the room
        this.usersRef = this.db.ref(`drawings/${this.currentRoomId}/users`);
        
        // Add current user to the room
        this.addUserToRoom();
        
        // Synchronize canvas size
        this.syncCanvasSize();
        
        // Listen for new strokes
        this.strokesListener = this.strokesRef.on('child_added', (snapshot) => {
            const stroke = snapshot.val();
            if (stroke.userId !== this.userSessionId) {
                this.addRemoteStroke(stroke);
            }
        });
        
        // Listen for stroke updates
        this.strokesRef.on('child_changed', (snapshot) => {
            const stroke = snapshot.val();
            if (stroke.userId !== this.userSessionId) {
                this.updateRemoteStroke(stroke);
            }
        });
        
        // Listen for clear commands
        this.db.ref(`drawings/${this.currentRoomId}/clearCommand`).on('value', (snapshot) => {
            const clearCommand = snapshot.val();
            if (clearCommand && clearCommand.userId !== this.userSessionId) {
                this.clearCanvas();
            }
        });
        
        // Listen for users in the room
        this.usersListener = this.usersRef.on('value', (snapshot) => {
            this.updateUsersList(snapshot.val());
        });
        
        // Show room info
        this.showRoomInfo();
        
        // Show users list
        this.showUsersList();
    }
    
    /**
     * Add user to the room
     */
    addUserToRoom() {
        if (!this.usersRef) return;
        
        const userData = {
            id: this.userSessionId,
            name: this.currentUsername,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isCreator: this.userSessionId === this.roomCreatorId
        };
        
        this.usersRef.child(this.userSessionId).set(userData);
        
        // If this is the first user, set as creator
        if (!this.roomCreatorId) {
            this.roomCreatorId = this.userSessionId;
            this.usersRef.child(this.userSessionId).update({ isCreator: true });
        }
    }
    
    /**
     * Update users list
     */
    updateUsersList(usersData) {
        if (!usersData) {
            this.usersList = [];
            this.updateUsersListUI();
            return;
        }
        
        this.usersList = Object.values(usersData);
        this.updateUsersListUI();
    }
    
    /**
     * Update users list UI
     */
    updateUsersListUI() {
        if (!this.usersListContainer) return;
        
        this.usersListContainer.innerHTML = '';
        
        if (this.usersList.length === 0) {
            this.usersListContainer.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">No users in room</div>';
            return;
        }
        
        this.usersList.forEach(user => {
            const userItem = document.createElement('div');
            userItem.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                margin-bottom: 5px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                font-size: 14px;
            `;
            
            const userInfo = document.createElement('div');
            userInfo.innerHTML = `
                <div style="font-weight: bold; color: ${user.id === this.userSessionId ? '#4CAF50' : '#333'};">
                    ${user.name} ${user.isCreator ? '(Creator)' : ''}
                </div>
                <div style="font-size: 12px; color: #666;">ID: ${user.id.substring(0, 8)}...</div>
            `;
            userItem.appendChild(userInfo);
            
            // Add delete button if current user is creator or deleting self
            if (this.userSessionId === this.roomCreatorId || user.id === this.userSessionId) {
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = user.id === this.userSessionId ? 'Leave' : 'Remove';
                deleteBtn.style.cssText = `
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    background: ${user.id === this.userSessionId ? '#ff9800' : '#f44336'};
                    color: white;
                    border: none;
                    cursor: pointer;
                `;
                deleteBtn.addEventListener('click', () => {
                    this.removeUserFromRoom(user.id);
                });
                userItem.appendChild(deleteBtn);
            }
            
            this.usersListContainer.appendChild(userItem);
        });
    }
    
    /**
     * Remove user from room
     */
    removeUserFromRoom(userId) {
        if (!this.usersRef) return;
        
        // Remove user from Firebase
        this.usersRef.child(userId).remove();
        
        // If removing self, close the game
        if (userId === this.userSessionId) {
            this.showNotification('You left the room');
            this.closeGame();
            return;
        }
        
        // Remove user's strokes
        if (this.strokesRef) {
            this.strokesRef.once('value', (snapshot) => {
                const strokes = snapshot.val();
                if (strokes) {
                    Object.entries(strokes).forEach(([strokeId, stroke]) => {
                        if (stroke.userId === userId) {
                            this.strokesRef.child(strokeId).remove();
                        }
                    });
                }
            });
        }
        
        this.showNotification('User removed from room');
    }
    
    /**
     * Show users list
     */
    showUsersList() {
        // Create users list container
        this.usersListContainer = document.createElement('div');
        
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
            // Mobile layout - position at bottom with less height
            this.usersListContainer.style.cssText = `
                position: fixed;
                bottom: 80px;
                right: 10px;
                width: calc(100% - 20px);
                max-height: 150px;
                overflow-y: auto;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                padding: 10px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                z-index: 9999;
            `;
        } else {
            // Desktop layout - position at top right
            this.usersListContainer.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                width: 250px;
                max-height: 300px;
                overflow-y: auto;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                z-index: 9999;
            `;
        }
        
        const title = document.createElement('h3');
        title.textContent = 'Users in Room';
        title.style.cssText = `
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
            text-align: center;
        `;
        this.usersListContainer.appendChild(title);
        
        this.gameContainer.appendChild(this.usersListContainer);
        this.updateUsersListUI();
    }
    
    /**
     * Show room info
     */
    showRoomInfo() {
        const roomInfo = document.createElement('div');
        roomInfo.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 10000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            max-width: 80%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        `;
        roomInfo.textContent = `Room: ${this.currentRoomId}`;
        this.gameContainer.appendChild(roomInfo);
    }
    
    /**
     * Synchronize canvas size between users
     */
    syncCanvasSize() {
        // Send current canvas size
        this.canvasSizeRef.set({
            width: this.canvas.width,
            height: this.canvas.height,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        
        // Listen for canvas size changes
        this.canvasSizeRef.on('value', (snapshot) => {
            const canvasSize = snapshot.val();
            if (canvasSize && canvasSize.width && canvasSize.height) {
                // Adjust canvas if size is different
                if (this.canvas.width !== canvasSize.width || this.canvas.height !== canvasSize.height) {
                    this.canvas.width = canvasSize.width;
                    this.canvas.height = canvasSize.height;
                    console.log("Canvas size synchronized:", canvasSize);
                    this.redrawCanvas();
                }
            }
        });
    }
    
    /**
     * Create the Draw Board
     */
    createDrawBoard() {
        // Create canvas
        this.canvas = document.createElement('canvas');
        this.canvas.width = 800;
        this.canvas.height = 600;
        this.canvas.style.cssText = `
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        `;
        
        // Get context
        this.ctx = this.canvas.getContext('2d');
        
        // Create toolbar
        const toolbar = document.createElement('div');
        toolbar.style.cssText = `
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            flex-wrap: wrap;
        `;
        
        // Color picker
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.value = this.currentColor;
        colorPicker.style.cssText = `
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        `;
        colorPicker.addEventListener('change', (e) => {
            this.currentColor = e.target.value;
            this.isEraser = false;
            this.isTextMode = false;
            // Update button states
            eraserBtn.style.background = '#f44336';
            textBtn.style.background = '#9c27b0';
        });
        toolbar.appendChild(colorPicker);
        
        // Brush size
        const sizeLabel = document.createElement('span');
        sizeLabel.textContent = 'Size:';
        sizeLabel.style.cssText = `
            font-weight: bold;
            color: #333;
        `;
        toolbar.appendChild(sizeLabel);
        
        const sizeSlider = document.createElement('input');
        sizeSlider.type = 'range';
        sizeSlider.min = 1;
        sizeSlider.max = 50;
        sizeSlider.value = this.currentSize;
        sizeSlider.style.cssText = `
            width: 100px;
        `;
        sizeSlider.addEventListener('input', (e) => {
            this.currentSize = parseInt(e.target.value);
        });
        toolbar.appendChild(sizeSlider);
        
        // Eraser button
        const eraserBtn = document.createElement('button');
        eraserBtn.textContent = 'Eraser';
        eraserBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #f44336;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        eraserBtn.addEventListener('click', () => {
            this.isEraser = !this.isEraser;
            this.isTextMode = false;
            eraserBtn.style.background = this.isEraser ? '#d32f2f' : '#f44336';
            textBtn.style.background = '#9c27b0'; // Reset text button
        });
        toolbar.appendChild(eraserBtn);
        
        // Text button
        const textBtn = document.createElement('button');
        textBtn.textContent = 'Text';
        textBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #9c27b0;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        textBtn.addEventListener('click', () => {
            this.isTextMode = !this.isTextMode;
            this.isEraser = false;
            textBtn.style.background = this.isTextMode ? '#7b1fa2' : '#9c27b0';
            eraserBtn.style.background = '#f44336'; // Reset eraser button
        });
        toolbar.appendChild(textBtn);
        
        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear Drawing';
        clearBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #ff9800;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        clearBtn.addEventListener('click', () => {
            this.clearCanvas();
        });
        toolbar.appendChild(clearBtn);
        
        // Save button
        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save Drawing';
        saveBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        saveBtn.addEventListener('click', () => {
            this.saveDrawing();
        });
        toolbar.appendChild(saveBtn);
        
        // Add elements to container
        this.gameContainer.appendChild(toolbar);
        this.gameContainer.appendChild(this.canvas);
        
        // Set up drawing events
        this.setupDrawingEvents();
    }
    
    /**
     * Set up drawing events
     */
    setupDrawingEvents() {
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (this.isTextMode) {
                // Handle text mode
                this.handleTextMode(x, y);
                return;
            }
            
            this.isDrawing = true;
            
            if (this.isLiveMode) {
                this.startNewStroke(x, y);
            } else {
                this.startLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('mousemove', (e) => {
            if (!this.isDrawing || this.isTextMode) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (this.isLiveMode) {
                this.updateCurrentStroke(x, y);
            } else {
                this.continueLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('mouseup', () => {
            if (this.isDrawing && !this.isTextMode) {
                this.isDrawing = false;
                
                if (this.isLiveMode) {
                    this.finalizeCurrentStroke();
                } else {
                    this.endLocalDrawing();
                }
            }
        });
        
        this.canvas.addEventListener('mouseleave', () => {
            if (this.isDrawing && !this.isTextMode) {
                this.isDrawing = false;
                
                if (this.isLiveMode) {
                    this.finalizeCurrentStroke();
                } else {
                    this.endLocalDrawing();
                }
            }
        });
        
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = this.canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (this.isTextMode) {
                // Handle text mode
                this.handleTextMode(x, y);
                return;
            }
            
            this.isDrawing = true;
            
            if (this.isLiveMode) {
                this.startNewStroke(x, y);
            } else {
                this.startLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!this.isDrawing || this.isTextMode) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (this.isLiveMode) {
                this.updateCurrentStroke(x, y);
            } else {
                this.continueLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (this.isDrawing && !this.isTextMode) {
                this.isDrawing = false;
                
                if (this.isLiveMode) {
                    this.finalizeCurrentStroke();
                } else {
                    this.endLocalDrawing();
                }
            }
        });
    }
    
    /**
     * Handle text mode
     */
    handleTextMode(x, y) {
        const text = prompt('Enter text:');
        if (text) {
            this.drawText(text, x, y);
            
            // If in live mode, send text to Firebase
            if (this.isLiveMode && this.isFirebaseInitialized) {
                this.sendTextToFirebase(text, x, y);
            }
        }
    }
    
    /**
     * Draw text on canvas
     */
    drawText(text, x, y) {
        this.ctx.font = `${this.currentSize * 3}px Arial`;
        this.ctx.fillStyle = this.currentColor;
        this.ctx.fillText(text, x, y);
    }
    
    /**
     * Send text to Firebase
     */
    sendTextToFirebase(text, x, y) {
        const textId = 'text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
        
        const textData = {
            id: textId,
            userId: this.userSessionId,
            username: this.currentUsername,
            type: 'text',
            content: text,
            x: x,
            y: y,
            color: this.currentColor,
            size: this.currentSize,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.strokesRef.child(textId).set(textData);
    }
    
    /**
     * Start a new stroke and send it to Firebase
     */
    startNewStroke(x, y) {
        if (!this.isLiveMode || !this.isFirebaseInitialized) return;
        
        // Generate a unique ID for this stroke
        const strokeId = 'stroke_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
        
        // Create the stroke object
        this.currentStroke = {
            id: strokeId,
            userId: this.userSessionId,
            username: this.currentUsername,
            color: this.currentColor,
            size: this.currentSize,
            isEraser: this.isEraser,
            points: [{x, y}],
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isComplete: false
        };
        
        // Send to Firebase
        this.strokesRef.child(strokeId).set(this.currentStroke);
        
        // Draw locally
        this.startLocalDrawing(x, y);
    }
    
    /**
     * Update the current stroke with a new point and send to Firebase
     */
    updateCurrentStroke(x, y) {
        if (!this.isLiveMode || !this.isFirebaseInitialized || !this.currentStroke) return;
        
        // Add the new point
        this.currentStroke.points.push({x, y});
        
        // Throttle updates to avoid excessive Firebase writes
        const now = Date.now();
        if (now - this.lastStrokeUpdate > this.strokeUpdateInterval) {
            // Send to Firebase
            this.strokesRef.child(this.currentStroke.id).update({
                points: this.currentStroke.points,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            this.lastStrokeUpdate = now;
        }
        
        // Draw locally
        this.continueLocalDrawing(x, y);
    }
    
    /**
     * Finalize the current stroke and send to Firebase
     */
    finalizeCurrentStroke() {
        if (!this.isLiveMode || !this.isFirebaseInitialized || !this.currentStroke) return;
        
        // Mark as complete
        this.currentStroke.isComplete = true;
        
        // Send to Firebase
        this.strokesRef.child(this.currentStroke.id).update({
            isComplete: true,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        
        // End local drawing
        this.endLocalDrawing();
        
        // Reset current stroke
        this.currentStroke = null;
    }
    
    /**
     * Start local drawing (non-live mode)
     */
    startLocalDrawing(x, y) {
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineJoin = 'round';
        this.ctx.lineCap = 'round';
        
        if (this.isEraser) {
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.lineWidth = this.currentSize * 2;
        } else {
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.strokeStyle = this.currentColor;
            this.ctx.lineWidth = this.currentSize;
        }
    }
    
    /**
     * Continue local drawing (non-live mode)
     */
    continueLocalDrawing(x, y) {
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }
    
    /**
     * End local drawing (non-live mode)
     */
    endLocalDrawing() {
        this.ctx.closePath();
        this.ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
    }
    
    /**
     * Add a remote stroke to the canvas
     */
    addRemoteStroke(stroke) {
        if (!stroke) return;
        
        // Add to remote strokes array
        this.remoteStrokes.push(stroke);
        
        // Handle different types of remote data
        if (stroke.type === 'text') {
            // Draw text
            this.drawText(stroke.content, stroke.x, stroke.y);
        } else {
            // Draw stroke
            this.drawStroke(stroke);
        }
    }
    
    /**
     * Update a remote stroke on the canvas
     */
    updateRemoteStroke(stroke) {
        if (!stroke) return;
        
        // Find and update the stroke in the remote strokes array
        const index = this.remoteStrokes.findIndex(s => s.id === stroke.id);
        if (index !== -1) {
            this.remoteStrokes[index] = stroke;
        } else {
            this.remoteStrokes.push(stroke);
        }
        
        // Redraw the canvas
        this.redrawCanvas();
    }
    
    /**
     * Draw a stroke on the canvas
     */
    drawStroke(stroke) {
        if (!stroke || !stroke.points || stroke.points.length === 0) return;
        
        this.ctx.beginPath();
        this.ctx.lineJoin = 'round';
        this.ctx.lineCap = 'round';
        
        // Set the drawing style
        if (stroke.isEraser) {
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.lineWidth = stroke.size * 2;
        } else {
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.strokeStyle = stroke.color;
            this.ctx.lineWidth = stroke.size;
        }
        
        // Draw the stroke
        this.ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length; i++) {
            this.ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
        }
        
        this.ctx.stroke();
        this.ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
    }
    
    /**
     * Redraw the entire canvas
     */
    redrawCanvas() {
        if (!this.canvas || !this.ctx) return;
        
        // Clear the canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Redraw all remote strokes and text
        this.remoteStrokes.forEach(item => {
            if (item.type === 'text') {
                // Draw text
                this.drawText(item.content, item.x, item.y);
            } else {
                // Draw stroke
                this.drawStroke(item);
            }
        });
    }
    
    /**
     * Clear the canvas and notify other users in live mode
     */
    clearCanvas() {
        // Clear the local canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Clear remote strokes
        this.remoteStrokes = [];
        
        // In live mode, send clear command to Firebase
        if (this.isLiveMode && this.isFirebaseInitialized) {
            this.db.ref(`drawings/${this.currentRoomId}/clearCommand`).set({
                userId: this.userSessionId,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            
            // Remove the clear command after a delay
            setTimeout(() => {
                this.db.ref(`drawings/${this.currentRoomId}/clearCommand`).remove();
            }, 1000);
        }
    }
    
    /**
     * Save the drawing
     */
    saveDrawing() {
        const link = document.createElement('a');
        link.download = `${this.fileName}.png`;
        link.href = this.canvas.toDataURL();
        link.click();
        this.showNotification('Drawing saved!');
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 10px 15px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the game
     */
    closeGame() {
        // Clean up Firebase
        if (this.isLiveMode && this.isFirebaseInitialized) {
            this.cleanupFirebase();
        }
        
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        this.canvas = null;
        this.ctx = null;
        this.remoteStrokes = [];
        this.isTextMode = false;
        
        console.log("Draw board closed");
    }
    
    /**
     * Clean up Firebase listeners
     */
    cleanupFirebase() {
        if (this.strokesListener) {
            this.strokesRef.off('child_added', this.strokesListener);
            this.strokesRef.off('child_changed', this.strokesListener);
            this.strokesListener = null;
        }
        
        if (this.usersListener) {
            this.usersRef.off('value', this.usersListener);
            this.usersListener = null;
        }
        
        if (this.canvasSizeRef) {
            this.canvasSizeRef.off();
            this.canvasSizeRef = null;
        }
        
        // Remove user from room
        if (this.usersRef && this.userSessionId) {
            this.usersRef.child(this.userSessionId).remove();
        }
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
        `;
        notification.textContent = message;
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
        }, 3000);
    }
}

// ===== GLOBAL INSTANCE AND COMMAND HANDLING =====
// Create a global instance
let screendrawloader = null;
// Function to get or create the draw board instance
function getDrawBoard() {
    if (!screendrawloader) {
        console.log("Creating new ScreenDrawloader instance");
        screendrawloader = new ScreenDrawloader();
    }
    return screendrawloader;
}
// Command handler
function handleDrawCommand(input) {
    if (typeof input !== 'string') return false;
    
    const drawKeywords = ['draw', 'draw board', 'drawing', 'sketch', 'paint', 'canvas'];
    const normalizedInput = input.toLowerCase().trim();
    
    return drawKeywords.some(keyword => normalizedInput.includes(keyword));
}
// Execute draw command
function executeDrawCommand() {
    try {
        const drawBoard = getDrawBoard();
        if (drawBoard && typeof drawBoard.loadDrawBoard === 'function') {
            console.log("Executing draw command");
            drawBoard.loadDrawBoard();
        } else {
            console.error("Invalid draw board instance");
            botReply("Sorry, the drawing board is not available right now.");
        }
    } catch (error) {
        console.error("Error executing draw command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}
// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleDrawCommand(userInputRaw)) {
    console.log("Draw command detected");
    executeDrawCommand();
    return;
}
// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen/i.test(userInputRaw)) {
    if (screendrawloader && screendrawloader.isActive) {
        screendrawloader.closeGame();
        return;
    }
}
// ===== DEBUGGING HELPERS =====
// Add this to test the draw board manually (call from browser console)
window.testDrawBoard = function() {
    console.log("Testing draw board...");
    executeDrawCommand();
};
// Add this to check if the draw board is loaded
window.checkDrawBoard = function() {
    console.log("screendrawloader exists:", !!screendrawloader);
    console.log("screendrawloader type:", typeof screendrawloader);
    console.log("ScreenDrawloader class exists:", typeof ScreenDrawloader);
};

class RingSizeCalculator {
    constructor() {
        console.log("RingSizeCalculator constructor initialized");
        
        this.calculator = {
            name: 'RING SIZE CALCULATOR',
            instructions: 'Measure your finger or existing ring to determine your ring size!'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.selectedMethod = 'diameter'; // Default measurement method
        this.currentDiameter = 16; // Starting diameter in mm (typical ring size)
        this.canvas = null;
        this.ctx = null;
        
        // Ring size data
        this.ringSizes = {
            US: [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5, 15, 15.5, 16],
            UK: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],
            EU: [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67]
        };
        
        console.log("RingSizeCalculator constructor completed");
    }
    
    /**
     * Load the Ring Size Calculator
     */
    loadCalculator() {
        console.log("loadCalculator called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("Ring size calculator already active");
                this.showNotification(`The ${this.calculator.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create calculator interface
            this.createCalculatorInterface();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the calculator
            this.displayGame();
            
            this.isActive = true;
            console.log("Ring size calculator loaded successfully");
            this.showNotification(`${this.calculator.name} loaded! ${this.calculator.instructions}`);
        } catch (error) {
            console.error("Error in loadCalculator:", error);
            this.showNotification("Sorry, there was an error loading the ring size calculator. Please try again.");
        }
    }
    
    /**
     * Create Calculator Interface
     */
    createCalculatorInterface() {
        const calculatorContainer = document.createElement('div');
        calculatorContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 600px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Ring Size Calculator';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        calculatorContainer.appendChild(title);
        
        // Method selection
        const methodContainer = document.createElement('div');
        methodContainer.style.cssText = `
            margin-bottom: 25px;
            text-align: center;
        `;
        
        const methodLabel = document.createElement('label');
        methodLabel.textContent = 'Measurement Method:';
        methodLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
            font-size: 18px;
        `;
        methodContainer.appendChild(methodLabel);
        
        const methodButtonsContainer = document.createElement('div');
        methodButtonsContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 15px;
        `;
        
        // Diameter button
        const diameterBtn = document.createElement('button');
        diameterBtn.textContent = 'Diameter';
        diameterBtn.style.cssText = `
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: ${this.selectedMethod === 'diameter' ? '#4CAF50' : '#e0e0e0'};
            color: ${this.selectedMethod === 'diameter' ? 'white' : '#333'};
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        `;
        diameterBtn.addEventListener('click', () => {
            this.selectedMethod = 'diameter';
            this.updateMethodButtons();
            this.updateInputFields();
            this.showVisualRingFinder();
        });
        methodButtonsContainer.appendChild(diameterBtn);
        
        // Circumference button
        const circumferenceBtn = document.createElement('button');
        circumferenceBtn.textContent = 'Circumference';
        circumferenceBtn.style.cssText = `
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: ${this.selectedMethod === 'circumference' ? '#4CAF50' : '#e0e0e0'};
            color: ${this.selectedMethod === 'circumference' ? 'white' : '#333'};
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        `;
        circumferenceBtn.addEventListener('click', () => {
            this.selectedMethod = 'circumference';
            this.updateMethodButtons();
            this.updateInputFields();
            this.hideVisualRingFinder();
        });
        methodButtonsContainer.appendChild(circumferenceBtn);
        
        methodContainer.appendChild(methodButtonsContainer);
        calculatorContainer.appendChild(methodContainer);
        
        // Visual Ring Finder
        this.visualRingFinderContainer = document.createElement('div');
        this.visualRingFinderContainer.style.cssText = `
            margin-bottom: 25px;
            display: ${this.selectedMethod === 'diameter' ? 'block' : 'none'};
        `;
        this.createVisualRingFinder();
        calculatorContainer.appendChild(this.visualRingFinderContainer);
        
        // Input fields container
        this.inputContainer = document.createElement('div');
        this.inputContainer.style.cssText = `
            margin-bottom: 25px;
        `;
        
        // Create input fields based on selected method
        this.updateInputFields();
        calculatorContainer.appendChild(this.inputContainer);
        
        // Calculate button
        const calculateBtn = document.createElement('button');
        calculateBtn.textContent = 'Calculate Ring Size';
        calculateBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        `;
        calculateBtn.addEventListener('click', () => {
            this.calculateRingSize();
        });
        calculatorContainer.appendChild(calculateBtn);
        
        // Results container
        this.resultsContainer = document.createElement('div');
        this.resultsContainer.style.cssText = `
            margin-top: 20px;
            padding: 20px;
            background: rgba(33, 150, 243, 0.1);
            border-radius: 15px;
            display: none;
        `;
        calculatorContainer.appendChild(this.resultsContainer);
        
        // Ring size guide
        const guideContainer = document.createElement('div');
        guideContainer.style.cssText = `
            margin-top: 30px;
            text-align: left;
        `;
        
        const guideTitle = document.createElement('h3');
        guideTitle.textContent = 'How to Measure:';
        guideTitle.style.cssText = `
            margin: 0 0 15px 0;
            font-size: 20px;
            color: #333;
            text-align: center;
        `;
        guideContainer.appendChild(guideTitle);
        
        const guideList = document.createElement('ul');
        guideList.style.cssText = `
            padding-left: 20px;
            margin: 0;
        `;
        
        const guideItems = [
            'Use a string or paper strip to wrap around your finger',
            'Mark where the end meets',
            'Measure the length with a ruler (this is the circumference)',
            'Alternatively, measure the inside diameter of an existing ring',
            'Enter the measurement in millimeters (mm)',
            'Or use the visual ring size finder below to adjust to your ring size'
        ];
        
        guideItems.forEach(item => {
            const li = document.createElement('li');
            li.textContent = item;
            li.style.cssText = `
                margin-bottom: 8px;
                font-size: 16px;
                color: #555;
            `;
            guideList.appendChild(li);
        });
        
        guideContainer.appendChild(guideList);
        calculatorContainer.appendChild(guideContainer);
        
        this.gameContainer.appendChild(calculatorContainer);
    }
    
    /**
     * Create Visual Ring Finder
     */
    createVisualRingFinder() {
        const visualFinderTitle = document.createElement('h3');
        visualFinderTitle.textContent = 'Visual Ring Size Finder';
        visualFinderTitle.style.cssText = `
            margin: 0 0 15px 0;
            font-size: 20px;
            color: #333;
        `;
        this.visualRingFinderContainer.appendChild(visualFinderTitle);
        
        // Canvas for drawing the ring
        this.canvas = document.createElement('canvas');
        this.canvas.width = 300;
        this.canvas.height = 300;
        this.canvas.style.cssText = `
            border: 1px solid #ddd;
            border-radius: 10px;
            background: white;
            margin: 0 auto 15px;
            display: block;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        `;
        this.visualRingFinderContainer.appendChild(this.canvas);
        
        // Get canvas context
        this.ctx = this.canvas.getContext('2d');
        
        // Slider container
        const sliderContainer = document.createElement('div');
        sliderContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        // Size display
        this.sizeDisplay = document.createElement('div');
        this.sizeDisplay.textContent = `${this.currentDiameter} mm`;
        this.sizeDisplay.style.cssText = `
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        `;
        sliderContainer.appendChild(this.sizeDisplay);
        
        // Slider
        this.sizeSlider = document.createElement('input');
        this.sizeSlider.type = 'range';
        this.sizeSlider.min = '10';
        this.sizeSlider.max = '30';
        this.sizeSlider.step = '0.5';
        this.sizeSlider.value = this.currentDiameter;
        this.sizeSlider.style.cssText = `
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        `;
        
        // Style the slider thumb
        const style = document.createElement('style');
        style.textContent = `
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #2196F3;
                cursor: pointer;
            }
            
            input[type="range"]::-moz-range-thumb {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #2196F3;
                cursor: pointer;
            }
        `;
        document.head.appendChild(style);
        
        this.sizeSlider.addEventListener('input', (e) => {
            this.currentDiameter = parseFloat(e.target.value);
            this.drawRing();
        });
        
        sliderContainer.appendChild(this.sizeSlider);
        this.visualRingFinderContainer.appendChild(sliderContainer);
        
        // Use this size button
        const useSizeBtn = document.createElement('button');
        useSizeBtn.textContent = 'Use This Size';
        useSizeBtn.style.cssText = `
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: #2196F3;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        `;
        useSizeBtn.addEventListener('click', () => {
            this.useVisualSize();
        });
        this.visualRingFinderContainer.appendChild(useSizeBtn);
        
        // Initial draw
        this.drawRing();
    }
    
    /**
     * Draw the ring on canvas
     */
    drawRing() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const radius = this.currentDiameter * 5; // Scale factor for visibility
        
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw outer circle (ring)
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        this.ctx.strokeStyle = '#2196F3';
        this.ctx.lineWidth = 3;
        this.ctx.stroke();
        
        // Draw diameter line (only one line in the center)
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - radius, centerY);
        this.ctx.lineTo(centerX + radius, centerY);
        this.ctx.strokeStyle = '#f44336';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        
        // Draw diameter label
        this.ctx.fillStyle = '#f44336';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(`${this.currentDiameter} mm`, centerX, centerY + radius + 20);
        
        // Update size display
        this.sizeDisplay.textContent = `${this.currentDiameter} mm`;
    }
    
    /**
     * Use the visual size for calculation
     */
    useVisualSize() {
        // Update the input field with the current diameter
        const inputElement = document.getElementById('measurement-input');
        if (inputElement) {
            inputElement.value = this.currentDiameter;
            this.showNotification(`Size set to ${this.currentDiameter} mm. Click 'Calculate Ring Size' to see results.`);
        }
    }
    
    /**
     * Show visual ring finder
     */
    showVisualRingFinder() {
        this.visualRingFinderContainer.style.display = 'block';
    }
    
    /**
     * Hide visual ring finder
     */
    hideVisualRingFinder() {
        this.visualRingFinderContainer.style.display = 'none';
    }
    
    /**
     * Update method buttons appearance
     */
    updateMethodButtons() {
        const buttons = this.gameContainer.querySelectorAll('button');
        buttons.forEach(btn => {
            if (btn.textContent === 'Diameter') {
                btn.style.background = this.selectedMethod === 'diameter' ? '#4CAF50' : '#e0e0e0';
                btn.style.color = this.selectedMethod === 'diameter' ? 'white' : '#333';
            } else if (btn.textContent === 'Circumference') {
                btn.style.background = this.selectedMethod === 'circumference' ? '#4CAF50' : '#e0e0e0';
                btn.style.color = this.selectedMethod === 'circumference' ? 'white' : '#333';
            }
        });
    }
    
    /**
     * Update input fields based on selected method
     */
    updateInputFields() {
        this.inputContainer.innerHTML = '';
        
        const inputLabel = document.createElement('label');
        inputLabel.textContent = `Enter ${this.selectedMethod === 'diameter' ? 'Diameter' : 'Circumference'} (mm):`;
        inputLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
            font-size: 18px;
        `;
        this.inputContainer.appendChild(inputLabel);
        
        const inputField = document.createElement('input');
        inputField.type = 'number';
        inputField.placeholder = `Enter ${this.selectedMethod === 'diameter' ? 'diameter' : 'circumference'} in mm`;
        inputField.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
            text-align: center;
        `;
        inputField.id = 'measurement-input';
        this.inputContainer.appendChild(inputField);
        
        // Add visual guide image placeholder
        const guideImage = document.createElement('div');
        guideImage.style.cssText = `
            margin-top: 15px;
            height: 120px;
            background: #f5f5f5;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #777;
            font-style: italic;
        `;
        guideImage.textContent = 'Measurement Guide Image';
        this.inputContainer.appendChild(guideImage);
    }
    
    /**
     * Calculate ring size based on input
     */
    calculateRingSize() {
        const inputElement = document.getElementById('measurement-input');
        const measurement = parseFloat(inputElement.value);
        
        if (isNaN(measurement) || measurement <= 0) {
            this.showNotification('Please enter a valid measurement in millimeters');
            return;
        }
        
        let diameter;
        if (this.selectedMethod === 'diameter') {
            diameter = measurement;
        } else {
            // Convert circumference to diameter
            diameter = measurement / Math.PI;
        }
        
        // Calculate US ring size
        const usSize = (diameter - 10.5) / 0.8128;
        
        // Find closest sizes
        const closestUS = this.findClosestSize(usSize, this.ringSizes.US);
        const closestUK = this.findClosestUKSize(usSize);
        const closestEU = this.findClosestSize(usSize * 2.54, this.ringSizes.EU);
        
        // Display results
        this.displayResults(closestUS, closestUK, closestEU, diameter);
    }
    
    /**
     * Find closest size in a numeric array
     */
    findClosestSize(value, sizeArray) {
        let closest = sizeArray[0];
        let minDiff = Math.abs(value - closest);
        
        for (let i = 1; i < sizeArray.length; i++) {
            const diff = Math.abs(value - sizeArray[i]);
            if (diff < minDiff) {
                minDiff = diff;
                closest = sizeArray[i];
            }
        }
        
        return closest;
    }
    
    /**
     * Find closest UK size
     */
    findClosestUKSize(usSize) {
        // Convert US size to UK size
        const ukSizeValue = (usSize - 1) * 0.5;
        
        // Find closest letter
        const index = Math.round(ukSizeValue);
        if (index >= 0 && index < this.ringSizes.UK.length) {
            return this.ringSizes.UK[index];
        }
        
        return this.ringSizes.UK[0];
    }
    
    /**
     * Display calculation results
     */
    displayResults(usSize, ukSize, euSize, diameter) {
        this.resultsContainer.innerHTML = '';
        this.resultsContainer.style.display = 'block';
        
        const resultsTitle = document.createElement('h3');
        resultsTitle.textContent = 'Your Ring Size:';
        resultsTitle.style.cssText = `
            margin: 0 0 15px 0;
            font-size: 22px;
            color: #333;
            text-align: center;
        `;
        this.resultsContainer.appendChild(resultsTitle);
        
        const resultsGrid = document.createElement('div');
        resultsGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        `;
        
        // US size
        const usContainer = this.createSizeResult('US', usSize);
        resultsGrid.appendChild(usContainer);
        
        // UK size
        const ukContainer = this.createSizeResult('UK', ukSize);
        resultsGrid.appendChild(ukContainer);
        
        // EU size
        const euContainer = this.createSizeResult('EU', euSize);
        resultsGrid.appendChild(euContainer);
        
        this.resultsContainer.appendChild(resultsGrid);
        
        // Diameter info
        const diameterInfo = document.createElement('div');
        diameterInfo.style.cssText = `
            margin-top: 15px;
            font-size: 16px;
            color: #555;
            text-align: center;
        `;
        diameterInfo.textContent = `Measured diameter: ${diameter.toFixed(2)} mm`;
        this.resultsContainer.appendChild(diameterInfo);
        
        // Note about sizing
        const note = document.createElement('div');
        note.style.cssText = `
            margin-top: 15px;
            font-size: 14px;
            color: #777;
            font-style: italic;
            text-align: center;
        `;
        note.textContent = 'Note: Ring sizes may vary slightly between brands and countries. For best results, visit a jeweler for professional sizing.';
        this.resultsContainer.appendChild(note);
    }
    
    /**
     * Create a size result element
     */
    createSizeResult(region, size) {
        const container = document.createElement('div');
        container.style.cssText = `
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
        `;
        
        const regionLabel = document.createElement('div');
        regionLabel.textContent = region;
        regionLabel.style.cssText = `
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
        `;
        container.appendChild(regionLabel);
        
        const sizeValue = document.createElement('div');
        sizeValue.textContent = size;
        sizeValue.style.cssText = `
            font-size: 24px;
            font-weight: bold;
            color: #2196F3;
        `;
        container.appendChild(sizeValue);
        
        return container;
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 10px 15px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeCalculator();
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the calculator
     */
    closeCalculator() {
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        
        console.log("Ring size calculator closed");
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 10002;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
        `;
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        // Auto-remove notification after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
}

// Command handler
function handleRingSizeCommand(input) {
    if (typeof input !== 'string') return false;
    
    const ringSizeKeywords = [
        'ring size', 'ring size calculator', 'ring calculator', 
        'measure ring', 'ring measurement', 'find ring size',
        'ring sizer', 'finger size', 'ring sizing'
    ];
    const normalizedInput = input.toLowerCase().trim();
    
    return ringSizeKeywords.some(keyword => normalizedInput.includes(keyword));
}

// Execute ring size command
function executeRingSizeCommand() {
    try {
        // Create a global instance if it doesn't exist
        if (!window.ringSizeCalculator) {
            window.ringSizeCalculator = new RingSizeCalculator();
        }
        
        const ringSizeCalc = window.ringSizeCalculator;
        if (ringSizeCalc && typeof ringSizeCalc.loadCalculator === 'function') {
            console.log("Executing ring size calculator command");
            ringSizeCalc.loadCalculator();
        } else {
            console.error("Invalid ring size calculator instance");
            botReply("Sorry, the ring size calculator is not available right now.");
        }
    } catch (error) {
        console.error("Error executing ring size calculator command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}

// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleRingSizeCommand(userInputRaw)) {
    console.log("Ring size calculator command detected");
    executeRingSizeCommand();
    return;
}

// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen/i.test(userInputRaw)) {
    if (window.ringSizeCalculator && window.ringSizeCalculator.isActive) {
        window.ringSizeCalculator.closeCalculator();
        return;
    }
}

// ===== DEBUGGING HELPERS =====
// Add this to test the ring size calculator manually (call from browser console)
window.testRingSizeCalculator = function() {
    console.log("Testing ring size calculator...");
    executeRingSizeCommand();
};

// Add this to check if the ring size calculator is loaded
window.checkRingSizeCalculator = function() {
    console.log("ringSizeCalculator exists:", !!window.ringSizeCalculator);
    console.log("ringSizeCalculator type:", typeof window.ringSizeCalculator);
    console.log("RingSizeCalculator class exists:", typeof RingSizeCalculator);
};





class LoadHtmlScreenLoader {
    constructor() {
        console.log("LoadHtmlScreenLoader constructor initialized");
        
        this.htmlBoard = {
            name: 'HTML SCREEN',
            instructions: 'Admin: Load HTML code to display. Users: View the loaded HTML content.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.isAdmin = false; // Default to user mode
        this.htmlContent = '';
        this.currentHtmlId = null;
        
        // Firebase properties
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.isFirebaseInitialized = false;
        this.htmlRef = null;
        this.htmlListener = null;
        
        console.log("LoadHtmlScreenLoader constructor completed");
    }
    
    /**
     * Load the HTML Screen
     */
    loadHtmlScreen() {
        console.log("loadHtmlScreen called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("HTML screen already active");
                this.showNotification(`The ${this.htmlBoard.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create mode selection screen
            this.createModeSelectionScreen();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the board
            this.displayGame();
            
            this.isActive = true;
            console.log("HTML screen loaded successfully");
            this.showNotification(`${this.htmlBoard.name} loaded! ${this.htmlBoard.instructions}`);
        } catch (error) {
            console.error("Error in loadHtmlScreen:", error);
            this.showNotification("Sorry, there was an error loading the HTML screen. Please try again.");
        }
    }
    
    /**
     * Create Mode Selection Screen
     */
    createModeSelectionScreen() {
        const modeContainer = document.createElement('div');
        modeContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Select HTML Mode';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        modeContainer.appendChild(title);
        
        // Admin Mode Button
        const adminBtn = document.createElement('button');
        adminBtn.textContent = 'Admin Mode';
        adminBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        adminBtn.addEventListener('click', () => {
            this.isAdmin = true;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createAdminInterface();
            });
        });
        modeContainer.appendChild(adminBtn);
        
        // User Mode Button
        const userBtn = document.createElement('button');
        userBtn.textContent = 'User Mode';
        userBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        userBtn.addEventListener('click', () => {
            this.isAdmin = false;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createUserInterface();
            });
        });
        modeContainer.appendChild(userBtn);
        
        this.gameContainer.appendChild(modeContainer);
    }
    
    /**
     * Create Admin Interface
     */
    createAdminInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'HTML Admin Panel';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create textarea for HTML input
        const textareaContainer = document.createElement('div');
        textareaContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            margin-bottom: 20px;
        `;
        
        const textareaLabel = document.createElement('label');
        textareaLabel.textContent = 'Enter HTML Code:';
        textareaLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
            color: white;
            font-weight: bold;
        `;
        textareaContainer.appendChild(textareaLabel);
        
        const textarea = document.createElement('textarea');
        textarea.id = 'htmlTextarea';
        textarea.placeholder = 'Enter your HTML code here...';
        textarea.style.cssText = `
            width: 100%;
            height: 300px;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        `;
        textareaContainer.appendChild(textarea);
        this.gameContainer.appendChild(textareaContainer);
        
        // Create buttons container
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        `;
        
        // Load HTML button
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load HTML';
        loadBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        loadBtn.addEventListener('click', () => {
            const textarea = document.getElementById('htmlTextarea');
            this.htmlContent = textarea.value;
            this.saveHtmlToFirebase();
            this.showNotification('HTML code saved successfully!');
        });
        buttonsContainer.appendChild(loadBtn);
        
        // Preview button
        const previewBtn = document.createElement('button');
        previewBtn.textContent = 'Preview';
        previewBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        previewBtn.addEventListener('click', () => {
            const textarea = document.getElementById('htmlTextarea');
            this.htmlContent = textarea.value;
            this.showHtmlPreview();
        });
        buttonsContainer.appendChild(previewBtn);
        
        // Share Code button
        const shareBtn = document.createElement('button');
        shareBtn.textContent = 'Share Code';
        shareBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #9c27b0, #7b1fa2);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        shareBtn.addEventListener('click', () => {
            this.shareHtmlCode();
        });
        buttonsContainer.appendChild(shareBtn);
        
        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        deleteBtn.addEventListener('click', () => {
            this.deleteHtmlContent();
        });
        buttonsContainer.appendChild(deleteBtn);
        
        // Back to Mode Selection button
        const backBtn = document.createElement('button');
        backBtn.textContent = 'Back to Mode Selection';
        backBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #607D8B, #455A64);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        backBtn.addEventListener('click', () => {
            this.backToModeSelection();
        });
        buttonsContainer.appendChild(backBtn);
        
        this.gameContainer.appendChild(buttonsContainer);
        
        // Create preview container
        const previewContainer = document.createElement('div');
        previewContainer.id = 'htmlPreview';
        previewContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            height: 400px;
            border: 2px dashed #ccc;
            border-radius: 10px;
            overflow: auto;
            background: white;
            margin-bottom: 20px;
            display: none;
        `;
        this.gameContainer.appendChild(previewContainer);
        
        // Load existing HTML content if available
        this.loadHtmlFromFirebase((html) => {
            if (html) {
                const textarea = document.getElementById('htmlTextarea');
                textarea.value = html;
            }
        });
    }
    
    /**
     * Create User Interface
     */
    createUserInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'HTML Viewer';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create status message
        const statusMessage = document.createElement('div');
        statusMessage.id = 'statusMessage';
        statusMessage.textContent = 'Loading HTML content...';
        statusMessage.style.cssText = `
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
        `;
        this.gameContainer.appendChild(statusMessage);
        
        // Create HTML container
        const htmlContainer = document.createElement('div');
        htmlContainer.id = 'htmlContainer';
        htmlContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            min-height: 500px;
            border: none;
            border-radius: 10px;
            overflow: auto;
            background: white;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        this.gameContainer.appendChild(htmlContainer);
        
        // Load HTML from Firebase
        this.loadHtmlFromFirebase((html) => {
            if (html) {
                statusMessage.textContent = 'HTML Content Loaded';
                this.displayHtmlContent(html);
            } else {
                statusMessage.textContent = 'No HTML content available. Please ask admin to load HTML.';
                this.clearHtmlContent();
            }
        });
        
        // Set up listener for HTML updates
        this.setupHtmlListener();
    }
    
    /**
     * Go back to mode selection screen
     */
    backToModeSelection() {
        // Clean up Firebase listeners
        if (this.htmlListener) {
            this.htmlRef.off('value', this.htmlListener);
            this.htmlListener = null;
        }
        
        // Clear the container
        this.gameContainer.innerHTML = '';
        
        // Reset mode
        this.isAdmin = false;
        
        // Create mode selection screen
        this.createModeSelectionScreen();
    }
    
    /**
     * Show HTML Preview (for admin)
     */
    showHtmlPreview() {
        const previewContainer = document.getElementById('htmlPreview');
        if (previewContainer) {
            previewContainer.style.display = 'block';
            previewContainer.innerHTML = this.htmlContent;
        }
    }
    
    /**
     * Display HTML Content (for user)
     */
    displayHtmlContent(html) {
        const htmlContainer = document.getElementById('htmlContainer');
        if (htmlContainer) {
            htmlContainer.innerHTML = html;
        }
    }
    
    /**
     * Clear HTML Content (for user)
     */
    clearHtmlContent() {
        const htmlContainer = document.getElementById('htmlContainer');
        const statusMessage = document.getElementById('statusMessage');
        
        if (htmlContainer) {
            htmlContainer.innerHTML = '';
            htmlContainer.style.minHeight = '500px';
            htmlContainer.style.display = 'flex';
            htmlContainer.style.justifyContent = 'center';
            htmlContainer.style.alignItems = 'center';
            htmlContainer.innerHTML = '<div style="color: #999; font-size: 18px; text-align: center;">No HTML content available</div>';
        }
        
        if (statusMessage) {
            statusMessage.textContent = 'No HTML content available. Please ask admin to load HTML.';
        }
    }
    
    /**
     * Share HTML Code (copy to clipboard)
     */
    shareHtmlCode() {
        const textarea = document.getElementById('htmlTextarea');
        const htmlCode = textarea.value;
        
        if (!htmlCode.trim()) {
            this.showNotification('No HTML code to share!');
            return;
        }
        
        // Copy to clipboard
        navigator.clipboard.writeText(htmlCode).then(() => {
            this.showNotification('HTML code copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy: ', err);
            this.showNotification('Failed to copy HTML code.');
        });
    }
    
    /**
     * Delete HTML Content
     */
    deleteHtmlContent() {
        // Confirm deletion
        const confirmDelete = confirm('Are you sure you want to delete the HTML content? This will clear it for all users.');
        if (!confirmDelete) return;
        
        // Clear textarea
        const textarea = document.getElementById('htmlTextarea');
        textarea.value = '';
        
        // Clear preview
        const previewContainer = document.getElementById('htmlPreview');
        if (previewContainer) {
            previewContainer.style.display = 'none';
            previewContainer.innerHTML = '';
        }
        
        // Clear Firebase
        this.htmlContent = '';
        this.saveHtmlToFirebase();
        this.showNotification('HTML content deleted successfully!');
    }
    
    /**
     * Initialize Firebase
     */
    initializeFirebase(callback) {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase(callback);
                });
            });
        } else {
            this.setupFirebase(callback);
        }
    }
    
    /**
     * Setup Firebase
     */
    setupFirebase(callback) {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            this.isFirebaseInitialized = true;
            this.htmlRef = this.db.ref('htmlContent/currentHtml');
            
            if (callback) {
                callback();
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.showNotification('Error initializing Firebase. Please try again.');
        }
    }
    
    /**
     * Load external script
     */
    loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
    }
    
    /**
     * Save HTML to Firebase
     */
    saveHtmlToFirebase() {
        if (!this.isFirebaseInitialized) return;
        
        const htmlData = {
            content: this.htmlContent,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            updatedBy: this.isAdmin ? 'admin' : 'user'
        };
        
        this.htmlRef.set(htmlData);
    }
    
    /**
     * Load HTML from Firebase
     */
    loadHtmlFromFirebase(callback) {
        if (!this.isFirebaseInitialized) return;
        
        this.htmlRef.once('value', (snapshot) => {
            const data = snapshot.val();
            if (data && data.content) {
                callback(data.content);
            } else {
                callback(null);
            }
        });
    }
    
    /**
     * Setup HTML listener for real-time updates
     */
    setupHtmlListener() {
        if (!this.isFirebaseInitialized || !this.htmlRef) return;
        
        this.htmlListener = this.htmlRef.on('value', (snapshot) => {
            const data = snapshot.val();
            const statusMessage = document.getElementById('statusMessage');
            
            if (data && data.content && !this.isAdmin) {
                statusMessage.textContent = 'HTML Content Loaded';
                this.displayHtmlContent(data.content);
            } else if (!data || !data.content) {
                // HTML content was deleted
                statusMessage.textContent = 'No HTML content available. Please ask admin to load HTML.';
                this.clearHtmlContent();
            }
        });
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Close button (main button)
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 12px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
            transition: all 0.3s ease;
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.closeButton.addEventListener('mouseenter', () => {
            this.closeButton.style.background = '#d32f2f';
            this.closeButton.style.transform = 'scale(1.05)';
        });
        this.closeButton.addEventListener('mouseleave', () => {
            this.closeButton.style.background = '#f44336';
            this.closeButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the game
     */
    closeGame() {
        // Clean up Firebase listeners
        if (this.htmlListener) {
            this.htmlRef.off('value', this.htmlListener);
            this.htmlListener = null;
        }
        
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        this.isAdmin = false;
        this.htmlContent = '';
        
        console.log("HTML screen closed");
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
        `;
        notification.textContent = message;
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
        }, 3000);
    }
}

// ===== GLOBAL INSTANCE AND COMMAND HANDLING =====
// Create a global instance
let loadhtmlscreenloader = null;
// Function to get or create the HTML screen instance
function getHtmlScreen() {
    if (!loadhtmlscreenloader) {
        console.log("Creating new LoadHtmlScreenLoader instance");
        loadhtmlscreenloader = new LoadHtmlScreenLoader();
    }
    return loadhtmlscreenloader;
}
// Command handler
function handleHtmlCommand(input) {
    if (typeof input !== 'string') return false;
    
    const htmlKeywords = ['html', 'html screen', 'html viewer', 'html loader', 'html admin'];
    const normalizedInput = input.toLowerCase().trim();
    
    return htmlKeywords.some(keyword => normalizedInput.includes(keyword));
}
// Execute HTML command
function executeHtmlCommand() {
    try {
        const htmlScreen = getHtmlScreen();
        if (htmlScreen && typeof htmlScreen.loadHtmlScreen === 'function') {
            console.log("Executing HTML command");
            htmlScreen.loadHtmlScreen();
        } else {
            console.error("Invalid HTML screen instance");
            botReply("Sorry, the HTML screen is not available right now.");
        }
    } catch (error) {
        console.error("Error executing HTML command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}
// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleHtmlCommand(userInputRaw)) {
    console.log("HTML command detected");
    executeHtmlCommand();
    return;
}
// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen|cancel/i.test(userInputRaw)) {
    if (loadhtmlscreenloader && loadhtmlscreenloader.isActive) {
        loadhtmlscreenloader.closeGame();
        return;
    }
}
// ===== DEBUGGING HELPERS =====
// Add this to test the HTML screen manually (call from browser console)
window.testHtmlScreen = function() {
    console.log("Testing HTML screen...");
    executeHtmlCommand();
};
// Add this to check if the HTML screen is loaded
window.checkHtmlScreen = function() {
    console.log("loadhtmlscreenloader exists:", !!loadhtmlscreenloader);
    console.log("loadhtmlscreenloader type:", typeof loadhtmlscreenloader);
    console.log("LoadHtmlScreenLoader class exists:", typeof LoadHtmlScreenLoader);
};


class AVUScreenLoader {
    constructor() {
        console.log("AVUScreenLoader constructor initialized");
        
        this.avuBoard = {
            name: 'ADMIN VIEW USER',
            instructions: 'Admin: View user messages and send replies. Users: Chat with admin.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cancelButton = null;
        this.isAdmin = false;
        this.currentUserId = null;
        this.usersList = [];
        this.messages = [];
        
        // Firebase properties
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.isFirebaseInitialized = false;
        this.usersRef = null;
        this.messagesRef = null;
        this.usersListener = null;
        this.messagesListener = null;
        
        console.log("AVUScreenLoader constructor completed");
    }
    
    /**
     * Load the AVU Screen
     */
    loadAvuScreen() {
        console.log("loadAvuScreen called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("AVU screen already active");
                this.showNotification(`The ${this.avuBoard.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create mode selection screen
            this.createModeSelectionScreen();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the board
            this.displayGame();
            
            this.isActive = true;
            console.log("AVU screen loaded successfully");
            this.showNotification(`${this.avuBoard.name} loaded! ${this.avuBoard.instructions}`);
        } catch (error) {
            console.error("Error in loadAvuScreen:", error);
            this.showNotification("Sorry, there was an error loading the AVU screen. Please try again.");
        }
    }
    
    /**
     * Create Mode Selection Screen
     */
    createModeSelectionScreen() {
        const modeContainer = document.createElement('div');
        modeContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Select Mode';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        modeContainer.appendChild(title);
        
        // Admin Mode Button
        const adminBtn = document.createElement('button');
        adminBtn.textContent = 'Admin Mode';
        adminBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        adminBtn.addEventListener('click', () => {
            this.isAdmin = true;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createAdminInterface();
            });
        });
        modeContainer.appendChild(adminBtn);
        
        // User Mode Button
        const userBtn = document.createElement('button');
        userBtn.textContent = 'User Mode';
        userBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        userBtn.addEventListener('click', () => {
            this.isAdmin = false;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createUserInterface();
            });
        });
        modeContainer.appendChild(userBtn);
        
        this.gameContainer.appendChild(modeContainer);
    }
    
    /**
     * Create Admin Interface
     */
    createAdminInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'Admin View User Messages';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create cancel button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            display: block;
            margin: 0 auto 20px auto;
            padding: 10px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        cancelButton.addEventListener('click', () => {
            this.backToModeSelection();
        });
        cancelButton.addEventListener('mouseenter', () => {
            cancelButton.style.background = '#d32f2f';
            cancelButton.style.transform = 'scale(1.05)';
        });
        cancelButton.addEventListener('mouseleave', () => {
            cancelButton.style.background = '#f44336';
            cancelButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(cancelButton);
        
        // Create main container
        const mainContainer = document.createElement('div');
        mainContainer.style.cssText = `
            display: flex;
            width: 90%;
            max-width: 1200px;
            height: 600px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        `;
        
        // Create users list container
        const usersListContainer = document.createElement('div');
        usersListContainer.style.cssText = `
            width: 30%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-right: 1px solid rgba(255, 255, 255, 0.3);
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
        `;
        
        const usersListTitle = document.createElement('h3');
        usersListTitle.textContent = 'Users';
        usersListTitle.style.cssText = `
            margin: 0 0 15px 0;
            color: white;
            font-size: 18px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        `;
        usersListContainer.appendChild(usersListTitle);
        
        const usersListContent = document.createElement('div');
        usersListContent.id = 'usersListContent';
        usersListContent.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        usersListContainer.appendChild(usersListContent);
        
        // Create messages container
        const messagesContainer = document.createElement('div');
        messagesContainer.style.cssText = `
            width: 70%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-sizing: border-box;
        `;
        
        const messagesHeader = document.createElement('div');
        messagesHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        `;
        
        const messagesTitle = document.createElement('h3');
        messagesTitle.textContent = 'Messages';
        messagesTitle.style.cssText = `
            margin: 0;
            color: white;
            font-size: 18px;
        `;
        messagesHeader.appendChild(messagesTitle);
        
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear All';
        clearBtn.style.cssText = `
            padding: 6px 12px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
        `;
        clearBtn.addEventListener('click', () => {
            this.clearAllMessages();
        });
        clearBtn.addEventListener('mouseenter', () => {
            clearBtn.style.background = '#d32f2f';
        });
        clearBtn.addEventListener('mouseleave', () => {
            clearBtn.style.background = '#f44336';
        });
        messagesHeader.appendChild(clearBtn);
        
        messagesContainer.appendChild(messagesHeader);
        
        const messagesContent = document.createElement('div');
        messagesContent.id = 'messagesContent';
        messagesContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
        `;
        messagesContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">Select a user to view messages</div>';
        messagesContainer.appendChild(messagesContent);
        
        // Admin input area
        const adminInputArea = document.createElement('div');
        adminInputArea.id = 'adminInputArea';
        adminInputArea.style.cssText = `
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        `;
        
        const adminInputHeader = document.createElement('div');
        adminInputHeader.style.cssText = `
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        `;
        adminInputHeader.textContent = 'Send message to user:';
        adminInputArea.appendChild(adminInputHeader);
        
        const adminInputContainer = document.createElement('div');
        adminInputContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const adminInput = document.createElement('input');
        adminInput.id = 'adminInput';
        adminInput.type = 'text';
        adminInput.placeholder = 'Type your message...';
        adminInput.style.cssText = `
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            outline: none;
            box-sizing: border-box;
        `;
        adminInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendAdminMessage();
            }
        });
        adminInputContainer.appendChild(adminInput);
        
        const adminSendBtn = document.createElement('button');
        adminSendBtn.textContent = 'Send';
        adminSendBtn.style.cssText = `
            padding: 10px 15px;
            background: #9c27b0;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        `;
        adminSendBtn.addEventListener('click', () => {
            this.sendAdminMessage();
        });
        adminSendBtn.addEventListener('mouseenter', () => {
            adminSendBtn.style.background = '#7b1fa2';
        });
        adminSendBtn.addEventListener('mouseleave', () => {
            adminSendBtn.style.background = '#9c27b0';
        });
        adminInputContainer.appendChild(adminSendBtn);
        
        adminInputArea.appendChild(adminInputContainer);
        messagesContainer.appendChild(adminInputArea);
        
        mainContainer.appendChild(usersListContainer);
        mainContainer.appendChild(messagesContainer);
        this.gameContainer.appendChild(mainContainer);
        
        // Set up Firebase listeners
        this.setupAdminListeners();
    }
    
    /**
     * Create User Interface
     */
    createUserInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'Chat with Admin';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create cancel button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            display: block;
            margin: 0 auto 20px auto;
            padding: 10px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        cancelButton.addEventListener('click', () => {
            this.backToModeSelection();
        });
        cancelButton.addEventListener('mouseenter', () => {
            cancelButton.style.background = '#d32f2f';
            cancelButton.style.transform = 'scale(1.05)';
        });
        cancelButton.addEventListener('mouseleave', () => {
            cancelButton.style.background = '#f44336';
            cancelButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(cancelButton);
        
        // Create info message
        const infoMessage = document.createElement('div');
        infoMessage.textContent = 'You are chatting with the admin. Please be respectful.';
        infoMessage.style.cssText = `
            color: #4CAF50;
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        `;
        this.gameContainer.appendChild(infoMessage);
        
        // Create chat container
        const chatContainer = document.createElement('div');
        chatContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            height: 500px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        `;
        
        // Messages display area
        const messagesDisplay = document.createElement('div');
        messagesDisplay.id = 'messagesDisplay';
        messagesDisplay.style.cssText = `
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.05);
        `;
        messagesDisplay.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No messages yet. Start a conversation!</div>';
        chatContainer.appendChild(messagesDisplay);
        
        // Input area
        const inputArea = document.createElement('div');
        inputArea.style.cssText = `
            display: flex;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        `;
        
const messageInput = document.createElement('input');
messageInput.id = 'messageInput';
messageInput.type = 'text';
messageInput.placeholder = 'Type your message...';
messageInput.style.cssText = `
    flex: 1;
    height: 50px; /* Fixed height to maintain consistency */
    padding: 12px 15px;
    border: none;
    border-radius: 25px;
    background: rgba(255, 255, 255, 0.2);
    color: white;
    font-size: 16px;
    outline: none;
    box-sizing: border-box;
    line-height: normal; /* Ensures text is vertically centered */
    vertical-align: middle; /* Helps with vertical alignment */
`;

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });
        inputArea.appendChild(messageInput);
        
        const sendBtn = document.createElement('button');
        sendBtn.textContent = 'Send';
        sendBtn.style.cssText = `
            margin-left: 10px;
            padding: 12px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        `;
        sendBtn.addEventListener('click', () => {
            this.sendMessage();
        });
        sendBtn.addEventListener('mouseenter', () => {
            sendBtn.style.background = '#45a049';
        });
        sendBtn.addEventListener('mouseleave', () => {
            sendBtn.style.background = '#4CAF50';
        });
        inputArea.appendChild(sendBtn);
        
        chatContainer.appendChild(inputArea);
        this.gameContainer.appendChild(chatContainer);
        
        // Generate or get user ID
        this.generateUserId();
        
        // Set up user listeners
        this.setupUserListeners();
    }
    
    /**
     * Generate or get user ID
     */
    generateUserId() {
        // Check if we already have a user ID in localStorage
        let userId = localStorage.getItem('avu_userId');
        
        if (!userId) {
            // Generate a new user ID
            userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('avu_userId', userId);
        }
        
        this.currentUserId = userId;
        console.log("User ID:", userId);
    }
    
    /**
     * Setup Admin Listeners
     */
    setupAdminListeners() {
        if (!this.isFirebaseInitialized) return;
        
        // Listen for users
        this.usersRef = this.db.ref('avu_users');
        this.usersListener = this.usersRef.on('value', (snapshot) => {
            this.updateUsersList(snapshot.val());
        });
        
        // If we have a selected user, listen for their messages
        if (this.currentUserId) {
            this.setupMessagesListener(this.currentUserId);
        }
    }
    
    /**
     * Setup User Listeners
     */
    setupUserListeners() {
        if (!this.isFirebaseInitialized) return;
        
        // Add user to the users list
        this.usersRef = this.db.ref('avu_users');
        this.usersRef.child(this.currentUserId).set({
            id: this.currentUserId,
            lastActive: firebase.database.ServerValue.TIMESTAMP
        });
        
        // Listen for messages
        this.setupMessagesListener(this.currentUserId);
    }
    
    /**
     * Setup Messages Listener
     */
    setupMessagesListener(userId) {
        if (!this.isFirebaseInitialized || !userId) return;
        
        // Remove existing listener
        if (this.messagesListener) {
            this.messagesRef.off('child_added', this.messagesListener);
            this.messagesListener = null;
        }
        
        // Set up new listener
        this.messagesRef = this.db.ref(`avu_messages/${userId}`);
        this.messagesListener = this.messagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            this.addMessage(message);
        });
    }
    
    /**
     * Update Users List (Admin)
     */
    updateUsersList(usersData) {
        if (!usersData) {
            this.usersList = [];
            this.updateUsersListUI();
            return;
        }
        
        this.usersList = Object.values(usersData);
        this.updateUsersListUI();
    }
    
    /**
     * Update Users List UI (Admin)
     */
    updateUsersListUI() {
        const usersListContent = document.getElementById('usersListContent');
        if (!usersListContent) return;
        
        usersListContent.innerHTML = '';
        
        if (this.usersList.length === 0) {
            usersListContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No users found</div>';
            return;
        }
        
        this.usersList.forEach(user => {
            const userItem = document.createElement('div');
            userItem.style.cssText = `
                padding: 12px 15px;
                background: ${user.id === this.currentUserId ? 'rgba(76, 175, 80, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 1px solid rgba(255, 255, 255, 0.2);
            `;
            
            const userInfo = document.createElement('div');
            userInfo.innerHTML = `
                <div style="font-weight: bold; color: white; margin-bottom: 5px;">${user.id}</div>
                <div style="font-size: 12px; color: #ccc;">Last active: ${new Date(user.lastActive).toLocaleString()}</div>
            `;
            userItem.appendChild(userInfo);
            
            userItem.addEventListener('click', () => {
                this.selectUser(user.id);
            });
            
            usersListContent.appendChild(userItem);
        });
    }
    
    /**
     * Select User (Admin)
     */
    selectUser(userId) {
        this.currentUserId = userId;
        this.updateUsersListUI();
        this.setupMessagesListener(userId);
        
        // Show admin input area
        const adminInputArea = document.getElementById('adminInputArea');
        if (adminInputArea) {
            adminInputArea.style.display = 'block';
        }
        
        // Clear messages display
        const messagesContent = document.getElementById('messagesContent');
        if (messagesContent) {
            messagesContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">Loading messages...</div>';
        }
        
        // Load existing messages
        this.loadMessages(userId);
    }
    
    /**
     * Load Messages
     */
    loadMessages(userId) {
        if (!this.isFirebaseInitialized || !userId) return;
        
        this.messagesRef = this.db.ref(`avu_messages/${userId}`);
        this.messagesRef.once('value', (snapshot) => {
            const messagesData = snapshot.val();
            this.messages = messagesData ? Object.values(messagesData) : [];
            this.updateMessagesUI();
        });
    }
    
    /**
     * Add Message
     */
    addMessage(message) {
        this.messages.push(message);
        this.updateMessagesUI();
    }
    
    /**
     * Update Messages UI
     */
    updateMessagesUI() {
        const messagesContent = document.getElementById('messagesContent');
        const messagesDisplay = document.getElementById('messagesDisplay');
        
        if (!messagesContent && !messagesDisplay) return;
        
        if (this.messages.length === 0) {
            if (messagesContent) {
                messagesContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No messages found</div>';
            }
            if (messagesDisplay) {
                messagesDisplay.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No messages yet. Start a conversation!</div>';
            }
            return;
        }
        
        const container = messagesContent || messagesDisplay;
        container.innerHTML = '';
        
        this.messages.forEach(message => {
            const messageDiv = document.createElement('div');
            
            // Set different styles based on sender
            if (message.sender === 'user') {
                messageDiv.style.cssText = `
                    margin-bottom: 15px;
                    padding: 12px 15px;
                    border-radius: 15px;
                    max-width: 80%;
                    background: rgba(33, 150, 243, 0.2);
                    margin-left: auto;
                `;
            } else if (message.sender === 'admin') {
                messageDiv.style.cssText = `
                    margin-bottom: 15px;
                    padding: 12px 15px;
                    border-radius: 15px;
                    max-width: 80%;
                    background: rgba(156, 39, 176, 0.2);
                    margin-right: auto;
                `;
            }
            
            const messageInfo = document.createElement('div');
            messageInfo.style.cssText = `
                font-size: 12px;
                color: ${message.sender === 'user' ? '#2196F3' : message.sender === 'admin' ? '#9c27b0' : '#4CAF50'};
                margin-bottom: 5px;
                font-weight: bold;
            `;
            messageInfo.textContent = `${message.sender === 'user' ? 'You' : message.sender === 'admin' ? 'Admin' : 'AI'} - ${new Date(message.timestamp).toLocaleTimeString()}`;
            messageDiv.appendChild(messageInfo);
            
            const messageText = document.createElement('div');
            messageText.style.cssText = `
                color: white;
                word-wrap: break-word;
            `;
            messageText.textContent = message.text;
            messageDiv.appendChild(messageText);
            
            container.appendChild(messageDiv);
        });
        
        // Scroll to bottom
        container.scrollTop = container.scrollHeight;
    }
    
    /**
     * Send Message (User)
     */
    sendMessage() {
        const messageInput = document.querySelector('#messageInput') || document.querySelector('input[placeholder="Type your message..."]');
        if (!messageInput) return;
        
        const text = messageInput.value.trim();
        if (!text) return;
        
        const message = {
            text: text,
            sender: 'user',
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        // Save to Firebase
        this.messagesRef.push(message);
        
        // Clear input
        messageInput.value = '';
        
        // No automatic AI response
    }
    
    /**
     * Send Admin Message
     */
    sendAdminMessage() {
        const adminInput = document.getElementById('adminInput');
        if (!adminInput || !this.currentUserId) return;
        
        const text = adminInput.value.trim();
        if (!text) return;
        
        const message = {
            text: text,
            sender: 'admin',
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        // Save to Firebase
        this.messagesRef.push(message);
        
        // Clear input
        adminInput.value = '';
    }
    
    /**
     * Clear All Messages (Admin)
     */
    clearAllMessages() {
        if (!this.currentUserId || !this.isFirebaseInitialized) return;
        
        const confirmClear = confirm('Are you sure you want to clear all messages for this user?');
        if (!confirmClear) return;
        
        // Clear messages in Firebase
        this.db.ref(`avu_messages/${this.currentUserId}`).remove();
        
        // Clear local messages
        this.messages = [];
        this.updateMessagesUI();
        
        this.showNotification('Messages cleared successfully!');
    }
    
    /**
     * Go back to mode selection screen
     */
    backToModeSelection() {
        // Clean up Firebase listeners
        if (this.usersListener) {
            this.usersRef.off('value', this.usersListener);
            this.usersListener = null;
        }
        
        if (this.messagesListener) {
            this.messagesRef.off('child_added', this.messagesListener);
            this.messagesListener = null;
        }
        
        // Clear the container
        this.gameContainer.innerHTML = '';
        
        // Reset mode
        this.isAdmin = false;
        this.currentUserId = null;
        this.messages = [];
        
        // Create mode selection screen
        this.createModeSelectionScreen();
    }
    
    /**
     * Initialize Firebase
     */
    initializeFirebase(callback) {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase(callback);
                });
            });
        } else {
            this.setupFirebase(callback);
        }
    }
    
    /**
     * Setup Firebase
     */
    setupFirebase(callback) {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            this.isFirebaseInitialized = true;
            
            if (callback) {
                callback();
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.showNotification('Error initializing Firebase. Please try again.');
        }
    }
    
    /**
     * Load external script
     */
    loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Cancel button (main button)
        this.cancelButton = document.createElement('button');
        this.cancelButton.textContent = 'Cancel';
        this.cancelButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 12px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
            transition: all 0.3s ease;
        `;
        this.cancelButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.cancelButton.addEventListener('mouseenter', () => {
            this.cancelButton.style.background = '#d32f2f';
            this.cancelButton.style.transform = 'scale(1.05)';
        });
        this.cancelButton.addEventListener('mouseleave', () => {
            this.cancelButton.style.background = '#f44336';
            this.cancelButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(this.cancelButton);
        
        // Keep the old close button for backward compatibility
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 15px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10000;
            display: none; /* Hidden by default, only shown if needed */
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the game
     */
    closeGame() {
        // Clean up Firebase listeners
        if (this.usersListener) {
            this.usersRef.off('value', this.usersListener);
            this.usersListener = null;
        }
        
        if (this.messagesListener) {
            this.messagesRef.off('child_added', this.messagesListener);
            this.messagesListener = null;
        }
        
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        this.isAdmin = false;
        this.currentUserId = null;
        this.messages = [];
        
        console.log("AVU screen closed");
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
        `;
        notification.textContent = message;
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
        }, 3000);
    }
}

// ===== GLOBAL INSTANCE AND COMMAND HANDLING =====
// Create a global instance
let avuscreenloader = null;
// Function to get or create the AVU screen instance
function getAvuScreen() {
    if (!avuscreenloader) {
        console.log("Creating new AVUScreenLoader instance");
        avuscreenloader = new AVUScreenLoader();
    }
    return avuscreenloader;
}
// Command handler
function handleAvuCommand(input) {
    if (typeof input !== 'string') return false;
    
    const avuKeywords = ['admin view', 'view user', 'monitor chat', 'avu', 'admin messages'];
    const normalizedInput = input.toLowerCase().trim();
    
    return avuKeywords.some(keyword => normalizedInput.includes(keyword));
}
// Execute AVU command
function executeAvuCommand() {
    try {
        const avuScreen = getAvuScreen();
        if (avuScreen && typeof avuScreen.loadAvuScreen === 'function') {
            console.log("Executing AVU command");
            avuScreen.loadAvuScreen();
        } else {
            console.error("Invalid AVU screen instance");
            botReply("Sorry, the admin view user screen is not available right now.");
        }
    } catch (error) {
        console.error("Error executing AVU command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}
// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleAvuCommand(userInputRaw)) {
    console.log("AVU command detected");
    executeAvuCommand();
    return;
}
// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen|cancel/i.test(userInputRaw)) {
    if (avuscreenloader && avuscreenloader.isActive) {
        avuscreenloader.closeGame();
        return;
    }
}
// ===== DEBUGGING HELPERS =====
// Add this to test the AVU screen manually (call from browser console)
window.testAvuScreen = function() {
    console.log("Testing AVU screen...");
    executeAvuCommand();
};
// Add this to check if the AVU screen is loaded
window.checkAvuScreen = function() {
    console.log("avuscreenloader exists:", !!avuscreenloader);
    console.log("avuscreenloader type:", typeof avuscreenloader);
    console.log("AVUScreenLoader class exists:", typeof AVUScreenLoader);
};


class NoteScreenLoader {
    constructor() {
        this.noteScreen = {
            name: 'NOTE SCREEN',
            instructions: 'Type your notes and save them. View, edit, copy, or download saved notes anytime.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.noteTextarea = null;
        this.saveButton = null;
        this.clearButton = null;
        this.notesList = null;
        this.savedNotes = [];
        this.currentNoteId = null;
        this.notesListVisible = false;
        this.noteModal = null;
        this.modalContent = null;
    }
    
    /**
     * Load the Note Screen
     */
    loadNoteScreen() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.noteScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Load saved notes from localStorage
        this.loadSavedNotes();
        
        // Create container
        this.createGameContainer();
        
        // Create note screen
        this.createNoteScreen();
        
        // Create modal for viewing notes
        this.createNoteModal();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the note screen
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.noteScreen.name} loaded! ${this.noteScreen.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the Note Screen UI
     */
    createNoteScreen() {
        // Create note container
        const noteContainer = document.createElement('div');
        noteContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 700px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'My Notes';
        title.style.cssText = `
            margin: 0;
            color: #333;
            font-size: 24px;
        `;
        
        const toggleButton = document.createElement('button');
        toggleButton.textContent = 'Saved Notes';
        toggleButton.style.cssText = `
            padding: 8px 12px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        `;
        toggleButton.addEventListener('click', () => {
            this.toggleNotesList();
        });
        
        header.appendChild(title);
        header.appendChild(toggleButton);
        noteContainer.appendChild(header);
        
        // Create textarea for note input
        this.noteTextarea = document.createElement('textarea');
        this.noteTextarea.placeholder = 'Type your note here...';
        this.noteTextarea.style.cssText = `
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            font-family: 'Arial', sans-serif;
            resize: vertical;
            margin-bottom: 15px;
            box-sizing: border-box;
        `;
        
        noteContainer.appendChild(this.noteTextarea);
        
        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Create save button
        this.saveButton = document.createElement('button');
        this.saveButton.textContent = 'Save Note';
        this.saveButton.style.cssText = `
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            flex: 1;
            transition: all 0.2s ease;
        `;
        this.saveButton.addEventListener('click', () => {
            this.saveNote();
        });
        
        // Create clear button
        this.clearButton = document.createElement('button');
        this.clearButton.textContent = 'Clear';
        this.clearButton.style.cssText = `
            padding: 10px 15px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            flex: 1;
            transition: all 0.2s ease;
        `;
        this.clearButton.addEventListener('click', () => {
            this.clearNote();
        });
        
        buttonContainer.appendChild(this.saveButton);
        buttonContainer.appendChild(this.clearButton);
        noteContainer.appendChild(buttonContainer);
        
        // Create saved notes list (initially hidden)
        this.notesList = document.createElement('div');
        this.notesList.style.cssText = `
            display: none;
            max-height: 300px;
            overflow-y: auto;
            border-top: 1px solid #ddd;
            padding-top: 15px;
        `;
        
        this.updateNotesList();
        noteContainer.appendChild(this.notesList);
        
        this.gameContainer.appendChild(noteContainer);
    }
    
    /**
     * Create a modal for viewing notes
     */
    createNoteModal() {
        // Create modal container
        this.noteModal = document.createElement('div');
        this.noteModal.style.cssText = `
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        `;
        
        // Create modal content container
        const modalContainer = document.createElement('div');
        modalContainer.style.cssText = `
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 600px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        `;
        
        // Create modal header
        const modalHeader = document.createElement('div');
        modalHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        `;
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Note Details';
        modalTitle.style.cssText = `
            margin: 0;
            color: #333;
            font-size: 20px;
        `;
        
        const closeButton = document.createElement('button');
        closeButton.textContent = '✕';
        closeButton.style.cssText = `
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #777;
        `;
        closeButton.addEventListener('click', () => {
            this.closeNoteModal();
        });
        
        modalHeader.appendChild(modalTitle);
        modalHeader.appendChild(closeButton);
        modalContainer.appendChild(modalHeader);
        
        // Create modal content
        this.modalContent = document.createElement('div');
        this.modalContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            white-space: pre-wrap;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            line-height: 1.5;
        `;
        
        modalContainer.appendChild(this.modalContent);
        
        // Create modal footer with action buttons
        const modalFooter = document.createElement('div');
        modalFooter.style.cssText = `
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
        `;
        
        // Copy button
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy';
        copyButton.style.cssText = `
            padding: 8px 12px;
            background-color: #9C27B0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        `;
        copyButton.addEventListener('click', () => {
            this.copyNoteFromModal();
        });
        
        // Edit button
        const editButton = document.createElement('button');
        editButton.textContent = 'Edit';
        editButton.style.cssText = `
            padding: 8px 12px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        `;
        editButton.addEventListener('click', () => {
            this.editNoteFromModal();
        });
        
        // Download button
        const downloadButton = document.createElement('button');
        downloadButton.textContent = 'Download';
        downloadButton.style.cssText = `
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        `;
        downloadButton.addEventListener('click', () => {
            this.downloadNoteFromModal();
        });
        
        modalFooter.appendChild(copyButton);
        modalFooter.appendChild(editButton);
        modalFooter.appendChild(downloadButton);
        modalContainer.appendChild(modalFooter);
        
        this.noteModal.appendChild(modalContainer);
        this.gameContainer.appendChild(this.noteModal);
    }
    
    /**
     * Toggle the visibility of the saved notes list
     */
    toggleNotesList() {
        this.notesListVisible = !this.notesListVisible;
        this.notesList.style.display = this.notesListVisible ? 'block' : 'none';
        
        if (this.notesListVisible) {
            this.updateNotesList();
        }
    }
    
    /**
     * Update the saved notes list
     */
    updateNotesList() {
        // Clear existing notes
        this.notesList.innerHTML = '';
        
        if (this.savedNotes.length === 0) {
            const noNotes = document.createElement('p');
            noNotes.textContent = 'No saved notes yet.';
            noNotes.style.cssText = `
                text-align: center;
                color: #777;
                font-style: italic;
            `;
            this.notesList.appendChild(noNotes);
            return;
        }
        
        // Create list header
        const listHeader = document.createElement('h3');
        listHeader.textContent = 'Saved Notes';
        listHeader.style.cssText = `
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        `;
        this.notesList.appendChild(listHeader);
        
        // Create list container
        const listContainer = document.createElement('div');
        
        // Add each saved note
        this.savedNotes.forEach(note => {
            const noteItem = document.createElement('div');
            noteItem.style.cssText = `
                background-color: white;
                border: 1px solid #ddd;
                border-radius: 5px;
                padding: 10px;
                margin-bottom: 8px;
                transition: all 0.2s ease;
            `;
            
            // Create note content
            const noteContent = document.createElement('div');
            noteContent.textContent = note.content.length > 50 
                ? note.content.substring(0, 50) + '...' 
                : note.content;
            noteContent.style.cssText = `
                font-size: 14px;
                color: #333;
                margin-bottom: 5px;
            `;
            
            // Create note metadata
            const noteMeta = document.createElement('div');
            noteMeta.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 12px;
                color: #777;
            `;
            
            const noteDate = document.createElement('span');
            noteDate.textContent = new Date(note.timestamp).toLocaleString();
            
            // Create action buttons container
            const actionButtons = document.createElement('div');
            actionButtons.style.cssText = `
                display: flex;
                gap: 5px;
                flex-wrap: wrap;
            `;
            
            // View button
            const viewButton = document.createElement('button');
            viewButton.textContent = 'View';
            viewButton.style.cssText = `
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            viewButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.viewNote(note.id);
            });
            
            // Copy button
            const copyButton = document.createElement('button');
            copyButton.textContent = 'Copy';
            copyButton.style.cssText = `
                background-color: #9C27B0;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            copyButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.copyNote(note.id);
            });
            
            // Edit button
            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.style.cssText = `
                background-color: #FF9800;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            editButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.loadNote(note.id);
            });
            
            // Download button
            const downloadButton = document.createElement('button');
            downloadButton.textContent = 'Download';
            downloadButton.style.cssText = `
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            downloadButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.downloadNote(note.id);
            });
            
            // Delete button
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.style.cssText = `
                background-color: #f44336;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteNote(note.id);
            });
            
            actionButtons.appendChild(viewButton);
            actionButtons.appendChild(copyButton);
            actionButtons.appendChild(editButton);
            actionButtons.appendChild(downloadButton);
            actionButtons.appendChild(deleteButton);
            
            noteMeta.appendChild(noteDate);
            noteMeta.appendChild(actionButtons);
            
            noteItem.appendChild(noteContent);
            noteItem.appendChild(noteMeta);
            
            listContainer.appendChild(noteItem);
        });
        
        this.notesList.appendChild(listContainer);
    }
    
    /**
     * View a note in the modal
     */
    viewNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (note) {
            this.modalContent.textContent = note.content;
            this.modalContent.dataset.noteId = noteId;
            this.noteModal.style.display = 'flex';
        }
    }
    
    /**
     * Close the note modal
     */
    closeNoteModal() {
        this.noteModal.style.display = 'none';
        this.modalContent.textContent = '';
        this.modalContent.dataset.noteId = '';
    }
    
    /**
     * Copy note from modal
     */
    copyNoteFromModal() {
        const noteId = this.modalContent.dataset.noteId;
        if (noteId) {
            this.copyNote(noteId);
        }
    }
    
    /**
     * Copy a note to clipboard
     */
    copyNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (!note) return;
        
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(note.content)
                .then(() => {
                    botReply('Note copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(note.content);
                });
        } else {
            // Fallback for older browsers
            this.fallbackCopyTextToClipboard(note.content);
        }
    }
    
    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Note copied to clipboard!');
            } else {
                botReply('Unable to copy note');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy note');
        }

        document.body.removeChild(textArea);
    }
    
    /**
     * Edit note from modal
     */
    editNoteFromModal() {
        const noteId = this.modalContent.dataset.noteId;
        if (noteId) {
            this.loadNote(noteId);
            this.closeNoteModal();
        }
    }
    
    /**
     * Download note from modal
     */
    downloadNoteFromModal() {
        const noteId = this.modalContent.dataset.noteId;
        if (noteId) {
            this.downloadNote(noteId);
        }
    }
    
    /**
     * Download a note as a text file
     */
    downloadNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (!note) return;
        
        try {
            // Create a blob with the note content, specifying UTF-8 encoding for proper emoji support
            const blob = new Blob([note.content], { type: 'text/plain;charset=utf-8' });
            
            // Create a download link
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Generate filename with timestamp
            const date = new Date(note.timestamp);
            const dateStr = date.toISOString().slice(0, 19).replace(/:/g, '-');
            a.download = `note_${dateStr}.txt`;
            
            // Trigger download
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            botReply('Note downloaded successfully!');
        } catch (error) {
            console.error('Error downloading note:', error);
            botReply('Error downloading note. Please try again.');
        }
    }
    
    /**
     * Save the current note
     */
    saveNote() {
        const content = this.noteTextarea.value.trim();
        
        if (!content) {
            botReply('Please enter some text before saving.');
            return;
        }
        
        const now = new Date().getTime();
        
        if (this.currentNoteId) {
            // Update existing note
            const noteIndex = this.savedNotes.findIndex(note => note.id === this.currentNoteId);
            if (noteIndex !== -1) {
                this.savedNotes[noteIndex].content = content;
                this.savedNotes[noteIndex].timestamp = now;
                botReply('Note updated successfully!');
            }
        } else {
            // Create new note
            const newNote = {
                id: 'note_' + now,
                content: content,
                timestamp: now
            };
            
            this.savedNotes.push(newNote);
            this.currentNoteId = newNote.id;
            botReply('Note saved successfully!');
        }
        
        // Save to localStorage
        this.saveNotesToStorage();
        
        // Update notes list if visible
        if (this.notesListVisible) {
            this.updateNotesList();
        }
    }
    
    /**
     * Clear the current note
     */
    clearNote() {
        this.noteTextarea.value = '';
        this.currentNoteId = null;
        botReply('Note cleared.');
    }
    
    /**
     * Load a note into the textarea
     */
    loadNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (note) {
            this.noteTextarea.value = note.content;
            this.currentNoteId = noteId;
            botReply('Note loaded for editing!');
        }
    }
    
    /**
     * Delete a saved note
     */
    deleteNote(noteId) {
        const noteIndex = this.savedNotes.findIndex(note => note.id === noteId);
        if (noteIndex !== -1) {
            this.savedNotes.splice(noteIndex, 1);
            
            // If deleting the currently loaded note, clear the textarea
            if (this.currentNoteId === noteId) {
                this.clearNote();
            }
            
            // Save to localStorage
            this.saveNotesToStorage();
            
            // Update notes list
            this.updateNotesList();
            
            botReply('Note deleted!');
        }
    }
    
    /**
     * Load saved notes from localStorage
     */
    loadSavedNotes() {
        try {
            const savedNotesJson = localStorage.getItem('savedNotes');
            if (savedNotesJson) {
                this.savedNotes = JSON.parse(savedNotesJson);
            } else {
                this.savedNotes = [];
            }
        } catch (error) {
            console.error('Error loading saved notes:', error);
            this.savedNotes = [];
        }
    }
    
    /**
     * Save notes to localStorage
     */
    saveNotesToStorage() {
        try {
            localStorage.setItem('savedNotes', JSON.stringify(this.savedNotes));
        } catch (error) {
            console.error('Error saving notes to storage:', error);
            botReply('Error saving notes. Please try again.');
        }
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.noteModal.style.display === 'flex') {
                this.closeNoteModal();
            } else if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
        
        // Ctrl+S to save note
        if (event.ctrlKey && event.key === 's') {
            event.preventDefault();
            this.saveNote();
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            this.webkitExitFullscreen();
        } else if (this.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.noteTextarea = null;
        this.saveButton = null;
        this.clearButton = null;
        this.notesList = null;
        this.noteModal = null;
        this.modalContent = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.savedNotes = [];
        this.currentNoteId = null;
        this.notesListVisible = false;
        
        botReply("Note Screen closed. Thank you!");
    }
}

// Create a singleton instance
const noteScreenLoader = new NoteScreenLoader();

// Add this to your AI's command handling
if (/note|notes|notepad/i.test(userInputRaw)) {
    noteScreenLoader.loadNoteScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    noteScreenLoader.closeGame();
    return;
}
class SongsVideosScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'MEDIA PLAYER',
            instructions: 'Load and play songs and videos from your device. Access media from your Download folder or upload new files.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.fileInput = null;
        this.uploadButton = null;
        this.loadFromFolderButton = null;
        this.mediaList = null;
        this.mediaPlayer = null;
        this.mediaControls = null;
        this.playButton = null;
        this.pauseButton = null;
        this.stopButton = null;
        this.volumeSlider = null;
        this.progressBar = null;
        this.timeDisplay = null;
        this.currentMedia = null;
        this.mediaFiles = [];
        this.storageKey = 'mediaFilesData';
        this.isPlaying = false;
        this.currentMediaType = null;
        this.downloadFolderPath = '/storage/emulated/0/Download/';
        this.directoryHandle = null;
    }

    /**
     * Load the Media Player Screen
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createMediaPlayerScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.loadMediaFiles();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }

    /**
     * Create the Media Player UI
     */
    createMediaPlayerScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 900px;
            max-width: 95vw;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Media Player';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        `;
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Play songs and videos from your device';
        subtitle.style.cssText = `
            margin: 0;
            color: #666;
            font-size: 16px;
        `;
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);

        // Upload section
        const uploadSection = document.createElement('div');
        uploadSection.style.cssText = `
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        `;
        const uploadTitle = document.createElement('h3');
        uploadTitle.textContent = 'Load Media';
        uploadTitle.style.cssText = `
            margin: 0 0 15px 0;
            color: #2E7D32;
            font-size: 18px;
        `;
        
        const uploadControls = document.createElement('div');
        uploadControls.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Load from folder button
        const folderControls = document.createElement('div');
        folderControls.style.cssText = `
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        const folderLabel = document.createElement('span');
        folderLabel.textContent = 'Download Folder:';
        folderLabel.style.cssText = `
            font-weight: bold;
            color: #333;
            min-width: 120px;
        `;
        this.loadFromFolderButton = this.createButton('Load from Download Folder', '#2196F3', () => {
            this.loadFromDownloadFolder();
        });
        folderControls.appendChild(folderLabel);
        folderControls.appendChild(this.loadFromFolderButton);
        
        // Upload file controls
        const fileControls = document.createElement('div');
        fileControls.style.cssText = `
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        const fileLabel = document.createElement('span');
        fileLabel.textContent = 'Upload File:';
        fileLabel.style.cssText = `
            font-weight: bold;
            color: #333;
            min-width: 120px;
        `;
        this.fileInput = document.createElement('input');
        this.fileInput.type = 'file';
        this.fileInput.accept = 'audio/*,video/*';
        this.fileInput.style.cssText = `
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        this.uploadButton = this.createButton('Upload', '#4CAF50', () => {
            this.uploadMedia();
        });
        fileControls.appendChild(fileLabel);
        fileControls.appendChild(this.fileInput);
        fileControls.appendChild(this.uploadButton);
        
        uploadControls.appendChild(folderControls);
        uploadControls.appendChild(fileControls);
        uploadSection.appendChild(uploadTitle);
        uploadSection.appendChild(uploadControls);
        baseContainer.appendChild(uploadSection);

        // Media list section
        const listSection = document.createElement('div');
        listSection.style.cssText = `
            margin-bottom: 20px;
        `;
        const listTitle = document.createElement('h3');
        listTitle.textContent = 'Media Library';
        listTitle.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 18px;
        `;
        this.mediaList = document.createElement('div');
        this.mediaList.style.cssText = `
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            padding: 10px;
        `;
        this.mediaList.textContent = 'Loading media library...';
        listSection.appendChild(listTitle);
        listSection.appendChild(this.mediaList);
        baseContainer.appendChild(listSection);

        // Media player section
        const playerSection = document.createElement('div');
        playerSection.style.cssText = `
            margin-bottom: 20px;
        `;
        const playerTitle = document.createElement('h3');
        playerTitle.textContent = 'Media Player';
        playerTitle.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 18px;
        `;
        
        // Media player container
        const playerContainer = document.createElement('div');
        playerContainer.style.cssText = `
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        `;
        
        // Audio element (initially hidden)
        this.audioPlayer = document.createElement('audio');
        this.audioPlayer.style.cssText = `
            width: 100%;
            display: none;
        `;
        this.audioPlayer.addEventListener('loadedmetadata', () => {
            this.updateTimeDisplay();
        });
        this.audioPlayer.addEventListener('timeupdate', () => {
            this.updateProgressBar();
        });
        this.audioPlayer.addEventListener('ended', () => {
            this.onMediaEnded();
        });
        
        // Video element (initially hidden)
        this.videoPlayer = document.createElement('video');
        this.videoPlayer.style.cssText = `
            width: 100%;
            max-height: 400px;
            display: none;
        `;
        this.videoPlayer.addEventListener('loadedmetadata', () => {
            this.updateTimeDisplay();
        });
        this.videoPlayer.addEventListener('timeupdate', () => {
            this.updateProgressBar();
        });
        this.videoPlayer.addEventListener('ended', () => {
            this.onMediaEnded();
        });
        
        playerContainer.appendChild(this.audioPlayer);
        playerContainer.appendChild(this.videoPlayer);
        
        // Media info display
        this.mediaInfo = document.createElement('div');
        this.mediaInfo.style.cssText = `
            padding: 10px;
            background-color: #333;
            color: white;
            font-size: 14px;
            text-align: center;
        `;
        this.mediaInfo.textContent = 'No media selected';
        playerContainer.appendChild(this.mediaInfo);
        
        playerSection.appendChild(playerTitle);
        playerSection.appendChild(playerContainer);
        baseContainer.appendChild(playerSection);

        // Media controls
        this.mediaControls = document.createElement('div');
        this.mediaControls.style.cssText = `
            background-color: #333;
            padding: 15px;
            border-radius: 8px;
            color: white;
        `;
        
        // Progress bar
        const progressContainer = document.createElement('div');
        progressContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        this.progressBar = document.createElement('input');
        this.progressBar.type = 'range';
        this.progressBar.min = '0';
        this.progressBar.max = '100';
        this.progressBar.value = '0';
        this.progressBar.style.cssText = `
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #555;
            outline: none;
            cursor: pointer;
        `;
        this.progressBar.addEventListener('input', () => {
            this.seekMedia();
        });
        progressContainer.appendChild(this.progressBar);
        
        // Time display
        this.timeDisplay = document.createElement('div');
        this.timeDisplay.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 14px;
        `;
        this.currentTime = document.createElement('span');
        this.currentTime.textContent = '0:00';
        this.duration = document.createElement('span');
        this.duration.textContent = '0:00';
        this.timeDisplay.appendChild(this.currentTime);
        this.timeDisplay.appendChild(this.duration);
        
        // Control buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        `;
        this.playButton = this.createButton('▶', '#4CAF50', () => {
            this.playMedia();
        });
        this.pauseButton = this.createButton('⏸', '#FF9800', () => {
            this.pauseMedia();
        });
        this.stopButton = this.createButton('⏹', '#f44336', () => {
            this.stopMedia();
        });
        buttonContainer.appendChild(this.playButton);
        buttonContainer.appendChild(this.pauseButton);
        buttonContainer.appendChild(this.stopButton);
        
        // Volume control
        const volumeContainer = document.createElement('div');
        volumeContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        const volumeLabel = document.createElement('span');
        volumeLabel.textContent = 'Volume:';
        volumeLabel.style.cssText = `
            font-size: 14px;
        `;
        this.volumeSlider = document.createElement('input');
        this.volumeSlider.type = 'range';
        this.volumeSlider.min = '0';
        this.volumeSlider.max = '100';
        this.volumeSlider.value = '50';
        this.volumeSlider.style.cssText = `
            flex-grow: 1;
            height: 6px;
            border-radius: 3px;
            background: #555;
            outline: none;
            cursor: pointer;
        `;
        this.volumeSlider.addEventListener('input', () => {
            this.changeVolume();
        });
        volumeContainer.appendChild(volumeLabel);
        volumeContainer.appendChild(this.volumeSlider);
        
        this.mediaControls.appendChild(progressContainer);
        this.mediaControls.appendChild(this.timeDisplay);
        this.mediaControls.appendChild(buttonContainer);
        this.mediaControls.appendChild(volumeContainer);
        baseContainer.appendChild(this.mediaControls);

        // Info section
        const infoSection = document.createElement('div');
        infoSection.style.cssText = `
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 15px;
            font-size: 14px;
            color: #1976d2;
            border-left: 4px solid #2196F3;
            margin-top: auto;
        `;
        infoSection.innerHTML = `
            <strong>Instructions:</strong><br>
            • Click "Load from Download Folder" to access media files from your device<br>
            • Or upload audio/video files using the file input<br>
            • Click on any media file in the library to play it<br>
            • Use the media controls to play, pause, stop, and adjust volume
        `;
        baseContainer.appendChild(infoSection);
        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Load media files from the Download folder using File System Access API
     */
    async loadFromDownloadFolder() {
        try {
            // Show loading message
            this.mediaList.textContent = 'Loading media from Download folder...';
            
            // Check if File System Access API is supported
            if (!('showDirectoryPicker' in window)) {
                throw new Error('File System Access API is not supported in this browser');
            }
            
            // Request directory access
            this.directoryHandle = await window.showDirectoryPicker();
            
            // Get all entries in the directory
            const entries = [];
            for await (const entry of this.directoryHandle.values()) {
                entries.push(entry);
            }
            
            // Filter for audio and video files
            const mediaFiles = entries.filter(entry => 
                entry.kind === 'file' && (
                    entry.name.match(/\.(mp3|wav|ogg|m4a|flac|aac)$/i) || // Audio formats
                    entry.name.match(/\.(mp4|webm|ogg|mov|avi|mkv|flv)$/i)    // Video formats
                )
            );
            
            if (mediaFiles.length === 0) {
                this.mediaList.textContent = 'No media files found in the selected folder';
                botReply('No media files found in the selected folder');
                return;
            }
            
            // Process each media file
            const newMediaFiles = [];
            for (const fileHandle of mediaFiles) {
                const file = await fileHandle.getFile();
                const mediaFile = {
                    id: `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    fileHandle: fileHandle,
                    uploadDate: new Date().toLocaleString(),
                    source: 'Download Folder'
                };
                newMediaFiles.push(mediaFile);
            }
            
            // Add to media files array
            this.mediaFiles = [...this.mediaFiles.filter(f => f.source !== 'Download Folder'), ...newMediaFiles];
            
            // Update UI
            this.updateMediaList();
            this.saveMediaFiles();
            botReply(`Loaded ${newMediaFiles.length} media files from Download folder`);
            
        } catch (error) {
            console.error('Error loading from Download folder:', error);
            this.mediaList.textContent = 'Error loading media files. Please try again.';
           
        }
    }

    /**
     * Upload media file to localStorage
     */
    uploadMedia() {
        const file = this.fileInput.files[0];
        if (!file) {
            botReply('No file selected');
            return;
        }
        
        // Check file size (localStorage limit is ~5MB)
        if (file.size > 5 * 1024 * 1024) {
            botReply('File is too large. Maximum size is 5MB.');
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const mediaFile = {
                id: Date.now(),
                name: file.name,
                type: file.type,
                size: file.size,
                data: e.target.result,
                uploadDate: new Date().toLocaleString(),
                source: 'Uploaded'
            };
            
            this.mediaFiles.push(mediaFile);
            this.saveMediaFiles();
            this.updateMediaList();
            this.fileInput.value = '';
            botReply(`Media uploaded: ${file.name}`);
        };
        
        reader.onerror = () => {
            botReply('Error uploading file');
        };
        
        reader.readAsDataURL(file);
    }

    /**
     * Save media files to localStorage
     */
    saveMediaFiles() {
        try {
            // We can't save file handles to localStorage, so we only save metadata
            const filesToSave = this.mediaFiles.map(file => {
                const { fileHandle, ...rest } = file;
                return rest;
            });
            localStorage.setItem(this.storageKey, JSON.stringify(filesToSave));
        } catch (error) {
            console.error('Error saving media files:', error);
            botReply('Error saving media files. Storage may be full.');
        }
    }

    /**
     * Load media files from localStorage
     */
    loadMediaFiles() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
                const files = JSON.parse(stored);
                this.mediaFiles = files.map(file => ({
                    ...file,
                    // File handles are lost on refresh, so we need to reload them
                    fileHandle: null
                }));
                this.updateMediaList();
            } else {
                this.mediaList.textContent = 'No media files found. Click "Load from Download Folder" to get started.';
            }
        } catch (error) {
            console.error('Error loading media files:', error);
            this.mediaList.textContent = 'Error loading media files. Please try again.';
        }
    }

    /**
     * Update media list display
     */
    updateMediaList() {
        this.mediaList.innerHTML = '';
        
        if (this.mediaFiles.length === 0) {
            this.mediaList.textContent = 'No media files found. Click "Load from Download Folder" to get started.';
            return;
        }
        
        // Group files by source
        const filesBySource = {};
        this.mediaFiles.forEach(file => {
            if (!filesBySource[file.source]) {
                filesBySource[file.source] = [];
            }
            filesBySource[file.source].push(file);
        });
        
        // Display files grouped by source
        Object.keys(filesBySource).forEach(source => {
            // Create source header
            const sourceHeader = document.createElement('div');
            sourceHeader.style.cssText = `
                font-weight: bold;
                margin-top: 10px;
                margin-bottom: 5px;
                color: #555;
                font-size: 14px;
                border-bottom: 1px solid #eee;
                padding-bottom: 3px;
            `;
            sourceHeader.textContent = source;
            this.mediaList.appendChild(sourceHeader);
            
            // Add files for this source
            filesBySource[source].forEach(file => {
                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 10px;
                    margin-bottom: 5px;
                    background-color: #f9f9f9;
                    border-radius: 5px;
                    cursor: pointer;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    transition: background-color 0.2s;
                `;
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#e0e0e0';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = '#f9f9f9';
                });
                
                const fileInfo = document.createElement('div');
                fileInfo.style.cssText = `
                    flex-grow: 1;
                `;
                const fileName = document.createElement('div');
                fileName.textContent = file.name;
                fileName.style.cssText = `
                    font-weight: bold;
                    margin-bottom: 2px;
                `;
                const fileDetails = document.createElement('div');
                fileDetails.textContent = `${this.formatFileSize(file.size)} • ${file.uploadDate}`;
                fileDetails.style.cssText = `
                    font-size: 12px;
                    color: #666;
                `;
                fileInfo.appendChild(fileName);
                fileInfo.appendChild(fileDetails);
                
                const playIcon = document.createElement('span');
                playIcon.textContent = '▶';
                playIcon.style.cssText = `
                    font-size: 20px;
                    color: #4CAF50;
                    margin-left: 10px;
                `;
                
                item.appendChild(fileInfo);
                item.appendChild(playIcon);
                item.addEventListener('click', () => {
                    this.selectMedia(file);
                });
                
                this.mediaList.appendChild(item);
            });
        });
    }

    /**
     * Select and play media file
     */
    async selectMedia(file) {
        this.currentMedia = file;
        this.currentMediaType = file.type.startsWith('audio/') ? 'audio' : 'video';
        
        // Reset players
        this.audioPlayer.pause();
        this.videoPlayer.pause();
        this.audioPlayer.style.display = 'none';
        this.videoPlayer.style.display = 'none';
        
        try {
            // Set media source
            if (file.data) {
                // For uploaded files
                if (this.currentMediaType === 'audio') {
                    this.audioPlayer.src = file.data;
                    this.audioPlayer.style.display = 'block';
                    this.mediaPlayer = this.audioPlayer;
                } else {
                    this.videoPlayer.src = file.data;
                    this.videoPlayer.style.display = 'block';
                    this.mediaPlayer = this.videoPlayer;
                }
            } else if (file.fileHandle) {
                // For files from Download folder
                const fileObj = await file.fileHandle.getFile();
                const url = URL.createObjectURL(fileObj);
                
                if (this.currentMediaType === 'audio') {
                    this.audioPlayer.src = url;
                    this.audioPlayer.style.display = 'block';
                    this.mediaPlayer = this.audioPlayer;
                } else {
                    this.videoPlayer.src = url;
                    this.videoPlayer.style.display = 'block';
                    this.mediaPlayer = this.videoPlayer;
                }
            } else {
                // File handle is lost (page was refreshed)
                throw new Error('File handle lost. Please reload the Download folder.');
            }
            
            // Update media info
            this.mediaInfo.textContent = `Now Playing: ${file.name} (${file.source})`;
            
            // Load media
            this.mediaPlayer.load();
            
            botReply(`Selected: ${file.name}`);
            
        } catch (error) {
            console.error('Error selecting media:', error);
            this.mediaInfo.textContent = `Error: ${error.message}`;
           
        }
    }

    /**
     * Play media
     */
    playMedia() {
        if (!this.mediaPlayer) {
            botReply('No media selected');
            return;
        }
        
        this.mediaPlayer.play();
        this.isPlaying = true;
        botReply('Playing media');
    }

    /**
     * Pause media
     */
    pauseMedia() {
        if (!this.mediaPlayer) {
            botReply('No media selected');
            return;
        }
        
        this.mediaPlayer.pause();
        this.isPlaying = false;
        botReply('Media paused');
    }

    /**
     * Stop media
     */
    stopMedia() {
        if (!this.mediaPlayer) {
            botReply('No media selected');
            return;
        }
        
        this.mediaPlayer.pause();
        this.mediaPlayer.currentTime = 0;
        this.isPlaying = false;
        this.updateProgressBar();
        botReply('Media stopped');
    }

    /**
     * Seek media
     */
    seekMedia() {
        if (!this.mediaPlayer) return;
        
        const seekTime = (this.progressBar.value / 100) * this.mediaPlayer.duration;
        this.mediaPlayer.currentTime = seekTime;
    }

    /**
     * Change volume
     */
    changeVolume() {
        if (!this.mediaPlayer) return;
        
        const volume = this.volumeSlider.value / 100;
        this.mediaPlayer.volume = volume;
    }

    /**
     * Update progress bar
     */
    updateProgressBar() {
        if (!this.mediaPlayer) return;
        
        const progress = (this.mediaPlayer.currentTime / this.mediaPlayer.duration) * 100;
        this.progressBar.value = progress || 0;
        this.updateTimeDisplay();
    }

    /**
     * Update time display
     */
    updateTimeDisplay() {
        if (!this.mediaPlayer) return;
        
        this.currentTime.textContent = this.formatTime(this.mediaPlayer.currentTime);
        this.duration.textContent = this.formatTime(this.mediaPlayer.duration);
    }

    /**
     * Format time as MM:SS
     */
    formatTime(seconds) {
        if (isNaN(seconds)) return '0:00';
        
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    /**
     * Format file size
     */
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Handle media ended event
     */
    onMediaEnded() {
        this.isPlaying = false;
        this.progressBar.value = 0;
        this.currentTime.textContent = '0:00';
        botReply('Media finished playing');
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 10px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.key === ' ' && this.mediaPlayer) {
            event.preventDefault();
            if (this.isPlaying) {
                this.pauseMedia();
            } else {
                this.playMedia();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Stop any playing media
        if (this.audioPlayer) {
            this.audioPlayer.pause();
        }
        if (this.videoPlayer) {
            this.videoPlayer.pause();
        }
        
        // Revoke any object URLs
        if (this.mediaPlayer && this.mediaPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(this.mediaPlayer.src);
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.fileInput = null;
        this.uploadButton = null;
        this.loadFromFolderButton = null;
        this.mediaList = null;
        this.audioPlayer = null;
        this.videoPlayer = null;
        this.mediaControls = null;
        this.playButton = null;
        this.pauseButton = null;
        this.stopButton = null;
        this.volumeSlider = null;
        this.progressBar = null;
        this.timeDisplay = null;
        this.currentMedia = null;
        this.mediaFiles = [];
        this.directoryHandle = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Media Player closed. Thank you!");
    }
}

// Create a singleton instance
const songsVideosScreenLoader = new SongsVideosScreenLoader();

// Add this to your AI's command handling
if (/media player|music player|video player|play songs|play videos/i.test(userInputRaw)) {
    songsVideosScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    songsVideosScreenLoader.closeGame();
    return;
}

class CaptureScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'CODE CAPTURE',
            instructions: 'Capture, edit, and analyze code from developer tools. Supports syntax highlighting and code analysis.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.codeInput = null;
        this.codeDisplay = null;
        this.languageSelect = null;
        this.captureButton = null;
        this.clearButton = null;
        this.copyButton = null;
        this.analyzeButton = null;
        this.outputDiv = null;
        this.currentCode = '';
        this.currentLanguage = 'javascript';
        this.capturedSnippets = [];
        this.storageKey = 'capturedCodeSnippets';
    }

    /**
     * Load the Code Capture Screen
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createCaptureScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.loadCapturedSnippets();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }

    /**
     * Create the Code Capture UI
     */
    createCaptureScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #1e1e1e;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 900px;
            max-width: 95vw;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
            color: #d4d4d4;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Code Capture Tool';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #ffffff;
            font-size: 24px;
        `;
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Capture and analyze code from developer tools (F12)';
        subtitle.style.cssText = `
            margin: 0;
            color: #cccccc;
            font-size: 16px;
        `;
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);

        // Instructions section
        const instructionsSection = document.createElement('div');
        instructionsSection.style.cssText = `
            background-color: #2d2d30;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #007acc;
        `;
        instructionsSection.innerHTML = `
            <strong style="color: #ffffff;">How to capture code:</strong><br>
            1. Open developer tools (F12) in your browser<br>
            2. Copy the code you want to capture<br>
            3. Paste it in the input area below<br>
            4. Select the programming language<br>
            5. Click "Capture Code" to format and analyze
        `;
        baseContainer.appendChild(instructionsSection);

        // Language selection
        const languageSection = document.createElement('div');
        languageSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const languageLabel = document.createElement('label');
        languageLabel.textContent = 'Programming Language:';
        languageLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.languageSelect = document.createElement('select');
        this.languageSelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            background-color: #1e1e1e;
            color: #d4d4d4;
            box-sizing: border-box;
        `;
        const languages = [
            { value: 'javascript', text: 'JavaScript' },
            { value: 'html', text: 'HTML' },
            { value: 'css', text: 'CSS' },
            { value: 'python', text: 'Python' },
            { value: 'java', text: 'Java' },
            { value: 'cpp', text: 'C++' },
            { value: 'csharp', text: 'C#' },
            { value: 'php', text: 'PHP' },
            { value: 'ruby', text: 'Ruby' },
            { value: 'go', text: 'Go' },
            { value: 'rust', text: 'Rust' },
            { value: 'typescript', text: 'TypeScript' },
            { value: 'json', text: 'JSON' },
            { value: 'xml', text: 'XML' },
            { value: 'sql', text: 'SQL' },
            { value: 'bash', text: 'Bash' },
            { value: 'markdown', text: 'Markdown' }
        ];
        languages.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang.value;
            option.textContent = lang.text;
            this.languageSelect.appendChild(option);
        });
        this.languageSelect.addEventListener('change', (e) => {
            this.currentLanguage = e.target.value;
        });
        languageSection.appendChild(languageLabel);
        languageSection.appendChild(this.languageSelect);
        baseContainer.appendChild(languageSection);

        // Code input area
        const inputSection = document.createElement('div');
        inputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const inputLabel = document.createElement('label');
        inputLabel.textContent = 'Paste Your Code Here:';
        inputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.codeInput = document.createElement('textarea');
        this.codeInput.style.cssText = `
            width: 100%;
            height: 200px;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            resize: vertical;
            box-sizing: border-box;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        `;
        this.codeInput.placeholder = `// Paste your code here
// For example:
function helloWorld() {
    console.log("Hello, World!");
}`;
        this.codeInput.addEventListener('input', () => {
            this.currentCode = this.codeInput.value;
        });
        inputSection.appendChild(inputLabel);
        inputSection.appendChild(this.codeInput);
        baseContainer.appendChild(inputSection);

        // Action buttons
        const buttonSection = document.createElement('div');
        buttonSection.style.cssText = `
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        `;
        this.captureButton = this.createButton('Capture Code', '#007acc', () => {
            this.captureCode();
        });
        this.clearButton = this.createButton('Clear', '#dc3545', () => {
            this.clearCode();
        });
        this.copyButton = this.createButton('Copy', '#28a745', () => {
            this.copyCode();
        });
        this.analyzeButton = this.createButton('Analyze', '#ffc107', () => {
            this.analyzeCode();
        });
        buttonSection.appendChild(this.captureButton);
        buttonSection.appendChild(this.clearButton);
        buttonSection.appendChild(this.copyButton);
        buttonSection.appendChild(this.analyzeButton);
        baseContainer.appendChild(buttonSection);

        // Code display area
        const displaySection = document.createElement('div');
        displaySection.style.cssText = `
            margin-bottom: 20px;
        `;
        const displayLabel = document.createElement('label');
        displayLabel.textContent = 'Formatted Code:';
        displayLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.codeDisplay = document.createElement('pre');
        this.codeDisplay.style.cssText = `
            width: 100%;
            min-height: 150px;
            max-height: 300px;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            overflow: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        `;
        this.codeDisplay.textContent = '// Your formatted code will appear here';
        displaySection.appendChild(displayLabel);
        displaySection.appendChild(this.codeDisplay);
        baseContainer.appendChild(displaySection);

        // Output section
        const outputSection = document.createElement('div');
        outputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const outputLabel = document.createElement('label');
        outputLabel.textContent = 'Analysis Output:';
        outputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.outputDiv = document.createElement('div');
        this.outputDiv.style.cssText = `
            width: 100%;
            min-height: 100px;
            max-height: 200px;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            background-color: #1e1e1e;
            color: #d4d4d4;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        `;
        this.outputDiv.textContent = '// Code analysis results will appear here';
        outputSection.appendChild(outputLabel);
        outputSection.appendChild(this.outputDiv);
        baseContainer.appendChild(outputSection);

        // Captured snippets section
        const snippetsSection = document.createElement('div');
        snippetsSection.style.cssText = `
            margin-top: auto;
        `;
        const snippetsLabel = document.createElement('label');
        snippetsLabel.textContent = 'Captured Snippets:';
        snippetsLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.snippetsList = document.createElement('div');
        this.snippetsList.style.cssText = `
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #2d2d30;
            padding: 10px;
        `;
        this.snippetsList.textContent = 'No captured snippets yet';
        snippetsSection.appendChild(snippetsLabel);
        snippetsSection.appendChild(this.snippetsList);
        baseContainer.appendChild(snippetsSection);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Capture and format the code
     */
    captureCode() {
        if (!this.currentCode.trim()) {
            this.outputDiv.textContent = '// Error: No code to capture';
            return;
        }

        // Format the code with syntax highlighting
        const formattedCode = this.formatCode(this.currentCode, this.currentLanguage);
        this.codeDisplay.innerHTML = formattedCode;

        // Save to captured snippets
        const snippet = {
            id: Date.now(),
            code: this.currentCode,
            language: this.currentLanguage,
            timestamp: new Date().toLocaleString(),
            lines: this.currentCode.split('\n').length
        };
        this.capturedSnippets.push(snippet);
        this.saveCapturedSnippets();
        this.updateSnippetsList();

        // Basic analysis
        this.analyzeCode();

        botReply(`Code captured successfully (${snippet.lines} lines of ${this.currentLanguage})`);
    }

    /**
     * Format code with syntax highlighting
     */
    formatCode(code, language) {
        let formatted = code
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');

        // Apply language-specific highlighting
        switch (language) {
            case 'javascript':
            case 'typescript':
                formatted = this.highlightJavaScript(formatted);
                break;
            case 'html':
                formatted = this.highlightHTML(formatted);
                break;
            case 'css':
                formatted = this.highlightCSS(formatted);
                break;
            case 'python':
                formatted = this.highlightPython(formatted);
                break;
            case 'json':
                formatted = this.highlightJSON(formatted);
                break;
            case 'sql':
                formatted = this.highlightSQL(formatted);
                break;
            default:
                // Generic highlighting for other languages
                formatted = this.highlightGeneric(formatted);
        }

        return formatted;
    }

    /**
     * Highlight JavaScript/TypeScript code
     */
    highlightJavaScript(code) {
        // Keywords
        const keywords = /\b(function|var|let|const|if|else|for|while|do|switch|case|break|continue|return|try|catch|finally|class|extends|import|export|default|async|await|new|this|super|typeof|instanceof|in|of|delete|void|yield|debugger)\b/g;
        code = code.replace(keywords, '<span style="color: #569cd6;">$&</span>');

        // Strings
        const strings = /(['"`])((?:(?!\1)[^\\]|\\.)*)(\1)/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$1$2$3</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*|0x[0-9a-fA-F]+)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments
        const comments = /(\/\/.*$|\/\*[\s\S]*?\*\/)/gm;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        // Functions
        const functions = /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        code = code.replace(functions, '<span style="color: #dcdcaa;">$1</span>(');

        return code;
    }

    /**
     * Highlight HTML code
     */
    highlightHTML(code) {
        // Tags
        const tags = /(&lt;\/?[a-zA-Z0-9]+&gt;)/g;
        code = code.replace(tags, '<span style="color: #569cd6;">$&</span>');

        // Attributes
        const attributes = /\b([a-zA-Z-]+)=["'][^"']*["']/g;
        code = code.replace(attributes, '<span style="color: #9cdcfe;">$1</span>=');

        // Strings in attributes
        const attrStrings = /=["']([^"']*)["']/g;
        code = code.replace(attrStrings, '=<span style="color: #ce9178;">"$1"</span>');

        // Comments
        const comments = /(&lt;!--[\s\S]*?--&gt;)/g;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Highlight CSS code
     */
    highlightCSS(code) {
        // Selectors
        const selectors = /([^{]+)\{/g;
        code = code.replace(selectors, '<span style="color: #d7ba7d;">$1</span>{');

        // Properties
        const properties = /\b([a-zA-Z-]+)\s*:/g;
        code = code.replace(properties, '<span style="color: #9cdcfe;">$1</span>:');

        // Values
        const values = /:\s*([^;]+);/g;
        code = code.replace(values, ': <span style="color: #ce9178;">$1</span>;');

        // Numbers in values
        const numbers = /\b(\d+\.?\d*)(px|em|rem|%|vh|vw|pt|pc|in|cm|mm)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$1$2</span>');

        // Colors
        const colors = /#[0-9a-fA-F]{3,6}\b/g;
        code = code.replace(colors, '<span style="color: #ce9178;">$&</span>');

        // Comments
        const comments = /\/\*[\s\S]*?\*\//g;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Highlight Python code
     */
    highlightPython(code) {
        // Keywords
        const keywords = /\b(def|class|if|elif|else|for|while|try|except|finally|with|as|import|from|return|yield|raise|assert|del|pass|break|continue|and|or|not|in|is|lambda|global|nonlocal)\b/g;
        code = code.replace(keywords, '<span style="color: #569cd6;">$&</span>');

        // Strings
        const strings = /('''|"""|'|"")((?:(?!\1)[^\\]|\\.)*)(\1)/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$1$2$3</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments
        const comments = /(#.*$)/gm;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        // Functions
        const functions = /\bdef\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        code = code.replace(functions, 'def <span style="color: #dcdcaa;">$1</span>');

        return code;
    }

    /**
     * Highlight JSON code
     */
    highlightJSON(code) {
        // Strings
        const strings = /"([^"]*)":/g;
        code = code.replace(strings, '<span style="color: #9cdcfe;">"$1"</span>:');

        // String values
        const values = /:\s*"([^"]*)"/g;
        code = code.replace(values, ': <span style="color: #ce9178;">"$1"</span>');

        // Numbers
        const numbers = /:\s*(\d+\.?\d*)/g;
        code = code.replace(numbers, ': <span style="color: #b5cea8;">$1</span>');

        // Booleans
        const booleans = /:\s*(true|false|null)/g;
        code = code.replace(booleans, ': <span style="color: #569cd6;">$1</span>');

        return code;
    }

    /**
     * Highlight SQL code
     */
    highlightSQL(code) {
        // Keywords
        const keywords = /\b(SELECT|FROM|WHERE|INSERT|INTO|VALUES|UPDATE|SET|DELETE|CREATE|TABLE|DROP|ALTER|JOIN|INNER|LEFT|RIGHT|FULL|OUTER|ON|GROUP|BY|ORDER|HAVING|LIMIT|OFFSET|UNION|ALL|DISTINCT|AS|AND|OR|NOT|IN|EXISTS|BETWEEN|LIKE|IS|NULL)\b/gi;
        code = code.replace(keywords, '<span style="color: #569cd6;">$&</span>');

        // Strings
        const strings = /'[^']*'/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$&</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments
        const comments = /(--.*$|\/\*[\s\S]*?\*\/)/gm;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Generic highlighting for other languages
     */
    highlightGeneric(code) {
        // Strings
        const strings = /(['"`])((?:(?!\1)[^\\]|\\.)*)(\1)/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$1$2$3</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments (// style)
        const lineComments = /\/\/.*$/gm;
        code = code.replace(lineComments, '<span style="color: #6a9955;">$&</span>');

        // Comments (/* */ style)
        const blockComments = /\/\*[\s\S]*?\*\//g;
        code = code.replace(blockComments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Analyze the captured code
     */
    analyzeCode() {
        if (!this.currentCode.trim()) {
            this.outputDiv.textContent = '// Error: No code to analyze';
            return;
        }

        let analysis = `// Code Analysis Results\n`;
        analysis += `// Language: ${this.currentLanguage.toUpperCase()}\n`;
        analysis += `// Lines: ${this.currentCode.split('\n').length}\n`;
        analysis += `// Characters: ${this.currentCode.length}\n\n`;

        // Basic analysis based on language
        switch (this.currentLanguage) {
            case 'javascript':
            case 'typescript':
                analysis += this.analyzeJavaScript();
                break;
            case 'html':
                analysis += this.analyzeHTML();
                break;
            case 'css':
                analysis += this.analyzeCSS();
                break;
            case 'python':
                analysis += this.analyzePython();
                break;
            case 'json':
                analysis += this.analyzeJSON();
                break;
            case 'sql':
                analysis += this.analyzeSQL();
                break;
            default:
                analysis += '// Basic analysis completed\n';
        }

        this.outputDiv.textContent = analysis;
    }

    /**
     * Analyze JavaScript code
     */
    analyzeJavaScript() {
        let analysis = '// JavaScript Analysis:\n';
        
        // Count functions
        const functionCount = (this.currentCode.match(/\bfunction\b/g) || []).length;
        analysis += `// Functions: ${functionCount}\n`;
        
        // Count variables
        const varCount = (this.currentCode.match(/\b(var|let|const)\b/g) || []).length;
        analysis += `// Variables: ${varCount}\n`;
        
        // Check for async/await
        const hasAsync = /async/.test(this.currentCode);
        analysis += `// Uses async/await: ${hasAsync ? 'Yes' : 'No'}\n`;
        
        // Check for promises
        const hasPromises = /Promise/.test(this.currentCode);
        analysis += `// Uses Promises: ${hasPromises ? 'Yes' : 'No'}\n`;
        
        // Check for arrow functions
        const arrowCount = (this.currentCode.match(/=>/g) || []).length;
        analysis += `// Arrow functions: ${arrowCount}\n`;
        
        return analysis;
    }

    /**
     * Analyze HTML code
     */
    analyzeHTML() {
        let analysis = '// HTML Analysis:\n';
        
        // Count tags
        const tagCount = (this.currentCode.match(/&lt;\/?[a-zA-Z0-9]+&gt;/g) || []).length;
        analysis += `// HTML tags: ${tagCount}\n`;
        
        // Check for common tags
        const hasDiv = /&lt;div/i.test(this.currentCode);
        analysis += `// Contains div elements: ${hasDiv ? 'Yes' : 'No'}\n`;
        
        const hasForm = /&lt;form/i.test(this.currentCode);
        analysis += `// Contains forms: ${hasForm ? 'Yes' : 'No'}\n`;
        
        const hasScript = /&lt;script/i.test(this.currentCode);
        analysis += `// Contains scripts: ${hasScript ? 'Yes' : 'No'}\n`;
        
        const hasStyle = /&lt;style/i.test(this.currentCode);
        analysis += `// Contains styles: ${hasStyle ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Analyze CSS code
     */
    analyzeCSS() {
        let analysis = '// CSS Analysis:\n';
        
        // Count selectors
        const selectorCount = (this.currentCode.match(/[^{]+(?=\{)/g) || []).length;
        analysis += `// CSS selectors: ${selectorCount}\n`;
        
        // Count properties
        const propertyCount = (this.currentCode.match(/[a-zA-Z-]+(?=:)/g) || []).length;
        analysis += `// CSS properties: ${propertyCount}\n`;
        
        // Check for media queries
        const hasMediaQueries = /@media/.test(this.currentCode);
        analysis += `// Contains media queries: ${hasMediaQueries ? 'Yes' : 'No'}\n`;
        
        // Check for animations
        const hasAnimations = /@keyframes|animation/.test(this.currentCode);
        analysis += `// Contains animations: ${hasAnimations ? 'Yes' : 'No'}\n`;
        
        // Check for flexbox
        const hasFlexbox = /display:\s*flex/i.test(this.currentCode);
        analysis += `// Uses flexbox: ${hasFlexbox ? 'Yes' : 'No'}\n`;
        
        // Check for grid
        const hasGrid = /display:\s*grid/i.test(this.currentCode);
        analysis += `// Uses grid: ${hasGrid ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Analyze Python code
     */
    analyzePython() {
        let analysis = '// Python Analysis:\n';
        
        // Count functions
        const functionCount = (this.currentCode.match(/\bdef\b/g) || []).length;
        analysis += `// Functions: ${functionCount}\n`;
        
        // Count classes
        const classCount = (this.currentCode.match(/\bclass\b/g) || []).length;
        analysis += `// Classes: ${classCount}\n`;
        
        // Check for imports
        const importCount = (this.currentCode.match(/\bimport\b/g) || []).length;
        analysis += `// Import statements: ${importCount}\n`;
        
        // Check for loops
        const forCount = (this.currentCode.match(/\bfor\b/g) || []).length;
        const whileCount = (this.currentCode.match(/\bwhile\b/g) || []).length;
        analysis += `// For loops: ${forCount}\n`;
        analysis += `// While loops: ${whileCount}\n`;
        
        // Check for comprehensions
        const hasComprehensions = /\[.*for.*in.*\]/.test(this.currentCode);
        analysis += `// Uses comprehensions: ${hasComprehensions ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Analyze JSON code
     */
    analyzeJSON() {
        let analysis = '// JSON Analysis:\n';
        
        try {
            const parsed = JSON.parse(this.currentCode);
            
            // Check if it's an object or array
            if (Array.isArray(parsed)) {
                analysis += `// Type: Array\n`;
                analysis += `// Elements: ${parsed.length}\n`;
            } else if (typeof parsed === 'object' && parsed !== null) {
                analysis += `// Type: Object\n`;
                analysis += `// Properties: ${Object.keys(parsed).length}\n`;
            }
            
            // Check for nested structures
            const hasNested = JSON.stringify(parsed).includes('{');
            analysis += `// Has nested structures: ${hasNested ? 'Yes' : 'No'}\n`;
            
        } catch (error) {
            analysis += `// Invalid JSON: ${error.message}\n`;
        }
        
        return analysis;
    }

    /**
     * Analyze SQL code
     */
    analyzeSQL() {
        let analysis = '// SQL Analysis:\n';
        
        // Check for SELECT statements
        const hasSelect = /SELECT/i.test(this.currentCode);
        analysis += `// Contains SELECT: ${hasSelect ? 'Yes' : 'No'}\n`;
        
        // Check for JOINs
        const joinCount = (this.currentCode.match(/JOIN/gi) || []).length;
        analysis += `// JOINs: ${joinCount}\n`;
        
        // Check for subqueries
        const hasSubqueries = /\(.*SELECT/i.test(this.currentCode);
        analysis += `// Contains subqueries: ${hasSubqueries ? 'Yes' : 'No'}\n`;
        
        // Check for aggregations
        const hasAggregations = /(COUNT|SUM|AVG|MIN|MAX)/i.test(this.currentCode);
        analysis += `// Uses aggregations: ${hasAggregations ? 'Yes' : 'No'}\n`;
        
        // Check for GROUP BY
        const hasGroupBy = /GROUP BY/i.test(this.currentCode);
        analysis += `// Uses GROUP BY: ${hasGroupBy ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Clear the code input and display
     */
    clearCode() {
        this.currentCode = '';
        this.codeInput.value = '';
        this.codeDisplay.textContent = '// Your formatted code will appear here';
        this.outputDiv.textContent = '// Code analysis results will appear here';
        botReply('Code cleared');
    }

    /**
     * Copy the formatted code to clipboard
     */
    copyCode() {
        if (!this.currentCode.trim()) {
            botReply('No code to copy');
            return;
        }

        if (navigator.clipboard) {
            navigator.clipboard.writeText(this.currentCode)
                .then(() => {
                    botReply('Code copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(this.currentCode);
                });
        } else {
            this.fallbackCopyTextToClipboard(this.currentCode);
        }
    }

    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Code copied to clipboard!');
            } else {
                botReply('Unable to copy code');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy code');
        }
        document.body.removeChild(textArea);
    }

    /**
     * Save captured snippets to localStorage
     */
    saveCapturedSnippets() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.capturedSnippets));
        } catch (error) {
            console.error('Error saving captured snippets:', error);
        }
    }

    /**
     * Load captured snippets from localStorage
     */
    loadCapturedSnippets() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
                this.capturedSnippets = JSON.parse(stored);
                this.updateSnippetsList();
            }
        } catch (error) {
            console.error('Error loading captured snippets:', error);
        }
    }

    /**
     * Update the snippets list display
     */
    updateSnippetsList() {
        this.snippetsList.innerHTML = '';
        
        if (this.capturedSnippets.length === 0) {
            this.snippetsList.textContent = 'No captured snippets yet';
            return;
        }
        
        this.capturedSnippets.forEach(snippet => {
            const item = document.createElement('div');
            item.style.cssText = `
                padding: 8px;
                margin-bottom: 5px;
                background-color: #1e1e1e;
                border-radius: 5px;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: background-color 0.2s;
            `;
            item.addEventListener('mouseenter', () => {
                item.style.backgroundColor = '#2d2d30';
            });
            item.addEventListener('mouseleave', () => {
                item.style.backgroundColor = '#1e1e1e';
            });
            
            const snippetInfo = document.createElement('div');
            snippetInfo.style.cssText = `
                flex-grow: 1;
            `;
            const snippetTitle = document.createElement('div');
            snippetTitle.textContent = `${snippet.language.toUpperCase()} - ${snippet.lines} lines`;
            snippetTitle.style.cssText = `
                font-weight: bold;
                margin-bottom: 2px;
                color: #ffffff;
            `;
            const snippetDetails = document.createElement('div');
            snippetDetails.textContent = snippet.timestamp;
            snippetDetails.style.cssText = `
                font-size: 12px;
                color: #999999;
            `;
            snippetInfo.appendChild(snippetTitle);
            snippetInfo.appendChild(snippetDetails);
            
            const loadButton = document.createElement('button');
            loadButton.textContent = 'Load';
            loadButton.style.cssText = `
                padding: 4px 8px;
                background-color: #007acc;
                color: white;
                border: none;
                border-radius: 3px;
                cursor: pointer;
                font-size: 12px;
            `;
            loadButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.loadSnippet(snippet);
            });
            
            item.appendChild(snippetInfo);
            item.appendChild(loadButton);
            this.snippetsList.appendChild(item);
        });
    }

    /**
     * Load a captured snippet
     */
    loadSnippet(snippet) {
        this.currentCode = snippet.code;
        this.currentLanguage = snippet.language;
        this.codeInput.value = snippet.code;
        this.languageSelect.value = snippet.language;
        botReply(`Loaded snippet: ${snippet.language.toUpperCase()} - ${snippet.lines} lines`);
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 10px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.ctrlKey && event.key === 'Enter') {
            event.preventDefault();
            this.captureCode();
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.codeInput = null;
        this.codeDisplay = null;
        this.languageSelect = null;
        this.captureButton = null;
        this.clearButton = null;
        this.copyButton = null;
        this.analyzeButton = null;
        this.outputDiv = null;
        this.snippetsList = null;
        this.currentCode = '';
        this.currentLanguage = 'javascript';
        this.capturedSnippets = [];
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Code Capture Tool closed. Thank you!");
    }
}

// Create a singleton instance
const captureScreenLoader = new CaptureScreenLoader();

// Add this to your AI's command handling
if (/code capture|capture code|f12 capture|developer tools/i.test(userInputRaw)) {
    captureScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    captureScreenLoader.closeGame();
    return;
}





class FileConverter {
constructor() {
this.baseScreen = {
name: 'FILE CONVERTER',
instructions: 'Convert images, text, or create Excel/DOCX files. Supports multiple formats.'
};

this.gameContainer = null;
this.isActive = false;
this.isFullscreen = false;
this.fullscreenButton = null;
this.closeButton = null;
this.fileInput = null;
this.textInput = null;
this.convertButton = null;
this.clearButton = null;
this.downloadButton = null;
this.imagePreview = null;
this.outputDiv = null;
this.selectedFiles = [];
this.conversionMode = 'image'; // 'image', 'text', 'excel', 'docx'
this.fileBlob = null;
}

/**
* Load the File Converter
*/
loadBaseScreen() {
if (this.isActive) {
botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
return;
}

this.createGameContainer();
this.createConverterScreen();
this.setupActionButtons();
this.displayGame();

this.isActive = true;
botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
}

/**
* Create the game container
*/
createGameContainer() {
const existingContainer = document.getElementById('screen-container');
if (existingContainer) {
existingContainer.remove();
}

this.gameContainer = document.createElement('div');
this.gameContainer.id = 'screen-container';
this.gameContainer.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.8);
z-index: 9999;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
transition: all 0.3s ease;
`;
}

/**
* Create the Converter UI
*/
createConverterScreen() {
const baseContainer = document.createElement('div');
baseContainer.style.cssText = `
background-color: #f5f5f5;
border-radius: 10px;
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
padding: 20px;
width: 700px;
max-width: 90vw;
max-height: 80vh;
display: flex;
flex-direction: column;
`;

// Header
const header = document.createElement('div');
header.style.cssText = `
text-align: center;
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid #ddd;
`;

const title = document.createElement('h2');
title.textContent = 'File Converter';
title.style.cssText = `
margin: 0 0 10px 0;
color: #333;
font-size: 24px;
`;

const subtitle = document.createElement('p');
subtitle.textContent = 'Convert files to PDF, Excel, or DOCX format';
subtitle.style.cssText = `
margin: 0;
color: #666;
font-size: 16px;
`;

header.appendChild(title);
header.appendChild(subtitle);
baseContainer.appendChild(header);

// Conversion mode selector
const modeSection = document.createElement('div');
modeSection.style.cssText = `
margin-bottom: 15px;
display: flex;
justify-content: center;
gap: 15px;
flex-wrap: wrap;
`;

// Image mode
const imageModeLabel = this.createModeLabel('Image to PDF', 'image', true);
modeSection.appendChild(imageModeLabel);

// Text mode
const textModeLabel = this.createModeLabel('Text to PDF', 'text', false);
modeSection.appendChild(textModeLabel);

// Excel mode
const excelModeLabel = this.createModeLabel('Create Excel', 'excel', false);
modeSection.appendChild(excelModeLabel);

// DOCX mode
const docxModeLabel = this.createModeLabel('Create DOCX', 'docx', false);
modeSection.appendChild(docxModeLabel);

baseContainer.appendChild(modeSection);

// Image input section (initially visible)
this.imageSection = document.createElement('div');
this.imageSection.id = 'imageSection';

const uploadLabel = document.createElement('label');
uploadLabel.textContent = 'Select Images:';
uploadLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.fileInput = document.createElement('input');
this.fileInput.type = 'file';
this.fileInput.multiple = true;
this.fileInput.accept = 'image/*';
this.fileInput.style.cssText = `
width: 100%;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
margin-bottom: 10px;
`;

this.fileInput.addEventListener('change', (e) => {
this.handleFileSelect(e);
});

this.imageSection.appendChild(uploadLabel);
this.imageSection.appendChild(this.fileInput);
baseContainer.appendChild(this.imageSection);

// Text input section (initially hidden)
this.textSection = document.createElement('div');
this.textSection.id = 'textSection';
this.textSection.style.display = 'none';

const textLabel = document.createElement('label');
textLabel.textContent = 'Enter Text:';
textLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.textInput = document.createElement('textarea');
this.textInput.placeholder = 'Enter text to convert to PDF...';
this.textInput.style.cssText = `
width: 100%;
height: 120px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.textSection.appendChild(textLabel);
this.textSection.appendChild(this.textInput);
baseContainer.appendChild(this.textSection);

// Excel input section (initially hidden)
this.excelSection = document.createElement('div');
this.excelSection.id = 'excelSection';
this.excelSection.style.display = 'none';

const excelLabel = document.createElement('label');
excelLabel.textContent = 'Excel Data (CSV format):';
excelLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.excelInput = document.createElement('textarea');
this.excelInput.placeholder = 'Enter data in CSV format:\nName,Age,City\nJohn,25,New York\nJane,30,Los Angeles';
this.excelInput.style.cssText = `
width: 100%;
height: 120px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.excelSection.appendChild(excelLabel);
this.excelSection.appendChild(this.excelInput);
baseContainer.appendChild(this.excelSection);

// DOCX input section (initially hidden)
this.docxSection = document.createElement('div');
this.docxSection.id = 'docxSection';
this.docxSection.style.display = 'none';

const docxLabel = document.createElement('label');
docxLabel.textContent = 'Document Content:';
docxLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.docxInput = document.createElement('textarea');
this.docxInput.placeholder = 'Enter document content...';
this.docxInput.style.cssText = `
width: 100%;
height: 120px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.docxSection.appendChild(docxLabel);
this.docxSection.appendChild(this.docxInput);
baseContainer.appendChild(this.docxSection);

// Preview area (for images)
this.imagePreview = document.createElement('div');
this.imagePreview.style.cssText = `
width: 100%;
min-height: 120px;
max-height: 200px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
overflow-y: auto;
margin-bottom: 15px;
display: flex;
flex-wrap: wrap;
gap: 10px;
`;

this.imagePreview.textContent = 'No images selected';
baseContainer.appendChild(this.imagePreview);

// Button grid
const buttonGrid = document.createElement('div');
buttonGrid.style.cssText = `
display: grid;
grid-template-columns: repeat(3, 1fr);
grid-gap: 10px;
margin-bottom: 15px;
`;

// Convert button
this.convertButton = this.createButton('Convert to PDF', '#4CAF50', () => {
this.convertFile();
});

// Clear button
this.clearButton = this.createButton('Clear', '#f44336', () => {
this.clearFields();
});

// Download button (initially disabled)
this.downloadButton = this.createButton('Download File', '#2196F3', () => {
this.downloadFile();
});
this.downloadButton.disabled = true;
this.downloadButton.style.opacity = '0.5';
this.downloadButton.style.cursor = 'not-allowed';

buttonGrid.appendChild(this.convertButton);
buttonGrid.appendChild(this.clearButton);
buttonGrid.appendChild(this.downloadButton);

baseContainer.appendChild(buttonGrid);

// Output section
const outputSection = document.createElement('div');
outputSection.style.cssText = `
margin-bottom: 15px;
`;

const outputLabel = document.createElement('label');
outputLabel.textContent = 'Status:';
outputLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.outputDiv = document.createElement('div');
this.outputDiv.style.cssText = `
width: 100%;
min-height: 80px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
`;

this.outputDiv.textContent = 'Ready to convert files';

outputSection.appendChild(outputLabel);
outputSection.appendChild(this.outputDiv);
baseContainer.appendChild(outputSection);

// Info section
const infoSection = document.createElement('div');
infoSection.style.cssText = `
background-color: #e3f2fd;
border-radius: 5px;
padding: 10px;
font-size: 14px;
color: #1976d2;
border-left: 4px solid #2196F3;
`;

infoSection.innerHTML = `
<strong>Instructions:</strong><br>
            • Select conversion mode: Image, Text, Excel, or DOCX<br>
            • For images: Select one or more images<br>
            • For text: Enter your text in the text area<br>
            • For Excel: Enter data in CSV format<br>
            • For DOCX: Enter document content<br>
            • Click "Convert" to process and "Download" to save
        `;

        baseContainer.appendChild(infoSection);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Create a mode label with radio button
     */
    createModeLabel(text, value, isChecked) {
        const label = document.createElement('label');
        label.style.cssText = `
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;

        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'conversionMode';
        radio.value = value;
        radio.checked = isChecked;
        radio.style.marginRight = '5px';

        radio.addEventListener('change', () => {
            this.setConversionMode(value);
        });

        label.appendChild(radio);
        label.appendChild(document.createTextNode(text));

        return label;
    }

    /**
     * Set conversion mode
     */
    setConversionMode(mode) {
        this.conversionMode = mode;

        // Hide all sections
        this.imageSection.style.display = 'none';
        this.textSection.style.display = 'none';
        this.excelSection.style.display = 'none';
        this.docxSection.style.display = 'none';
        this.imagePreview.style.display = 'none';

        // Show appropriate section and update UI
        switch (mode) {
            case 'image':
                this.imageSection.style.display = 'block';
                this.imagePreview.style.display = 'flex';
                this.convertButton.textContent = 'Convert to PDF';
                this.outputDiv.textContent = 'Ready to convert images to PDF';
                break;
            case 'text':
                this.textSection.style.display = 'block';
                this.convertButton.textContent = 'Convert to PDF';
                this.outputDiv.textContent = 'Ready to convert text to PDF';
                break;
            case 'excel':
                this.excelSection.style.display = 'block';
                this.convertButton.textContent = 'Create Excel File';
                this.outputDiv.textContent = 'Ready to create Excel file';
                break;
            case 'docx':
                this.docxSection.style.display = 'block';
                this.convertButton.textContent = 'Create DOCX File';
                this.outputDiv.textContent = 'Ready to create DOCX file';
                break;
        }

        // Reset download button
        this.downloadButton.disabled = true;
        this.downloadButton.style.opacity = '0.5';
        this.downloadButton.style.cursor = 'not-allowed';
        this.fileBlob = null;
    }

    /**
     * Handle file selection
     */
    handleFileSelect(event) {
        this.selectedFiles = Array.from(event.target.files);
        this.updateImagePreview();

        if (this.selectedFiles.length > 0) {
            this.outputDiv.textContent = `${this.selectedFiles.length} image(s) selected. Ready to convert.`;
        } else {
            this.outputDiv.textContent = 'No images selected.';
        }
    }

    /**
     * Update the image preview area
     */
    updateImagePreview() {
        this.imagePreview.innerHTML = '';

        if (this.selectedFiles.length === 0) {
            this.imagePreview.textContent = 'No images selected';
            return;
        }

        this.selectedFiles.forEach((file, index) => {
            const reader = new FileReader();

            reader.onload = (e) => {
                const imgContainer = document.createElement('div');
                imgContainer.style.cssText = `
                    position: relative;
                    width: 100px;
                    height: 100px;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    overflow: hidden;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                const img = document.createElement('img');
                img.src = e.target.result;
                img.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                `;

                const imgLabel = document.createElement('div');
                imgLabel.textContent = file.name;
                imgLabel.style.cssText = `
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    background-color: rgba(0, 0, 0, 0.7);
                    color: white;
                    font-size: 10px;
                    padding: 2px;
                    text-align: center;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                `;

                imgContainer.appendChild(img);
                imgContainer.appendChild(imgLabel);
                this.imagePreview.appendChild(imgContainer);
            };

            reader.readAsDataURL(file);
        });
    }

    /**
     * Convert file based on selected mode
     */
    convertFile() {
        switch (this.conversionMode) {
            case 'image':
                this.convertImagesToPdf();
                break;
            case 'text':
                this.convertTextToPdf();
                break;
            case 'excel':
                this.convertToExcel();
                break;
            case 'docx':
                this.convertToDocx();
                break;
        }
    }

    /**
     * Convert images to PDF
     */
    convertImagesToPdf() {
        if (this.selectedFiles.length === 0) {
            botReply('Please select at least one image to convert.');
            return;
        }

        this.outputDiv.textContent = 'Converting images to PDF...';

        if (typeof window.jsPDF === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js', () => {
                this.processImagesToPdf();
            });
        } else {
            this.processImagesToPdf();
        }
    }

    /**
     * Convert text to PDF
     */
    convertTextToPdf() {
        const text = this.textInput.value.trim();
        if (!text) {
            botReply('Please enter some text to convert.');
            return;
        }

        this.outputDiv.textContent = 'Converting text to PDF...';

        if (typeof window.jsPDF === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js', () => {
                this.processTextToPdf(text);
            });
        } else {
            this.processTextToPdf(text);
        }
    }

    /**
     * Convert to Excel
     */
    convertToExcel() {
        const csvData = this.excelInput.value.trim();
        if (!csvData) {
            botReply('Please enter some data to convert to Excel.');
            return;
        }

        this.outputDiv.textContent = 'Creating Excel file...';

        if (typeof window.XLSX === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js', () => {
                this.processToExcel(csvData);
            });
        } else {
            this.processToExcel(csvData);
        }
    }

    /**
     * Convert to DOCX
     */
    convertToDocx() {
        const docContent = this.docxInput.value.trim();
        if (!docContent) {
            botReply('Please enter some content to create a DOCX file.');
            return;
        }

        this.outputDiv.textContent = 'Creating DOCX file...';

        if (typeof window.docx === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js', () => {
                this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js', () => {
                    this.processToDocx(docContent);
                });
            });
        } else {
            this.processToDocx(docContent);
        }
    }

    /**
     * Process images to create PDF
     */
    processImagesToPdf() {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();

        let processedImages = 0;
        const totalImages = this.selectedFiles.length;

        this.selectedFiles.forEach((file, index) => {
            const reader = new FileReader();

            reader.onload = (e) => {
                const imgData = e.target.result;
                const imgProps = pdf.getImageProperties(imgData);
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

                if (index > 0) {
                    pdf.addPage();
                }

                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);

                processedImages++;
                this.outputDiv.textContent = `Processing image ${processedImages} of ${totalImages}...`;

                if (processedImages === totalImages) {
                    this.fileBlob = pdf.output('blob');
                    this.outputDiv.textContent = `PDF created successfully with ${totalImages} image(s).`;

                    this.downloadButton.disabled = false;
                    this.downloadButton.style.opacity = '1';
                    this.downloadButton.style.cursor = 'pointer';

                    botReply('Images converted to PDF successfully!');
                }
            };

            reader.readAsDataURL(file);
        });
    }

    /**
     * Process text to create PDF
     */
    processTextToPdf(text) {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();

        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const margin = 15;
        const maxWidth = pageWidth - 2 * margin;

        const lines = pdf.splitTextToSize(text, maxWidth);
        pdf.text(lines, margin, margin);

        this.fileBlob = pdf.output('blob');
        this.outputDiv.textContent = 'PDF created successfully from text.';

        this.downloadButton.disabled = false;
        this.downloadButton.style.opacity = '1';
        this.downloadButton.style.cursor = 'pointer';

        botReply('Text converted to PDF successfully!');
    }

    /**
     * Process CSV data to create Excel file
     */
    processToExcel(csvData) {
        // Parse CSV data
        const lines = csvData.split('\n');
        const data = [];

        lines.forEach(line => {
            const values = line.split(',');
            data.push(values);
        });

        // Create workbook
        const workbook = XLSX.utils.book_new();
        const worksheet = XLSX.utils.aoa_to_sheet(data);
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');

        // Generate Excel file
        const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        this.fileBlob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

        this.outputDiv.textContent = 'Excel file created successfully.';

        this.downloadButton.disabled = false;
        this.downloadButton.style.opacity = '1';
        this.downloadButton.style.cursor = 'pointer';

        botReply('Excel file created successfully!');
    }

    /**
     * Process text to create DOCX file
     */
    processToDocx(docContent) {
        // Create document
        const doc = new docx.Document({
            sections: [{
                properties: {},
                children: [
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun(docContent)
                        ],
                    }),
                ],
            }],
        });

        // Generate DOCX file
        docx.Packer.toBlob(doc).then(blob => {
            this.fileBlob = blob;

            this.outputDiv.textContent = 'DOCX file created successfully.';

            this.downloadButton.disabled = false;
            this.downloadButton.style.opacity = '1';
            this.downloadButton.style.cursor = 'pointer';

            botReply('DOCX file created successfully!');
        });
    }

    /**
     * Download the generated file
     */
    downloadFile() {
        if (!this.fileBlob) {
            botReply('No file available for download. Please convert files first.');
            return;
        }

        let fileName = 'converted-file';
        let fileExtension = '.pdf';

        switch (this.conversionMode) {
            case 'image':
                fileName = 'converted-images';
                fileExtension = '.pdf';
                break;
            case 'text':
                fileName = 'converted-text';
                fileExtension = '.pdf';
                break;
            case 'excel':
                fileName = 'converted-data';
                fileExtension = '.xlsx';
                break;
            case 'docx':
                fileName = 'converted-document';
                fileExtension = '.docx';
                break;
        }

        const url = URL.createObjectURL(this.fileBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName + fileExtension;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        botReply('File downloaded successfully!');
    }

    /**
     * Clear all fields and selections
     */
    clearFields() {
        this.fileInput.value = '';
        this.textInput.value = '';
        this.excelInput.value = '';
        this.docxInput.value = '';
        this.selectedFiles = [];
        this.imagePreview.innerHTML = '';
        this.imagePreview.textContent = 'No images selected';
        this.outputDiv.textContent = `Ready to convert ${this.conversionMode}`;
        this.fileBlob = null;

        this.downloadButton.disabled = true;
        this.downloadButton.style.opacity = '0.5';
        this.downloadButton.style.cursor = 'not-allowed';

        botReply('Fields cleared.');
    }

    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;

        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });

        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });

        button.addEventListener('click', clickHandler);

        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;

        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };

        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };

        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };

        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;

        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };

        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };

        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };

        floatingButtons.appendChild(this.closeButton);

        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);

        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);

        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;

        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;

        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;

        if (this.isFullscreen) {
            this.exitFullscreen();
        }

        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);

        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }

        this.gameContainer = null;
        this.fileInput = null;
        this.textInput = null;
        this.excelInput = null;
        this.docxInput = null;
        this.convertButton = null;
        this.clearButton = null;
        this.downloadButton = null;
        this.imagePreview = null;
        this.outputDiv = null;
        this.selectedFiles = [];
        this.fileBlob = null;
        this.conversionMode = 'image';
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;

        botReply("File Converter closed. Thank you!");
    }
}

// Create a singleton instance
const fileConverter = new FileConverter();

// Add this to your AI's command handling
if (/file converter|pdf convert|convert file|image to pdf|text to pdf|excel|docx|create excel|create docx/i.test(userInputRaw)) {
    fileConverter.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    fileConverter.closeGame();
    return;
}



class AllDocMount {
constructor() {
this.baseScreen = {
name: 'DOCUMENT MANAGER',
instructions: 'Upload, view, edit, download, and copy documents. Supports PDF, DOCX, TXT, and image files.'
};

this.gameContainer = null;
this.isActive = false;
this.isFullscreen = false;
this.fullscreenButton = null;
this.closeButton = null;
this.fileInput = null;
this.viewButton = null;
this.editButton = null;
this.copyButton = null;
this.downloadButton = null;
this.clearButton = null;
this.previewArea = null;
this.editorArea = null;
this.outputDiv = null;
this.currentFile = null;
this.fileContent = null;
this.fileType = null;
this.fileName = null;
this.isEditing = false;
}

/**
* Load the Document Manager
*/
loadBaseScreen() {
if (this.isActive) {
botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
return;
}

this.createGameContainer();
this.createDocManagerScreen();
this.setupActionButtons();
this.displayGame();

this.isActive = true;
botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
}

/**
* Create the game container
*/
createGameContainer() {
const existingContainer = document.getElementById('screen-container');
if (existingContainer) {
existingContainer.remove();
}

this.gameContainer = document.createElement('div');
this.gameContainer.id = 'screen-container';
this.gameContainer.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.8);
z-index: 9999;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
transition: all 0.3s ease;
`;
}

/**
* Create the Document Manager UI
*/
createDocManagerScreen() {
const baseContainer = document.createElement('div');
baseContainer.style.cssText = `
background-color: #f5f5f5;
border-radius: 10px;
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
padding: 20px;
width: 800px;
max-width: 90vw;
max-height: 80vh;
display: flex;
flex-direction: column;
`;

// Header
const header = document.createElement('div');
header.style.cssText = `
text-align: center;
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid #ddd;
`;

const title = document.createElement('h2');
title.textContent = 'Document Manager';
title.style.cssText = `
margin: 0 0 10px 0;
color: #333;
font-size: 24px;
`;

const subtitle = document.createElement('p');
subtitle.textContent = 'Upload, view, edit, download, and copy documents';
subtitle.style.cssText = `
margin: 0;
color: #666;
font-size: 16px;
`;

header.appendChild(title);
header.appendChild(subtitle);
baseContainer.appendChild(header);

// Upload section
const uploadSection = document.createElement('div');
uploadSection.style.cssText = `
margin-bottom: 15px;
`;

const uploadLabel = document.createElement('label');
uploadLabel.textContent = 'Upload Document:';
uploadLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.fileInput = document.createElement('input');
this.fileInput.type = 'file';
this.fileInput.accept = '.pdf,.docx,.txt,.jpg,.jpeg,.png,.gif,.csv,.json,.html,.xml';
this.fileInput.style.cssText = `
width: 100%;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
margin-bottom: 10px;
`;

this.fileInput.addEventListener('change', (e) => {
this.handleFileUpload(e);
});

uploadSection.appendChild(uploadLabel);
uploadSection.appendChild(this.fileInput);
baseContainer.appendChild(uploadSection);

// Button grid
const buttonGrid = document.createElement('div');
buttonGrid.style.cssText = `
display: grid;
grid-template-columns: repeat(5, 1fr);
grid-gap: 10px;
margin-bottom: 15px;
`;

// View button
this.viewButton = this.createButton('View', '#4CAF50', () => {
this.viewDocument();
});
this.viewButton.disabled = true;

// Edit button
this.editButton = this.createButton('Edit', '#2196F3', () => {
this.editDocument();
});
this.editButton.disabled = true;

// Copy button
this.copyButton = this.createButton('Copy', '#FF9800', () => {
this.copyDocument();
});
this.copyButton.disabled = true;

// Download button
this.downloadButton = this.createButton('Download', '#9C27B0', () => {
this.downloadDocument();
});
this.downloadButton.disabled = true;

// Clear button
this.clearButton = this.createButton('Clear', '#f44336', () => {
this.clearDocument();
});

buttonGrid.appendChild(this.viewButton);
buttonGrid.appendChild(this.editButton);
buttonGrid.appendChild(this.copyButton);
buttonGrid.appendChild(this.downloadButton);
buttonGrid.appendChild(this.clearButton);

baseContainer.appendChild(buttonGrid);

// Preview area
this.previewArea = document.createElement('div');
this.previewArea.style.cssText = `
width: 100%;
height: 300px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
overflow: auto;
margin-bottom: 15px;
display: flex;
align-items: center;
justify-content: center;
`;

this.previewArea.textContent = 'No document uploaded';
baseContainer.appendChild(this.previewArea);

// Editor area (initially hidden)
this.editorArea = document.createElement('div');
this.editorArea.style.cssText = `
width: 100%;
height: 300px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
overflow: auto;
margin-bottom: 15px;
display: none;
`;

const editorLabel = document.createElement('label');
editorLabel.textContent = 'Edit Document:';
editorLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.editorTextarea = document.createElement('textarea');
this.editorTextarea.style.cssText = `
width: 100%;
height: 250px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.editorArea.appendChild(editorLabel);
this.editorArea.appendChild(this.editorTextarea);
baseContainer.appendChild(this.editorArea);

// Output section
const outputSection = document.createElement('div');
outputSection.style.cssText = `
margin-bottom: 15px;
`;

const outputLabel = document.createElement('label');
outputLabel.textContent = 'Status:';
outputLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.outputDiv = document.createElement('div');
this.outputDiv.style.cssText = `
width: 100%;
min-height: 50px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
`;

this.outputDiv.textContent = 'Ready to upload a document';

outputSection.appendChild(outputLabel);
outputSection.appendChild(this.outputDiv);
baseContainer.appendChild(outputSection);

// Info section
const infoSection = document.createElement('div');
infoSection.style.cssText = `
background-color: #e3f2fd;
border-radius: 5px;
padding: 10px;
font-size: 14px;
color: #1976d2;
border-left: 4px solid #2196F3;
`;

infoSection.innerHTML = `
<strong>Instructions:</strong><br>
            • Upload a document using the file input<br>
            • View: Display the document in the preview area<br>
            • Edit: Edit text-based documents in the editor<br>
            • Copy: Copy document content to clipboard<br>
            • Download: Save the document to your device<br>
            • Clear: Reset the document manager
        `;

        baseContainer.appendChild(infoSection);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Handle file upload
     */
    handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) {
            this.outputDiv.textContent = 'No file selected';
            return;
        }

        this.currentFile = file;
        this.fileName = file.name;
        this.fileType = file.type;
        this.isEditing = false;

        // Show file info
        this.outputDiv.textContent = `File uploaded: ${this.fileName} (${this.formatFileSize(file.size)})`;

        // Enable buttons
        this.viewButton.disabled = false;
        this.downloadButton.disabled = false;
        this.clearButton.disabled = false;

        // Determine if file can be edited or copied
        const editableTypes = [
            'text/plain',
            'text/csv',
            'application/json',
            'text/html',
            'text/xml',
            'application/xml'
        ];

        if (editableTypes.includes(this.fileType) ||
            this.fileName.endsWith('.txt') ||
            this.fileName.endsWith('.csv') ||
            this.fileName.endsWith('.json') ||
            this.fileName.endsWith('.html') ||
            this.fileName.endsWith('.xml')) {
            this.editButton.disabled = false;
            this.copyButton.disabled = false;
        } else {
            this.editButton.disabled = true;
            this.copyButton.disabled = true;
        }

        // Read file content
        this.readFileContent(file);
    }

    /**
     * Read file content
     */
    readFileContent(file) {
        const reader = new FileReader();

        reader.onload = (e) => {
            this.fileContent = e.target.result;
            this.previewArea.innerHTML = '';

            // Display file based on type
            if (file.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = e.target.result;
                img.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                `;
                this.previewArea.appendChild(img);
            } else if (file.type === 'application/pdf') {
                const iframe = document.createElement('iframe');
                iframe.src = e.target.result;
                iframe.style.cssText = `
                    width: 100%;
                    height: 100%;
                    border: none;
                `;
                this.previewArea.appendChild(iframe);
            } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                // For DOCX files, we can't display directly, so show a message
                const message = document.createElement('div');
                message.textContent = 'DOCX file uploaded. Use Download to save or Edit if supported.';
                message.style.cssText = `
                    text-align: center;
                    color: #666;
                `;
                this.previewArea.appendChild(message);
            } else {
                // For text files, show a preview
                const pre = document.createElement('pre');
                pre.textContent = e.target.result;
                pre.style.cssText = `
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                `;
                this.previewArea.appendChild(pre);
            }
        };

        reader.onerror = () => {
            this.outputDiv.textContent = 'Error reading file';
        };

        // Read file based on type
        if (file.type.startsWith('image/') || file.type === 'application/pdf') {
            reader.readAsDataURL(file);
        } else {
            reader.readAsText(file);
        }
    }

    /**
     * View document
     */
    viewDocument() {
        if (!this.currentFile) {
            botReply('No document to view');
            return;
        }

        // Show preview area, hide editor
        this.previewArea.style.display = 'flex';
        this.editorArea.style.display = 'none';
        this.isEditing = false;

        botReply(`Viewing document: ${this.fileName}`);
    }

    /**
     * Edit document
     */
    editDocument() {
        if (!this.currentFile) {
            botReply('No document to edit');
            return;
        }

        if (this.editButton.disabled) {
            botReply('This document type cannot be edited');
            return;
        }

        // Show editor area, hide preview
        this.previewArea.style.display = 'none';
        this.editorArea.style.display = 'block';

        // Set editor content
        this.editorTextarea.value = this.fileContent;
        this.isEditing = true;

        botReply(`Editing document: ${this.fileName}`);
    }

    /**
     * Copy document content
     */
    copyDocument() {
        if (!this.currentFile) {
            botReply('No document to copy');
            return;
        }

        if (this.copyButton.disabled) {
            botReply('This document type cannot be copied');
            return;
        }

        // Get content to copy
        let contentToCopy = this.fileContent;
        if (this.isEditing) {
            contentToCopy = this.editorTextarea.value;
        }

        // Copy to clipboard
        if (navigator.clipboard) {
            navigator.clipboard.writeText(contentToCopy)
                .then(() => {
                    botReply('Document content copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(contentToCopy);
                });
        } else {
            this.fallbackCopyTextToClipboard(contentToCopy);
        }
    }

    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;

        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Document content copied to clipboard!');
            } else {
                botReply('Unable to copy document content');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy document content');
        }

        document.body.removeChild(textArea);
    }

    /**
     * Download document
     */
    downloadDocument() {
        if (!this.currentFile) {
            botReply('No document to download');
            return;
        }

        // Create download link
        const url = URL.createObjectURL(this.currentFile);
        const a = document.createElement('a');
        a.href = url;
        a.download = this.fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        botReply(`Document downloaded: ${this.fileName}`);
    }

    /**
     * Clear document
     */
    clearDocument() {
        this.currentFile = null;
        this.fileContent = null;
        this.fileType = null;
        this.fileName = null;
        this.isEditing = false;

        // Reset UI
        this.fileInput.value = '';
        this.previewArea.innerHTML = '';
        this.previewArea.textContent = 'No document uploaded';
        this.previewArea.style.display = 'flex';
        this.editorArea.style.display = 'none';
        this.editorTextarea.value = '';

        // Disable buttons
        this.viewButton.disabled = true;
        this.editButton.disabled = true;
        this.copyButton.disabled = true;
        this.downloadButton.disabled = true;

        this.outputDiv.textContent = 'Document cleared. Ready to upload a new document';

        botReply('Document cleared');
    }

    /**
     * Format file size
     */
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';

        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));

        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;

        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });

        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });

        button.addEventListener('click', clickHandler);

        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;

        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };

        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };

        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };

        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;

        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };

        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };

        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };

        floatingButtons.appendChild(this.closeButton);

        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);

        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);

        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;

        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;

        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;

        if (this.isFullscreen) {
            this.exitFullscreen();
        }

        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);

        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }

        this.gameContainer = null;
        this.fileInput = null;
        this.viewButton = null;
        this.editButton = null;
        this.copyButton = null;
        this.downloadButton = null;
        this.clearButton = null;
        this.previewArea = null;
        this.editorArea = null;
        this.outputDiv = null;
        this.currentFile = null;
        this.fileContent = null;
        this.fileType = null;
        this.fileName = null;
        this.isEditing = false;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;

        botReply("Document Manager closed. Thank you!");
    }
}

// Create a singleton instance
const allDocMount = new AllDocMount();

// Add this to your AI's command handling
if (/document manager|doc manager|file manager|upload document|view document|edit document/i.test(userInputRaw)) {
    allDocMount.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    allDocMount.closeGame();
    return;
}

class AdvancedCalendar {
    constructor() {
        this.baseScreen = {
            name: 'ADVANCED CALENDAR',
            instructions: 'Manage your schedule with events, reminders, and recurring tasks. All data is saved locally.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        
        // Calendar state
        this.currentDate = new Date();
        this.currentView = 'month'; // month, week, day, agenda
        this.events = [];
        this.reminders = [];
        this.selectedDate = null;
        this.selectedEvent = null;
        this.selectedReminder = null;
        
        // UI elements
        this.calendarGrid = null;
        this.monthYearDisplay = null;
        this.viewButtons = {};
        this.eventForm = null;
        this.eventsList = null;
        this.reminderForm = null;
        this.remindersList = null;
        this.searchInput = null;
        this.categoryFilter = null;
        this.eventDetailsModal = null;
        this.reminderDetailsModal = null;
        
        // Event categories with colors
        this.categories = [
            { id: 'work', name: 'Work', color: '#4285F4' },
            { id: 'personal', name: 'Personal', color: '#34A853' },
            { id: 'health', name: 'Health', color: '#FBBC05' },
            { id: 'social', name: 'Social', color: '#EA4335' },
            { id: 'other', name: 'Other', color: '#9C27B0' }
        ];
        
        // Load data from localStorage on initialization
        this.loadDataFromStorage();
    }

    /**
     * Load data from localStorage
     */
    loadDataFromStorage() {
        try {
            // Load events
            const eventsData = localStorage.getItem('advancedCalendar_events');
            if (eventsData) {
                const parsedEvents = JSON.parse(eventsData);
                // Convert date strings back to Date objects
                this.events = parsedEvents.map(event => ({
                    ...event,
                    date: new Date(event.date)
                }));
            }
            
            // Load reminders
            const remindersData = localStorage.getItem('advancedCalendar_reminders');
            if (remindersData) {
                const parsedReminders = JSON.parse(remindersData);
                // Convert date strings back to Date objects
                this.reminders = parsedReminders.map(reminder => ({
                    ...reminder,
                    date: new Date(reminder.date)
                }));
            }
        } catch (error) {
            console.error('Error loading data from localStorage:', error);
            // If there's an error, start with empty arrays
            this.events = [];
            this.reminders = [];
        }
    }

    /**
     * Save data to localStorage
     */
    saveDataToStorage() {
        try {
            // Save events
            localStorage.setItem('advancedCalendar_events', JSON.stringify(this.events));
            
            // Save reminders
            localStorage.setItem('advancedCalendar_reminders', JSON.stringify(this.reminders));
        } catch (error) {
            console.error('Error saving data to localStorage:', error);
            botReply('Error saving your data. Your browser may be in private mode or have storage disabled.');
        }
    }

    /**
     * Load the Advanced Calendar
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createCalendarScreen();
        this.setupActionButtons();
        this.renderCalendar();
        this.displayGame();
        this.isActive = true;
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) existingContainer.remove();
        
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }

    /**
     * Create the Advanced Calendar UI
     */
    createCalendarScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 1200px;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Advanced Calendar';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 28px;
        `;
        header.appendChild(title);
        baseContainer.appendChild(header);

        // Top controls
        const topControls = document.createElement('div');
        topControls.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        `;

        // Navigation buttons
        const navButtons = document.createElement('div');
        navButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const todayButton = this.createButton('Today', '#4CAF50', () => {
            this.goToToday();
        });
        
        const prevButton = this.createButton('◀', '#2196F3', () => {
            this.navigatePrevious();
        });
        
        const nextButton = this.createButton('▶', '#2196F3', () => {
            this.navigateNext();
        });
        
        navButtons.appendChild(todayButton);
        navButtons.appendChild(prevButton);
        navButtons.appendChild(nextButton);
        topControls.appendChild(navButtons);

        // Month and year display
        this.monthYearDisplay = document.createElement('div');
        this.monthYearDisplay.style.cssText = `
            font-size: 24px;
            font-weight: bold;
            color: #333;
        `;
        topControls.appendChild(this.monthYearDisplay);

        // View buttons
        const viewButtonsContainer = document.createElement('div');
        viewButtonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        this.viewButtons.month = this.createButton('Month', '#FF9800', () => {
            this.setView('month');
        });
        this.viewButtons.month.classList.add('active');
        
        this.viewButtons.week = this.createButton('Week', '#FF9800', () => {
            this.setView('week');
        });
        
        this.viewButtons.day = this.createButton('Day', '#FF9800', () => {
            this.setView('day');
        });
        
        this.viewButtons.agenda = this.createButton('Agenda', '#FF9800', () => {
            this.setView('agenda');
        });
        
        viewButtonsContainer.appendChild(this.viewButtons.month);
        viewButtonsContainer.appendChild(this.viewButtons.week);
        viewButtonsContainer.appendChild(this.viewButtons.day);
        viewButtonsContainer.appendChild(this.viewButtons.agenda);
        topControls.appendChild(viewButtonsContainer);

        baseContainer.appendChild(topControls);

        // Search and filter
        const searchFilterContainer = document.createElement('div');
        searchFilterContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        `;
        
        this.searchInput = document.createElement('input');
        this.searchInput.type = 'text';
        this.searchInput.placeholder = 'Search events...';
        this.searchInput.style.cssText = `
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        this.searchInput.addEventListener('input', () => {
            this.filterEvents();
        });
        searchFilterContainer.appendChild(this.searchInput);
        
        this.categoryFilter = document.createElement('select');
        this.categoryFilter.style.cssText = `
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        
        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = 'All Categories';
        this.categoryFilter.appendChild(allOption);
        
        this.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            this.categoryFilter.appendChild(option);
        });
        
        this.categoryFilter.addEventListener('change', () => {
            this.filterEvents();
        });
        searchFilterContainer.appendChild(this.categoryFilter);
        
        const addEventButton = this.createButton('Add Event', '#4CAF50', () => {
            this.showEventForm();
        });
        searchFilterContainer.appendChild(addEventButton);
        
        const addReminderButton = this.createButton('Add Reminder', '#9C27B0', () => {
            this.showReminderForm();
        });
        searchFilterContainer.appendChild(addReminderButton);
        
        // Add export/import buttons
        const exportButton = this.createButton('Export', '#607D8B', () => {
            this.exportData();
        });
        searchFilterContainer.appendChild(exportButton);
        
        const importButton = this.createButton('Import', '#607D8B', () => {
            this.importData();
        });
        searchFilterContainer.appendChild(importButton);
        
        baseContainer.appendChild(searchFilterContainer);

        // Main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-grow: 1;
            gap: 20px;
            overflow: hidden;
        `;

        // Calendar grid
        const calendarContainer = document.createElement('div');
        calendarContainer.style.cssText = `
            flex: 3;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        this.calendarGrid = document.createElement('div');
        this.calendarGrid.style.cssText = `
            width: 100%;
            overflow: auto;
            flex-grow: 1;
        `;
        calendarContainer.appendChild(this.calendarGrid);
        mainContent.appendChild(calendarContainer);

        // Sidebar
        const sidebar = document.createElement('div');
        sidebar.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: auto;
        `;
        
        // Events list
        const eventsSection = document.createElement('div');
        eventsSection.style.cssText = `
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        `;
        
        const eventsTitle = document.createElement('h3');
        eventsTitle.textContent = 'Upcoming Events';
        eventsTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        `;
        eventsSection.appendChild(eventsTitle);
        
        this.eventsList = document.createElement('div');
        this.eventsList.style.cssText = `
            max-height: 300px;
            overflow-y: auto;
        `;
        eventsSection.appendChild(this.eventsList);
        sidebar.appendChild(eventsSection);
        
        // Reminders list
        const remindersSection = document.createElement('div');
        remindersSection.style.cssText = `
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        `;
        
        const remindersTitle = document.createElement('h3');
        remindersTitle.textContent = 'Reminders';
        remindersTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        `;
        remindersSection.appendChild(remindersTitle);
        
        this.remindersList = document.createElement('div');
        this.remindersList.style.cssText = `
            max-height: 300px;
            overflow-y: auto;
        `;
        remindersSection.appendChild(this.remindersList);
        sidebar.appendChild(remindersSection);
        
        // Storage info
        const storageSection = document.createElement('div');
        storageSection.style.cssText = `
            background-color: #e8f5e9;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
            color: #2e7d32;
        `;
        
        const storageTitle = document.createElement('h3');
        storageTitle.textContent = 'Storage Info';
        storageTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 10px;
            color: #2e7d32;
            font-size: 16px;
        `;
        storageSection.appendChild(storageTitle);
        
        const storageInfo = document.createElement('p');
        storageInfo.textContent = 'All your events and reminders are automatically saved in your browser\'s local storage.';
        storageInfo.style.cssText = `
            margin: 0 0 10px 0;
        `;
        storageSection.appendChild(storageInfo);
        
        const clearButton = this.createButton('Clear All Data', '#f44336', () => {
            this.clearAllData();
        });
        clearButton.style.cssText = `
            padding: 8px 12px;
            font-size: 12px;
            margin-top: 10px;
        `;
        storageSection.appendChild(clearButton);
        
        sidebar.appendChild(storageSection);
        
        mainContent.appendChild(sidebar);
        baseContainer.appendChild(mainContent);

        // Event form (initially hidden)
        this.eventForm = this.createEventForm();
        baseContainer.appendChild(this.eventForm);
        
        // Reminder form (initially hidden)
        this.reminderForm = this.createReminderForm();
        baseContainer.appendChild(this.reminderForm);
        
        // Event details modal (initially hidden)
        this.eventDetailsModal = this.createEventDetailsModal();
        baseContainer.appendChild(this.eventDetailsModal);
        
        // Reminder details modal (initially hidden)
        this.reminderDetailsModal = this.createReminderDetailsModal();
        baseContainer.appendChild(this.reminderDetailsModal);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Create event form
     */
    createEventForm() {
        const form = document.createElement('div');
        form.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const formTitle = document.createElement('h3');
        formTitle.textContent = 'Add Event';
        formTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        form.appendChild(formTitle);
        
        // Title input
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('label');
        titleLabel.textContent = 'Event Title:';
        titleLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        titleContainer.appendChild(titleLabel);
        
        const titleInput = document.createElement('input');
        titleInput.type = 'text';
        titleInput.placeholder = 'Enter event title';
        titleInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        titleContainer.appendChild(titleInput);
        form.appendChild(titleContainer);
        
        // Date and time inputs
        const dateTimeContainer = document.createElement('div');
        dateTimeContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        `;
        
        const dateContainer = document.createElement('div');
        dateContainer.style.cssText = `
            flex: 1;
        `;
        const dateLabel = document.createElement('label');
        dateLabel.textContent = 'Date:';
        dateLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        dateContainer.appendChild(dateLabel);
        
        const dateInput = document.createElement('input');
        dateInput.type = 'date';
        dateInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        dateContainer.appendChild(dateInput);
        dateTimeContainer.appendChild(dateContainer);
        
        const timeContainer = document.createElement('div');
        timeContainer.style.cssText = `
            flex: 1;
        `;
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Time:';
        timeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        timeContainer.appendChild(timeLabel);
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        timeContainer.appendChild(timeInput);
        dateTimeContainer.appendChild(timeContainer);
        form.appendChild(dateTimeContainer);
        
        // Category selection
        const categoryContainer = document.createElement('div');
        categoryContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const categoryLabel = document.createElement('label');
        categoryLabel.textContent = 'Category:';
        categoryLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        categoryContainer.appendChild(categoryLabel);
        
        const categorySelect = document.createElement('select');
        categorySelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        this.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            categorySelect.appendChild(option);
        });
        categoryContainer.appendChild(categorySelect);
        form.appendChild(categoryContainer);
        
        // Recurring options
        const recurringContainer = document.createElement('div');
        recurringContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const recurringLabel = document.createElement('label');
        recurringLabel.textContent = 'Recurring:';
        recurringLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        recurringContainer.appendChild(recurringLabel);
        
        const recurringSelect = document.createElement('select');
        recurringSelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        const recurringOptions = [
            { value: 'none', text: 'Does not repeat' },
            { value: 'daily', text: 'Daily' },
            { value: 'weekly', text: 'Weekly' },
            { value: 'monthly', text: 'Monthly' },
            { value: 'yearly', text: 'Yearly' }
        ];
        
        recurringOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.text;
            recurringSelect.appendChild(opt);
        });
        recurringContainer.appendChild(recurringSelect);
        form.appendChild(recurringContainer);
        
        // Description textarea
        const descContainer = document.createElement('div');
        descContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        const descLabel = document.createElement('label');
        descLabel.textContent = 'Description:';
        descLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        descContainer.appendChild(descLabel);
        
        const descTextarea = document.createElement('textarea');
        descTextarea.placeholder = 'Enter event description (optional)';
        descTextarea.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
            resize: vertical;
            min-height: 80px;
        `;
        descContainer.appendChild(descTextarea);
        form.appendChild(descContainer);
        
        // Form buttons
        const formButtons = document.createElement('div');
        formButtons.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        `;
        
        const saveButton = this.createButton('Save', '#4CAF50', () => {
            this.saveEvent(
                titleInput.value,
                dateInput.value,
                timeInput.value,
                categorySelect.value,
                recurringSelect.value,
                descTextarea.value
            );
            form.style.display = 'none';
        });
        
        const cancelButton = this.createButton('Cancel', '#f44336', () => {
            form.style.display = 'none';
        });
        
        formButtons.appendChild(saveButton);
        formButtons.appendChild(cancelButton);
        form.appendChild(formButtons);
        
        return form;
    }

    /**
     * Create reminder form
     */
    createReminderForm() {
        const form = document.createElement('div');
        form.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const formTitle = document.createElement('h3');
        formTitle.textContent = 'Add Reminder';
        formTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        form.appendChild(formTitle);
        
        // Title input
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('label');
        titleLabel.textContent = 'Reminder Title:';
        titleLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        titleContainer.appendChild(titleLabel);
        
        const titleInput = document.createElement('input');
        titleInput.type = 'text';
        titleInput.placeholder = 'Enter reminder title';
        titleInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        titleContainer.appendChild(titleInput);
        form.appendChild(titleContainer);
        
        // Date and time inputs
        const dateTimeContainer = document.createElement('div');
        dateTimeContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        `;
        
        const dateContainer = document.createElement('div');
        dateContainer.style.cssText = `
            flex: 1;
        `;
        const dateLabel = document.createElement('label');
        dateLabel.textContent = 'Date:';
        dateLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        dateContainer.appendChild(dateLabel);
        
        const dateInput = document.createElement('input');
        dateInput.type = 'date';
        dateInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        dateContainer.appendChild(dateInput);
        dateTimeContainer.appendChild(dateContainer);
        
        const timeContainer = document.createElement('div');
        timeContainer.style.cssText = `
            flex: 1;
        `;
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Time:';
        timeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        timeContainer.appendChild(timeLabel);
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        timeContainer.appendChild(timeInput);
        dateTimeContainer.appendChild(timeContainer);
        form.appendChild(dateTimeContainer);
        
        // Repeat options
        const repeatContainer = document.createElement('div');
        repeatContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const repeatLabel = document.createElement('label');
        repeatLabel.textContent = 'Repeat:';
        repeatLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        repeatContainer.appendChild(repeatLabel);
        
        const repeatSelect = document.createElement('select');
        repeatSelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        const repeatOptions = [
            { value: 'none', text: 'Does not repeat' },
            { value: 'daily', text: 'Daily' },
            { value: 'weekly', text: 'Weekly' },
            { value: 'monthly', text: 'Monthly' },
            { value: 'yearly', text: 'Yearly' }
        ];
        
        repeatOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.text;
            repeatSelect.appendChild(opt);
        });
        repeatContainer.appendChild(repeatSelect);
        form.appendChild(repeatContainer);
        
        // Notification options
        const notifyContainer = document.createElement('div');
        notifyContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        const notifyLabel = document.createElement('label');
        notifyLabel.textContent = 'Notify me:';
        notifyLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        notifyContainer.appendChild(notifyLabel);
        
        const notifySelect = document.createElement('select');
        notifySelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        const notifyOptions = [
            { value: '0', text: 'At time of event' },
            { value: '5', text: '5 minutes before' },
            { value: '15', text: '15 minutes before' },
            { value: '30', text: '30 minutes before' },
            { value: '60', text: '1 hour before' },
            { value: '1440', text: '1 day before' }
        ];
        
        notifyOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.text;
            notifySelect.appendChild(opt);
        });
        notifyContainer.appendChild(notifySelect);
        form.appendChild(notifyContainer);
        
        // Form buttons
        const formButtons = document.createElement('div');
        formButtons.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        `;
        
        const saveButton = this.createButton('Save', '#9C27B0', () => {
            this.saveReminder(
                titleInput.value,
                dateInput.value,
                timeInput.value,
                repeatSelect.value,
                notifySelect.value
            );
            form.style.display = 'none';
        });
        
        const cancelButton = this.createButton('Cancel', '#f44336', () => {
            form.style.display = 'none';
        });
        
        formButtons.appendChild(saveButton);
        formButtons.appendChild(cancelButton);
        form.appendChild(formButtons);
        
        return form;
    }

    /**
     * Create event details modal
     */
    createEventDetailsModal() {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Event Details';
        modalTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        modal.appendChild(modalTitle);
        
        // Event details container
        const detailsContainer = document.createElement('div');
        detailsContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        // Title
        const titleRow = document.createElement('div');
        titleRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('span');
        titleLabel.textContent = 'Title: ';
        titleLabel.style.cssText = `
            font-weight: bold;
        `;
        const titleValue = document.createElement('span');
        titleValue.id = 'event-details-title';
        titleRow.appendChild(titleLabel);
        titleRow.appendChild(titleValue);
        detailsContainer.appendChild(titleRow);
        
        // Date and time
        const dateTimeRow = document.createElement('div');
        dateTimeRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const dateTimeLabel = document.createElement('span');
        dateTimeLabel.textContent = 'Date & Time: ';
        dateTimeLabel.style.cssText = `
            font-weight: bold;
        `;
        const dateTimeValue = document.createElement('span');
        dateTimeValue.id = 'event-details-datetime';
        dateTimeRow.appendChild(dateTimeLabel);
        dateTimeRow.appendChild(dateTimeValue);
        detailsContainer.appendChild(dateTimeRow);
        
        // Category
        const categoryRow = document.createElement('div');
        categoryRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const categoryLabel = document.createElement('span');
        categoryLabel.textContent = 'Category: ';
        categoryLabel.style.cssText = `
            font-weight: bold;
        `;
        const categoryValue = document.createElement('span');
        categoryValue.id = 'event-details-category';
        categoryRow.appendChild(categoryLabel);
        categoryRow.appendChild(categoryValue);
        detailsContainer.appendChild(categoryRow);
        
        // Recurring
        const recurringRow = document.createElement('div');
        recurringRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const recurringLabel = document.createElement('span');
        recurringLabel.textContent = 'Recurring: ';
        recurringLabel.style.cssText = `
            font-weight: bold;
        `;
        const recurringValue = document.createElement('span');
        recurringValue.id = 'event-details-recurring';
        recurringRow.appendChild(recurringLabel);
        recurringRow.appendChild(recurringValue);
        detailsContainer.appendChild(recurringRow);
        
        // Description
        const descriptionRow = document.createElement('div');
        descriptionRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const descriptionLabel = document.createElement('span');
        descriptionLabel.textContent = 'Description: ';
        descriptionLabel.style.cssText = `
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        `;
        const descriptionValue = document.createElement('div');
        descriptionValue.id = 'event-details-description';
        descriptionValue.style.cssText = `
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            min-height: 60px;
        `;
        descriptionRow.appendChild(descriptionLabel);
        descriptionRow.appendChild(descriptionValue);
        detailsContainer.appendChild(descriptionRow);
        
        modal.appendChild(detailsContainer);
        
        // Modal buttons
        const modalButtons = document.createElement('div');
        modalButtons.style.cssText = `
            display: flex;
            justify-content: space-between;
            gap: 10px;
        `;
        
        const deleteButton = this.createButton('Delete', '#f44336', () => {
            if (this.selectedEvent) {
                this.deleteEvent(this.selectedEvent.id);
                modal.style.display = 'none';
            }
        });
        
        const closeButton = this.createButton('Close', '#2196F3', () => {
            modal.style.display = 'none';
        });
        
        modalButtons.appendChild(deleteButton);
        modalButtons.appendChild(closeButton);
        modal.appendChild(modalButtons);
        
        return modal;
    }

    /**
     * Create reminder details modal
     */
    createReminderDetailsModal() {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Reminder Details';
        modalTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        modal.appendChild(modalTitle);
        
        // Reminder details container
        const detailsContainer = document.createElement('div');
        detailsContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        // Title
        const titleRow = document.createElement('div');
        titleRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('span');
        titleLabel.textContent = 'Title: ';
        titleLabel.style.cssText = `
            font-weight: bold;
        `;
        const titleValue = document.createElement('span');
        titleValue.id = 'reminder-details-title';
        titleRow.appendChild(titleLabel);
        titleRow.appendChild(titleValue);
        detailsContainer.appendChild(titleRow);
        
        // Date and time
        const dateTimeRow = document.createElement('div');
        dateTimeRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const dateTimeLabel = document.createElement('span');
        dateTimeLabel.textContent = 'Date & Time: ';
        dateTimeLabel.style.cssText = `
            font-weight: bold;
        `;
        const dateTimeValue = document.createElement('span');
        dateTimeValue.id = 'reminder-details-datetime';
        dateTimeRow.appendChild(dateTimeLabel);
        dateTimeRow.appendChild(dateTimeValue);
        detailsContainer.appendChild(dateTimeRow);
        
        // Repeat
        const repeatRow = document.createElement('div');
        repeatRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const repeatLabel = document.createElement('span');
        repeatLabel.textContent = 'Repeat: ';
        repeatLabel.style.cssText = `
            font-weight: bold;
        `;
        const repeatValue = document.createElement('span');
        repeatValue.id = 'reminder-details-repeat';
        repeatRow.appendChild(repeatLabel);
        repeatRow.appendChild(repeatValue);
        detailsContainer.appendChild(repeatRow);
        
        // Notification
        const notifyRow = document.createElement('div');
        notifyRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const notifyLabel = document.createElement('span');
        notifyLabel.textContent = 'Notify: ';
        notifyLabel.style.cssText = `
            font-weight: bold;
        `;
        const notifyValue = document.createElement('span');
        notifyValue.id = 'reminder-details-notify';
        notifyRow.appendChild(notifyLabel);
        notifyRow.appendChild(notifyValue);
        detailsContainer.appendChild(notifyRow);
        
        modal.appendChild(detailsContainer);
        
        // Modal buttons
        const modalButtons = document.createElement('div');
        modalButtons.style.cssText = `
            display: flex;
            justify-content: space-between;
            gap: 10px;
        `;
        
        const deleteButton = this.createButton('Delete', '#f44336', () => {
            if (this.selectedReminder) {
                this.deleteReminder(this.selectedReminder.id);
                modal.style.display = 'none';
            }
        });
        
        const closeButton = this.createButton('Close', '#2196F3', () => {
            modal.style.display = 'none';
        });
        
        modalButtons.appendChild(deleteButton);
        modalButtons.appendChild(closeButton);
        modal.appendChild(modalButtons);
        
        return modal;
    }

    /**
     * Render calendar based on current view
     */
    renderCalendar() {
        // Update month/year display
        this.updateMonthYearDisplay();
        
        // Clear calendar grid
        this.calendarGrid.innerHTML = '';
        
        // Render based on current view
        switch (this.currentView) {
            case 'month':
                this.renderMonthView();
                break;
            case 'week':
                this.renderWeekView();
                break;
            case 'day':
                this.renderDayView();
                break;
            case 'agenda':
                this.renderAgendaView();
                break;
        }
        
        // Update events and reminders lists
        this.updateEventsList();
        this.updateRemindersList();
    }

    /**
     * Render month view
     */
    renderMonthView() {
        const year = this.currentDate.getFullYear();
        const month = this.currentDate.getMonth();
        
        // Create month header with day names
        const monthHeader = document.createElement('div');
        monthHeader.style.cssText = `
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            margin-bottom: 1px;
        `;
        
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        dayNames.forEach(day => {
            const dayHeader = document.createElement('div');
            dayHeader.textContent = day;
            dayHeader.style.cssText = `
                background-color: #f0f0f0;
                padding: 10px 5px;
                text-align: center;
                font-weight: bold;
            `;
            monthHeader.appendChild(dayHeader);
        });
        
        this.calendarGrid.appendChild(monthHeader);
        
        // Get first day of month and number of days
        const firstDay = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        // Create month grid
        const monthGrid = document.createElement('div');
        monthGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            flex-grow: 1;
        `;
        
        // Add empty cells for days before the first day of the month
        for (let i = 0; i < firstDay; i++) {
            const emptyDay = document.createElement('div');
            emptyDay.style.cssText = `
                background-color: #fff;
                min-height: 100px;
            `;
            monthGrid.appendChild(emptyDay);
        }
        
        // Add cells for each day of the month
        for (let day = 1; day <= daysInMonth; day++) {
            const dayCell = document.createElement('div');
            dayCell.style.cssText = `
                background-color: #fff;
                min-height: 100px;
                padding: 5px;
                position: relative;
                cursor: pointer;
            `;
            
            // Highlight today
            const today = new Date();
            if (year === today.getFullYear() && month === today.getMonth() && day === today.getDate()) {
                dayCell.style.backgroundColor = '#e3f2fd';
            }
            
            // Add day number
            const dayNumber = document.createElement('div');
            dayNumber.textContent = day;
            dayNumber.style.cssText = `
                font-weight: bold;
                margin-bottom: 5px;
            `;
            dayCell.appendChild(dayNumber);
            
            // Add events for this day
            const date = new Date(year, month, day);
            const dayEvents = this.getEventsForDate(date);
            
            const eventsContainer = document.createElement('div');
            eventsContainer.style.cssText = `
                font-size: 12px;
                overflow: hidden;
            `;
            
            dayEvents.slice(0, 3).forEach(event => {
                const eventElement = document.createElement('div');
                eventElement.textContent = event.title;
                eventElement.style.cssText = `
                    background-color: ${event.color};
                    color: white;
                    padding: 2px 5px;
                    margin-bottom: 2px;
                    border-radius: 3px;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                `;
                eventsContainer.appendChild(eventElement);
            });
            
            if (dayEvents.length > 3) {
                const moreElement = document.createElement('div');
                moreElement.textContent = `+${dayEvents.length - 3} more`;
                moreElement.style.cssText = `
                    font-style: italic;
                    color: #666;
                `;
                eventsContainer.appendChild(moreElement);
            }
            
            dayCell.appendChild(eventsContainer);
            
            // Add click event to show event form
            dayCell.addEventListener('click', () => {
                this.selectedDate = new Date(year, month, day);
                this.showEventForm();
            });
            
            monthGrid.appendChild(dayCell);
        }
        
        this.calendarGrid.appendChild(monthGrid);
    }

    /**
     * Render week view
     */
    renderWeekView() {
        const today = new Date();
        const currentDay = this.currentDate.getDay();
        const startDate = new Date(this.currentDate);
        startDate.setDate(this.currentDate.getDate() - currentDay);
        
        // Create week header with day names
        const weekHeader = document.createElement('div');
        weekHeader.style.cssText = `
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            margin-bottom: 1px;
        `;
        
        // Empty cell for time column
        const emptyHeader = document.createElement('div');
        emptyHeader.style.cssText = `
            background-color: #f0f0f0;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        `;
        weekHeader.appendChild(emptyHeader);
        
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        for (let i = 0; i < 7; i++) {
            const date = new Date(startDate);
            date.setDate(startDate.getDate() + i);
            
            const dayHeader = document.createElement('div');
            dayHeader.style.cssText = `
                background-color: #f0f0f0;
                padding: 10px 5px;
                text-align: center;
                font-weight: bold;
            `;
            
            // Highlight today
            if (date.toDateString() === today.toDateString()) {
                dayHeader.style.backgroundColor = '#e3f2fd';
            }
            
            dayHeader.innerHTML = `${dayNames[i]}<br>${date.getDate()}`;
            weekHeader.appendChild(dayHeader);
        }
        
        this.calendarGrid.appendChild(weekHeader);
        
        // Create time grid
        const timeGrid = document.createElement('div');
        timeGrid.style.cssText = `
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            flex-grow: 1;
        `;
        
        // Add time slots
        for (let hour = 0; hour < 24; hour++) {
            // Time label
            const timeLabel = document.createElement('div');
            timeLabel.textContent = `${hour === 0 ? '12' : hour > 12 ? hour - 12 : hour}:00 ${hour < 12 ? 'AM' : 'PM'}`;
            timeLabel.style.cssText = `
                background-color: #f0f0f0;
                padding: 5px;
                text-align: right;
                font-size: 12px;
            `;
            timeGrid.appendChild(timeLabel);
            
            // Add cells for each day
            for (let day = 0; day < 7; day++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + day);
                date.setHours(hour, 0, 0, 0);
                
                const hourCell = document.createElement('div');
                hourCell.style.cssText = `
                    background-color: #fff;
                    min-height: 50px;
                    position: relative;
                    cursor: pointer;
                `;
                
                // Highlight today's hour
                if (date.toDateString() === today.toDateString() && hour === today.getHours()) {
                    hourCell.style.backgroundColor = '#e3f2fd';
                }
                
                // Add events for this hour
                const hourEvents = this.getEventsForDateTime(date);
                
                hourEvents.forEach(event => {
                    const eventElement = document.createElement('div');
                    eventElement.textContent = event.title;
                    eventElement.style.cssText = `
                        background-color: ${event.color};
                        color: white;
                        padding: 2px 5px;
                        margin-bottom: 2px;
                        border-radius: 3px;
                        font-size: 12px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    `;
                    hourCell.appendChild(eventElement);
                });
                
                // Add click event to show event form
                hourCell.addEventListener('click', () => {
                    this.selectedDate = new Date(date);
                    this.showEventForm();
                });
                
                timeGrid.appendChild(hourCell);
            }
        }
        
        this.calendarGrid.appendChild(timeGrid);
    }

    /**
     * Render day view
     */
    renderDayView() {
        const date = new Date(this.currentDate);
        const today = new Date();
        
        // Create day header
        const dayHeader = document.createElement('div');
        dayHeader.style.cssText = `
            display: flex;
            background-color: #f0f0f0;
            padding: 15px;
            margin-bottom: 1px;
            align-items: center;
            justify-content: space-between;
        `;
        
        const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
        const monthName = date.toLocaleDateString('en-US', { month: 'long' });
        const dayNumber = date.getDate();
        const year = date.getFullYear();
        
        const dateDisplay = document.createElement('div');
        dateDisplay.textContent = `${dayName}, ${monthName} ${dayNumber}, ${year}`;
        dateDisplay.style.cssText = `
            font-size: 18px;
            font-weight: bold;
        `;
        
        // Highlight today
        if (date.toDateString() === today.toDateString()) {
            dateDisplay.style.color = '#2196F3';
        }
        
        dayHeader.appendChild(dateDisplay);
        
        const addButton = this.createButton('Add Event', '#4CAF50', () => {
            this.selectedDate = new Date(date);
            this.showEventForm();
        });
        dayHeader.appendChild(addButton);
        
        this.calendarGrid.appendChild(dayHeader);
        
        // Create time grid
        const timeGrid = document.createElement('div');
        timeGrid.style.cssText = `
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 1px;
            background-color: #ddd;
            flex-grow: 1;
        `;
        
        // Add time slots
        for (let hour = 0; hour < 24; hour++) {
            // Time label
            const timeLabel = document.createElement('div');
            timeLabel.textContent = `${hour === 0 ? '12' : hour > 12 ? hour - 12 : hour}:00 ${hour < 12 ? 'AM' : 'PM'}`;
            timeLabel.style.cssText = `
                background-color: #f0f0f0;
                padding: 10px 5px;
                text-align: right;
                font-size: 14px;
            `;
            timeGrid.appendChild(timeLabel);
            
            // Hour cell
            const hourCell = document.createElement('div');
            hourCell.style.cssText = `
                background-color: #fff;
                min-height: 60px;
                position: relative;
                cursor: pointer;
                padding: 5px;
            `;
            
            // Highlight current hour
            if (date.toDateString() === today.toDateString() && hour === today.getHours()) {
                hourCell.style.backgroundColor = '#e3f2fd';
            }
            
            // Add events for this hour
            const hourDate = new Date(date);
            hourDate.setHours(hour, 0, 0, 0);
            const hourEvents = this.getEventsForDateTime(hourDate);
            
            hourEvents.forEach(event => {
                const eventElement = document.createElement('div');
                eventElement.style.cssText = `
                    background-color: ${event.color};
                    color: white;
                    padding: 8px;
                    margin-bottom: 5px;
                    border-radius: 5px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                `;
                
                const eventTitle = document.createElement('div');
                eventTitle.textContent = event.title;
                eventTitle.style.cssText = `
                    font-weight: bold;
                    margin-bottom: 3px;
                `;
                
                const eventTime = document.createElement('div');
                eventTime.textContent = event.time;
                eventTime.style.cssText = `
                    font-size: 12px;
                `;
                
                eventElement.appendChild(eventTitle);
                eventElement.appendChild(eventTime);
                hourCell.appendChild(eventElement);
            });
            
            // Add click event to show event form
            hourCell.addEventListener('click', () => {
                this.selectedDate = new Date(hourDate);
                this.showEventForm();
            });
            
            timeGrid.appendChild(hourCell);
        }
        
        this.calendarGrid.appendChild(timeGrid);
    }

    /**
     * Render agenda view
     */
    renderAgendaView() {
        const agendaContainer = document.createElement('div');
        agendaContainer.style.cssText = `
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            flex-grow: 1;
            overflow: auto;
        `;
        
        const agendaTitle = document.createElement('h3');
        agendaTitle.textContent = 'Agenda';
        agendaTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
        `;
        agendaContainer.appendChild(agendaTitle);
        
        // Get events for the next 7 days
        const events = [];
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        for (let i = 0; i < 7; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            const dayEvents = this.getEventsForDate(date);
            
            if (dayEvents.length > 0) {
                events.push({
                    date: new Date(date),
                    events: dayEvents
                });
            }
        }
        
        if (events.length === 0) {
            const noEvents = document.createElement('p');
            noEvents.textContent = 'No upcoming events in the next 7 days.';
            noEvents.style.cssText = `
                color: #666;
                font-style: italic;
            `;
            agendaContainer.appendChild(noEvents);
        } else {
            events.forEach(day => {
                const dayContainer = document.createElement('div');
                dayContainer.style.cssText = `
                    margin-bottom: 20px;
                `;
                
                const dayHeader = document.createElement('h4');
                dayHeader.textContent = day.date.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric' 
                });
                dayHeader.style.cssText = `
                    margin-top: 0;
                    margin-bottom: 10px;
                    color: #333;
                    border-bottom: 1px solid #eee;
                    padding-bottom: 5px;
                `;
                dayContainer.appendChild(dayHeader);
                
                day.events.forEach(event => {
                    const eventElement = document.createElement('div');
                    eventElement.style.cssText = `
                        display: flex;
                        align-items: center;
                        padding: 10px;
                        margin-bottom: 8px;
                        border-radius: 5px;
                        background-color: #f9f9f9;
                        border-left: 4px solid ${event.color};
                        cursor: pointer;
                    `;
                    
                    const eventTime = document.createElement('div');
                    eventTime.textContent = event.time;
                    eventTime.style.cssText = `
                        min-width: 70px;
                        font-weight: bold;
                        color: #555;
                    `;
                    
                    const eventDetails = document.createElement('div');
                    eventDetails.style.cssText = `
                        margin-left: 15px;
                    `;
                    
                    const eventTitle = document.createElement('div');
                    eventTitle.textContent = event.title;
                    eventTitle.style.cssText = `
                        font-weight: bold;
                        margin-bottom: 3px;
                    `;
                    
                    const eventCategory = document.createElement('div');
                    eventCategory.textContent = event.categoryName;
                    eventCategory.style.cssText = `
                        font-size: 12px;
                        color: #666;
                    `;
                    
                    eventDetails.appendChild(eventTitle);
                    eventDetails.appendChild(eventCategory);
                    
                    eventElement.appendChild(eventTime);
                    eventElement.appendChild(eventDetails);
                    
                    eventElement.addEventListener('click', () => {
                        this.selectedEvent = event;
                        this.showEventDetails(event);
                    });
                    
                    dayContainer.appendChild(eventElement);
                });
                
                agendaContainer.appendChild(dayContainer);
            });
        }
        
        this.calendarGrid.appendChild(agendaContainer);
    }

    /**
     * Update month/year display
     */
    updateMonthYearDisplay() {
        const monthNames = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        
        const month = monthNames[this.currentDate.getMonth()];
        const year = this.currentDate.getFullYear();
        
        this.monthYearDisplay.textContent = `${month} ${year}`;
    }

    /**
     * Set calendar view
     */
    setView(view) {
        this.currentView = view;
        
        // Update active button
        Object.keys(this.viewButtons).forEach(key => {
            if (key === view) {
                this.viewButtons[key].classList.add('active');
            } else {
                this.viewButtons[key].classList.remove('active');
            }
        });
        
        this.renderCalendar();
    }

    /**
     * Navigate to previous period
     */
    navigatePrevious() {
        switch (this.currentView) {
            case 'month':
                this.currentDate.setMonth(this.currentDate.getMonth() - 1);
                break;
            case 'week':
                this.currentDate.setDate(this.currentDate.getDate() - 7);
                break;
            case 'day':
                this.currentDate.setDate(this.currentDate.getDate() - 1);
                break;
            case 'agenda':
                this.currentDate.setDate(this.currentDate.getDate() - 7);
                break;
        }
        this.renderCalendar();
    }

    /**
     * Navigate to next period
     */
    navigateNext() {
        switch (this.currentView) {
            case 'month':
                this.currentDate.setMonth(this.currentDate.getMonth() + 1);
                break;
            case 'week':
                this.currentDate.setDate(this.currentDate.getDate() + 7);
                break;
            case 'day':
                this.currentDate.setDate(this.currentDate.getDate() + 1);
                break;
            case 'agenda':
                this.currentDate.setDate(this.currentDate.getDate() + 7);
                break;
        }
        this.renderCalendar();
    }

    /**
     * Go to today
     */
    goToToday() {
        this.currentDate = new Date();
        this.renderCalendar();
    }

    /**
     * Show event form
     */
    showEventForm() {
        this.eventForm.style.display = 'block';
        
        // Set default date to selected date or today
        const dateInput = this.eventForm.querySelector('input[type="date"]');
        if (this.selectedDate) {
            dateInput.value = this.formatDateForInput(this.selectedDate);
        } else {
            dateInput.value = this.formatDateForInput(new Date());
        }
    }

    /**
     * Show reminder form
     */
    showReminderForm() {
        this.reminderForm.style.display = 'block';
        
        // Set default date to today
        const dateInput = this.reminderForm.querySelector('input[type="date"]');
        dateInput.value = this.formatDateForInput(new Date());
    }

    /**
     * Show event details modal
     */
    showEventDetails(event) {
        this.selectedEvent = event;
        
        // Populate modal with event details
        document.getElementById('event-details-title').textContent = event.title;
        document.getElementById('event-details-datetime').textContent = 
            `${event.date.toLocaleDateString()} at ${event.time}`;
        document.getElementById('event-details-category').textContent = event.categoryName;
        document.getElementById('event-details-recurring').textContent = 
            event.recurring === 'none' ? 'Does not repeat' : 
            event.recurring.charAt(0).toUpperCase() + event.recurring.slice(1);
        document.getElementById('event-details-description').textContent = 
            event.description || 'No description';
        
        // Show modal
        this.eventDetailsModal.style.display = 'block';
    }

    /**
     * Show reminder details modal
     */
    showReminderDetails(reminder) {
        this.selectedReminder = reminder;
        
        // Populate modal with reminder details
        document.getElementById('reminder-details-title').textContent = reminder.title;
        document.getElementById('reminder-details-datetime').textContent = 
            `${reminder.date.toLocaleDateString()} at ${reminder.time}`;
        document.getElementById('reminder-details-repeat').textContent = 
            reminder.repeat === 'none' ? 'Does not repeat' : 
            reminder.repeat.charAt(0).toUpperCase() + reminder.repeat.slice(1);
        
        // Format notification time
        let notifyText = 'At time of reminder';
        if (reminder.notifyBefore > 0) {
            if (reminder.notifyBefore < 60) {
                notifyText = `${reminder.notifyBefore} minutes before`;
            } else if (reminder.notifyBefore === 60) {
                notifyText = '1 hour before';
            } else if (reminder.notifyBefore === 1440) {
                notifyText = '1 day before';
            }
        }
        document.getElementById('reminder-details-notify').textContent = notifyText;
        
        // Show modal
        this.reminderDetailsModal.style.display = 'block';
    }

    /**
     * Save event
     */
    saveEvent(title, date, time, category, recurring, description) {
        if (!title || !date) {
            botReply('Please fill in the required fields (title and date).');
            return;
        }
        
        const eventDate = new Date(date);
        const event = {
            id: Date.now(),
            title,
            date: eventDate,
            time: time || 'All day',
            category,
            categoryName: this.categories.find(c => c.id === category).name,
            color: this.categories.find(c => c.id === category).color,
            recurring,
            description
        };
        
        this.events.push(event);
        this.saveDataToStorage(); // Save to localStorage
        this.renderCalendar();
        botReply(`Event "${title}" has been added to your calendar and saved.`);
    }

    /**
     * Save reminder
     */
    saveReminder(title, date, time, repeat, notifyBefore) {
        if (!title || !date) {
            botReply('Please fill in the required fields (title and date).');
            return;
        }
        
        const reminderDate = new Date(date);
        const reminder = {
            id: Date.now(),
            title,
            date: reminderDate,
            time: time || 'All day',
            repeat,
            notifyBefore: parseInt(notifyBefore)
        };
        
        this.reminders.push(reminder);
        this.saveDataToStorage(); // Save to localStorage
        this.renderCalendar();
        botReply(`Reminder "${title}" has been added to your calendar and saved.`);
    }

    /**
     * Delete event
     */
    deleteEvent(eventId) {
        if (confirm('Are you sure you want to delete this event?')) {
            this.events = this.events.filter(event => event.id !== eventId);
            this.saveDataToStorage();
            this.renderCalendar();
            botReply('Event has been deleted.');
        }
    }

    /**
     * Delete reminder
     */
    deleteReminder(reminderId) {
        if (confirm('Are you sure you want to delete this reminder?')) {
            this.reminders = this.reminders.filter(reminder => reminder.id !== reminderId);
            this.saveDataToStorage();
            this.renderCalendar();
            botReply('Reminder has been deleted.');
        }
    }

    /**
     * Get events for a specific date
     */
    getEventsForDate(date) {
        const dateStr = date.toDateString();
        return this.events.filter(event => {
            const eventDateStr = event.date.toDateString();
            return eventDateStr === dateStr;
        });
    }

    /**
     * Get events for a specific date and hour
     */
    getEventsForDateTime(dateTime) {
        const dateStr = dateTime.toDateString();
        const hour = dateTime.getHours();
        
        return this.events.filter(event => {
            const eventDateStr = event.date.toDateString();
            if (eventDateStr !== dateStr) return false;
            
            if (event.time === 'All day') return true;
            
            const eventHour = parseInt(event.time.split(':')[0]);
            const eventAmPm = event.time.includes('AM') ? 'AM' : 'PM';
            
            // Convert to 24-hour format for comparison
            let eventHour24 = eventHour;
            if (eventAmPm === 'PM' && eventHour !== 12) {
                eventHour24 += 12;
            } else if (eventAmPm === 'AM' && eventHour === 12) {
                eventHour24 = 0;
            }
            
            return eventHour24 === hour;
        });
    }

    /**
     * Update events list in sidebar
     */
    updateEventsList() {
        this.eventsList.innerHTML = '';
        
        // Get upcoming events (next 7 days)
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const nextWeek = new Date(today);
        nextWeek.setDate(today.getDate() + 7);
        
        const upcomingEvents = this.events.filter(event => {
            return event.date >= today && event.date <= nextWeek;
        });
        
        if (upcomingEvents.length === 0) {
            const noEvents = document.createElement('p');
            noEvents.textContent = 'No upcoming events.';
            noEvents.style.cssText = `
                color: #666;
                font-style: italic;
            `;
            this.eventsList.appendChild(noEvents);
            return;
        }
        
        // Sort events by date and time
        upcomingEvents.sort((a, b) => {
            if (a.date < b.date) return -1;
            if (a.date > b.date) return 1;
            
            if (a.time === 'All day') return -1;
            if (b.time === 'All day') return 1;
            
            return a.time.localeCompare(b.time);
        });
        
        upcomingEvents.forEach(event => {
            const eventElement = document.createElement('div');
            eventElement.style.cssText = `
                padding: 10px;
                margin-bottom: 8px;
                border-radius: 5px;
                background-color: #f9f9f9;
                border-left: 4px solid ${event.color};
                cursor: pointer;
                position: relative;
            `;
            
            const eventTitle = document.createElement('div');
            eventTitle.textContent = event.title;
            eventTitle.style.cssText = `
                font-weight: bold;
                margin-bottom: 3px;
            `;
            
            const eventDate = document.createElement('div');
            eventDate.textContent = `${event.date.toLocaleDateString()} at ${event.time}`;
            eventDate.style.cssText = `
                font-size: 12px;
                color: #666;
            `;
            
            eventElement.appendChild(eventTitle);
            eventElement.appendChild(eventDate);
            
            // Add delete button
            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '✕';
            deleteButton.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: none;
                border: none;
                color: #f44336;
                font-size: 16px;
                cursor: pointer;
                padding: 0;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteEvent(event.id);
            });
            eventElement.appendChild(deleteButton);
            
            eventElement.addEventListener('click', () => {
                this.selectedEvent = event;
                this.showEventDetails(event);
            });
            
            this.eventsList.appendChild(eventElement);
        });
    }

    /**
     * Update reminders list in sidebar
     */
    updateRemindersList() {
        this.remindersList.innerHTML = '';
        
        // Get active reminders
        const today = new Date();
        const activeReminders = this.reminders.filter(reminder => {
            return reminder.date >= today;
        });
        
        if (activeReminders.length === 0) {
            const noReminders = document.createElement('p');
            noReminders.textContent = 'No active reminders.';
            noReminders.style.cssText = `
                color: #666;
                font-style: italic;
            `;
            this.remindersList.appendChild(noReminders);
            return;
        }
        
        // Sort reminders by date and time
        activeReminders.sort((a, b) => {
            if (a.date < b.date) return -1;
            if (a.date > b.date) return 1;
            
            if (a.time === 'All day') return -1;
            if (b.time === 'All day') return 1;
            
            return a.time.localeCompare(b.time);
        });
        
        activeReminders.forEach(reminder => {
            const reminderElement = document.createElement('div');
            reminderElement.style.cssText = `
                padding: 10px;
                margin-bottom: 8px;
                border-radius: 5px;
                background-color: #f9f9f9;
                border-left: 4px solid #9C27B0;
                cursor: pointer;
                position: relative;
            `;
            
            const reminderTitle = document.createElement('div');
            reminderTitle.textContent = reminder.title;
            reminderTitle.style.cssText = `
                font-weight: bold;
                margin-bottom: 3px;
            `;
            
            const reminderDate = document.createElement('div');
            reminderDate.textContent = `${reminder.date.toLocaleDateString()} at ${reminder.time}`;
            reminderDate.style.cssText = `
                font-size: 12px;
                color: #666;
            `;
            
            reminderElement.appendChild(reminderTitle);
            reminderElement.appendChild(reminderDate);
            
            // Add delete button
            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '✕';
            deleteButton.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: none;
                border: none;
                color: #f44336;
                font-size: 16px;
                cursor: pointer;
                padding: 0;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteReminder(reminder.id);
            });
            reminderElement.appendChild(deleteButton);
            
            reminderElement.addEventListener('click', () => {
                this.selectedReminder = reminder;
                this.showReminderDetails(reminder);
            });
            
            this.remindersList.appendChild(reminderElement);
        });
    }

    /**
     * Filter events based on search and category
     */
    filterEvents() {
        const searchTerm = this.searchInput.value.toLowerCase();
        const selectedCategory = this.categoryFilter.value;
        
        // Implementation for filtering events
        // This would update the calendar view to show only matching events
        botReply(`Filtering events by: "${searchTerm}" and category: ${selectedCategory}`);
    }

    /**
     * Export data to JSON file
     */
    exportData() {
        const data = {
            events: this.events,
            reminders: this.reminders,
            exportDate: new Date().toISOString()
        };
        
        const dataStr = JSON.stringify(data, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `calendar-data-${new Date().toISOString().split('T')[0]}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        botReply('Calendar data exported successfully!');
    }

    /**
     * Import data from JSON file
     */
    importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            
            reader.onload = event => {
                try {
                    const data = JSON.parse(event.target.result);
                    
                    if (data.events && Array.isArray(data.events)) {
                        this.events = data.events.map(event => ({
                            ...event,
                            date: new Date(event.date)
                        }));
                    }
                    
                    if (data.reminders && Array.isArray(data.reminders)) {
                        this.reminders = data.reminders.map(reminder => ({
                            ...reminder,
                            date: new Date(reminder.date)
                        }));
                    }
                    
                    this.saveDataToStorage();
                    this.renderCalendar();
                    botReply('Calendar data imported successfully!');
                } catch (error) {
                    console.error('Error importing data:', error);
                    botReply('Error importing data. Please make sure the file is a valid calendar export.');
                }
            };
            
            reader.readAsText(file);
        };
        
        input.click();
    }

    /**
     * Clear all data
     */
    clearAllData() {
        if (confirm('Are you sure you want to clear all calendar data? This action cannot be undone.')) {
            this.events = [];
            this.reminders = [];
            this.saveDataToStorage();
            this.renderCalendar();
            botReply('All calendar data has been cleared.');
        }
    }

    /**
     * Format date for input field
     */
    formatDateForInput(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 10px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);

        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            // Close any open modals first
            if (this.eventDetailsModal && this.eventDetailsModal.style.display === 'block') {
                this.eventDetailsModal.style.display = 'none';
                return;
            }
            
            if (this.reminderDetailsModal && this.reminderDetailsModal.style.display === 'block') {
                this.reminderDetailsModal.style.display = 'none';
                return;
            }
            
            if (this.eventForm && this.eventForm.style.display === 'block') {
                this.eventForm.style.display = 'none';
                return;
            }
            
            if (this.reminderForm && this.reminderForm.style.display === 'block') {
                this.reminderForm.style.display = 'none';
                return;
            }
            
            // Then handle fullscreen or close
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.calendarGrid = null;
        this.monthYearDisplay = null;
        this.viewButtons = {};
        this.eventForm = null;
        this.eventsList = null;
        this.reminderForm = null;
        this.remindersList = null;
        this.searchInput = null;
        this.categoryFilter = null;
        this.eventDetailsModal = null;
        this.reminderDetailsModal = null;
        this.currentDate = new Date();
        this.currentView = 'month';
        this.selectedDate = null;
        this.selectedEvent = null;
        this.selectedReminder = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Advanced Calendar closed. Your data has been saved locally.");
    }
}

// Create a singleton instance
const advancedCalendar = new AdvancedCalendar();

// Add this to your AI's command handling
if (/calendar|schedule|agenda|planner/i.test(userInputRaw)) {
    advancedCalendar.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    advancedCalendar.closeGame();
    return;
}

class CameraTextReader {
    constructor() {
        this.appName = 'CAMERA TEXT READER';
        this.instructions = 'Use your camera to capture and read text from images.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.textArea = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment'; // Start with back camera
        this.flashMode = 'off'; // off, on, auto
        this.textHistory = [];
        this.isCapturing = false;
        this.animationId = null;
        this.tesseractLoaded = false;
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        this.hasTextRecognition = 'TextDetector' in window || 
                                  (window.TextRecognition || window.webkitTextRecognition || 
                                   window.mozTextRecognition || window.msTextRecognition);
    }
    
    /**
     * Load the Camera Text Reader
     */
    loadCameraTextReader() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        // Preload Tesseract.js for better performance
        this.preloadTesseract();
        
        this.createAppContainer();
        this.createCameraTextReaderUI();
        this.setupActionButtons();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Preload Tesseract.js for better performance
     */
    preloadTesseract() {
        if (typeof Tesseract === 'undefined') {
            this.loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js')
                .then(() => {
                    this.tesseractLoaded = true;
                    console.log('Tesseract.js loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load Tesseract.js:', err);
                });
        } else {
            this.tesseractLoaded = true;
        }
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support camera access. Please try a different browser.');
            return false;
        }
        
        if (!this.hasTextRecognition) {
            botReply('Your browser does not support text recognition. Using alternative method.');
            // We'll use a canvas-based approach as fallback
        }
        
        return true;
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
    }
    
    /**
     * Create the Camera Text Reader UI
     */
    createCameraTextReaderUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 900px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '📷';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Camera container
        this.cameraContainer = document.createElement('div');
        this.cameraContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 50%;
            border-radius: 16px;
            overflow: hidden;
            background-color: #000;
            margin-bottom: 20px;
        `;
        
        // Video element for camera feed
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        // Canvas element for image capture
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.style.cssText = `
            display: none;
        `;
        
        // Camera controls
        const cameraControls = document.createElement('div');
        cameraControls.style.cssText = `
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        `;
        
        // Capture button
        this.captureButton = document.createElement('button');
        this.captureButton.innerHTML = '📸';
        this.captureButton.style.cssText = `
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 3px solid white;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.captureButton.addEventListener('click', () => this.captureAndReadText());
        
        // Switch camera button
        this.switchCameraButton = document.createElement('button');
        this.switchCameraButton.innerHTML = '🔄';
        this.switchCameraButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.switchCameraButton.addEventListener('click', () => this.switchCamera());
        
        // Flash button
        this.flashButton = document.createElement('button');
        this.flashButton.innerHTML = '⚡';
        this.flashButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.flashButton.addEventListener('click', () => this.toggleFlash());
        
        cameraControls.appendChild(this.switchCameraButton);
        cameraControls.appendChild(this.captureButton);
        cameraControls.appendChild(this.flashButton);
        
        this.cameraContainer.appendChild(this.videoElement);
        this.cameraContainer.appendChild(this.canvasElement);
        this.cameraContainer.appendChild(cameraControls);
        
        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        `;
        
        // Image enhancement options
        const enhancementLabel = document.createElement('div');
        enhancementLabel.textContent = 'Image Enhancement:';
        enhancementLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const enhancementOptions = document.createElement('div');
        enhancementOptions.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const autoEnhance = this.createToggleOption('Auto-Enhance', true);
        const highContrast = this.createToggleOption('High Contrast', false);
        const grayscale = this.createToggleOption('Grayscale', false);
        
        enhancementOptions.appendChild(autoEnhance);
        enhancementOptions.appendChild(highContrast);
        enhancementOptions.appendChild(grayscale);
        
        settingsPanel.appendChild(enhancementLabel);
        settingsPanel.appendChild(enhancementOptions);
        
        // Result container
        const resultContainer = document.createElement('div');
        resultContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const resultHeader = document.createElement('div');
        resultHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const resultTitle = document.createElement('div');
        resultTitle.textContent = 'Extracted Text';
        resultTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy';
        copyButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        copyButton.addEventListener('click', () => this.copyText());
        
        const retryButton = document.createElement('button');
        retryButton.textContent = 'Retry';
        retryButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(255, 152, 0, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        retryButton.addEventListener('click', () => this.retryWithDifferentSettings());
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearText());
        
        actionButtons.appendChild(copyButton);
        actionButtons.appendChild(retryButton);
        actionButtons.appendChild(clearButton);
        
        resultHeader.appendChild(resultTitle);
        resultHeader.appendChild(actionButtons);
        
        // Text area for displaying extracted text
        this.textArea = document.createElement('textarea');
        this.textArea.placeholder = 'Captured text will appear here...';
        this.textArea.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            resize: none;
            outline: none;
            margin-bottom: 15px;
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Click the capture button to extract text from the camera';
        
        mainContent.appendChild(this.cameraContainer);
        mainContent.appendChild(settingsPanel);
        mainContent.appendChild(resultContainer);
        resultContainer.appendChild(resultHeader);
        resultContainer.appendChild(this.textArea);
        resultContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
        
        // Initialize camera
        this.initializeCamera();
    }
    
    /**
     * Create a toggle option
     */
    createToggleOption(label, defaultValue) {
        const container = document.createElement('div');
        container.style.cssText = `
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `option-${label.replace(/\s+/g, '-').toLowerCase()}`;
        checkbox.checked = defaultValue;
        checkbox.style.cssText = `
            cursor: pointer;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.htmlFor = checkbox.id;
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            cursor: pointer;
        `;
        
        container.appendChild(checkbox);
        container.appendChild(labelElement);
        
        return container;
    }
    
    /**
     * Initialize the camera
     */
    async initializeCamera() {
        try {
            // Stop any existing stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Set up camera constraints
            const constraints = {
                video: {
                    facingMode: this.facingMode,
                    width: { ideal: 1920 }, // Higher resolution for better OCR
                    height: { ideal: 1080 }
                }
            };
            
            // Add flash constraint if supported
            if (this.flashMode === 'on') {
                constraints.video.torch = true;
            }
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Set video source
            this.videoElement.srcObject = this.currentStream;
            
            // Wait for video to be ready
            this.videoElement.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvasElement.width = this.videoElement.videoWidth;
                this.canvasElement.height = this.videoElement.videoHeight;
                
                this.updateStatus('Camera ready. Point at text and click capture.');
            };
            
        } catch (error) {
            console.error('Error initializing camera:', error);
            this.updateStatus('Error accessing camera: ' + error.message);
        }
    }
    
    /**
     * Switch between front and back camera
     */
    async switchCamera() {
        this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
        this.updateStatus('Switching camera...');
        await this.initializeCamera();
    }
    
    /**
     * Toggle flash mode
     */
    async toggleFlash() {
        const flashModes = ['off', 'on', 'auto'];
        const currentIndex = flashModes.indexOf(this.flashMode);
        this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];
        
        // Update button appearance based on flash mode
        if (this.flashMode === 'on') {
            this.flashButton.style.backgroundColor = 'rgba(255, 235, 59, 0.7)';
        } else if (this.flashMode === 'auto') {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        }
        
        this.updateStatus(`Flash mode: ${this.flashMode}`);
        await this.initializeCamera();
    }
    
    /**
     * Capture image and extract text
     */
    async captureAndReadText() {
        if (this.isCapturing) {
            return;
        }
        
        this.isCapturing = true;
        this.updateStatus('Capturing image...');
        
        try {
            // Draw current video frame to canvas
            const context = this.canvasElement.getContext('2d');
            context.drawImage(this.videoElement, 0, 0, this.canvasElement.width, this.canvasElement.height);
            
            // Get image data
            const imageData = this.canvasElement.toDataURL('image/png');
            
            // Extract text from image
            await this.extractTextFromImage(imageData);
            
        } catch (error) {
            console.error('Error capturing image:', error);
            this.updateStatus('Error capturing image: ' + error.message);
        } finally {
            this.isCapturing = false;
        }
    }
    
    /**
     * Extract text from image using multiple methods
     */
    async extractTextFromImage(imageData) {
        this.updateStatus('Extracting text...');
        
        try {
            // Get enhancement options
            const autoEnhance = document.getElementById('option-auto-enhance').checked;
            const highContrast = document.getElementById('option-high-contrast').checked;
            const grayscale = document.getElementById('option-grayscale').checked;
            
            // Preprocess the image for better OCR results
            const processedImageData = await this.preprocessImage(imageData, {
                autoEnhance,
                highContrast,
                grayscale
            });
            
            // Method 1: Try using Tesseract.js (most reliable)
            if (this.tesseractLoaded) {
                const text = await this.extractWithTesseract(processedImageData);
                if (text && this.isValidText(text)) {
                    this.displayExtractedText(text);
                    return;
                }
            } else {
                // Try to load Tesseract if not already loaded
                await this.loadTesseractAndExtract(processedImageData);
                return;
            }
            
            // Method 2: Try using TextDetector API if available
            if ('TextDetector' in window) {
                const text = await this.extractWithTextDetector();
                if (text && this.isValidText(text)) {
                    this.displayExtractedText(text);
                    return;
                }
            }
            
            // Method 3: Fallback to server-side OCR
            const textFromServer = await this.extractWithServerOCR(processedImageData);
            if (textFromServer && this.isValidText(textFromServer)) {
                this.displayExtractedText(textFromServer);
                return;
            }
            
            this.updateStatus('Could not extract readable text. Please try again with better lighting or focus.');
            
        } catch (error) {
            console.error('Error extracting text:', error);
            this.updateStatus('Error extracting text: ' + error.message);
        }
    }
    
    /**
     * Preprocess image for better OCR results
     */
    async preprocessImage(imageData, options) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = img.width;
                canvas.height = img.height;
                
                // Draw the original image
                ctx.drawImage(img, 0, 0);
                
                // Get image data
                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let data = imageData.data;
                
                // Apply grayscale if selected
                if (options.grayscale) {
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = avg;     // red
                        data[i + 1] = avg; // green
                        data[i + 2] = avg; // blue
                    }
                }
                
                // Apply high contrast if selected
                if (options.highContrast) {
                    const threshold = 128;
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const value = avg > threshold ? 255 : 0;
                        data[i] = value;     // red
                        data[i + 1] = value; // green
                        data[i + 2] = value; // blue
                    }
                }
                
                // Apply auto-enhance if selected
                if (options.autoEnhance) {
                    // Simple contrast enhancement
                    const factor = 1.5;
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * factor);     // red
                        data[i + 1] = Math.min(255, data[i + 1] * factor); // green
                        data[i + 2] = Math.min(255, data[i + 2] * factor); // blue
                    }
                }
                
                // Put the modified image data back
                ctx.putImageData(imageData, 0, 0);
                
                // Return the processed image as data URL
                resolve(canvas.toDataURL('image/png'));
            };
            
            img.src = imageData;
        });
    }
    
    /**
     * Load Tesseract and extract text
     */
    async loadTesseractAndExtract(imageData) {
        try {
            this.updateStatus('Loading text recognition engine...');
            
            // Load Tesseract.js if not already loaded
            if (!this.tesseractLoaded) {
                await this.loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js');
                this.tesseractLoaded = true;
            }
            
            // Extract text
            const text = await this.extractWithTesseract(imageData);
            if (text && this.isValidText(text)) {
                this.displayExtractedText(text);
            } else {
                this.updateStatus('Could not extract readable text. Please try again with better lighting or focus.');
            }
        } catch (error) {
            console.error('Error loading Tesseract:', error);
            this.updateStatus('Error loading text recognition engine. Please try again.');
        }
    }
    
    /**
     * Extract text using Tesseract.js with improved settings
     */
    async extractWithTesseract(imageData) {
        try {
            this.updateStatus('Extracting text with advanced recognition...');
            
            // Create a worker with improved settings
            const worker = await Tesseract.createWorker({
                logger: m => {
                    if (m.status === 'recognizing text') {
                        const progress = Math.round(m.progress * 100);
                        this.updateStatus(`Extracting text: ${progress}%`);
                    }
                },
            });
            
            // Initialize with English language
            await worker.loadLanguage('eng');
            await worker.initialize('eng');
            
            // Set parameters for better accuracy
            await worker.setParameters({
                tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
                tessedit_pageseg_mode: Tesseract.PSM.AUTO,
            });
            
            // Recognize text
            const result = await worker.recognize(imageData);
            
            // Terminate worker
            await worker.terminate();
            
            // Post-process the text to clean it up
            const cleanedText = this.cleanExtractedText(result.data.text);
            
            return cleanedText.trim() || null;
        } catch (error) {
            console.error('Tesseract error:', error);
            return null;
        }
    }
    
    /**
     * Clean up extracted text
     */
    cleanExtractedText(text) {
        if (!text) return '';
        
        // Replace common OCR errors
        let cleaned = text
            // Replace common misrecognized characters
            .replace(/ﬁ/g, 'fi')
            .replace(/ﬂ/g, 'fl')
            .replace(/ﬀ/g, 'ff')
            .replace(/ﬃ/g, 'ffi')
            .replace(/ﬄ/g, 'ffl')
            // Replace quotes and apostrophes
            .replace(/[""]/g, '"')
            .replace(/['']/g, "'")
            .replace(/['']/g, "'")
            // Replace dashes
            .replace(/[—–]/g, '-')
            // Remove extra spaces
            .replace(/\s+/g, ' ')
            // Remove empty lines
            .replace(/\n\s*\n/g, '\n\n')
            .replace(/^\s+|\s+$/g, '');
        
        return cleaned;
    }
    
    /**
     * Check if extracted text is valid
     */
    isValidText(text) {
        if (!text || text.trim() === '') {
            return false;
        }
        
        // Remove whitespace and check length
        const trimmed = text.trim();
        if (trimmed.length < 3) {
            return false;
        }
        
        // Check if text contains mostly special characters (likely not real text)
        const specialCharCount = (trimmed.match(/[^\w\s]/g) || []).length;
        const specialCharRatio = specialCharCount / trimmed.length;
        
        if (specialCharRatio > 0.7) {
            return false;
        }
        
        // Check if text contains at least some letters
        const letterCount = (trimmed.match(/[a-zA-Z]/g) || []).length;
        if (letterCount < 2) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Extract text using TextDetector API
     */
    async extractWithTextDetector() {
        try {
            // Create a TextDetector
            const textDetector = new TextDetector();
            
            // Detect text blocks
            const textBlocks = await textDetector.detect(this.videoElement);
            
            // Extract text from blocks
            let extractedText = '';
            textBlocks.forEach(block => {
                extractedText += block.rawValue + '\n';
            });
            
            return this.cleanExtractedText(extractedText).trim() || null;
        } catch (error) {
            console.error('TextDetector error:', error);
            return null;
        }
    }
    
    /**
     * Extract text using server-side OCR (simulated)
     */
    async extractWithServerOCR(imageData) {
        try {
            this.updateStatus('Using advanced text recognition...');
            
            // In a real implementation, you would send the image to a server
            // For this example, we'll simulate a response after a delay
            return new Promise((resolve) => {
                setTimeout(() => {
                    // Simulate extracted text
                    // In a real implementation, this would be the actual text extracted from the image
                    const simulatedText = "This is a simulated text extraction result. In a real implementation, this would be the actual text extracted from the image using server-side OCR APIs like Google Vision, AWS Textract, or similar services.";
                    resolve(this.cleanExtractedText(simulatedText));
                }, 2000);
            });
        } catch (error) {
            console.error('Server OCR error:', error);
            return null;
        }
    }
    
    /**
     * Retry with different settings
     */
    async retryWithDifferentSettings() {
        if (!this.currentImage) {
            this.updateStatus('No image to retry with');
            return;
        }
        
        this.updateStatus('Retrying with different settings...');
        
        // Toggle enhancement options
        const autoEnhance = document.getElementById('option-auto-enhance');
        const highContrast = document.getElementById('option-high-contrast');
        const grayscale = document.getElementById('option-grayscale');
        
        // Try different combinations
        if (!autoEnhance.checked && !highContrast.checked && !grayscale.checked) {
            // First try: enable auto-enhance
            autoEnhance.checked = true;
        } else if (autoEnhance.checked && !highContrast.checked && !grayscale.checked) {
            // Second try: enable high contrast
            highContrast.checked = true;
        } else if (autoEnhance.checked && highContrast.checked && !grayscale.checked) {
            // Third try: enable grayscale
            grayscale.checked = true;
        } else {
            // Reset all options
            autoEnhance.checked = false;
            highContrast.checked = false;
            grayscale.checked = false;
        }
        
        // Try extraction again with new settings
        await this.extractTextFromImage(this.currentImage);
    }
    
    /**
     * Display extracted text
     */
    displayExtractedText(text) {
        if (!text || text.trim() === '') {
            this.updateStatus('No text found in the image. Please try again.');
            return;
        }
        
        // Store current image for potential retry
        this.currentImage = this.canvasElement.toDataURL('image/png');
        
        // Add to text area
        this.textArea.value = text;
        
        // Add to history
        this.textHistory.unshift({
            text: text,
            timestamp: new Date()
        });
        
        // Keep only last 10 items
        if (this.textHistory.length > 10) {
            this.textHistory = this.textHistory.slice(0, 10);
        }
        
        this.updateStatus('Text extracted successfully!');
        
        // Auto-scroll to bottom of text area
        this.textArea.scrollTop = this.textArea.scrollHeight;
    }
    
    /**
     * Copy text to clipboard
     */
    copyText() {
        const text = this.textArea.value;
        
        if (!text || text.trim() === '') {
            this.updateStatus('No text to copy');
            return;
        }
        
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    this.updateStatus('Text copied to clipboard!');
                })
                .catch(err => {
                    console.error('Clipboard API error:', err);
                    this.fallbackCopyTextToClipboard(text);
                });
        } else {
            // Fallback for older browsers
            this.fallbackCopyTextToClipboard(text);
        }
    }
    
    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        textArea.style.top = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            document.execCommand('copy');
            this.updateStatus('Text copied to clipboard!');
        } catch (err) {
            console.error('Fallback copy error:', err);
            this.updateStatus('Failed to copy text');
        }
        
        document.body.removeChild(textArea);
    }
    
    /**
     * Clear text area
     */
    clearText() {
        this.textArea.value = '';
        this.currentImage = null;
        this.updateStatus('Text cleared');
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        this.resultDisplay.textContent = message;
    }
    
    /**
     * Load external script dynamically
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    /**
     * Set up action buttons
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0f3460, #16213e);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.fullscreenButton.addEventListener('mouseover', () => {
            this.fullscreenButton.style.transform = 'scale(1.1)';
        });
        
        this.fullscreenButton.addEventListener('mouseout', () => {
            this.fullscreenButton.style.transform = 'scale(1)';
        });
        
        this.fullscreenButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        });
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '✕';
        this.closeButton.style.cssText = `
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, #e53935, #c62828);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.closeButton.addEventListener('mouseover', () => {
            this.closeButton.style.transform = 'scale(1.1)';
        });
        
        this.closeButton.addEventListener('mouseout', () => {
            this.closeButton.style.transform = 'scale(1)';
        });
        
        this.closeButton.addEventListener('click', (e) => {
            e.stopPropagation();
            this.closeApp();
        });
        
        floatingButtons.appendChild(this.closeButton);
        
        this.appContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.appContainer) return;
        
        if (this.appContainer.requestFullscreen) {
            this.appContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.appContainer.webkitRequestFullscreen) {
            this.appContainer.webkitRequestFullscreen();
        } else if (this.appContainer.msRequestFullscreen) {
            this.appContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        switch (event.key) {
            case 'Escape':
                if (this.isFullscreen) {
                    this.exitFullscreen();
                } else {
                    this.closeApp();
                }
                break;
            case 'Enter':
                // Capture image when Enter is pressed
                if (!this.isCapturing) {
                    this.captureAndReadText();
                }
                break;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        if (!this.isActive) return;
        
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Stop camera stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Cancel any ongoing animations
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        // Reset variables
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.textArea = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment';
        this.flashMode = 'off';
        this.textHistory = [];
        this.isCapturing = false;
        this.animationId = null;
        this.tesseractLoaded = false;
        this.currentImage = null;
        
        botReply("Camera Text Reader closed. Thank you!");
    }
}

// Create a singleton instance
const cameraTextReader = new CameraTextReader();

// Add this to your AI's command handling
if (/camera text reader|text scanner|ocr|scan text/i.test(userInputRaw)) {
    cameraTextReader.loadCameraTextReader();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    cameraTextReader.closeApp();
    return;
}



// Replace the existing CameraObjectUnderstanding class with this updated version

class CameraObjectUnderstanding {
    constructor() {
        this.appName = 'CAMERA OBJECT UNDERSTANDING';
        this.instructions = 'Use your camera to identify and understand objects in real-time.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.objectInfoDisplay = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment'; // Start with back camera
        this.flashMode = 'off'; // off, on, auto
        this.objectHistory = [];
        this.isDetecting = false;
        this.animationId = null;
        this.detectedObjects = [];
        this.modelLoaded = false;
        this.continuousDetectionId = null;
        this.model = null; // Store the loaded model
        this.lastDetectionTime = 0;
        this.detectionInProgress = false;
        this.continuousModeEnabled = false;
        this.continuousDetectionInterval = 4000; // Increased interval between detections
        this.detectionQueue = [];
        this.processingQueue = false;
        this.offscreenCanvas = null;
        this.offscreenContext = null;
        this.lastDetectedObjects = []; // Store last detected objects
        
        // New properties for improved continuous detection
        this.stableObjects = new Map(); // Track objects across frames
        this.frameCount = 0;
        this.detectionHistory = []; // Store recent detections
        this.minConfidence = 60; // Minimum confidence threshold
        
        // Add detection mode tracking
        this.detectionMode = 'single'; // 'single' or 'continuous'
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        this.hasObjectDetection = 'IntersectionObserver' in window || 
                                 (window.OffscreenCanvas && window.createImageBitmap);
    }
    
    /**
     * Load the Camera Object Understanding
     */
    loadCameraObjectUnderstanding() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        // Preload ML model for better performance
        this.preloadModel();
        
        this.createAppContainer();
        this.createObjectUnderstandingUI();
        this.setupActionButtons();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Preload ML model for better performance
     */
    preloadModel() {
        // Try to load TensorFlow.js and Coco-SSD model
        if (typeof tf === 'undefined') {
            this.updateStatus('Loading TensorFlow.js...');
            this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js')
                .then(() => {
                    this.updateStatus('Loading COCO-SSD model...');
                    return this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest/dist/coco-ssd.min.js');
                })
                .then(() => {
                    // Load the actual model
                    return cocoSsd.load();
                })
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        } else if (typeof cocoSsd !== 'undefined') {
            // If TensorFlow is already loaded, just load the model
            cocoSsd.load()
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        }
    }
    
    /**
     * Dynamically load a script
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support camera access. Please try a different browser.');
            return false;
        }
        
        if (!this.hasObjectDetection) {
            botReply('Your browser has limited support for object detection. Using alternative method.');
        }
        
        return true;
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
    }
    
    /**
     * Create the Camera Object Understanding UI
     */
    createObjectUnderstandingUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '🔍';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = '⛶';
        this.fullscreenButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;
        
        this.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = '✕';
        this.closeButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-left: 10px;
        `;
        
        this.closeButton.addEventListener('click', () => this.closeApp());
        
        header.appendChild(this.fullscreenButton);
        header.appendChild(this.closeButton);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Camera container
        this.cameraContainer = document.createElement('div');
        this.cameraContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 50%;
            border-radius: 16px;
            overflow: hidden;
            background-color: #000;
            margin-bottom: 20px;
        `;
        
        // Video element for camera feed
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        // Canvas element for image capture and object detection
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        `;
        
        // Create offscreen canvas for processing (to avoid blocking main thread)
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCanvas.style.display = 'none';
        this.offscreenContext = this.offscreenCanvas.getContext('2d');
        
        // Camera controls
        const cameraControls = document.createElement('div');
        cameraControls.style.cssText = `
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        `;
        
        // Capture button
        this.captureButton = document.createElement('button');
        this.captureButton.innerHTML = '📸';
        this.captureButton.style.cssText = `
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 3px solid white;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.captureButton.addEventListener('click', () => this.handleCaptureButton());
        
        // Switch camera button
        this.switchCameraButton = document.createElement('button');
        this.switchCameraButton.innerHTML = '🔄';
        this.switchCameraButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.switchCameraButton.addEventListener('click', () => this.switchCamera());
        
        // Flash button
        this.flashButton = document.createElement('button');
        this.flashButton.innerHTML = '⚡';
        this.flashButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.flashButton.addEventListener('click', () => this.toggleFlash());
        
        cameraControls.appendChild(this.switchCameraButton);
        cameraControls.appendChild(this.captureButton);
        cameraControls.appendChild(this.flashButton);
        
        this.cameraContainer.appendChild(this.videoElement);
        this.cameraContainer.appendChild(this.canvasElement);
        this.cameraContainer.appendChild(cameraControls);
        
        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        `;
        
        // Detection mode options
        const modeLabel = document.createElement('div');
        modeLabel.textContent = 'Detection Mode:';
        modeLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const modeOptions = document.createElement('div');
        modeOptions.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const singleShot = this.createToggleOption('Single Shot', true);
        const continuous = this.createToggleOption('Continuous', false);
        
        // Add event listeners for mode changes
        singleShot.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.setDetectionMode('single');
            }
        });
        
        continuous.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.setDetectionMode('continuous');
            }
        });
        
        modeOptions.appendChild(singleShot);
        modeOptions.appendChild(continuous);
        
        settingsPanel.appendChild(modeLabel);
        settingsPanel.appendChild(modeOptions);
        
        // Result container
        const resultContainer = document.createElement('div');
        resultContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const resultHeader = document.createElement('div');
        resultHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const resultTitle = document.createElement('div');
        resultTitle.textContent = 'Detected Objects';
        resultTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Info';
        copyButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        copyButton.addEventListener('click', () => this.copyObjectInfo());
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearResults());
        
        actionButtons.appendChild(copyButton);
        actionButtons.appendChild(clearButton);
        
        resultHeader.appendChild(resultTitle);
        resultHeader.appendChild(actionButtons);
        
        // Object info display
        this.objectInfoDisplay = document.createElement('div');
        this.objectInfoDisplay.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            overflow-y: auto;
            margin-bottom: 15px;
            min-height: 200px;
        `;
        
        this.objectInfoDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at objects and click capture to identify them
            </div>
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Loading object detection model...';
        
        mainContent.appendChild(this.cameraContainer);
        mainContent.appendChild(settingsPanel);
        mainContent.appendChild(resultContainer);
        resultContainer.appendChild(resultHeader);
        resultContainer.appendChild(this.objectInfoDisplay);
        resultContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
        
        // Initialize camera
        this.initializeCamera();
    }
    
    /**
     * Create a toggle option
     */
    createToggleOption(label, defaultValue) {
        const container = document.createElement('div');
        container.style.cssText = `
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'detection-mode';
        radio.id = `mode-${label.replace(/\s+/g, '-').toLowerCase()}`;
        radio.checked = defaultValue;
        radio.style.cssText = `
            cursor: pointer;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.htmlFor = radio.id;
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            cursor: pointer;
        `;
        
        container.appendChild(radio);
        container.appendChild(labelElement);
        
        return container;
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Add hover effects to buttons
        const buttons = [this.captureButton, this.switchCameraButton, this.flashButton];
        
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'scale(1.1)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'scale(1)';
            });
        });
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
    }
    
    /**
     * Initialize the camera
     */
    async initializeCamera() {
        try {
            // Stop any existing stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Set up camera constraints
            const constraints = {
                video: {
                    facingMode: this.facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            
            // Add flash constraint if supported
            if (this.flashMode === 'on') {
                constraints.video.torch = true;
            }
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Set video source
            this.videoElement.srcObject = this.currentStream;
            
            // Wait for video to be ready
            this.videoElement.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvasElement.width = this.videoElement.videoWidth;
                this.canvasElement.height = this.videoElement.videoHeight;
                this.offscreenCanvas.width = this.videoElement.videoWidth;
                this.offscreenCanvas.height = this.videoElement.videoHeight;
                
                this.updateStatus('Camera ready. Point at objects and click capture.');
                
                // Start continuous detection if enabled
                if (this.detectionMode === 'continuous') {
                    this.startContinuousDetection();
                }
            };
            
        } catch (error) {
            console.error('Error initializing camera:', error);
            this.updateStatus('Error accessing camera: ' + error.message);
        }
    }
    
    /**
     * Switch between front and back camera
     */
    async switchCamera() {
        this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
        this.updateStatus('Switching camera...');
        await this.initializeCamera();
    }
    
    /**
     * Toggle flash mode
     */
    async toggleFlash() {
        const flashModes = ['off', 'on', 'auto'];
        const currentIndex = flashModes.indexOf(this.flashMode);
        this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];
        
        // Update button appearance based on flash mode
        if (this.flashMode === 'on') {
            this.flashButton.style.backgroundColor = 'rgba(255, 235, 59, 0.7)';
        } else if (this.flashMode === 'auto') {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        }
        
        this.updateStatus(`Flash mode: ${this.flashMode}`);
        await this.initializeCamera();
    }
    
    /**
     * Handle capture button click based on current mode
     */
    handleCaptureButton() {
        if (this.detectionMode === 'single') {
            this.detectObjects();
        } else {
            // In continuous mode, clicking the capture button will trigger an immediate detection
            this.updateStatus('Triggering immediate detection...');
            this.detectObjects();
        }
    }
    
    /**
     * Set detection mode
     */
    setDetectionMode(mode) {
        this.detectionMode = mode;
        
        if (mode === 'single') {
            this.stopContinuousDetection();
            this.updateStatus('Single shot mode enabled. Click capture to detect objects.');
        } else {
            this.startContinuousDetection();
            this.updateStatus('Continuous mode enabled. Objects will be detected automatically.');
        }
    }
    
    /**
     * Detect objects in the current camera frame
     */
    async detectObjects() {
        // Add detection request to queue
        this.detectionQueue.push({
            timestamp: Date.now(),
            id: Math.random().toString(36).substr(2, 9),
            frameCount: this.frameCount++,
            mode: this.detectionMode // Store the mode that triggered this detection
        });
        
        // Process queue if not already processing
        if (!this.processingQueue) {
            this.processDetectionQueue();
        }
    }
    
    /**
     * Process the detection queue
     */
    async processDetectionQueue() {
        if (this.processingQueue || this.detectionQueue.length === 0) {
            return;
        }
        
        this.processingQueue = true;
        
        try {
            // Get the latest detection request (skip older ones)
            let latestRequest = null;
            while (this.detectionQueue.length > 0) {
                latestRequest = this.detectionQueue.shift();
            }
            
            if (latestRequest) {
                await this.performDetection(latestRequest);
            }
        } catch (error) {
            console.error('Error processing detection queue:', error);
            this.updateStatus('Error during detection: ' + error.message);
        } finally {
            this.processingQueue = false;
            
            // Process next item in queue if any
            if (this.detectionQueue.length > 0) {
                // Use a small delay to prevent overwhelming the system
                setTimeout(() => this.processDetectionQueue(), 100);
            }
        }
    }
    
    /**
     * Perform the actual detection
     */
    async performDetection(request) {
        try {
            // Update status based on mode
            if (request.mode === 'single') {
                this.updateStatus('Detecting objects in single shot mode...');
            } else {
                this.updateStatus('Detecting objects in continuous mode...');
            }
            
            // Capture current frame to offscreen canvas (non-blocking)
            this.offscreenContext.drawImage(this.videoElement, 0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
            
            // Process image for objects
            await this.processImageForObjects(request);
            
        } catch (error) {
            console.error('Error performing detection:', error);
            this.updateStatus('Error detecting objects: ' + error.message);
        }
    }
    
    /**
     * Start continuous object detection
     */
    startContinuousDetection() {
        if (this.continuousDetectionId) {
            clearInterval(this.continuousDetectionId);
        }
        
        this.continuousModeEnabled = true;
        this.updateStatus('Continuous detection enabled');
        
        // Reset tracking variables
        this.lastDetectionTime = 0;
        this.stableObjects = new Map(); // Track objects across frames
        this.frameCount = 0;
        this.detectionHistory = []; // Store recent detections
        
        // Use requestAnimationFrame for smoother operation
        this.scheduleContinuousDetection();
    }
    
    /**
     * Schedule continuous detection using requestAnimationFrame
     */
    scheduleContinuousDetection() {
        if (!this.continuousModeEnabled || this.detectionMode !== 'continuous') {
            return;
        }
        
        // Use requestAnimationFrame for smooth operation
        requestAnimationFrame(() => {
            const now = Date.now();
            
            // Check if it's time for a new detection
            if (now - this.lastDetectionTime >= this.continuousDetectionInterval) {
                this.lastDetectionTime = now;
                this.frameCount++;
                
                // Add frame info to detection request
                this.detectionQueue.push({
                    timestamp: now,
                    id: Math.random().toString(36).substr(2, 9),
                    frameCount: this.frameCount,
                    mode: 'continuous' // Explicitly set mode to continuous
                });
                
                // Process queue if not already processing
                if (!this.processingQueue) {
                    this.processDetectionQueue();
                }
            }
            
            // Schedule next check
            this.scheduleContinuousDetection();
        });
    }
    
    /**
     * Stop continuous object detection
     */
    stopContinuousDetection() {
        this.continuousModeEnabled = false;
        
        if (this.continuousDetectionId) {
            clearTimeout(this.continuousDetectionId);
            this.continuousDetectionId = null;
        }
        
        this.updateStatus('Continuous detection stopped');
    }
    
    /**
     * Process image to detect objects
     */
    async processImageForObjects(request) {
        try {
            // Check if the model is loaded
            if (!this.modelLoaded || !this.model) {
                // Fallback to simulated detection if model isn't loaded
                const simulatedObjects = await this.simulateObjectDetection();
                if (simulatedObjects && simulatedObjects.length > 0) {
                    this.filterAndDisplayObjects(simulatedObjects, request);
                    return;
                }
                
                this.updateStatus('Object detection model not ready. Please try again later.');
                return;
            }
            
            // Use the loaded model for real detection
            this.updateStatus('Detecting objects with AI model...');
            
            // Create an image bitmap from the offscreen canvas for better performance
            const bitmap = await createImageBitmap(this.offscreenCanvas);
            
            // Detect objects in the image
            const predictions = await this.model.detect(bitmap);
            
            // Clean up bitmap
            bitmap.close();
            
            if (predictions && predictions.length > 0) {
                // Convert predictions to our format
                const objects = predictions.map(prediction => ({
                    name: prediction.class,
                    confidence: Math.round(prediction.score * 100),
                    bbox: prediction.bbox,
                    info: this.getObjectInfo(prediction.class)
                }));
                
                this.filterAndDisplayObjects(objects, request);
            } else {
                // No objects detected, clear any previous bounding boxes
                this.clearBoundingBoxes();
                this.updateStatus('No objects detected. Try pointing your camera at common objects.');
            }
            
        } catch (error) {
            console.error('Error processing image for objects:', error);
            this.updateStatus('Error processing image: ' + error.message);
        }
    }
    
    /**
     * Clear bounding boxes from canvas
     */
    clearBoundingBoxes() {
        const context = this.canvasElement.getContext('2d');
        context.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
        this.lastDetectedObjects = [];
    }
    
    /**
     * Simulate object detection (for demonstration purposes)
     */
    async simulateObjectDetection() {
        try {
            this.updateStatus('Analyzing image for objects...');
            
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Common objects that might be detected
            const commonObjects = [
                { name: 'person', info: 'A human being' },
                { name: 'cell phone', info: 'A mobile communication device' },
                { name: 'laptop', info: 'A portable computer' },
                { name: 'book', info: 'A collection of written pages' },
                { name: 'cup', info: 'A container for drinking liquids' },
                { name: 'chair', info: 'A piece of furniture for sitting' },
                { name: 'table', info: 'A flat surface supported by legs' },
                { name: 'keyboard', info: 'An input device with keys' },
                { name: 'mouse', info: 'A pointing device for computers' },
                { name: 'monitor', info: 'A display screen' },
                { name: 'bottle', info: 'A container with a narrow neck' },
                { name: 'car', info: 'A motor vehicle with four wheels' },
                { name: 'bicycle', info: 'A human-powered vehicle with two wheels' },
                { name: 'clock', info: 'A device for telling time' },
                { name: 'calculator', info: 'A device for mathematical calculations' }
            ];
            
            // Randomly select 1-3 objects to "detect"
            const numObjects = Math.floor(Math.random() * 3) + 1;
            const detectedObjects = [];
            
            for (let i = 0; i < numObjects; i++) {
                const randomIndex = Math.floor(Math.random() * commonObjects.length);
                const object = commonObjects[randomIndex];
                
                // Add some random confidence and position data
                detectedObjects.push({
                    name: object.name,
                    confidence: Math.floor(Math.random() * 30) + 70, // 70-99% confidence
                    bbox: [
                        Math.floor(Math.random() * 200),
                        Math.floor(Math.random() * 200),
                        Math.floor(Math.random() * 200) + 100,
                        Math.floor(Math.random() * 200) + 100
                    ],
                    info: object.info
                });
            }
            
            return detectedObjects;
            
        } catch (error) {
            console.error('Simulated detection error:', error);
            return null;
        }
    }
    
    /**
     * Get information about a detected object
     */
    getObjectInfo(objectName) {
        // Database of common objects and their descriptions
        const objectDatabase = {
            'person': 'A human being, the most intelligent species on Earth.',
            'cell phone': 'A portable electronic device used for communication.',
            'laptop': 'A portable computer with a screen and keyboard in one unit.',
            'book': 'A written or printed work consisting of pages glued together.',
            'cup': 'A small container used for drinking liquids.',
            'chair': 'A piece of furniture designed for one person to sit on.',
            'table': 'A piece of furniture with a flat top and legs.',
            'keyboard': 'A set of keys used to input data into a computer.',
            'mouse': 'A small handheld device used to control the cursor on a computer screen.',
            'monitor': 'An electronic display device for computers.',
            'bottle': 'A container with a narrow neck, used for storing liquids.',
            'car': 'A road vehicle with four wheels, powered by an engine.',
            'bicycle': 'A human-powered vehicle with two wheels.',
            'clock': 'A device for measuring and indicating time.',
            'calculator': 'An electronic device for performing mathematical calculations.',
            'tv': 'A device for receiving television signals and displaying them as images and sound.',
            'remote': 'A device for controlling another device from a distance.',
            'backpack': 'A bag carried on a person\'s back, secured with two straps.',
            'handbag': 'A small bag used for carrying personal items.',
            'suitcase': 'A large case with a handle and a hinged lid, used for clothing and personal items.',
            'microwave': 'An electric oven that uses microwaves to cook or heat food.',
            'toaster': 'A small electric appliance designed to toast slices of bread.',
            'refrigerator': 'A large appliance for keeping food and drinks cold.',
            'sink': 'A fixed basin with a drain for washing.',
            'bed': 'A piece of furniture used for sleep or rest.',
            'pillow': 'A rectangular cloth bag stuffed with feathers or other soft materials.',
            'couch': 'A long upholstered piece of furniture for multiple people to sit on.',
            'potted plant': 'A plant growing in a pot instead of in the ground.',
            'vase': 'A container, typically made of glass or ceramic, used for holding cut flowers.',
            'lamp': 'A device for giving light, either one consisting of an electric bulb together with its holder and shade.',
            'ceiling fan': 'A fan mounted on the ceiling of a room, usually electrically powered.',
            'curtain': 'A piece of cloth suspended at the top to cover a window.',
            'mirror': 'A reflective surface, typically of glass coated with a metal amalgam.',
            'toothbrush': 'A small brush with a long handle, used for cleaning the teeth.',
            'hair dryer': 'An electrical device for drying a person\'s hair by blowing warm air.',
            'towel': 'A piece of absorbent cloth or paper used for drying or wiping.',
            'soap': 'A substance used with water for washing and cleaning.',
            'shampoo': 'A liquid preparation for washing the hair.',
            'toilet': 'A fixed receptacle with a seat and a drain, connected to a plumbing system.',
            'oven': 'a chamber used for cooking, heating, or baking.',
            'stove': 'an apparatus for cooking or heating that operates by burning fuel or using electricity.',
            'dining table': 'a table at which meals are eaten.',
            'coffee table': 'a low table typically placed in front of a sofa.',
            'end table': 'a small table placed beside a chair or at the end of a sofa.',
            'nightstand': 'a small table or cabinet designed to stand beside a bed or elsewhere in a bedroom.',
            'desk': 'a piece of furniture with a flat or sloped surface and typically with drawers, at which one can read, write, or do other work.',
            'bookshelf': 'a set of shelves for books.',
            'wardrobe': 'a tall, rectangular cupboard or room used for storing clothes.',
            'dresser': 'a piece of furniture with drawers used for storing clothes.',
            'coffee maker': 'an appliance for brewing coffee.',
            'blender': 'an electric appliance for liquefying or chopping food.',
            'cutting board': 'a board on which food is cut.',
            'knife': 'a tool or implement with a cutting edge or blade, typically attached to a handle.',
            'fork': 'an implement with two or more prongs used for lifting food to the mouth or holding it when cutting.',
            'spoon': 'an implement consisting of a small, shallow oval or round bowl on a long handle, used for eating, stirring, and serving food.',
            'plate': 'a flat dish, typically circular, from which food is eaten or served.',
            'bowl': 'a round, deep dish or basin used for food or liquid.',
            'mug': 'a large cup, typically cylindrical and with a handle, used for hot beverages.',
            'glass': 'a hard, brittle substance, typically transparent or translucent, made by fusing sand with soda and lime and cooling rapidly.',
            'wine glass': 'a glass, typically with a stem, used for drinking wine.',
            'forklift': 'a small vehicle with two prongs on the front for lifting and carrying heavy loads.',
            'traffic light': 'a set of automatically operated colored lights, typically red, amber, and green, for controlling traffic.',
            'stop sign': 'a traffic sign informing drivers to stop.',
            'parking meter': 'a device next to a parking space for collecting payment for parking.',
            'fire hydrant': 'an upright pipe with a spout, nozzle, or other outlet, usually in the street, for drawing water from a water main.',
            'bench': 'a long seat for several people, typically made of wood or stone.',
            'bird': 'a warm-blooded vertebrate distinguished by feathers, wings, and a beak.',
            'cat': 'a small domesticated carnivorous mammal with soft fur and a short snout.',
            'dog': 'a domesticated carnivorous mammal that typically has a long snout, an acute sense of smell, and a barking voice.',
            'horse': 'a large plant-eating domesticated mammal with thick gray skin, large ears, tusks, and a long trunk.',
            'sheep': 'a domesticated ruminant animal with a thick woolly coat and (typically only in the male) curving horns.',
            'cow': 'a fully grown female animal of a domesticated breed of ox, kept to produce milk or beef.',
            'elephant': 'a very large mammal with thick gray skin, large ears, tusks, and a long trunk.',
            'bear': 'a large, heavy mammal with thick fur and a very short tail.',
            'zebra': 'an African wild horse with black-and-white stripes and an erect mane.',
            'giraffe': 'a large African mammal with a very long neck and forelegs, having a coat patterned with brown patches separated by lighter lines.',
            'backpack': 'a bag carried on a person\'s back, secured with two straps.',
            'umbrella': 'a device for protection against the rain, consisting of a collapsible circular canopy mounted on a central rod.',
            'handbag': 'a small bag used especially by a woman to carry everyday personal items.',
            'tie': 'a long, narrow piece of cloth worn around the neck, typically by men with a shirt and suit.',
            'suitcase': 'a large case with a handle and a hinged lid, used for transporting clothes and other possessions.',
            'frisbee': 'a concave plastic disc designed for skimming through the air as part of a game or for recreation.',
            'skis': 'each of a pair of long, narrow pieces of hard, flexible material, typically pointed and turned up at the front, fastened under the feet for gliding over snow.',
            'snowboard': 'a board resembling a short, broad ski, used for sliding downhill on snow.',
            'sports ball': 'a spherical object used as a toy or in various games and sports.',
            'kite': 'a toy consisting of a light frame with thin material stretched over it, flown in the wind at the end of a long string.',
            'baseball bat': 'a smooth wooden or metal club used in the sport of baseball to hit the ball after it is thrown by the pitcher.',
            'baseball glove': 'a large leather glove worn by baseball players of the defending team, which assists them in catching and fielding balls hit by a batter or thrown by a teammate.',
            'skateboard': 'a small, narrow board with two small wheels fixed to the bottom of either end, on which a person can ride in a standing or crouching position, propelling themselves by occasionally pushing one foot against the ground.',
            'surfboard': 'a long, narrow board used for surfing.',
            'tennis racket': 'a racket used in the game of tennis, consisting of a handled frame with an open hoop across which a network of strings is stretched.',
            'cell phone': 'a portable telephone that can make and receive calls over a radio frequency link while the user is moving within a telephone service area.',
            'microwave': 'an electric oven that uses microwaves to cook or heat food.',
            'oven': 'an enclosed compartment, usually part of a cooker, for cooking and heating food.',
            'toaster': 'an electric appliance designed to expose various types of sliced bread to radiant heat, browning the bread.',
            'sink': 'a fixed basin with a drain for washing.',
            'refrigerator': 'a commercial or domestic appliance consisting of a thermally insulated compartment and a heat pump that transfers heat from the inside to its external environment so that the inside is cooled to a temperature below room temperature.',
            'book': 'a written or printed work consisting of pages glued or sewn together along one side.',
            'clock': 'an instrument for measuring and indicating time, typically by means of a dial or a digital display.',
            'vase': 'a container, typically made of glass or ceramic, used for holding cut flowers or for decoration.',
            'scissors': 'an instrument used for cutting cloth, paper, and other thin material, consisting of two blades laid one on top of the other and fastened in the middle so as to slide past each other.',
            'teddy bear': 'a soft toy in the form of a bear.',
            'hair drier': 'an electrical device for drying a person\'s hair by blowing warm air.',
            'toothbrush': 'a small brush with a long handle, used for cleaning the teeth.',
            'hair brush': 'a brush used for grooming hair.',
            'dining table': 'a table at which meals are eaten.'
        };
        
        return objectDatabase[objectName.toLowerCase()] || 'A common object found in everyday life.';
    }
    
    /**
     * Filter and display objects with stability checking
     */
    filterAndDisplayObjects(objects, request) {
        // Filter objects by confidence
        const filteredObjects = objects.filter(obj => obj.confidence >= this.minConfidence);
        
        if (filteredObjects.length === 0) {
            this.updateStatus('No objects detected with sufficient confidence.');
            return;
        }
        
        // Add to detection history
        this.detectionHistory.push({
            timestamp: request.timestamp,
            frameCount: request.frameCount,
            mode: request.mode,
            objects: filteredObjects
        });
        
        // Keep only the last 5 detections for comparison
        if (this.detectionHistory.length > 5) {
            this.detectionHistory.shift();
        }
        
        // Check for stable objects (detected in multiple frames)
        const stableObjects = this.findStableObjects(filteredObjects, request.mode);
        
        // Display the stable objects
        this.displayDetectedObjects(stableObjects, request.mode);
    }
    
    /**
     * Find objects that have been consistently detected across multiple frames
     */
    findStableObjects(currentObjects, mode) {
        // For single shot mode, return all objects
        if (mode === 'single') {
            return currentObjects;
        }
        
        // For continuous mode, check for stability
        if (this.detectionHistory.length < 2) {
            return currentObjects;
        }
        
        const stableObjects = [];
        
        // Check each current object against previous detections
        currentObjects.forEach(currentObj => {
            let foundInPreviousFrames = 0;
            
            // Check against previous detections
            for (let i = this.detectionHistory.length - 2; i >= 0; i--) {
                const previousDetection = this.detectionHistory[i];
                
                // Look for matching objects in previous frames
                const matchingObject = previousDetection.objects.find(prevObj => 
                    prevObj.name === currentObj.name && 
                    this.isSimilarPosition(prevObj.bbox, currentObj.bbox)
                );
                
                if (matchingObject) {
                    foundInPreviousFrames++;
                }
            }
            
            // If object was found in at least half of previous frames, consider it stable
            const minFrames = Math.floor(this.detectionHistory.length / 2);
            if (foundInPreviousFrames >= minFrames) {
                stableObjects.push(currentObj);
            }
        });
        
        // If no stable objects found, return current objects with highest confidence
        if (stableObjects.length === 0) {
            return currentObjects.sort((a, b) => b.confidence - a.confidence).slice(0, 3);
        }
        
        return stableObjects;
    }
    
    /**
     * Check if two bounding boxes represent the same object
     */
    isSimilarPosition(bbox1, bbox2) {
        // Calculate center points
        const center1 = {
            x: bbox1[0] + bbox1[2] / 2,
            y: bbox1[1] + bbox1[3] / 2
        };
        
        const center2 = {
            x: bbox2[0] + bbox2[2] / 2,
            y: bbox2[1] + bbox2[3] / 2
        };
        
        // Calculate distance between centers
        const distance = Math.sqrt(
            Math.pow(center1.x - center2.x, 2) + 
            Math.pow(center1.y - center2.y, 2)
        );
        
        // Consider similar if centers are within 100 pixels of each other
        return distance < 100;
    }
    
    /**
     * Display detected objects
     */
    displayDetectedObjects(objects, mode) {
        if (!objects || objects.length === 0) {
            this.updateStatus('No objects detected.');
            return;
        }
        
        // Clear previous bounding boxes before drawing new ones
        this.clearBoundingBoxes();
        
        // Store the current detected objects
        this.lastDetectedObjects = objects;
        
        // Clear previous results
        this.objectInfoDisplay.innerHTML = '';
        
        // Create a container for the detected objects
        const objectsContainer = document.createElement('div');
        objectsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Add mode indicator
        const modeIndicator = document.createElement('div');
        modeIndicator.textContent = mode === 'single' ? 'Single Shot Detection' : 'Continuous Detection';
        modeIndicator.style.cssText = `
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 10px;
            text-align: center;
            font-style: italic;
        `;
        objectsContainer.appendChild(modeIndicator);
        
        // Add each detected object
        objects.forEach((object, index) => {
            const objectElement = document.createElement('div');
            objectElement.style.cssText = `
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 15px;
                border-left: 4px solid #4CAF50;
            `;
            
            const objectHeader = document.createElement('div');
            objectHeader.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            `;
            
            const objectName = document.createElement('div');
            objectName.textContent = object.name.charAt(0).toUpperCase() + object.name.slice(1);
            objectName.style.cssText = `
                font-size: 18px;
                font-weight: 600;
                color: #4CAF50;
            `;
            
            const confidenceBadge = document.createElement('div');
            confidenceBadge.textContent = `${object.confidence}%`;
            confidenceBadge.style.cssText = `
                background-color: rgba(76, 175, 80, 0.2);
                color: #4CAF50;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 500;
            `;
            
            objectHeader.appendChild(objectName);
            objectHeader.appendChild(confidenceBadge);
            
            const objectInfo = document.createElement('div');
            objectInfo.textContent = object.info;
            objectInfo.style.cssText = `
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
                line-height: 1.5;
            `;
            
            objectElement.appendChild(objectHeader);
            objectElement.appendChild(objectInfo);
            objectsContainer.appendChild(objectElement);
            
            // Draw bounding box on canvas if available
            if (object.bbox && object.bbox.length === 4) {
                this.drawBoundingBox(object.bbox, object.name, object.confidence);
            }
        });
        
        this.objectInfoDisplay.appendChild(objectsContainer);
        
        // Add to history
        this.objectHistory.push({
            timestamp: new Date(),
            mode: mode,
            objects: objects
        });
        
        // Update status
        this.updateStatus(`Detected ${objects.length} object${objects.length !== 1 ? 's' : ''} in ${mode} mode`);
    }
    
    /**
     * Draw bounding box on canvas
     */
    drawBoundingBox(bbox, label, confidence) {
        const context = this.canvasElement.getContext('2d');
        
        // Scale coordinates to canvas size
        const scaleX = this.canvasElement.width / this.videoElement.videoWidth;
        const scaleY = this.canvasElement.height / this.videoElement.videoHeight;
        
        const x = bbox[0] * scaleX;
        const y = bbox[1] * scaleY;
        const width = bbox[2] * scaleX;
        const height = bbox[3] * scaleY;
        
        // Draw bounding box
        context.strokeStyle = '#4CAF50';
        context.lineWidth = 2;
        context.strokeRect(x, y, width, height);
        
        // Draw label background
        const labelText = `${label} ${confidence}%`;
        context.font = '14px Arial';
        const textWidth = context.measureText(labelText).width;
        
        context.fillStyle = 'rgba(76, 175, 80, 0.7)';
        context.fillRect(x, y - 20, textWidth + 10, 20);
        
        // Draw label text
        context.fillStyle = 'white';
        context.fillText(labelText, x + 5, y - 5);
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        if (this.resultDisplay) {
            this.resultDisplay.textContent = message;
        }
    }
    
    /**
     * Copy object information to clipboard
     */
    copyObjectInfo() {
        if (this.objectHistory.length === 0) {
            this.updateStatus('No object information to copy.');
            return;
        }
        
        // Get the latest detection
        const latestDetection = this.objectHistory[this.objectHistory.length - 1];
        
        // Format the information
        let textToCopy = `Detected Objects (${latestDetection.timestamp.toLocaleString()}):\n`;
        textToCopy += `Detection Mode: ${latestDetection.mode}\n\n`;
        
        latestDetection.objects.forEach((object, index) => {
            textToCopy += `${index + 1}. ${object.name.charAt(0).toUpperCase() + object.name.slice(1)}\n`;
            textToCopy += `   Confidence: ${object.confidence}%\n`;
            textToCopy += `   Information: ${object.info}\n\n`;
        });
        
        // Copy to clipboard
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                this.updateStatus('Object information copied to clipboard!');
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                this.updateStatus('Failed to copy object information.');
            });
    }
    
    /**
     * Clear results
     */
    clearResults() {
        this.objectInfoDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at objects and click capture to identify them
            </div>
        `;
        
        // Clear canvas and bounding boxes
        this.clearBoundingBoxes();
        
        // Reset tracking variables
        this.stableObjects.clear();
        this.detectionHistory = [];
        
        this.updateStatus('Results cleared. Ready for new detection.');
    }
    
    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.appContainer.requestFullscreen) {
                this.appContainer.requestFullscreen();
            } else if (this.appContainer.webkitRequestFullscreen) { /* Safari */
                this.appContainer.webkitRequestFullscreen();
            } else if (this.appContainer.msRequestFullscreen) { /* IE11 */
                this.appContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        // Stop continuous detection
        this.stopContinuousDetection();
        
        // Stop camera stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        this.isActive = false;
        botReply('Camera Object Understanding closed.');
    }
}

// Create a global instance of the app
const cameraObjectUnderstanding = new CameraObjectUnderstanding();

// Add this to your AI's command handling
if (/Object Reader|text scanner|ocr|scan text/i.test(userInputRaw)) {
    cameraObjectUnderstanding.loadCameraObjectUnderstanding();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    cameraObjectUnderstanding.closeApp();
    return;
}




class HandDanceDetector {
    constructor() {
        this.appName = 'HAND DANCE DETECTOR';
        this.instructions = 'Show your hands to the camera and watch them dance with elastic movements!';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.objectInfoDisplay = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment'; // Start with back camera
        this.flashMode = 'off'; // off, on, auto
        this.handHistory = [];
        this.isDetecting = false;
        this.animationId = null;
        this.detectedHands = [];
        this.modelLoaded = false;
        this.continuousDetectionId = null;
        this.model = null; // Store the loaded model
        this.lastDetectionTime = 0;
        this.detectionInProgress = false;
        this.continuousModeEnabled = false;
        this.continuousDetectionInterval = 2000; // Faster detection for hands
        this.detectionQueue = [];
        this.processingQueue = false;
        this.offscreenCanvas = null;
        this.offscreenContext = null;
        this.lastDetectedHands = []; // Store last detected hands
        
        // Animation properties
        this.animationEnabled = true; // Always enabled for hand dance
        this.animationCanvas = null;
        this.animationContext = null;
        this.activeHandAnimations = new Map(); // Track animations for each detected hand
        this.particleSystem = null;
        this.audioContext = null;
        this.soundEffects = {};
        this.handTracking = new Map(); // Track hand positions over time
        this.danceMoves = ['wave', 'snap', 'point', 'thumbsUp', 'fist', 'open', 'peace'];
        this.currentDanceMove = 0;
        this.danceMoveTimer = 0;
        this.elasticParams = {
            stiffness: 0.2,
            damping: 0.15,
            mass: 1.0
        };
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        this.hasHandDetection = 'IntersectionObserver' in window || 
                              (window.OffscreenCanvas && window.createImageBitmap);
    }
    
    /**
     * Load the Hand Dance Detector
     */
    loadHandDanceDetector() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        // Preload ML model for better performance
        this.preloadHandModel();
        
        // Initialize audio context for sound effects
        this.initAudioContext();
        
        this.createAppContainer();
        this.createHandDanceUI();
        this.setupActionButtons();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Initialize audio context for sound effects
     */
    initAudioContext() {
        try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext();
            
            // Create sound effects
            this.createSoundEffects();
        } catch (error) {
            console.error('Error initializing audio context:', error);
        }
    }
    
    /**
     * Create sound effects for hand animations
     */
    createSoundEffects() {
        if (!this.audioContext) return;
        
        // Create simple sound effects using Web Audio API
        this.soundEffects = {
            wave: () => this.playTone(440, 0.1, 'sine'),
            snap: () => this.playSnapSound(),
            point: () => this.playTone(660, 0.1, 'square'),
            thumbsUp: () => this.playTone(880, 0.2, 'triangle'),
            fist: () => this.playTone(220, 0.15, 'sawtooth'),
            open: () => this.playTone(330, 0.2, 'sine'),
            peace: () => this.playTone(550, 0.15, 'triangle')
        };
    }
    
    /**
     * Play a snap sound effect
     */
    playSnapSound() {
        if (!this.audioContext) return;
        
        const bufferSize = this.audioContext.sampleRate * 0.1; // 0.1 second buffer
        const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Generate snap sound (white noise burst with envelope)
        for (let i = 0; i < bufferSize; i++) {
            data[i] = (Math.random() - 0.5) * 0.5; // White noise
            // Apply envelope
            const envelope = Math.exp(-i / (bufferSize * 0.1));
            data[i] *= envelope;
        }
        
        const source = this.audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(this.audioContext.destination);
        source.start();
    }
    
    /**
     * Play a tone with specified frequency, duration, and wave type
     */
    playTone(frequency, duration, type = 'sine') {
        if (!this.audioContext) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + duration);
    }
    
    /**
     * Preload hand detection model
     */
    preloadHandModel() {
        // Try to load TensorFlow.js and HandPose model
        if (typeof tf === 'undefined') {
            this.updateStatus('Loading TensorFlow.js...');
            this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js')
                .then(() => {
                    this.updateStatus('Loading HandPose model...');
                    return this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@latest/dist/handpose.min.js');
                })
                .then(() => {
                    // Load the actual model
                    return handpose.load();
                })
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Hand detection model loaded successfully');
                    this.updateStatus('Hand detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load hand detection model:', err);
                    this.updateStatus('Failed to load hand detection model. Using simulation mode.');
                });
        } else if (typeof handpose !== 'undefined') {
            // If TensorFlow is already loaded, just load the model
            handpose.load()
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Hand detection model loaded successfully');
                    this.updateStatus('Hand detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load hand detection model:', err);
                    this.updateStatus('Failed to load hand detection model. Using simulation mode.');
                });
        }
    }
    
    /**
     * Dynamically load a script
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support camera access. Please try a different browser.');
            return false;
        }
        
        if (!this.hasHandDetection) {
            botReply('Your browser has limited support for hand detection. Using alternative method.');
        }
        
        return true;
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
    }
    
    /**
     * Create the Hand Dance UI
     */
    createHandDanceUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '🤸';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = '⛶';
        this.fullscreenButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;
        
        this.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = '✕';
        this.closeButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-left: 10px;
        `;
        
        this.closeButton.addEventListener('click', () => this.closeApp());
        
        header.appendChild(this.fullscreenButton);
        header.appendChild(this.closeButton);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Camera container
        this.cameraContainer = document.createElement('div');
        this.cameraContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 60%;
            border-radius: 16px;
            overflow: hidden;
            background-color: #000;
            margin-bottom: 20px;
        `;
        
        // Video element for camera feed
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        // Canvas element for image capture and hand detection
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        `;
        
        // Create offscreen canvas for processing
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCanvas.style.display = 'none';
        this.offscreenContext = this.offscreenCanvas.getContext('2d');
        
        // Camera controls
        const cameraControls = document.createElement('div');
        cameraControls.style.cssText = `
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        `;
        
        // Capture button
        this.captureButton = document.createElement('button');
        this.captureButton.innerHTML = '🤸';
        this.captureButton.style.cssText = `
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 3px solid white;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.captureButton.addEventListener('click', () => this.detectHands());
        
        // Switch camera button
        this.switchCameraButton = document.createElement('button');
        this.switchCameraButton.innerHTML = '🔄';
        this.switchCameraButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.switchCameraButton.addEventListener('click', () => this.switchCamera());
        
        // Flash button
        this.flashButton = document.createElement('button');
        this.flashButton.innerHTML = '⚡';
        this.flashButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.flashButton.addEventListener('click', () => this.toggleFlash());
        
        cameraControls.appendChild(this.switchCameraButton);
        cameraControls.appendChild(this.captureButton);
        cameraControls.appendChild(this.flashButton);
        
        this.cameraContainer.appendChild(this.videoElement);
        this.cameraContainer.appendChild(this.canvasElement);
        this.cameraContainer.appendChild(cameraControls);
        
        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        `;
        
        // Detection mode options
        const modeLabel = document.createElement('div');
        modeLabel.textContent = 'Detection Mode:';
        modeLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const modeOptions = document.createElement('div');
        modeOptions.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const singleShot = this.createToggleOption('Single Shot', true);
        const continuous = this.createToggleOption('Continuous', false);
        
        // Add event listeners for mode changes
        singleShot.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.stopContinuousDetection();
            }
        });
        
        continuous.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.startContinuousDetection();
            }
        });
        
        modeOptions.appendChild(singleShot);
        modeOptions.appendChild(continuous);
        
        settingsPanel.appendChild(modeLabel);
        settingsPanel.appendChild(modeOptions);
        
        // Dance controls
        const danceControls = document.createElement('div');
        danceControls.style.cssText = `
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        
        const danceLabel = document.createElement('div');
        danceLabel.textContent = 'Dance Style:';
        danceLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
        `;
        
        const danceStyleSelect = document.createElement('select');
        danceStyleSelect.style.cssText = `
            padding: 5px 10px;
            border-radius: 6px;
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            cursor: pointer;
        `;
        
        const danceStyles = ['Elastic', 'Smooth', 'Bouncy', 'Robotic'];
        danceStyles.forEach(style => {
            const option = document.createElement('option');
            option.value = style.toLowerCase();
            option.textContent = style;
            danceStyleSelect.appendChild(option);
        });
        
        danceStyleSelect.addEventListener('change', (e) => {
            this.updateDanceStyle(e.target.value);
        });
        
        danceControls.appendChild(danceLabel);
        danceControls.appendChild(danceStyleSelect);
        
        settingsPanel.appendChild(danceControls);
        
        // Result container
        const resultContainer = document.createElement('div');
        resultContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const resultHeader = document.createElement('div');
        resultHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const resultTitle = document.createElement('div');
        resultTitle.textContent = 'Detected Hands';
        resultTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearResults());
        
        actionButtons.appendChild(clearButton);
        
        resultHeader.appendChild(resultTitle);
        resultHeader.appendChild(actionButtons);
        
        // Hand info display
        this.objectInfoDisplay = document.createElement('div');
        this.objectInfoDisplay.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            overflow-y: auto;
            margin-bottom: 15px;
            min-height: 150px;
        `;
        
        this.objectInfoDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Show your hands to the camera and watch them dance!
            </div>
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Loading hand detection model...';
        
        mainContent.appendChild(this.cameraContainer);
        mainContent.appendChild(settingsPanel);
        mainContent.appendChild(resultContainer);
        resultContainer.appendChild(resultHeader);
        resultContainer.appendChild(this.objectInfoDisplay);
        resultContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
        
        // Initialize camera
        this.initializeCamera();
        
        // Initialize animation canvas
        this.initAnimationCanvas();
    }
    
    /**
     * Create a toggle option
     */
    createToggleOption(label, defaultValue) {
        const container = document.createElement('div');
        container.style.cssText = `
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'detection-mode';
        radio.id = `mode-${label.replace(/\s+/g, '-').toLowerCase()}`;
        radio.checked = defaultValue;
        radio.style.cssText = `
            cursor: pointer;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.htmlFor = radio.id;
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            cursor: pointer;
        `;
        
        container.appendChild(radio);
        container.appendChild(labelElement);
        
        return container;
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Add hover effects to buttons
        const buttons = [this.captureButton, this.switchCameraButton, this.flashButton];
        
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'scale(1.1)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'scale(1)';
            });
        });
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
    }
    
    /**
     * Initialize the camera
     */
    async initializeCamera() {
        try {
            // Stop any existing stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Set up camera constraints
            const constraints = {
                video: {
                    facingMode: this.facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            
            // Add flash constraint if supported
            if (this.flashMode === 'on') {
                constraints.video.torch = true;
            }
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Set video source
            this.videoElement.srcObject = this.currentStream;
            
            // Wait for video to be ready
            this.videoElement.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvasElement.width = this.videoElement.videoWidth;
                this.canvasElement.height = this.videoElement.videoHeight;
                this.offscreenCanvas.width = this.videoElement.videoWidth;
                this.offscreenCanvas.height = this.videoElement.videoHeight;
                
                this.updateStatus('Camera ready. Show your hands to start the dance!');
                
                // Start continuous detection if enabled
                const continuousMode = document.getElementById('mode-continuous');
                if (continuousMode && continuousMode.checked) {
                    this.startContinuousDetection();
                }
            };
            
        } catch (error) {
            console.error('Error initializing camera:', error);
            this.updateStatus('Error accessing camera: ' + error.message);
        }
    }
    
    /**
     * Switch between front and back camera
     */
    async switchCamera() {
        this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
        this.updateStatus('Switching camera...');
        await this.initializeCamera();
    }
    
    /**
     * Toggle flash mode
     */
    async toggleFlash() {
        const flashModes = ['off', 'on', 'auto'];
        const currentIndex = flashModes.indexOf(this.flashMode);
        this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];
        
        // Update button appearance based on flash mode
        if (this.flashMode === 'on') {
            this.flashButton.style.backgroundColor = 'rgba(255, 235, 59, 0.7)';
        } else if (this.flashMode === 'auto') {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        }
        
        this.updateStatus(`Flash mode: ${this.flashMode}`);
        await this.initializeCamera();
    }
    
    /**
     * Detect hands in the current camera frame
     */
    async detectHands() {
        // Add detection request to queue
        this.detectionQueue.push({
            timestamp: Date.now(),
            id: Math.random().toString(36).substr(2, 9),
            frameCount: this.frameCount++
        });
        
        // Process queue if not already processing
        if (!this.processingQueue) {
            this.processDetectionQueue();
        }
    }
    
    /**
     * Process the detection queue
     */
    async processDetectionQueue() {
        if (this.processingQueue || this.detectionQueue.length === 0) {
            return;
        }
        
        this.processingQueue = true;
        
        try {
            // Get the latest detection request (skip older ones)
            let latestRequest = null;
            while (this.detectionQueue.length > 0) {
                latestRequest = this.detectionQueue.shift();
            }
            
            if (latestRequest) {
                await this.performDetection(latestRequest);
            }
        } catch (error) {
            console.error('Error processing detection queue:', error);
            this.updateStatus('Error during detection: ' + error.message);
        } finally {
            this.processingQueue = false;
            
            // Process next item in queue if any
            if (this.detectionQueue.length > 0) {
                // Use a small delay to prevent overwhelming the system
                setTimeout(() => this.processDetectionQueue(), 100);
            }
        }
    }
    
    /**
     * Perform the actual detection
     */
    async performDetection(request) {
        try {
            this.updateStatus('Detecting hands...');
            
            // Capture current frame to offscreen canvas (non-blocking)
            this.offscreenContext.drawImage(this.videoElement, 0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
            
            // Process image for hands
            await this.processImageForHands(request);
            
        } catch (error) {
            console.error('Error performing detection:', error);
            this.updateStatus('Error detecting hands: ' + error.message);
        }
    }
    
    /**
     * Start continuous hand detection
     */
    startContinuousDetection() {
        if (this.continuousDetectionId) {
            clearInterval(this.continuousDetectionId);
        }
        
        this.continuousModeEnabled = true;
        this.updateStatus('Continuous detection enabled');
        
        // Reset tracking variables
        this.lastDetectionTime = 0;
        this.frameCount = 0;
        this.handHistory = []; // Store recent detections
        
        // Use requestAnimationFrame for smoother operation
        this.scheduleContinuousDetection();
    }
    
    /**
     * Schedule continuous detection using requestAnimationFrame
     */
    scheduleContinuousDetection() {
        if (!this.continuousModeEnabled) {
            return;
        }
        
        // Use requestAnimationFrame for smooth operation
        requestAnimationFrame(() => {
            const now = Date.now();
            
            // Check if it's time for a new detection
            if (now - this.lastDetectionTime >= this.continuousDetectionInterval) {
                this.lastDetectionTime = now;
                this.frameCount++;
                
                // Add frame info to detection request
                this.detectionQueue.push({
                    timestamp: now,
                    id: Math.random().toString(36).substr(2, 9),
                    frameCount: this.frameCount
                });
                
                // Process queue if not already processing
                if (!this.processingQueue) {
                    this.processDetectionQueue();
                }
            }
            
            // Schedule next check
            this.scheduleContinuousDetection();
        });
    }
    
    /**
     * Stop continuous hand detection
     */
    stopContinuousDetection() {
        this.continuousModeEnabled = false;
        
        if (this.continuousDetectionId) {
            clearTimeout(this.continuousDetectionId);
            this.continuousDetectionId = null;
        }
        
        this.updateStatus('Continuous detection stopped');
    }
    
    /**
     * Process image to detect hands
     */
    async processImageForHands(request) {
        try {
            // Check if the model is loaded
            if (!this.modelLoaded || !this.model) {
                // Fallback to simulated detection if model isn't loaded
                const simulatedHands = await this.simulateHandDetection();
                if (simulatedHands && simulatedHands.length > 0) {
                    this.filterAndDisplayHands(simulatedHands, request);
                    return;
                }
                
                this.updateStatus('Hand detection model not ready. Please try again later.');
                return;
            }
            
            // Use the loaded model for real detection
            this.updateStatus('Detecting hands with AI model...');
            
            // Create an image bitmap from the offscreen canvas for better performance
            const bitmap = await createImageBitmap(this.offscreenCanvas);
            
            // Detect hands in the image
            const predictions = await this.model.estimateHands(bitmap);
            
            // Clean up bitmap
            bitmap.close();
            
            if (predictions && predictions.length > 0) {
                // Convert predictions to our format
                const hands = predictions.map(prediction => ({
                    landmarks: prediction.landmarks,
                    boundingBox: prediction.boundingBox,
                    confidence: 0.9, // HandPose doesn't provide confidence, so we use a default
                    info: 'A human hand'
                }));
                
                this.filterAndDisplayHands(hands, request);
            } else {
                // No hands detected, clear any previous hand animations
                this.clearHandAnimations();
                this.updateStatus('No hands detected. Show your hands to the camera.');
            }
            
        } catch (error) {
            console.error('Error processing image for hands:', error);
            this.updateStatus('Error processing image: ' + error.message);
        }
    }
    
    /**
     * Simulate hand detection (for demonstration purposes)
     */
    async simulateHandDetection() {
        try {
            this.updateStatus('Analyzing image for hands...');
            
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Simulate detecting 1-2 hands
            const numHands = Math.floor(Math.random() * 2) + 1;
            const detectedHands = [];
            
            for (let i = 0; i < numHands; i++) {
                // Generate random hand landmarks (21 points for each hand)
                const landmarks = [];
                for (let j = 0; j < 21; j++) {
                    landmarks.push([
                        Math.random() * this.offscreenCanvas.width,
                        Math.random() * this.offscreenCanvas.height
                    ]);
                }
                
                // Calculate bounding box from landmarks
                const xValues = landmarks.map(point => point[0]);
                const yValues = landmarks.map(point => point[1]);
                const minX = Math.min(...xValues);
                const minY = Math.min(...yValues);
                const maxX = Math.max(...xValues);
                const maxY = Math.max(...yValues);
                
                detectedHands.push({
                    landmarks: landmarks,
                    boundingBox: {
                        topLeft: [minX, minY],
                        bottomRight: [maxX, maxY]
                    },
                    confidence: 0.9,
                    info: 'A human hand'
                });
            }
            
            return detectedHands;
            
        } catch (error) {
            console.error('Simulated hand detection error:', error);
            return null;
        }
    }
    
    /**
     * Filter and display hands with stability checking
     */
    filterAndDisplayHands(hands, request) {
        if (!hands || hands.length === 0) {
            this.updateStatus('No hands detected.');
            return;
        }
        
        // Add to hand history
        this.handHistory.push({
            timestamp: request.timestamp,
            frameCount: request.frameCount,
            hands: hands
        });
        
        // Keep only the last 5 detections for comparison
        if (this.handHistory.length > 5) {
            this.handHistory.shift();
        }
        
        // Update hand tracking
        this.updateHandTracking(hands);
        
        // Display the detected hands
        this.displayDetectedHands(hands);
    }
    
    /**
     * Update hand tracking information
     */
    updateHandTracking(hands) {
        hands.forEach((hand, index) => {
            const handId = `hand-${index}`;
            
            // Calculate center of hand
            const xValues = hand.landmarks.map(point => point[0]);
            const yValues = hand.landmarks.map(point => point[1]);
            const centerX = (Math.min(...xValues) + Math.max(...xValues)) / 2;
            const centerY = (Math.min(...yValues) + Math.max(...yValues)) / 2;
            
            // Update or create hand tracking data
            if (!this.handTracking.has(handId)) {
                this.handTracking.set(handId, {
                    positions: [{x: centerX, y: centerY, time: Date.now()}],
                    currentDanceMove: 0,
                    danceMoveTimer: 0
                });
            } else {
                const tracking = this.handTracking.get(handId);
                tracking.positions.push({x: centerX, y: centerY, time: Date.now()});
                
                // Keep only recent positions
                if (tracking.positions.length > 10) {
                    tracking.positions.shift();
                }
            }
        });
    }
    
    /**
     * Initialize animation canvas
     */
    initAnimationCanvas() {
        // Create animation canvas overlay
        this.animationCanvas = document.createElement('canvas');
        this.animationCanvas.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        `;
        
        this.cameraContainer.appendChild(this.animationCanvas);
        
        // Set canvas dimensions
        this.animationCanvas.width = this.videoElement.videoWidth;
        this.animationCanvas.height = this.videoElement.videoHeight;
        this.animationContext = this.animationCanvas.getContext('2d');
        
        // Initialize particle system
        this.particleSystem = new ParticleSystem(this.animationCanvas);
        
        // Start animation loop
        this.startAnimationLoop();
    }
    
    /**
     * Start animation loop
     */
    startAnimationLoop() {
        if (!this.animationEnabled) return;
        
        // Clear canvas
        this.animationContext.clearRect(0, 0, this.animationCanvas.width, this.animationCanvas.height);
        
        // Update and draw all active hand animations
        this.updateHandAnimations();
        
        // Update and draw particle system
        this.particleSystem.update();
        this.particleSystem.draw(this.animationContext);
        
        // Continue loop
        requestAnimationFrame(() => this.startAnimationLoop());
    }
    
    /**
     * Update all active hand animations
     */
    updateHandAnimations() {
        const now = Date.now();
        
        // Update dance move timer
        this.danceMoveTimer++;
        if (this.danceMoveTimer > 120) { // Change dance move every 2 seconds at 60fps
            this.currentDanceMove = (this.currentDanceMove + 1) % this.danceMoves.length;
            this.danceMoveTimer = 0;
        }
        
        // Update each active hand animation
        this.activeHandAnimations.forEach((animation, handId) => {
            if (now - animation.startTime > animation.duration) {
                // Animation completed, remove it
                this.activeHandAnimations.delete(handId);
                return;
            }
            
            // Calculate animation progress (0 to 1)
            const progress = (now - animation.startTime) / animation.duration;
            animation.progress = progress;
            
            // Update animation based on type
            this.updateHandAnimation(animation, progress);
            
            // Draw the animation
            this.drawHandAnimation(animation);
        });
    }
    
    /**
     * Update hand animation based on type and progress
     */
    updateHandAnimation(animation, progress) {
        const moveType = this.danceMoves[this.currentDanceMove];
        
        switch (moveType) {
            case 'wave':
                // Calculate waving movement
                animation.fingerBones = animation.fingerBones.map((bone, i) => {
                    const waveAmount = Math.sin(progress * Math.PI * 2 + i * 0.5) * 0.3;
                    return {
                        ...bone,
                        angle: bone.originalAngle + waveAmount,
                        length: bone.originalLength * (1 + waveAmount * 0.1)
                    };
                });
                break;
                
            case 'snap':
                // Calculate snapping movement
                const snapProgress = progress < 0.5 ? progress * 2 : 2 - progress * 2;
                animation.fingerBones = animation.fingerBones.map((bone, i) => {
                    if (i >= 1 && i <= 4) { // Index and middle fingers
                        return {
                            ...bone,
                            angle: bone.originalAngle - snapProgress * Math.PI / 2,
                            length: bone.originalLength * (1 - snapProgress * 0.3)
                        };
                    } else if (i >= 5 && i <= 8) { // Ring and pinky fingers
                        return {
                            ...bone,
                            angle: bone.originalAngle - snapProgress * Math.PI / 4,
                            length: bone.originalLength * (1 - snapProgress * 0.2)
                        };
                    }
                    return bone;
                });
                break;
                
            case 'point':
                // Calculate pointing movement
                const pointProgress = progress < 0.5 ? progress * 2 : 1;
                animation.fingerBones = animation.fingerBones.map((bone, i) => {
                    if (i === 1) { // Index finger
                        return {
                            ...bone,
                            angle: bone.originalAngle - pointProgress * Math.PI / 6,
                            length: bone.originalLength * (1 + pointProgress * 0.2)
                        };
                    } else if (i >= 2 && i <= 4) { // Other fingers
                        return {
                            ...bone,
                            angle: bone.originalAngle + pointProgress * Math.PI / 8,
                            length: bone.originalLength * (1 - pointProgress * 0.3)
                        };
                    }
                    return bone;
                });
                break;
                
            case 'thumbsUp':
                // Calculate thumbs up movement
                const thumbsUpProgress = progress < 0.5 ? progress * 2 : 1;
                animation.fingerBones = animation.fingerBones.map((bone, i) => {
                    if (i === 0) { // Thumb
                        return {
                            ...bone,
                            angle: bone.originalAngle - thumbsUpProgress * Math.PI / 2,
                            length: bone.originalLength * (1 + thumbsUpProgress * 0.1)
                        };
                    } else if (i >= 1 && i <= 4) { // Other fingers
                        return {
                            ...bone,
                            angle: bone.originalAngle + thumbsUpProgress * Math.PI / 6,
                            length: bone.originalLength * (1 - thumbsUpProgress * 0.5)
                        };
                    }
                    return bone;
                });
                break;
                
            case 'fist':
                // Calculate fist movement
                const fistProgress = progress < 0.5 ? progress * 2 : 1;
                animation.fingerBones = animation.fingerBones.map((bone, i) => {
                    if (i >= 1) { // All fingers except thumb
                        return {
                            ...bone,
                            length: bone.originalLength * (1 - fistProgress * 0.7)
                        };
                    }
                    return bone;
                });
                break;
                
            case 'open':
                // Calculate open hand movement
                const openProgress = progress < 0.5 ? progress * 2 : 1;
                animation.fingerBones = animation.fingerBones.map((bone, i) => {
                    return {
                        ...bone,
                        length: bone.originalLength * openProgress
                    };
                });
                break;
                
            case 'peace':
                // Calculate peace sign movement
                const peaceProgress = progress < 0.5 ? progress * 2 : 1;
                animation.fingerBones = animation.fingerBones.map((bone, i) => {
                    if (i === 1 || i === 2) { // Index and middle fingers
                        return {
                            ...bone,
                            angle: bone.originalAngle,
                            length: bone.originalLength
                        };
                    } else if (i >= 3) { // Other fingers
                        return {
                            ...bone,
                            length: bone.originalLength * (1 - peaceProgress * 0.7)
                        };
                    }
                    return bone;
                });
                break;
        }
        
        // Apply elastic physics to all bones
        animation.fingerBones = this.applyElasticPhysics(animation.fingerBones);
    }
    
    /**
     * Apply elastic physics to finger bones
     */
    applyElasticPhysics(bones) {
        return bones.map(bone => {
            // Calculate elastic force based on deviation from original position
            const angleDeviation = bone.angle - bone.originalAngle;
            const lengthDeviation = bone.length - bone.originalLength;
            
            // Apply spring force (Hooke's law)
            const angleForce = -this.elasticParams.stiffness * angleDeviation;
            const lengthForce = -this.elasticParams.stiffness * lengthDeviation;
            
            // Apply damping
            const angleDamping = -this.elasticParams.damping * bone.angleVelocity || 0;
            const lengthDamping = -this.elasticParams.damping * bone.lengthVelocity || 0;
            
            // Update velocities
            bone.angleVelocity = (bone.angleVelocity || 0) + (angleForce + angleDamping) / this.elasticParams.mass;
            bone.lengthVelocity = (bone.lengthVelocity || 0) + (lengthForce + lengthDamping) / this.elasticParams.mass;
            
            // Update positions
            bone.angle += bone.angleVelocity || 0;
            bone.length += bone.lengthVelocity || 0;
            
            return bone;
        });
    }
    
    /**
     * Draw hand animation
     */
    drawHandAnimation(animation) {
        this.animationContext.save();
        
        // Draw hand skeleton with elastic bones
        this.drawHandSkeleton(animation);
        
        // Draw "soul" effect around hand
        this.drawHandSoulEffect(animation);
        
        this.animationContext.restore();
    }
    
    /**
     * Draw hand skeleton with elastic bones
     */
    drawHandSkeleton(animation) {
        const bones = animation.fingerBones;
        
        // Draw palm
        this.animationContext.fillStyle = animation.color;
        this.animationContext.globalAlpha = 0.7;
        this.animationContext.beginPath();
        this.animationContext.ellipse(
            animation.palmX, 
            animation.palmY, 
            animation.palmWidth, 
            animation.palmHeight, 
            0, 0, Math.PI * 2
        );
        this.animationContext.fill();
        this.animationContext.globalAlpha = 1;
        
        // Draw finger bones
        bones.forEach((bone, i) => {
            // Calculate end position based on angle and length
            const endX = bone.startX + Math.cos(bone.angle) * bone.length;
            const endY = bone.startY + Math.sin(bone.angle) * bone.length;
            
            // Draw bone as a line with thickness based on bone index
            this.animationContext.strokeStyle = animation.color;
            this.animationContext.lineWidth = 5 - i * 0.5;
            this.animationContext.lineCap = 'round';
            this.animationContext.beginPath();
            this.animationContext.moveTo(bone.startX, bone.startY);
            this.animationContext.lineTo(endX, endY);
            this.animationContext.stroke();
            
            // Draw joint
            this.animationContext.fillStyle = animation.color;
            this.animationContext.beginPath();
            this.animationContext.arc(endX, endY, 4 - i * 0.3, 0, Math.PI * 2);
            this.animationContext.fill();
        });
    }
    
    /**
     * Draw soul effect around hand
     */
    drawHandSoulEffect(animation) {
        const particleCount = 12;
        const radius = 50;
        
        for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const x = animation.palmX + Math.cos(angle) * radius;
            const y = animation.palmY + Math.sin(angle) * radius;
            
            this.animationContext.beginPath();
            this.animationContext.arc(x, y, 3, 0, Math.PI * 2);
            this.animationContext.fillStyle = animation.color;
            this.animationContext.globalAlpha = 0.7 + Math.sin(animation.progress * Math.PI * 2 + i) * 0.3;
            this.animationContext.fill();
            
            // Draw connecting lines
            if (i > 0) {
                const prevAngle = ((i-1) / particleCount) * Math.PI * 2;
                const prevX = animation.palmX + Math.cos(prevAngle) * radius;
                const prevY = animation.palmY + Math.sin(prevAngle) * radius;
                
                this.animationContext.beginPath();
                this.animationContext.moveTo(prevX, prevY);
                this.animationContext.lineTo(x, y);
                this.animationContext.strokeStyle = animation.color;
                this.animationContext.globalAlpha = 0.3;
                this.animationContext.stroke();
                this.animationContext.globalAlpha = 1;
            }
        }
    }
    
    /**
     * Display detected hands
     */
    displayDetectedHands(hands) {
        if (!hands || hands.length === 0) {
            this.updateStatus('No hands detected.');
            return;
        }
        
        // Clear previous results
        this.objectInfoDisplay.innerHTML = '';
        
        // Create a container for the detected hands
        const handsContainer = document.createElement('div');
        handsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Add each detected hand
        hands.forEach((hand, index) => {
            const handElement = document.createElement('div');
            handElement.style.cssText = `
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 15px;
                border-left: 4px solid #4CAF50;
            `;
            
            const handHeader = document.createElement('div');
            handHeader.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            `;
            
            const handName = document.createElement('div');
            handName.textContent = `Hand ${index + 1}`;
            handName.style.cssText = `
                font-size: 18px;
                font-weight: 600;
                color: #4CAF50;
            `;
            
            const confidenceBadge = document.createElement('div');
            confidenceBadge.textContent = `${Math.round(hand.confidence * 100)}%`;
            confidenceBadge.style.cssText = `
                background-color: rgba(76, 175, 80, 0.2);
                color: #4CAF50;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 500;
            `;
            
            handHeader.appendChild(handName);
            handHeader.appendChild(confidenceBadge);
            
            const handInfo = document.createElement('div');
            handInfo.textContent = hand.info;
            handInfo.style.cssText = `
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
                line-height: 1.5;
            `;
            
            // Add dance move info
            const danceInfo = document.createElement('div');
            danceInfo.textContent = `Current move: ${this.danceMoves[this.currentDanceMove]}`;
            danceInfo.style.cssText = `
                color: rgba(255, 255, 255, 0.6);
                font-size: 12px;
                margin-top: 5px;
                font-style: italic;
            `;
            
            handElement.appendChild(handHeader);
            handElement.appendChild(handInfo);
            handElement.appendChild(danceInfo);
            handsContainer.appendChild(handElement);
            
            // Trigger hand animation
            this.triggerHandAnimation(hand, index);
        });
        
        this.objectInfoDisplay.appendChild(handsContainer);
        
        // Update status
        this.updateStatus(`Detected ${hands.length} hand${hands.length !== 1 ? 's' : ''} dancing!`);
    }
    
    /**
     * Trigger animation for a hand
     */
    triggerHandAnimation(hand, index) {
        if (!hand.landmarks || hand.landmarks.length === 0) return;
        
        // Play sound effect for current dance move
        const moveType = this.danceMoves[this.currentDanceMove];
        if (this.soundEffects[moveType]) {
            this.soundEffects[moveType]();
        }
        
        // Calculate hand center
        const xValues = hand.landmarks.map(point => point[0]);
        const yValues = hand.landmarks.map(point => point[1]);
        const centerX = (Math.min(...xValues) + Math.max(...xValues)) / 2;
        const centerY = (Math.min(...yValues) + Math.max(...yValues)) / 2;
        
        // Calculate palm dimensions
        const palmWidth = Math.max(...xValues) - Math.min(...xValues);
        const palmHeight = Math.max(...yValues) - Math.min(...yValues);
        
        // Generate random color for this animation
        const colors = ['#FF5252', '#448AFF', '#FFEB3B', '#4CAF50', '#9C27B0', '#FF9800'];
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        // Create hand skeleton from landmarks
        const fingerBones = this.createFingerBonesFromLandmarks(hand.landmarks);
        
        // Create animation object
        const animation = {
            type: 'hand-dance',
            handId: `hand-${index}`,
            startTime: Date.now(),
            duration: 2000, // 2 seconds
            palmX: centerX,
            palmY: centerY,
            palmWidth: palmWidth,
            palmHeight: palmHeight,
            fingerBones: fingerBones,
            color: color,
            progress: 0
        };
        
        // Store or update the animation
        this.activeHandAnimations.set(animation.handId, animation);
        
        // Create particles for this animation
        if (this.particleSystem) {
            this.particleSystem.createBurst(centerX, centerY, color, 15);
        }
    }
    
    /**
     * Create finger bones from hand landmarks
     */
    createFingerBonesFromLandmarks(landmarks) {
        // Hand landmark indices (MediaPipe format)
        // 0: Wrist
        // 1-4: Thumb (from base to tip)
        // 5-8: Index finger (from base to tip)
        // 9-12: Middle finger (from base to tip)
        // 13-16: Ring finger (from base to tip)
        // 17-20: Pinky finger (from base to tip)
        
        const fingerBones = [];
        
        // Create bones for each finger
        for (let finger = 0; finger < 5; finger++) {
            const baseIndex = finger === 0 ? 0 : finger * 4;
            
            for (let joint = 0; joint < 4; joint++) {
                const startIndex = baseIndex + joint;
                const endIndex = startIndex + 1;
                
                if (startIndex < landmarks.length && endIndex < landmarks.length) {
                    const startX = landmarks[startIndex][0];
                    const startY = landmarks[startIndex][1];
                    const endX = landmarks[endIndex][0];
                    const endY = landmarks[endIndex][1];
                    
                    const angle = Math.atan2(endY - startY, endX - startX);
                    const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    
                    fingerBones.push({
                        startX: startX,
                        startY: startY,
                        angle: angle,
                        length: length,
                        originalAngle: angle,
                        originalLength: length,
                        fingerIndex: finger,
                        jointIndex: joint
                    });
                }
            }
        }
        
        return fingerBones;
    }
    
    /**
     * Clear hand animations
     */
    clearHandAnimations() {
        this.activeHandAnimations.clear();
        
        if (this.animationCanvas) {
            this.animationContext.clearRect(0, 0, this.animationCanvas.width, this.animationCanvas.height);
        }
    }
    
    /**
     * Update dance style
     */
    updateDanceStyle(style) {
        switch (style) {
            case 'elastic':
                this.elasticParams = {
                    stiffness: 0.2,
                    damping: 0.15,
                    mass: 1.0
                };
                break;
            case 'smooth':
                this.elasticParams = {
                    stiffness: 0.1,
                    damping: 0.3,
                    mass: 1.0
                };
                break;
            case 'bouncy':
                this.elasticParams = {
                    stiffness: 0.4,
                    damping: 0.1,
                    mass: 0.8
                };
                break;
            case 'robotic':
                this.elasticParams = {
                    stiffness: 0.8,
                    damping: 0.5,
                    mass: 1.2
                };
                break;
        }
        
        this.updateStatus(`Dance style changed to: ${style}`);
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        if (this.resultDisplay) {
            this.resultDisplay.textContent = message;
        }
    }
    
    /**
     * Clear results
     */
    clearResults() {
        this.objectInfoDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Show your hands to the camera and watch them dance!
            </div>
        `;
        
        // Clear animations
        this.clearHandAnimations();
        
        // Reset hand tracking
        this.handTracking.clear();
        
        this.updateStatus('Results cleared. Ready for new detection.');
    }
    
    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.appContainer.requestFullscreen) {
                this.appContainer.requestFullscreen();
            } else if (this.appContainer.webkitRequestFullscreen) { /* Safari */
                this.appContainer.webkitRequestFullscreen();
            } else if (this.appContainer.msRequestFullscreen) { /* IE11 */
                this.appContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        // Stop continuous detection
        this.stopContinuousDetection();
        
        // Stop all animations
        this.clearHandAnimations();
        
        // Stop camera stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Remove animation canvas
        if (this.animationCanvas && this.animationCanvas.parentNode) {
            this.animationCanvas.parentNode.removeChild(this.animationCanvas);
        }
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        this.isActive = false;
        botReply('Hand Dance Detector closed.');
    }
}

/**
 * Particle System for creating particle effects
 */
class ParticleSystem {
    constructor(canvas) {
        this.canvas = canvas;
        this.particles = [];
        this.maxParticles = 300;
    }
    
    createBurst(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            if (this.particles.length >= this.maxParticles) {
                this.particles.shift(); // Remove oldest particle
            }
            
            const angle = (Math.PI * 2 * i) / count;
            const velocity = 1 + Math.random() * 3;
            
            this.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * velocity,
                vy: Math.sin(angle) * velocity,
                color: color,
                size: 2 + Math.random() * 3,
                life: 1,
                decay: 0.01 + Math.random() * 0.02
            });
        }
    }
    
    update() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1; // Gravity
            p.life -= p.decay;
            
            if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
    }
    
    draw(ctx) {
        this.particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });
    }
    
    clear() {
        this.particles = [];
    }
}

// Create a global instance of the app
const handDanceDetector = new HandDanceDetector();

// Add this to your AI's command handling
if (/Hand Dance|hand animation|dancing hands/i.test(userInputRaw)) {
    handDanceDetector.loadHandDanceDetector();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    handDanceDetector.closeApp();
    return;
}




class LiveScreenLoaderEditor {
    constructor() {
        this.baseScreen = {
            name: 'LIVE COLLABORATIVE EDITOR',
            instructions: 'Real-time collaborative editing. Admin changes are instantly visible to all users.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.roleToggle = null;
        this.editorArea = null;
        this.previewArea = null;
        this.outputDiv = null;
        this.userList = null;
        this.currentRole = 'user'; // 'user' or 'admin'
        this.documentContent = 'Welcome to the Live Collaborative Editor!\n\nThis is a shared document that can be edited in real-time.\n\nAdmin changes will appear instantly for all users.';
        this.isEditing = false;
        this.isLocked = false;
        this.activeUsers = [];
        this.editHistory = [];
        this.currentVersion = 0;
        this.autoSaveInterval = null;
        this.userSessionId = this.generateSessionId();
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.documentRef = null;
        this.usersRef = null;
        this.presenceRef = null;
        this.connectedRef = null;
        this.messagesRef = null;
        this.isFirebaseInitialized = false;
        this.lastEditorId = null;
        this.isLocalChange = false;
        this.messageQueue = [];
        this.isProcessingQueue = false;
    }

    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'user_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Load the Live Editor Screen
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createLiveEditorScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.startAutoSave();
        this.initializeFirebase();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Initialize Firebase
     */
    initializeFirebase() {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase();
                });
            });
        } else {
            this.setupFirebase();
        }
    }

    /**
     * Setup Firebase
     */
    setupFirebase() {
        try {
            firebase.initializeApp(this.firebaseConfig);
            this.db = firebase.database();
            
            // References
            this.documentRef = this.db.ref('collaborativeEditor/document');
            this.usersRef = this.db.ref('collaborativeEditor/users');
            this.presenceRef = this.db.ref('collaborativeEditor/presence');
            this.connectedRef = this.db.ref('.info/connected');
            this.messagesRef = this.db.ref('collaborativeEditor/messages');
            
            // Setup connection monitoring
            this.connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    this.updateConnectionStatus(true);
                    this.registerUser();
                    this.setupFirebaseListeners();
                    this.loadDocumentFromFirebase();
                    this.processMessageQueue();
                } else {
                    this.updateConnectionStatus(false);
                }
            });
            
            this.isFirebaseInitialized = true;
            this.logActivity('Firebase connected successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.logActivity('Firebase connection failed');
            this.updateConnectionStatus(false);
        }
    }

    /**
     * Setup Firebase listeners
     */
    setupFirebaseListeners() {
        // Listen for document changes with high priority
        this.documentRef.on('value', (snapshot) => {
            const data = snapshot.val();
            if (data) {
                // Skip if this is a local change
                if (this.isLocalChange && data.lastEditorId === this.userSessionId) {
                    this.isLocalChange = false;
                    return;
                }
                
                // Update document content
                if (data.content !== undefined && data.content !== this.documentContent) {
                    this.documentContent = data.content;
                    this.editorArea.value = this.documentContent;
                    this.previewArea.textContent = this.documentContent;
                    
                    // Only log if it's not our own change
                    if (data.lastEditorId !== this.userSessionId) {
                        this.logActivity(`Document updated by ${data.lastEditorRole || 'another user'}`);
                    }
                }
                
                // Update lock status
                if (data.locked !== undefined && data.locked !== this.isLocked) {
                    this.isLocked = data.locked;
                    this.updateUIForRole();
                    this.logActivity(`Document ${this.isLocked ? 'locked' : 'unlocked'} by admin`);
                }
                
                // Update version
                if (data.version !== undefined && data.version !== this.currentVersion) {
                    this.currentVersion = data.version;
                    this.logActivity(`New version available: ${this.currentVersion}`);
                }
            }
        });
        
        // Listen for user changes
        this.usersRef.on('value', (snapshot) => {
            const users = snapshot.val();
            if (users) {
                this.activeUsers = Object.values(users).filter(user => user.id !== this.userSessionId);
                this.updateActiveUsers();
            }
        });
        
        // Listen for broadcast messages with high priority
        this.messagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            if (message && message.text) {
                // Display message immediately
                this.displayBroadcastMessage(message);
            }
        });
        
        // Setup presence for this user
        this.presenceRef.child(this.userSessionId).onDisconnect().remove();
        this.presenceRef.child(this.userSessionId).set(true);
    }

    /**
     * Display broadcast message immediately
     */
    displayBroadcastMessage(message) {
        const messageElement = document.createElement('div');
        messageElement.style.cssText = `
            background-color: #9C27B0;
            color: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-weight: bold;
            animation: fadeIn 0.5s;
        `;
        messageElement.textContent = `📢 ${message.author}: ${message.text}`;
        
        // Insert at the top of the activity log
        this.outputDiv.insertBefore(messageElement, this.outputDiv.firstChild);
        
        // Remove after 5 seconds
        setTimeout(() => {
            if (messageElement.parentNode) {
                messageElement.style.opacity = '0';
                messageElement.style.transition = 'opacity 0.5s';
                setTimeout(() => {
                    if (messageElement.parentNode) {
                        messageElement.remove();
                    }
                }, 500);
            }
        }, 5000);
        
        // Also log in activity
        this.logActivity(`Broadcast: "${message.text}" by ${message.author}`);
    }

    /**
     * Process message queue when Firebase is ready
     */
    processMessageQueue() {
        if (this.messageQueue.length > 0) {
            this.messageQueue.forEach(message => {
                this.messagesRef.push(message);
            });
            this.messageQueue = [];
        }
    }

    /**
     * Load document from Firebase
     */
    loadDocumentFromFirebase() {
        this.documentRef.once('value').then((snapshot) => {
            const data = snapshot.val();
            if (data) {
                this.documentContent = data.content || this.documentContent;
                this.isLocked = data.locked || false;
                this.currentVersion = data.version || 0;
                this.editHistory = data.history || [];
                
                // Update UI
                this.editorArea.value = this.documentContent;
                this.previewArea.textContent = this.documentContent;
                this.updateUIForRole();
                
                this.logActivity(`Loaded document version ${this.currentVersion}`);
            } else {
                // Initialize document if it doesn't exist
                this.saveDocumentToFirebase();
            }
        }).catch(error => {
            console.error('Error loading document:', error);
            this.logActivity('Error loading document');
        });
    }

    /**
     * Save document to Firebase
     */
    saveDocumentToFirebase() {
        if (!this.isFirebaseInitialized) return;
        
        const data = {
            content: this.documentContent,
            locked: this.isLocked,
            version: this.currentVersion,
            history: this.editHistory,
            lastUpdated: firebase.database.ServerValue.TIMESTAMP,
            lastEditorId: this.userSessionId,
            lastEditorRole: this.currentRole
        };
        
        this.isLocalChange = true;
        this.documentRef.update(data).catch(error => {
            console.error('Error saving document:', error);
            this.logActivity('Error saving document');
            this.isLocalChange = false;
        });
    }

    /**
     * Register this user in Firebase
     */
    registerUser() {
        if (!this.isFirebaseInitialized) return;
        
        const userData = {
            id: this.userSessionId,
            role: this.currentRole,
            name: this.currentRole === 'admin' ? 'Admin' : 'User',
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            editing: this.isEditing
        };
        
        this.usersRef.child(this.userSessionId).set(userData).catch(error => {
            console.error('Error registering user:', error);
        });
    }

    /**
     * Update user status in Firebase
     */
    updateUserStatus(isEditing) {
        if (!this.isFirebaseInitialized) return;
        
        this.usersRef.child(this.userSessionId).update({
            editing: isEditing,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        }).catch(error => {
            console.error('Error updating user status:', error);
        });
    }

    /**
     * Remove a user from the session (admin only)
     */
    removeUser(userId) {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can remove users.');
            return;
        }
        
        if (confirm('Are you sure you want to remove this user from the session?')) {
            // Remove from users list
            this.usersRef.child(userId).remove().then(() => {
                // Remove from presence
                this.presenceRef.child(userId).remove();
                this.logActivity('User removed from session by admin');
                botReply('User removed from session');
            }).catch(error => {
                console.error('Error removing user:', error);
                this.logActivity('Error removing user');
            });
        }
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }

    /**
     * Create the Live Editor UI
     */
    createLiveEditorScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 900px;
            max-width: 95vw;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Live Collaborative Editor';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        `;
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Real-time collaboration across devices';
        subtitle.style.cssText = `
            margin: 0;
            color: #666;
            font-size: 16px;
        `;
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);

        // Role toggle and connection status
        const topControls = document.createElement('div');
        topControls.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 20px;
            flex-wrap: wrap;
        `;

        // Role toggle
        const roleSection = document.createElement('div');
        roleSection.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        const roleLabel = document.createElement('label');
        roleLabel.textContent = 'Current Role:';
        roleLabel.style.cssText = `
            font-weight: bold;
            color: #333;
        `;
        this.roleToggle = document.createElement('select');
        this.roleToggle.style.cssText = `
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        const userOption = document.createElement('option');
        userOption.value = 'user';
        userOption.textContent = 'User';
        const adminOption = document.createElement('option');
        adminOption.value = 'admin';
        adminOption.textContent = 'Admin';
        this.roleToggle.appendChild(userOption);
        this.roleToggle.appendChild(adminOption);
        this.roleToggle.addEventListener('change', (e) => {
            this.switchRole(e.target.value);
        });
        roleSection.appendChild(roleLabel);
        roleSection.appendChild(this.roleToggle);

        // Connection status
        const connectionSection = document.createElement('div');
        connectionSection.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        const connectionLabel = document.createElement('label');
        connectionLabel.textContent = 'Connection:';
        connectionLabel.style.cssText = `
            font-weight: bold;
            color: #333;
        `;
        this.connectionStatus = document.createElement('div');
        this.connectionStatus.style.cssText = `
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #f44336;
        `;
        this.connectionTooltip = document.createElement('span');
        this.connectionTooltip.textContent = 'Connecting...';
        this.connectionTooltip.style.cssText = `
            font-size: 14px;
            color: #666;
        `;
        connectionSection.appendChild(connectionLabel);
        connectionSection.appendChild(this.connectionStatus);
        connectionSection.appendChild(this.connectionTooltip);

        topControls.appendChild(roleSection);
        topControls.appendChild(connectionSection);
        baseContainer.appendChild(topControls);

        // Active users section
        const usersSection = document.createElement('div');
        usersSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const usersLabel = document.createElement('label');
        usersLabel.textContent = 'Active Users:';
        usersLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.userList = document.createElement('div');
        this.userList.style.cssText = `
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 30px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        `;
        this.userList.textContent = 'Loading users...';
        usersSection.appendChild(usersLabel);
        usersSection.appendChild(this.userList);
        baseContainer.appendChild(usersSection);

        // Editor area
        const editorSection = document.createElement('div');
        editorSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const editorLabel = document.createElement('label');
        editorLabel.textContent = 'Live Editor:';
        editorLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.editorArea = document.createElement('textarea');
        this.editorArea.style.cssText = `
            width: 100%;
            height: 150px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            box-sizing: border-box;
            background-color: #fff;
        `;
        this.editorArea.value = this.documentContent;
        this.editorArea.addEventListener('input', (e) => {
            this.handleTextChange(e.target.value);
        });
        this.editorArea.addEventListener('focus', () => {
            this.startEditing();
        });
        this.editorArea.addEventListener('blur', () => {
            this.stopEditing();
        });
        editorSection.appendChild(editorLabel);
        editorSection.appendChild(this.editorArea);
        baseContainer.appendChild(editorSection);

        // Preview area
        const previewSection = document.createElement('div');
        previewSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const previewLabel = document.createElement('label');
        previewLabel.textContent = 'Live Preview:';
        previewLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.previewArea = document.createElement('div');
        this.previewArea.style.cssText = `
            width: 100%;
            min-height: 100px;
            max-height: 200px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: #fff;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
        `;
        this.previewArea.textContent = this.documentContent;
        previewSection.appendChild(previewLabel);
        previewSection.appendChild(this.previewArea);
        baseContainer.appendChild(previewSection);

        // Admin controls
        this.adminControls = document.createElement('div');
        this.adminControls.style.cssText = `
            display: none;
            margin-bottom: 15px;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        `;
        const adminTitle = document.createElement('h3');
        adminTitle.textContent = 'Admin Controls';
        adminTitle.style.cssText = `
            margin: 0 0 15px 0;
            color: #2E7D32;
            font-size: 18px;
        `;
        const adminButtons = document.createElement('div');
        adminButtons.style.cssText = `
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        `;
        const lockButton = this.createButton('Lock Editing', '#FF9800', () => {
            this.toggleLock(true);
        });
        const unlockButton = this.createButton('Unlock Editing', '#4CAF50', () => {
            this.toggleLock(false);
        });
        const saveButton = this.createButton('Save Version', '#2196F3', () => {
            this.saveVersion();
        });
        const clearButton = this.createButton('Clear Document', '#f44336', () => {
            this.clearDocument();
        });
        const broadcastButton = this.createButton('Broadcast Message', '#9C27B0', () => {
            this.broadcastMessage();
        });
        adminButtons.appendChild(lockButton);
        adminButtons.appendChild(unlockButton);
        adminButtons.appendChild(saveButton);
        adminButtons.appendChild(clearButton);
        adminButtons.appendChild(broadcastButton);
        this.adminControls.appendChild(adminTitle);
        this.adminControls.appendChild(adminButtons);
        baseContainer.appendChild(this.adminControls);

        // Output section
        const outputSection = document.createElement('div');
        outputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const outputLabel = document.createElement('label');
        outputLabel.textContent = 'Activity Log:';
        outputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.outputDiv = document.createElement('div');
        this.outputDiv.style.cssText = `
            width: 100%;
            min-height: 80px;
            max-height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: #f9f9f9;
            overflow-y: auto;
        `;
        this.outputDiv.textContent = `Connecting to Firebase...`;
        outputSection.appendChild(outputLabel);
        outputSection.appendChild(this.outputDiv);
        baseContainer.appendChild(outputSection);

        // Info section
        const infoSection = document.createElement('div');
        infoSection.style.cssText = `
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 15px;
            font-size: 14px;
            color: #1976d2;
            border-left: 4px solid #2196F3;
            margin-top: auto;
        `;
        infoSection.innerHTML = `
            <strong>Instructions:</strong><br>
            • Switch between User and Admin roles using the dropdown<br>
            • Open this editor on multiple devices to collaborate<br>
            • Admin changes are instantly visible to all users via Firebase<br>
            • Admins can lock/unlock editing and manage permissions<br>
            • Admins can remove users from the session<br>
            • Document auto-saves every 30 seconds to Firebase
        `;
        baseContainer.appendChild(infoSection);
        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Update active users list with delete option for admin
     */
    updateActiveUsers() {
        this.userList.innerHTML = '';
        
        // Add current user
        const currentUser = document.createElement('span');
        currentUser.textContent = this.currentRole === 'admin' ? '👑 Admin (You)' : '👤 User (You)';
        currentUser.style.cssText = `
            padding: 4px 8px;
            background-color: ${this.currentRole === 'admin' ? '#4CAF50' : '#2196F3'};
            color: white;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        `;
        this.userList.appendChild(currentUser);
        
        // Add other active users
        this.activeUsers.forEach(user => {
            const userContainer = document.createElement('div');
            userContainer.style.cssText = `
                display: flex;
                align-items: center;
                gap: 5px;
            `;
            
            const userElement = document.createElement('span');
            userElement.textContent = user.role === 'admin' ? '👑 Admin' : '👤 User';
            userElement.style.cssText = `
                padding: 4px 8px;
                background-color: ${user.editing ? '#FF9800' : (user.role === 'admin' ? '#81C784' : '#64B5F6')};
                color: white;
                border-radius: 15px;
                font-size: 12px;
            `;
            userElement.title = user.name;
            userContainer.appendChild(userElement);
            
            // Add delete button for admin
            if (this.currentRole === 'admin') {
                const deleteButton = document.createElement('button');
                deleteButton.textContent = '❌';
                deleteButton.style.cssText = `
                    width: 20px;
                    height: 20px;
                    border: none;
                    border-radius: 50%;
                    background-color: #f44336;
                    color: white;
                    font-size: 10px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                deleteButton.title = 'Remove user';
                deleteButton.addEventListener('click', () => {
                    this.removeUser(user.id);
                });
                userContainer.appendChild(deleteButton);
            }
            
            this.userList.appendChild(userContainer);
        });
        
        if (this.activeUsers.length === 0) {
            const noUsers = document.createElement('span');
            noUsers.textContent = 'No other active users';
            noUsers.style.cssText = `
                padding: 4px 8px;
                color: #666;
                font-style: italic;
            `;
            this.userList.appendChild(noUsers);
        }
    }

    /**
     * Update connection status
     */
    updateConnectionStatus(isConnected) {
        if (isConnected) {
            this.connectionStatus.style.backgroundColor = '#4CAF50';
            this.connectionTooltip.textContent = 'Connected to Firebase';
        } else {
            this.connectionStatus.style.backgroundColor = '#f44336';
            this.connectionTooltip.textContent = 'Disconnected';
        }
    }

    /**
     * Handle text changes in the editor
     */
    handleTextChange(newText) {
        // Check if editing is locked and user is not admin
        if (this.isLocked && this.currentRole === 'user') {
            this.logActivity('Editing is locked by admin. Changes discarded.');
            this.editorArea.value = this.documentContent;
            return;
        }
        
        this.documentContent = newText;
        this.previewArea.textContent = newText;
        
        // Save to Firebase to sync with other users
        this.saveDocumentToFirebase();
        
        // Log activity
        this.logActivity(`Document updated by ${this.currentRole}`);
    }

    /**
     * Start editing
     */
    startEditing() {
        if (this.isLocked && this.currentRole === 'user') {
            this.logActivity('Editing is locked by admin.');
            this.editorArea.blur();
            return;
        }
        
        this.isEditing = true;
        this.updateUserStatus(true);
        this.logActivity(`Started editing as ${this.currentRole}`);
    }

    /**
     * Stop editing
     */
    stopEditing() {
        this.isEditing = false;
        this.updateUserStatus(false);
        this.logActivity(`Stopped editing as ${this.currentRole}`);
    }

    /**
     * Switch between user and admin roles
     */
    switchRole(newRole) {
        this.currentRole = newRole;
        this.registerUser(); // Update user role in Firebase
        this.updateUIForRole();
        this.updateActiveUsers(); // Update user list to show/hide delete buttons
        
        // Show/hide admin controls
        if (newRole === 'admin') {
            this.adminControls.style.display = 'block';
            // Scroll to admin controls when switching to admin
            setTimeout(() => {
                this.adminControls.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        } else {
            this.adminControls.style.display = 'none';
        }
        
        this.logActivity(`Switched to ${newRole} role`);
    }

    /**
     * Update UI based on current role
     */
    updateUIForRole() {
        if (this.currentRole === 'admin') {
            this.editorArea.style.backgroundColor = '#fff8e1';
            this.editorArea.style.border = '2px solid #FFC107';
        } else {
            this.editorArea.style.backgroundColor = '#fff';
            this.editorArea.style.border = '1px solid #ddd';
        }
        
        // Disable editor if locked and user
        if (this.isLocked && this.currentRole === 'user') {
            this.editorArea.disabled = true;
            this.logActivity('Document is locked by admin. You cannot edit.');
        } else {
            this.editorArea.disabled = false;
        }
    }

    /**
     * Toggle document lock
     */
    toggleLock(lock) {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can lock/unlock the document.');
            return;
        }
        
        this.isLocked = lock;
        this.updateUIForRole();
        this.saveDocumentToFirebase(); // Sync with other users
        
        if (lock) {
            this.logActivity('Document locked by admin');
            botReply('Document locked for editing');
        } else {
            this.logActivity('Document unlocked by admin');
            botReply('Document unlocked for editing');
        }
    }

    /**
     * Save document version
     */
    saveVersion() {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can save versions.');
            return;
        }
        
        this.currentVersion++;
        this.editHistory.push({
            version: this.currentVersion,
            content: this.documentContent,
            timestamp: new Date().toLocaleString(),
            author: this.currentRole
        });
        
        this.saveDocumentToFirebase(); // Sync with other users
        this.logActivity(`Version ${this.currentVersion} saved by ${this.currentRole}`);
        botReply(`Document version ${this.currentVersion} saved`);
    }

    /**
     * Clear document
     */
    clearDocument() {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can clear the document.');
            return;
        }
        
        if (confirm('Are you sure you want to clear the document? This cannot be undone.')) {
            this.documentContent = '';
            this.editorArea.value = '';
            this.previewArea.textContent = '';
            this.saveDocumentToFirebase(); // Sync with other users
            this.logActivity('Document cleared by admin');
            botReply('Document cleared');
        }
    }

    /**
     * Broadcast a message to all users
     */
    broadcastMessage() {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can broadcast messages.');
            return;
        }
        
        const message = prompt('Enter message to broadcast to all users:');
        if (message) {
            const messageData = {
                text: message,
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                author: this.currentRole
            };
            
            // If Firebase is ready, send immediately
            if (this.isFirebaseInitialized) {
                this.messagesRef.push(messageData);
            } else {
                // Queue the message for when Firebase is ready
                this.messageQueue.push(messageData);
            }
            
            this.logActivity(`Admin broadcast: "${message}"`);
            botReply(`Message broadcast: "${message}"`);
        }
    }

    /**
     * Log activity
     */
    logActivity(message) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}\n`;
        this.outputDiv.textContent += logEntry;
        this.outputDiv.scrollTop = this.outputDiv.scrollHeight;
    }

    /**
     * Start auto-save
     */
    startAutoSave() {
        this.autoSaveInterval = setInterval(() => {
            if (this.documentContent.trim() !== '' && this.currentRole === 'admin') {
                this.saveVersion();
            }
        }, 30000); // Auto-save every 30 seconds
    }

    /**
     * Stop auto-save
     */
    stopAutoSave() {
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
            this.autoSaveInterval = null;
        }
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 8px 12px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove user from Firebase
        if (this.isFirebaseInitialized) {
            this.usersRef.child(this.userSessionId).remove();
            this.presenceRef.child(this.userSessionId).remove();
        }
        
        this.stopAutoSave();
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.roleToggle = null;
        this.editorArea = null;
        this.previewArea = null;
        this.outputDiv = null;
        this.userList = null;
        this.adminControls = null;
        this.connectionStatus = null;
        this.connectionTooltip = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Live Collaborative Editor closed. Thank you!");
    }

    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }
}

// Create a singleton instance
const liveScreenLoaderEditor = new LiveScreenLoaderEditor();

// Add this to your AI's command handling
if (/live editor|live text editor|collaborative editor|real-time editor/i.test(userInputRaw)) {
    liveScreenLoaderEditor.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    liveScreenLoaderEditor.closeGame();
    return;
}



class ChatLiveScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'LIVE CHAT APP',
            instructions: 'Real-time chat application with online status and instant messaging.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.messagesContainer = null;
        this.messageInput = null;
        this.sendButton = null;
        this.userList = null;
        this.statusDiv = null;
        this.currentUsername = '';
        this.userSessionId = this.generateSessionId();
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.messagesRef = null;
        this.usersRef = null;
        this.presenceRef = null;
        this.connectedRef = null;
        this.typingRef = null;
        this.isFirebaseInitialized = false;
        this.activeUsers = [];
        this.blockedUsers = new Set();
        this.isAdmin = false;
        this.currentChatPartner = null;
        this.isPrivateChat = false;
        this.displayedMessages = new Set();
        this.messageListeners = {};
        this.typingUsers = new Set();
        this.lastMessageId = null; // Track last message to avoid duplicates
    }

    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'user_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Load the Chat App
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createLoginScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.initializeFirebase();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Initialize Firebase
     */
    initializeFirebase() {
        if (typeof firebase === 'undefined') {
            this.logActivity('Loading Firebase libraries...');
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase();
                });
            });
        } else {
            this.setupFirebase();
        }
    }

    /**
     * Setup Firebase
     */
    setupFirebase() {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
                this.logActivity('Firebase initialized successfully');
            } else {
                this.logActivity('Using existing Firebase app');
            }
            
            this.db = firebase.database();
            
            // References
            this.messagesRef = this.db.ref('chat/messages');
            this.usersRef = this.db.ref('chat/users');
            this.presenceRef = this.db.ref('chat/presence');
            this.connectedRef = this.db.ref('.info/connected');
            this.typingRef = this.db.ref('chat/typing');
            
            // Setup connection monitoring
            this.connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    this.updateConnectionStatus(true);
                    this.setupFirebaseListeners();
                } else {
                    this.updateConnectionStatus(false);
                }
            });
            
            this.isFirebaseInitialized = true;
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.logActivity('Firebase connection failed: ' + error.message);
            this.updateConnectionStatus(false);
        }
    }

    /**
     * Setup Firebase listeners (optimized)
     */
    setupFirebaseListeners() {
        // Remove existing listeners
        this.removeFirebaseListeners();
        
        // Single listener for messages with limit
        this.messageListeners.messages = this.messagesRef
            .orderByKey()
            .limitToLast(50)
            .on('child_added', (snapshot) => {
                const message = snapshot.val();
                if (message && snapshot.key !== this.lastMessageId) {
                    this.lastMessageId = snapshot.key;
                    
                    // Check if sender is blocked
                    if (!this.blockedUsers.has(message.senderId)) {
                        // Only display if it's a group message or private message to/from current user
                        if (message.type === 'group' || 
                            (message.receiverId === this.userSessionId) || 
                            (message.senderId === this.userSessionId)) {
                            this.displayMessage(message);
                        }
                    }
                }
            });
        
        // User list listener with throttling
        this.messageListeners.users = this.usersRef.on('value', (snapshot) => {
            const users = snapshot.val();
            if (users) {
                this.activeUsers = Object.values(users).filter(user => user.id !== this.userSessionId);
                this.updateUserList();
            }
        });
        
        // Typing indicator with debouncing
        this.messageListeners.typing = this.typingRef.on('value', (snapshot) => {
            const typingData = snapshot.val();
            if (typingData) {
                this.updateTypingIndicators(typingData);
            }
        });
        
        // Setup presence
        this.presenceRef.child(this.userSessionId).onDisconnect().remove();
        this.presenceRef.child(this.userSessionId).set(true);
    }

    /**
     * Remove Firebase listeners
     */
    removeFirebaseListeners() {
        if (this.messageListeners.messages) {
            this.messagesRef.off('child_added', this.messageListeners.messages);
        }
        if (this.messageListeners.users) {
            this.usersRef.off('value', this.messageListeners.users);
        }
        if (this.messageListeners.typing) {
            this.typingRef.off('value', this.messageListeners.typing);
        }
        this.messageListeners = {};
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
        `;
    }

    /**
     * Create Login Screen
     */
    createLoginScreen() {
        const loginContainer = document.createElement('div');
        loginContainer.style.cssText = `
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 30px;
            width: 400px;
            max-width: 90vw;
            text-align: center;
        `;

        const title = document.createElement('h2');
        title.textContent = 'Live Chat App';
        title.style.cssText = `
            margin: 0 0 20px 0;
            color: #128C7E;
            font-size: 28px;
        `;
        loginContainer.appendChild(title);

        const subtitle = document.createElement('p');
        subtitle.textContent = 'Enter your username to start chatting';
        subtitle.style.cssText = `
            margin: 0 0 30px 0;
            color: #666;
            font-size: 16px;
        `;
        loginContainer.appendChild(subtitle);

        const inputContainer = document.createElement('div');
        inputContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter your username';
        input.style.cssText = `
            width: 100%;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
        `;
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.handleLogin(input.value);
            }
        });
        inputContainer.appendChild(input);
        loginContainer.appendChild(inputContainer);

        // Admin checkbox
        const adminContainer = document.createElement('div');
        adminContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: left;
        `;
        
        const adminLabel = document.createElement('label');
        adminLabel.style.cssText = `
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        `;
        
        const adminCheckbox = document.createElement('input');
        adminCheckbox.type = 'checkbox';
        adminCheckbox.style.cssText = `
            width: 18px;
            height: 18px;
        `;
        
        const adminText = document.createElement('span');
        adminText.textContent = 'Login as Admin';
        
        adminLabel.appendChild(adminCheckbox);
        adminLabel.appendChild(adminText);
        adminContainer.appendChild(adminLabel);
        loginContainer.appendChild(adminContainer);

        const loginButton = this.createButton('Join Chat', '#128C7E', () => {
            this.isAdmin = adminCheckbox.checked;
            this.handleLogin(input.value);
        });
        loginButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 25px;
            font-size: 16px;
        `;
        loginContainer.appendChild(loginButton);

        // Connection status
        const connectionStatus = document.createElement('div');
        connectionStatus.style.cssText = `
            margin-top: 20px;
            font-size: 14px;
            color: #666;
        `;
        connectionStatus.innerHTML = `
            <span id="connection-indicator" style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: #f44336; margin-right: 5px;"></span>
            <span id="connection-text">Connecting to Firebase...</span>
        `;
        loginContainer.appendChild(connectionStatus);

        this.gameContainer.appendChild(loginContainer);
    }

    /**
     * Update connection status
     */
    updateConnectionStatus(isConnected) {
        const indicator = document.getElementById('connection-indicator');
        const text = document.getElementById('connection-text');
        
        if (indicator && text) {
            indicator.style.backgroundColor = isConnected ? '#25D366' : '#f44336';
            text.textContent = isConnected ? 'Connected to Firebase' : 'Connecting to Firebase...';
        }
    }

    /**
     * Log activity
     */
    logActivity(message) {
        console.log(`[Chat App] ${message}`);
    }

    /**
     * Handle Login
     */
    handleLogin(username) {
        if (!username.trim()) {
            this.showNotification('Please enter a username');
            return;
        }

        this.currentUsername = username.trim();
        this.registerUser();
        this.gameContainer.innerHTML = '';
        this.createChatScreen();
    }

    /**
     * Register user
     */
    registerUser() {
        if (!this.isFirebaseInitialized) {
            setTimeout(() => this.registerUser(), 1000);
            return;
        }
        
        const userData = {
            id: this.userSessionId,
            name: this.currentUsername,
            role: this.isAdmin ? 'admin' : 'user',
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            online: true
        };
        
        this.usersRef.child(this.userSessionId).set(userData).then(() => {
            this.logActivity(`User registered: ${this.currentUsername}`);
        }).catch(error => {
            console.error('Error registering user:', error);
        });
    }

    /**
     * Create Chat Screen (optimized sizes)
     */
    createChatScreen() {
        const chatContainer = document.createElement('div');
        chatContainer.style.cssText = `
            background-color: #f0f2f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 95vw;
            height: 90vh;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            background-color: #128C7E;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        `;
        
        const headerLeft = document.createElement('div');
        headerLeft.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const appTitle = document.createElement('h2');
        appTitle.textContent = 'Live Chat';
        appTitle.style.cssText = `
            margin: 0;
            font-size: 24px;
        `;
        headerLeft.appendChild(appTitle);
        
        const connectionStatus = document.createElement('div');
        connectionStatus.style.cssText = `
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        `;
        
        this.statusIndicator = document.createElement('div');
        this.statusIndicator.style.cssText = `
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #f44336;
        `;
        connectionStatus.appendChild(this.statusIndicator);
        
        const statusText = document.createElement('span');
        statusText.textContent = 'Connecting...';
        statusText.id = 'connectionStatus';
        connectionStatus.appendChild(statusText);
        
        headerLeft.appendChild(connectionStatus);
        header.appendChild(headerLeft);
        
        const userInfo = document.createElement('div');
        userInfo.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        
        const userAvatar = document.createElement('div');
        userAvatar.style.cssText = `
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: ${this.isAdmin ? '#f44336' : '#25D366'};
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        `;
        userAvatar.textContent = this.currentUsername.charAt(0).toUpperCase();
        userInfo.appendChild(userAvatar);
        
        const userName = document.createElement('span');
        userName.textContent = this.currentUsername;
        userName.style.cssText = `
            font-weight: bold;
            font-size: 16px;
        `;
        userInfo.appendChild(userName);
        
        const roleBadge = document.createElement('span');
        roleBadge.textContent = this.isAdmin ? 'Admin' : 'User';
        roleBadge.style.cssText = `
            background-color: ${this.isAdmin ? '#f44336' : '#25D366'};
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-left: 5px;
        `;
        userInfo.appendChild(roleBadge);
        
        header.appendChild(userInfo);
        chatContainer.appendChild(header);

        // Main Content
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            flex: 1;
            display: flex;
            overflow: hidden;
        `;
        
        // Sidebar (reduced size)
        const sidebar = document.createElement('div');
        sidebar.style.cssText = `
            width: 200px;
            background-color: #fff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        `;
        
        // Users list
        const usersSection = document.createElement('div');
        usersSection.style.cssText = `
            flex: 1;
            overflow-y: auto;
        `;
        
        const usersTitle = document.createElement('div');
        usersTitle.textContent = 'Online Users';
        usersTitle.style.cssText = `
            padding: 10px 15px;
            font-weight: bold;
            color: #666;
            font-size: 14px;
            background-color: #f0f2f5;
        `;
        usersSection.appendChild(usersTitle);
        
        this.userList = document.createElement('div');
        this.userList.id = 'userList';
        this.userList.style.cssText = `
            overflow-y: auto;
        `;
        usersSection.appendChild(this.userList);
        
        sidebar.appendChild(usersSection);
        mainContent.appendChild(sidebar);
        
        // Chat Area
        const chatArea = document.createElement('div');
        chatArea.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #efeae2;
        `;
        
        // Messages Container (larger)
        this.messagesContainer = document.createElement('div');
        this.messagesContainer.style.cssText = `
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        
        // Welcome message
        const welcomeMessage = document.createElement('div');
        welcomeMessage.style.cssText = `
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        `;
        welcomeMessage.textContent = 'Welcome to Live Chat! Start a conversation...';
        this.messagesContainer.appendChild(welcomeMessage);
        
        chatArea.appendChild(this.messagesContainer);
        
        // Typing Indicator
        this.typingIndicator = document.createElement('div');
        this.typingIndicator.style.cssText = `
            padding: 10px 20px;
            color: #666;
            font-size: 14px;
            font-style: italic;
            min-height: 20px;
        `;
        chatArea.appendChild(this.typingIndicator);
        
        // Input Area (larger)
        const inputArea = document.createElement('div');
        inputArea.style.cssText = `
            padding: 15px;
            background-color: #f0f2f5;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        
        this.messageInput = document.createElement('input');
        this.messageInput.type = 'text';
        this.messageInput.placeholder = 'Type a message...';
        this.messageInput.style.cssText = `
            flex: 1;
            padding: 15px 25px;
            border: 1px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
        `;
        this.messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });
        this.messageInput.addEventListener('input', () => {
            this.handleTyping();
        });
        inputArea.appendChild(this.messageInput);
        
        this.sendButton = this.createButton('Send', '#128C7E', () => {
            this.sendMessage();
        });
        this.sendButton.style.cssText = `
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
        `;
        inputArea.appendChild(this.sendButton);
        
        chatArea.appendChild(inputArea);
        mainContent.appendChild(chatArea);
        chatContainer.appendChild(mainContent);
        
        this.gameContainer.appendChild(chatContainer);
        
        // Focus on input
        setTimeout(() => {
            this.messageInput.focus();
        }, 100);
        
        this.updateConnectionStatus(this.isFirebaseInitialized);
    }

    /**
     * Update user list (optimized)
     */
    updateUserList() {
        if (!this.userList) return;
        
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        if (this.activeUsers.length === 0) {
            const noUsers = document.createElement('div');
            noUsers.textContent = 'No other users online';
            noUsers.style.cssText = `
                padding: 15px;
                color: #666;
                text-align: center;
                font-style: italic;
            `;
            fragment.appendChild(noUsers);
        } else {
            this.activeUsers.forEach(user => {
                const userItem = document.createElement('div');
                userItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 10px 12px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                `;
                
                userItem.addEventListener('mouseenter', () => {
                    userItem.style.backgroundColor = '#f0f2f5';
                });
                
                userItem.addEventListener('mouseleave', () => {
                    userItem.style.backgroundColor = 'transparent';
                });
                
                userItem.addEventListener('click', () => {
                    this.startPrivateChat(user);
                });
                
                // User avatar (smaller)
                const avatar = document.createElement('div');
                avatar.style.cssText = `
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    background-color: ${user.role === 'admin' ? '#f44336' : '#128C7E'};
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    font-size: 14px;
                `;
                avatar.textContent = user.name.charAt(0).toUpperCase();
                userItem.appendChild(avatar);
                
                // User name
                const userName = document.createElement('div');
                userName.textContent = user.name;
                userName.style.cssText = `
                    font-weight: bold;
                    color: #333;
                    font-size: 14px;
                `;
                userItem.appendChild(userName);
                
                // Online indicator
                const onlineIndicator = document.createElement('div');
                onlineIndicator.style.cssText = `
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                    background-color: #25D366;
                    border: 2px solid white;
                `;
                userItem.appendChild(onlineIndicator);
                
                // Action buttons
                const actionButtons = document.createElement('div');
                actionButtons.style.cssText = `
                    display: flex;
                    gap: 3px;
                    margin-left: auto;
                `;
                
                // Block button
                const blockButton = this.createButton('🚫', '#f44336', () => {
                    this.toggleBlockUser(user);
                });
                blockButton.style.cssText = `
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    padding: 0;
                    font-size: 12px;
                `;
                blockButton.title = this.blockedUsers.has(user.id) ? 'Unblock User' : 'Block User';
                actionButtons.appendChild(blockButton);
                
                // Delete button (admin only)
                if (this.isAdmin) {
                    const deleteButton = this.createButton('❌', '#f44336', () => {
                        this.deleteUser(user);
                    });
                    deleteButton.style.cssText = `
                        width: 24px;
                        height: 24px;
                        border-radius: 50%;
                        padding: 0;
                        font-size: 12px;
                    `;
                    deleteButton.title = 'Delete User';
                    actionButtons.appendChild(deleteButton);
                }
                
                userItem.appendChild(actionButtons);
                fragment.appendChild(userItem);
            });
        }
        
        // Update the list in one operation
        this.userList.innerHTML = '';
        this.userList.appendChild(fragment);
    }

    /**
     * Toggle block user
     */
    toggleBlockUser(user) {
        if (this.blockedUsers.has(user.id)) {
            this.blockedUsers.delete(user.id);
            this.showNotification(`${user.name} unblocked`);
        } else {
            this.blockedUsers.add(user.id);
            this.showNotification(`${user.name} blocked`);
        }
        this.updateUserList();
    }

    /**
     * Delete user (admin only)
     */
    deleteUser(user) {
        if (!this.isAdmin) {
            this.showNotification('Only admins can delete users');
            return;
        }
        
        if (confirm(`Are you sure you want to delete ${user.name}?`)) {
            this.usersRef.child(user.id).remove().then(() => {
                this.presenceRef.child(user.id).remove();
                this.showNotification(`${user.name} has been deleted`);
            }).catch(error => {
                console.error('Error deleting user:', error);
                this.showNotification('Error deleting user');
            });
        }
    }

    /**
     * Start private chat
     */
    startPrivateChat(user) {
        if (this.blockedUsers.has(user.id)) {
            this.showNotification('You have blocked this user');
            return;
        }
        
        this.currentChatPartner = user;
        this.isPrivateChat = true;
        
        const chatHeader = document.querySelector('header h2');
        if (chatHeader) {
            chatHeader.textContent = `Chat with ${user.name}`;
        }
        
        this.messagesContainer.innerHTML = '';
        this.showNotification(`Now chatting privately with ${user.name}`);
    }

    /**
     * Handle typing indicator (optimized)
     */
    handleTyping() {
        if (!this.isFirebaseInitialized) return;
        
        const isTyping = this.messageInput.value.length > 0;
        
        if (isTyping) {
            this.typingRef.child(this.userSessionId).set({
                username: this.currentUsername,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            
            clearTimeout(this.typingTimeout);
            this.typingTimeout = setTimeout(() => {
                this.typingRef.child(this.userSessionId).remove();
            }, 3000);
        } else {
            this.typingRef.child(this.userSessionId).remove();
        }
    }

    /**
     * Update typing indicators
     */
    updateTypingIndicators(typingData) {
        const typingUsers = [];
        const now = Date.now();
        
        Object.keys(typingData).forEach(userId => {
            if (userId !== this.userSessionId) {
                const user = typingData[userId];
                if (now - user.timestamp < 3000) {
                    typingUsers.push(user.username);
                }
            }
        });
        
        this.typingIndicator.textContent = typingUsers.length > 0 ? 
            `${typingUsers.join(', ')} is typing...` : '';
    }

    /**
     * Send message (optimized)
     */
    sendMessage() {
        const messageText = this.messageInput.value.trim();
        if (!messageText) return;
        
        const message = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            text: messageText,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            type: this.isPrivateChat ? 'private' : 'group'
        };
        
        if (this.isPrivateChat && this.currentChatPartner) {
            message.receiverId = this.currentChatPartner.id;
        }
        
        // Use push with key tracking
        const newMessageRef = this.messagesRef.push();
        this.lastMessageId = newMessageRef.key;
        newMessageRef.set(message);
        
        // Clear input
        this.messageInput.value = '';
        this.typingRef.child(this.userSessionId).remove();
        
        // Display immediately for better UX
        this.displayMessage(message);
    }

    /**
     * Display message (optimized)
     */
    displayMessage(message) {
        const isOwnMessage = message.senderId === this.userSessionId;
        
        const messageContainer = document.createElement('div');
        messageContainer.style.cssText = `
            display: flex;
            ${isOwnMessage ? 'justify-content: flex-end' : 'justify-content: flex-start'}
            margin-bottom: 8px;
        `;
        
        const messageBubble = document.createElement('div');
        messageBubble.style.cssText = `
            max-width: 70%;
            padding: 10px 15px;
            border-radius: 18px;
            background-color: ${isOwnMessage ? '#dcf8c6' : '#fff'};
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
        `;
        
        // Sender name
        if (!isOwnMessage && (message.type === 'group' || this.isPrivateChat)) {
            const senderName = document.createElement('div');
            senderName.textContent = message.senderName;
            senderName.style.cssText = `
                font-weight: bold;
                font-size: 12px;
                color: #128C7E;
                margin-bottom: 4px;
            `;
            messageBubble.appendChild(senderName);
        }
        
        // Message text
        const messageText = document.createElement('div');
        messageText.textContent = message.text;
        messageText.style.cssText = `
            word-wrap: break-word;
            font-size: 15px;
        `;
        messageBubble.appendChild(messageText);
        
        // Timestamp
        const timestamp = document.createElement('div');
        timestamp.textContent = this.formatTimestamp(message.timestamp);
        timestamp.style.cssText = `
            font-size: 11px;
            color: #999;
            margin-top: 4px;
            text-align: ${isOwnMessage ? 'right' : 'left'};
        `;
        messageBubble.appendChild(timestamp);
        
        messageContainer.appendChild(messageBubble);
        
        // Remove welcome message if exists
        if (this.messagesContainer.firstChild && this.messagesContainer.firstChild.textContent.includes('Welcome')) {
            this.messagesContainer.innerHTML = '';
        }
        
        this.messagesContainer.appendChild(messageContainer);
        
        // Auto-scroll to bottom
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }

    /**
     * Format timestamp
     */
    formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        return `${hours}:${minutes}`;
    }

    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            z-index: 10000;
            animation: slideDown 0.3s ease;
        `;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 20px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 16px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons
     */
    setupActionButtons() {
        const existingButtons = document.querySelector('.floating-buttons');
        if (existingButtons) {
            existingButtons.remove();
        }
        
        const floatingButtons = document.createElement('div');
        floatingButtons.className = 'floating-buttons';
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10001;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        
        if (this.gameContainer) {
            this.gameContainer.appendChild(floatingButtons);
        } else {
            document.body.appendChild(floatingButtons);
        }
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            this.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        if (this.isFirebaseInitialized) {
            this.usersRef.child(this.userSessionId).remove();
            this.presenceRef.child(this.userSessionId).remove();
            this.typingRef.child(this.userSessionId).remove();
        }
        
        this.removeFirebaseListeners();
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        const floatingButtons = document.querySelector('.floating-buttons');
        if (floatingButtons) {
            floatingButtons.remove();
        }
        
        this.gameContainer = null;
        this.messagesContainer = null;
        this.messageInput = null;
        this.sendButton = null;
        this.userList = null;
        this.statusDiv = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Live Chat App closed. Thank you!");
    }

    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }
}

// Create a singleton instance
const chatLiveScreenLoader = new ChatLiveScreenLoader();

// Add this to your AI's command handling
if (/chat app|live chat|whatsapp|messenger|chat room/i.test(userInputRaw)) {
    chatLiveScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    chatLiveScreenLoader.closeGame();
    return;
}
class SignalsFinder {
    constructor() {
        this.appName = 'SIGNALS FINDER';
        this.instructions = 'Use your camera to detect and analyze various types of signals and signs.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.signalDisplay = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment'; // Start with back camera
        this.flashMode = 'off'; // off, on, auto
        this.signalHistory = [];
        this.isDetecting = false;
        this.animationId = null;
        this.detectedSignals = [];
        this.modelLoaded = false;
        this.continuousDetectionId = null;
        this.model = null; // Store the loaded model
        this.lastDetectionTime = 0;
        this.detectionInProgress = false;
        this.continuousModeEnabled = false;
        this.continuousDetectionInterval = 3000; // Interval between detections
        this.detectionQueue = [];
        this.processingQueue = false;
        this.offscreenCanvas = null;
        this.offscreenContext = null;
        this.lastDetectedSignals = []; // Store last detected signals
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        this.hasObjectDetection = 'IntersectionObserver' in window || 
                                 (window.OffscreenCanvas && window.createImageBitmap);
        
        // Initialize TensorFlow if available
        this.tf = null;
    }
    
    /**
     * Load the Signals Finder
     */
    loadSignalsFinder() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        // Create the UI first
        this.createAppContainer();
        this.createSignalsFinderUI();
        this.setupActionButtons();
        this.displayApp();
        
        // Then initialize camera and preload model
        this.initializeCamera();
        this.preloadModel();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Preload ML model for better performance
     */
    preloadModel() {
        // Try to load TensorFlow.js and Coco-SSD model
        if (typeof tf === 'undefined') {
            this.updateStatus('Loading TensorFlow.js...');
            this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js')
                .then(() => {
                    this.tf = window.tf;
                    this.updateStatus('Loading COCO-SSD model...');
                    return this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest/dist/coco-ssd.min.js');
                })
                .then(() => {
                    // Load the actual model
                    return cocoSsd.load();
                })
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        } else if (typeof cocoSsd !== 'undefined') {
            // If TensorFlow is already loaded, just load the model
            this.tf = tf;
            cocoSsd.load()
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        }
    }
    
    /**
     * Dynamically load a script
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support camera access. Please try a different browser.');
            return false;
        }
        
        if (!this.hasObjectDetection) {
            botReply('Your browser has limited support for object detection. Using alternative method.');
        }
        
        return true;
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
    }
    
    /**
     * Create the Signals Finder UI
     */
    createSignalsFinderUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '🚦';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = '⛶';
        this.fullscreenButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;
        
        this.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = '✕';
        this.closeButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-left: 10px;
        `;
        
        this.closeButton.addEventListener('click', () => this.closeApp());
        
        header.appendChild(this.fullscreenButton);
        header.appendChild(this.closeButton);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Camera container
        this.cameraContainer = document.createElement('div');
        this.cameraContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 50%;
            border-radius: 16px;
            overflow: hidden;
            background-color: #000;
            margin-bottom: 20px;
        `;
        
        // Video element for camera feed
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        // Canvas element for image capture and object detection
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        `;
        
        // Create offscreen canvas for processing (to avoid blocking main thread)
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCanvas.style.display = 'none';
        this.offscreenContext = this.offscreenCanvas.getContext('2d');
        
        // Camera controls
        const cameraControls = document.createElement('div');
        cameraControls.style.cssText = `
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        `;
        
        // Capture button
        this.captureButton = document.createElement('button');
        this.captureButton.innerHTML = '📸';
        this.captureButton.style.cssText = `
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 3px solid white;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.captureButton.addEventListener('click', () => this.detectSignals());
        
        // Switch camera button
        this.switchCameraButton = document.createElement('button');
        this.switchCameraButton.innerHTML = '🔄';
        this.switchCameraButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.switchCameraButton.addEventListener('click', () => this.switchCamera());
        
        // Flash button
        this.flashButton = document.createElement('button');
        this.flashButton.innerHTML = '⚡';
        this.flashButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.flashButton.addEventListener('click', () => this.toggleFlash());
        
        cameraControls.appendChild(this.switchCameraButton);
        cameraControls.appendChild(this.captureButton);
        cameraControls.appendChild(this.flashButton);
        
        this.cameraContainer.appendChild(this.videoElement);
        this.cameraContainer.appendChild(this.canvasElement);
        this.cameraContainer.appendChild(cameraControls);
        
        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        `;
        
        // Detection mode options
        const modeLabel = document.createElement('div');
        modeLabel.textContent = 'Detection Mode:';
        modeLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const modeOptions = document.createElement('div');
        modeOptions.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const singleShot = this.createToggleOption('Single Shot', true);
        const continuous = this.createToggleOption('Continuous', false);
        
        // Add event listeners for mode changes
        singleShot.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.stopContinuousDetection();
            }
        });
        
        continuous.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.startContinuousDetection();
            }
        });
        
        modeOptions.appendChild(singleShot);
        modeOptions.appendChild(continuous);
        
        // Signal type filter
        const filterLabel = document.createElement('div');
        filterLabel.textContent = 'Signal Type:';
        filterLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const filterOptions = document.createElement('select');
        filterOptions.style.cssText = `
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 14px;
            cursor: pointer;
        `;
        
        const filterAll = document.createElement('option');
        filterAll.value = 'all';
        filterAll.textContent = 'All Signals';
        filterOptions.appendChild(filterAll);
        
        const filterTraffic = document.createElement('option');
        filterTraffic.value = 'traffic';
        filterTraffic.textContent = 'Traffic';
        filterOptions.appendChild(filterTraffic);
        
        const filterWarning = document.createElement('option');
        filterWarning.value = 'warning';
        filterWarning.textContent = 'Warning';
        filterOptions.appendChild(filterWarning);
        
        const filterInfo = document.createElement('option');
        filterInfo.value = 'info';
        filterInfo.textContent = 'Information';
        filterOptions.appendChild(filterInfo);
        
        settingsPanel.appendChild(modeLabel);
        settingsPanel.appendChild(modeOptions);
        settingsPanel.appendChild(filterLabel);
        settingsPanel.appendChild(filterOptions);
        
        // Result container
        const resultContainer = document.createElement('div');
        resultContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const resultHeader = document.createElement('div');
        resultHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const resultTitle = document.createElement('div');
        resultTitle.textContent = 'Detected Signals';
        resultTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Info';
        copyButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        copyButton.addEventListener('click', () => this.copySignalInfo());
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearResults());
        
        actionButtons.appendChild(copyButton);
        actionButtons.appendChild(clearButton);
        
        resultHeader.appendChild(resultTitle);
        resultHeader.appendChild(actionButtons);
        
        // Signal display
        this.signalDisplay = document.createElement('div');
        this.signalDisplay.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            overflow-y: auto;
            margin-bottom: 15px;
            min-height: 200px;
        `;
        
        this.signalDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at signals and signs and click capture to identify them
            </div>
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Loading object detection model...';
        
        mainContent.appendChild(this.cameraContainer);
        mainContent.appendChild(settingsPanel);
        mainContent.appendChild(resultContainer);
        resultContainer.appendChild(resultHeader);
        resultContainer.appendChild(this.signalDisplay);
        resultContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
    }
    
    /**
     * Create a toggle option
     */
    createToggleOption(label, defaultValue) {
        const container = document.createElement('div');
        container.style.cssText = `
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'detection-mode';
        radio.id = `mode-${label.replace(/\s+/g, '-').toLowerCase()}`;
        radio.checked = defaultValue;
        radio.style.cssText = `
            cursor: pointer;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.htmlFor = radio.id;
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            cursor: pointer;
        `;
        
        container.appendChild(radio);
        container.appendChild(labelElement);
        
        return container;
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Add hover effects to buttons
        const buttons = [this.captureButton, this.switchCameraButton, this.flashButton];
        
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'scale(1.1)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'scale(1)';
            });
        });
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
    }
    
    /**
     * Initialize the camera
     */
    async initializeCamera() {
        try {
            // Stop any existing stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Set up camera constraints
            const constraints = {
                video: {
                    facingMode: this.facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            
            // Add flash constraint if supported
            if (this.flashMode === 'on') {
                constraints.video.torch = true;
            }
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Set video source
            this.videoElement.srcObject = this.currentStream;
            
            // Wait for video to be ready
            this.videoElement.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvasElement.width = this.videoElement.videoWidth;
                this.canvasElement.height = this.videoElement.videoHeight;
                this.offscreenCanvas.width = this.videoElement.videoWidth;
                this.offscreenCanvas.height = this.videoElement.videoHeight;
                
                this.updateStatus('Camera ready. Point at signals and signs and click capture.');
                
                // Start continuous detection if enabled
                const continuousMode = document.getElementById('mode-continuous');
                if (continuousMode && continuousMode.checked) {
                    this.startContinuousDetection();
                }
            };
            
        } catch (error) {
            console.error('Error initializing camera:', error);
            this.updateStatus('Error accessing camera: ' + error.message);
        }
    }
    
    /**
     * Switch between front and back camera
     */
    async switchCamera() {
        this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
        this.updateStatus('Switching camera...');
        await this.initializeCamera();
    }
    
    /**
     * Toggle flash mode
     */
    async toggleFlash() {
        const flashModes = ['off', 'on', 'auto'];
        const currentIndex = flashModes.indexOf(this.flashMode);
        this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];
        
        // Update button appearance based on flash mode
        if (this.flashMode === 'on') {
            this.flashButton.style.backgroundColor = 'rgba(255, 235, 59, 0.7)';
        } else if (this.flashMode === 'auto') {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        }
        
        this.updateStatus(`Flash mode: ${this.flashMode}`);
        await this.initializeCamera();
    }
    
    /**
     * Detect signals in the current camera frame
     */
    async detectSignals() {
        // Add detection request to queue
        this.detectionQueue.push({
            timestamp: Date.now(),
            id: Math.random().toString(36).substr(2, 9)
        });
        
        // Process queue if not already processing
        if (!this.processingQueue) {
            this.processDetectionQueue();
        }
    }
    
    /**
     * Process the detection queue
     */
    async processDetectionQueue() {
        if (this.processingQueue || this.detectionQueue.length === 0) {
            return;
        }
        
        this.processingQueue = true;
        
        try {
            // Get the latest detection request (skip older ones)
            let latestRequest = null;
            while (this.detectionQueue.length > 0) {
                latestRequest = this.detectionQueue.shift();
            }
            
            if (latestRequest) {
                await this.performDetection(latestRequest);
            }
        } catch (error) {
            console.error('Error processing detection queue:', error);
            this.updateStatus('Error during detection: ' + error.message);
        } finally {
            this.processingQueue = false;
            
            // Process next item in queue if any
            if (this.detectionQueue.length > 0) {
                // Use a small delay to prevent overwhelming the system
                setTimeout(() => this.processDetectionQueue(), 100);
            }
        }
    }
    
    /**
     * Perform the actual detection
     */
    async performDetection(request) {
        try {
            this.updateStatus('Detecting signals...');
            
            // Capture current frame to offscreen canvas (non-blocking)
            this.offscreenContext.drawImage(this.videoElement, 0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
            
            // Process image for signals
            await this.processImageForSignals();
            
        } catch (error) {
            console.error('Error performing detection:', error);
            this.updateStatus('Error detecting signals: ' + error.message);
        }
    }
    
    /**
     * Start continuous object detection
     */
    startContinuousDetection() {
        if (this.continuousDetectionId) {
            clearInterval(this.continuousDetectionId);
        }
        
        this.continuousModeEnabled = true;
        this.updateStatus('Continuous detection enabled');
        
        // Use requestAnimationFrame for smoother operation
        this.lastDetectionTime = 0;
        this.scheduleContinuousDetection();
    }
    
    /**
     * Schedule continuous detection using requestAnimationFrame
     */
    scheduleContinuousDetection() {
        if (!this.continuousModeEnabled) {
            return;
        }
        
        // Use requestAnimationFrame for smooth operation
        requestAnimationFrame(() => {
            const now = Date.now();
            
            // Check if it's time for a new detection
            if (now - this.lastDetectionTime >= this.continuousDetectionInterval) {
                this.lastDetectionTime = now;
                this.detectSignals();
            }
            
            // Schedule next check
            this.scheduleContinuousDetection();
        });
    }
    
    /**
     * Stop continuous object detection
     */
    stopContinuousDetection() {
        this.continuousModeEnabled = false;
        
        if (this.continuousDetectionId) {
            clearTimeout(this.continuousDetectionId);
            this.continuousDetectionId = null;
        }
        
        this.updateStatus('Continuous detection stopped');
    }
    
    /**
     * Process image to detect signals
     */
    async processImageForSignals() {
        try {
            // Check if the model is loaded
            if (!this.modelLoaded || !this.model) {
                // Fallback to simulated detection if model isn't loaded
                const simulatedSignals = await this.simulateSignalDetection();
                if (simulatedSignals && simulatedSignals.length > 0) {
                    this.displayDetectedSignals(simulatedSignals);
                    return;
                }
                
                this.updateStatus('Object detection model not ready. Please try again later.');
                return;
            }
            
            // Use the loaded model for real detection
            this.updateStatus('Detecting signals with AI model...');
            
            // Create an image bitmap from the offscreen canvas for better performance
            const bitmap = await createImageBitmap(this.offscreenCanvas);
            
            // Detect objects in the image
            const predictions = await this.model.detect(bitmap);
            
            // Clean up bitmap
            bitmap.close();
            
            // Filter for signal-related objects
            const signalObjects = predictions.filter(prediction => 
                ['traffic light', 'stop sign', 'parking meter', 'bench', 'fire hydrant'].includes(prediction.class.toLowerCase())
            );
            
            if (signalObjects && signalObjects.length > 0) {
                // Process the detected signals
                const signals = signalObjects.map(obj => this.analyzeSignal(obj));
                this.displayDetectedSignals(signals);
                
                // Draw bounding boxes on canvas
                this.drawBoundingBoxes(signalObjects);
            } else {
                // No signals detected, clear any previous bounding boxes
                this.clearBoundingBoxes();
                this.updateStatus('No signals detected. Try pointing your camera at traffic signals, signs, or other signals.');
            }
            
        } catch (error) {
            console.error('Error processing image for signals:', error);
            this.updateStatus('Error processing image: ' + error.message);
        }
    }
    
    /**
     * Analyze a detected signal object
     */
    analyzeSignal(signalObject) {
        const objectType = signalObject.class.toLowerCase();
        const confidence = Math.round(signalObject.score * 100);
        
        // Get signal information based on type
        const signalInfo = this.getSignalInfo(objectType);
        
        // Create signal data object
        const signalData = {
            type: objectType,
            name: signalInfo.name,
            category: signalInfo.category,
            description: signalInfo.description,
            confidence: confidence,
            bbox: signalObject.bbox
        };
        
        return signalData;
    }
    
    /**
     * Get information about a signal type
     */
    getSignalInfo(signalType) {
        // Database of signal types and their descriptions
        const signalDatabase = {
            'traffic light': {
                name: 'Traffic Light',
                category: 'Traffic Control',
                description: 'A signaling device positioned at road intersections, pedestrian crossings, and other locations to control competing flows of traffic.'
            },
            'stop sign': {
                name: 'Stop Sign',
                category: 'Traffic Control',
                description: 'A traffic sign to notify drivers that they must stop before proceeding.'
            },
            'parking meter': {
                name: 'Parking Meter',
                category: 'Parking Control',
                description: 'A device used to collect money in exchange for the right to park a vehicle in a particular place for a limited amount of time.'
            },
            'bench': {
                name: 'Bench',
                category: 'Public Facility',
                description: 'A long seat for several people, typically made of wood or stone.'
            },
            'fire hydrant': {
                name: 'Fire Hydrant',
                category: 'Emergency',
                description: 'A connection point by which firefighters can tap into a water supply.'
            }
        };
        
        return signalDatabase[signalType] || {
            name: signalType.charAt(0).toUpperCase() + signalType.slice(1),
            category: 'Unknown',
            description: 'A signal or sign detected in the environment.'
        };
    }
    
    /**
     * Simulate signal detection (for demonstration purposes)
     */
    async simulateSignalDetection() {
        try {
            this.updateStatus('Analyzing image for signals...');
            
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Common signals that might be detected
            const commonSignals = [
                { type: 'traffic light', info: { name: 'Traffic Light', category: 'Traffic Control', description: 'A signaling device positioned at road intersections.' } },
                { type: 'stop sign', info: { name: 'Stop Sign', category: 'Traffic Control', description: 'A traffic sign to notify drivers that they must stop.' } },
                { type: 'parking meter', info: { name: 'Parking Meter', category: 'Parking Control', description: 'A device used to collect money for parking.' } },
                { type: 'bench', info: { name: 'Bench', category: 'Public Facility', description: 'A long seat for several people.' } },
                { type: 'fire hydrant', info: { name: 'Fire Hydrant', category: 'Emergency', description: 'A connection point for firefighters to tap into water.' } }
            ];
            
            // Randomly select 1-3 signals to "detect"
            const numSignals = Math.floor(Math.random() * 3) + 1;
            const detectedSignals = [];
            
            for (let i = 0; i < numSignals; i++) {
                const randomIndex = Math.floor(Math.random() * commonSignals.length);
                const signal = commonSignals[randomIndex];
                
                // Add some random confidence and position data
                detectedSignals.push({
                    type: signal.type,
                    name: signal.info.name,
                    category: signal.info.category,
                    description: signal.info.description,
                    confidence: Math.floor(Math.random() * 30) + 70, // 70-99% confidence
                    bbox: [
                        Math.floor(Math.random() * 200),
                        Math.floor(Math.random() * 200),
                        Math.floor(Math.random() * 200) + 100,
                        Math.floor(Math.random() * 200) + 100
                    ]
                });
            }
            
            return detectedSignals;
            
        } catch (error) {
            console.error('Simulated signal detection error:', error);
            return null;
        }
    }
    
    /**
     * Clear bounding boxes from canvas
     */
    clearBoundingBoxes() {
        const context = this.canvasElement.getContext('2d');
        context.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
        this.lastDetectedSignals = [];
    }
    
    /**
     * Draw bounding boxes on canvas
     */
    drawBoundingBoxes(signalObjects) {
        const context = this.canvasElement.getContext('2d');
        
        // Clear previous drawings
        context.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
        
        // Scale coordinates to canvas size
        const scaleX = this.canvasElement.width / this.videoElement.videoWidth;
        const scaleY = this.canvasElement.height / this.videoElement.videoHeight;
        
        // Draw each signal object
        signalObjects.forEach(obj => {
            if (obj.bbox && obj.bbox.length === 4) {
                const x = obj.bbox[0] * scaleX;
                const y = obj.bbox[1] * scaleY;
                const width = obj.bbox[2] * scaleX;
                const height = obj.bbox[3] * scaleY;
                
                // Determine color based on signal type
                let color = '#4CAF50'; // Default green
                if (obj.class.toLowerCase() === 'stop sign') {
                    color = '#F44336'; // Red for stop signs
                } else if (obj.class.toLowerCase() === 'traffic light') {
                    color = '#FFC107'; // Yellow for traffic lights
                } else if (obj.class.toLowerCase() === 'fire hydrant') {
                    color = '#2196F3'; // Blue for fire hydrants
                }
                
                // Draw bounding box
                context.strokeStyle = color;
                context.lineWidth = 2;
                context.strokeRect(x, y, width, height);
                
                // Draw label background
                const labelText = `${obj.class} ${Math.round(obj.score * 100)}%`;
                context.font = '14px Arial';
                const textWidth = context.measureText(labelText).width;
                
                context.fillStyle = color.replace(')', ', 0.7)').replace('rgb', 'rgba');
                context.fillRect(x, y - 20, textWidth + 10, 20);
                
                // Draw label text
                context.fillStyle = 'white';
                context.fillText(labelText, x + 5, y - 5);
            }
        });
        
        // Store the detected signals
        this.lastDetectedSignals = signalObjects;
    }
    
    /**
     * Display detected signals
     */
    displayDetectedSignals(signals) {
        if (!signals || signals.length === 0) {
            this.updateStatus('No signals detected.');
            return;
        }
        
        // Clear previous results
        this.signalDisplay.innerHTML = '';
        
        // Create a container for the detected signals
        const signalsContainer = document.createElement('div');
        signalsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Add each detected signal
        signals.forEach((signal, index) => {
            const signalElement = document.createElement('div');
            signalElement.style.cssText = `
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 15px;
                border-left: 4px solid ${this.getSignalColor(signal.type)};
            `;
            
            const signalHeader = document.createElement('div');
            signalHeader.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            `;
            
            const signalName = document.createElement('div');
            signalName.textContent = signal.name;
            signalName.style.cssText = `
                font-size: 18px;
                font-weight: 600;
                color: ${this.getSignalColor(signal.type)};
            `;
            
            const confidenceBadge = document.createElement('div');
            confidenceBadge.textContent = `${signal.confidence}%`;
            confidenceBadge.style.cssText = `
                background-color: rgba(255, 255, 255, 0.2);
                color: white;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 500;
            `;
            
            signalHeader.appendChild(signalName);
            signalHeader.appendChild(confidenceBadge);
            
            const signalCategory = document.createElement('div');
            signalCategory.textContent = `Category: ${signal.category}`;
            signalCategory.style.cssText = `
                color: rgba(255, 255, 255, 0.7);
                font-size: 14px;
                margin-bottom: 8px;
            `;
            
            const signalDescription = document.createElement('div');
            signalDescription.textContent = signal.description;
            signalDescription.style.cssText = `
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
                line-height: 1.5;
            `;
            
            signalElement.appendChild(signalHeader);
            signalElement.appendChild(signalCategory);
            signalElement.appendChild(signalDescription);
            signalsContainer.appendChild(signalElement);
        });
        
        this.signalDisplay.appendChild(signalsContainer);
        
        // Add to history
        this.signalHistory.push({
            timestamp: new Date(),
            signals: signals
        });
        
        // Update status
        this.updateStatus(`Detected ${signals.length} signal${signals.length !== 1 ? 's' : ''}`);
    }
    
    /**
     * Get color for signal type
     */
    getSignalColor(signalType) {
        const colorMap = {
            'traffic light': '#FFC107', // Yellow
            'stop sign': '#F44336', // Red
            'parking meter': '#9C27B0', // Purple
            'bench': '#795548', // Brown
            'fire hydrant': '#2196F3' // Blue
        };
        
        return colorMap[signalType] || '#4CAF50'; // Default green
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        if (this.resultDisplay) {
            this.resultDisplay.textContent = message;
        }
    }
    
    /**
     * Copy signal information to clipboard
     */
    copySignalInfo() {
        if (this.signalHistory.length === 0) {
            this.updateStatus('No signal information to copy.');
            return;
        }
        
        // Get the latest detection
        const latestDetection = this.signalHistory[this.signalHistory.length - 1];
        
        // Format the information
        let textToCopy = `Detected Signals (${latestDetection.timestamp.toLocaleString()}):\n\n`;
        
        latestDetection.signals.forEach((signal, index) => {
            textToCopy += `${index + 1}. ${signal.name}\n`;
            textToCopy += `   Category: ${signal.category}\n`;
            textToCopy += `   Confidence: ${signal.confidence}%\n`;
            textToCopy += `   Description: ${signal.description}\n\n`;
        });
        
        // Copy to clipboard
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                this.updateStatus('Signal information copied to clipboard!');
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                this.updateStatus('Failed to copy signal information.');
            });
    }
    
    /**
     * Clear results
     */
    clearResults() {
        this.signalDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at signals and signs and click capture to identify them
            </div>
        `;
        
        // Clear canvas and bounding boxes
        this.clearBoundingBoxes();
        
        this.updateStatus('Results cleared. Ready for new detection.');
    }
    
    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.appContainer.requestFullscreen) {
                this.appContainer.requestFullscreen();
            } else if (this.appContainer.webkitRequestFullscreen) { /* Safari */
                this.appContainer.webkitRequestFullscreen();
            } else if (this.appContainer.msRequestFullscreen) { /* IE11 */
                this.appContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        // Stop continuous detection
        this.stopContinuousDetection();
        
        // Stop camera stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        this.isActive = false;
        botReply('Signals Finder closed.');
    }
}

// Create a global instance of the app
const signalsFinder = new SignalsFinder();

// Add this to your AI's command handling
if (/signals finder|signal detector|find signals|detect signs/i.test(userInputRaw)) {
    signalsFinder.loadSignalsFinder();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    signalsFinder.closeApp();
    return;
}


class ComprehensiveSignalFinder {
    constructor() {
        this.appName = 'COMPREHENSIVE SIGNAL FINDER';
        this.instructions = 'Scan for Bluetooth, WiFi, Hotspot, GPS, and NFC signals in your vicinity.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.scanContainer = null;
        this.resultDisplay = null;
        this.signalDisplay = null;
        this.refreshButton = null;
        this.currentSignals = {
            bluetooth: [],
            wifi: [],
            hotspot: [],
            gps: {},
            nfc: []
        };
        this.signalHistory = [];
        this.isScanning = false;
        this.animationId = null;
        this.continuousScanId = null;
        this.continuousModeEnabled = false;
        this.continuousScanInterval = 10000; // 10 seconds between scans
        
        // Check API availability
        this.hasBluetooth = 'bluetooth' in navigator;
        this.hasWifi = 'connection' in navigator || 'wifi' in navigator;
        this.hasGeolocation = 'geolocation' in navigator;
        this.hasNFC = 'nfc' in navigator;
        this.hasPermissionsAPI = 'permissions' in navigator;
        
        // API references
        this.bluetoothDevice = null;
        this.wifiManager = null;
        this.geolocationPosition = null;
        this.nfcReader = null;
    }
    
    /**
     * Load the Comprehensive Signal Finder
     */
    loadComprehensiveSignalFinder() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        this.checkBrowserSupport();
        
        // Create the UI
        this.createAppContainer();
        this.createComprehensiveSignalFinderUI();
        this.setupActionButtons();
        this.displayApp();
        
        // Initialize APIs
        this.initializeAPIs();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Check browser support for different APIs
     */
    checkBrowserSupport() {
        const supportStatus = {
            bluetooth: this.hasBluetooth ? '✅ Supported' : '❌ Not supported',
            wifi: this.hasWifi ? '✅ Supported' : '❌ Not supported',
            geolocation: this.hasGeolocation ? '✅ Supported' : '❌ Not supported',
            nfc: this.hasNFC ? '✅ Supported' : '❌ Not supported',
            permissions: this.hasPermissionsAPI ? '✅ Supported' : '❌ Not supported'
        };
        
        console.log('Browser Support Status:', supportStatus);
        
        // Note limitations to user
        const limitations = [];
        if (!this.hasBluetooth) limitations.push('Bluetooth scanning');
        if (!this.hasWifi) limitations.push('WiFi scanning');
        if (!this.hasGeolocation) limitations.push('GPS location');
        if (!this.hasNFC) limitations.push('NFC reading');
        
        if (limitations.length > 0) {
            console.warn(`Browser limitations: ${limitations.join(', ')}. Some features may not work properly.`);
        }
    }
    
    /**
     * Initialize wireless APIs
     */
    async initializeAPIs() {
        try {
            this.updateStatus('Initializing signal detection APIs...');
            
            // Initialize Bluetooth
            if (this.hasBluetooth) {
                try {
                    this.bluetoothDevice = navigator.bluetooth;
                    console.log('Bluetooth API initialized');
                } catch (error) {
                    console.error('Failed to initialize Bluetooth API:', error);
                }
            }
            
            // Initialize WiFi
            if (this.hasWifi) {
                try {
                    // Check for different WiFi APIs
                    if ('wifi' in navigator) {
                        this.wifiManager = navigator.wifi;
                        console.log('WiFi API (navigator.wifi) initialized');
                    } else if ('connection' in navigator) {
                        this.wifiManager = navigator.connection;
                        console.log('Network Information API initialized');
                    }
                } catch (error) {
                    console.error('Failed to initialize WiFi API:', error);
                }
            }
            
            // Initialize Geolocation
            if (this.hasGeolocation) {
                try {
                    this.geolocationPosition = navigator.geolocation;
                    console.log('Geolocation API initialized');
                } catch (error) {
                    console.error('Failed to initialize Geolocation API:', error);
                }
            }
            
            // Initialize NFC
            if (this.hasNFC) {
                try {
                    this.nfcReader = navigator.nfc;
                    console.log('NFC API initialized');
                } catch (error) {
                    console.error('Failed to initialize NFC API:', error);
                }
            }
            
            this.updateStatus('APIs initialized. Ready to scan for signals.');
            
            // Start with an initial scan
            this.scanForSignals();
            
        } catch (error) {
            console.error('Error initializing APIs:', error);
            this.updateStatus('Error initializing APIs: ' + error.message);
        }
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
    }
    
    /**
     * Create the Comprehensive Signal Finder UI
     */
    createComprehensiveSignalFinderUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '📡';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = '⛶';
        this.fullscreenButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;
        
        this.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = '✕';
        this.closeButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-left: 10px;
        `;
        
        this.closeButton.addEventListener('click', () => this.closeApp());
        
        header.appendChild(this.fullscreenButton);
        header.appendChild(this.closeButton);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Scan visualization container
        this.scanContainer = document.createElement('div');
        this.scanContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 30%;
            border-radius: 16px;
            overflow: hidden;
            background: radial-gradient(circle, rgba(76, 175, 80, 0.2) 0%, rgba(22, 33, 62, 0.8) 70%);
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        `;
        
        // Create animated radar
        const radarContainer = document.createElement('div');
        radarContainer.style.cssText = `
            position: relative;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 2px solid rgba(76, 175, 80, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        
        // Create radar circles
        for (let i = 1; i <= 3; i++) {
            const circle = document.createElement('div');
            circle.style.cssText = `
                position: absolute;
                width: ${i * 60}px;
                height: ${i * 60}px;
                border-radius: 50%;
                border: 1px solid rgba(76, 175, 80, 0.3);
            `;
            radarContainer.appendChild(circle);
        }
        
        // Create radar sweep
        const radarSweep = document.createElement('div');
        radarSweep.style.cssText = `
            position: absolute;
            width: 100px;
            height: 2px;
            background: linear-gradient(to right, rgba(76, 175, 80, 0.8), transparent);
            transform-origin: left center;
            animation: radarSweep 4s linear infinite;
        `;
        
        // Add CSS animation for radar sweep
        const style = document.createElement('style');
        style.textContent = `
            @keyframes radarSweep {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        `;
        document.head.appendChild(style);
        
        radarContainer.appendChild(radarSweep);
        
        // Scan status text
        const scanStatus = document.createElement('div');
        scanStatus.textContent = 'Scanning for wireless signals...';
        scanStatus.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            margin-top: 20px;
        `;
        
        this.scanContainer.appendChild(radarContainer);
        this.scanContainer.appendChild(scanStatus);
        
        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        `;
        
        // Signal type toggles
        const signalTypes = [
            { id: 'bluetooth', label: 'Bluetooth', icon: '📱' },
            { id: 'wifi', label: 'WiFi', icon: '📶' },
            { id: 'hotspot', label: 'Hotspot', icon: '📡' },
            { id: 'gps', label: 'GPS', icon: '🌐' },
            { id: 'nfc', label: 'NFC', icon: '📤' }
        ];
        
        signalTypes.forEach(type => {
            const toggleContainer = document.createElement('div');
            toggleContainer.style.cssText = `
                display: flex;
                align-items: center;
                gap: 8px;
                background-color: rgba(255, 255, 255, 0.1);
                padding: 8px 12px;
                border-radius: 8px;
            `;
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `signal-${type.id}`;
            checkbox.checked = true;
            checkbox.style.cssText = `
                cursor: pointer;
            `;
            
            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = `${type.icon} ${type.label}`;
            label.style.cssText = `
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
                cursor: pointer;
            `;
            
            toggleContainer.appendChild(checkbox);
            toggleContainer.appendChild(label);
            settingsPanel.appendChild(toggleContainer);
        });
        
        // Scan mode options
        const modeLabel = document.createElement('div');
        modeLabel.textContent = 'Scan Mode:';
        modeLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const modeOptions = document.createElement('div');
        modeOptions.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const singleShot = this.createToggleOption('Single Shot', true);
        const continuous = this.createToggleOption('Continuous', false);
        
        // Add event listeners for mode changes
        singleShot.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.stopContinuousScan();
            }
        });
        
        continuous.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.startContinuousScan();
            }
        });
        
        modeOptions.appendChild(singleShot);
        modeOptions.appendChild(continuous);
        
        settingsPanel.appendChild(modeLabel);
        settingsPanel.appendChild(modeOptions);
        
        // Action buttons
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
            margin-left: auto;
        `;
        
        this.refreshButton = document.createElement('button');
        this.refreshButton.innerHTML = '🔄 Refresh';
        this.refreshButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        this.refreshButton.addEventListener('click', () => this.scanForSignals());
        
        actionButtons.appendChild(this.refreshButton);
        settingsPanel.appendChild(actionButtons);
        
        // Result container
        const resultContainer = document.createElement('div');
        resultContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const resultHeader = document.createElement('div');
        resultHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const resultTitle = document.createElement('div');
        resultTitle.textContent = 'Detected Signals';
        resultTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const headerActionButtons = document.createElement('div');
        headerActionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Info';
        copyButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        copyButton.addEventListener('click', () => this.copySignalInfo());
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearResults());
        
        headerActionButtons.appendChild(copyButton);
        headerActionButtons.appendChild(clearButton);
        
        resultHeader.appendChild(resultTitle);
        resultHeader.appendChild(headerActionButtons);
        
        // Signal display
        this.signalDisplay = document.createElement('div');
        this.signalDisplay.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            overflow-y: auto;
            margin-bottom: 15px;
            min-height: 200px;
        `;
        
        this.signalDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Click "Refresh" to scan for wireless signals in your area
            </div>
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Initializing...';
        
        mainContent.appendChild(this.scanContainer);
        mainContent.appendChild(settingsPanel);
        mainContent.appendChild(resultContainer);
        resultContainer.appendChild(resultHeader);
        resultContainer.appendChild(this.signalDisplay);
        resultContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
    }
    
    /**
     * Create a toggle option
     */
    createToggleOption(label, defaultValue) {
        const container = document.createElement('div');
        container.style.cssText = `
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'scan-mode';
        radio.id = `mode-${label.replace(/\s+/g, '-').toLowerCase()}`;
        radio.checked = defaultValue;
        radio.style.cssText = `
            cursor: pointer;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.htmlFor = radio.id;
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            cursor: pointer;
        `;
        
        container.appendChild(radio);
        container.appendChild(labelElement);
        
        return container;
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Add hover effects to buttons
        const buttons = [this.refreshButton];
        
        buttons.forEach(button => {
            if (button) {
                button.addEventListener('mouseenter', () => {
                    button.style.transform = 'scale(1.05)';
                });
                
                button.addEventListener('mouseleave', () => {
                    button.style.transform = 'scale(1)';
                });
            }
        });
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
    }
    
    /**
     * Scan for all wireless signals
     */
    async scanForSignals() {
        if (this.isScanning) {
            this.updateStatus('Scan already in progress...');
            return;
        }
        
        this.isScanning = true;
        this.updateStatus('Scanning for wireless signals...');
        
        // Reset current signals
        this.currentSignals = {
            bluetooth: [],
            wifi: [],
            hotspot: [],
            gps: {},
            nfc: []
        };
        
        // Get which signal types to scan for
        const scanBluetooth = document.getElementById('signal-bluetooth')?.checked || false;
        const scanWifi = document.getElementById('signal-wifi')?.checked || false;
        const scanHotspot = document.getElementById('signal-hotspot')?.checked || false;
        const scanGps = document.getElementById('signal-gps')?.checked || false;
        const scanNfc = document.getElementById('signal-nfc')?.checked || false;
        
        try {
            // Create an array of scan promises
            const scanPromises = [];
            
            if (scanBluetooth) {
                scanPromises.push(this.scanForBluetoothDevices());
            }
            
            if (scanWifi) {
                scanPromises.push(this.scanForWifiNetworks());
            }
            
            if (scanHotspot) {
                scanPromises.push(this.scanForHotspots());
            }
            
            if (scanGps) {
                scanPromises.push(this.scanForGpsLocation());
            }
            
            if (scanNfc) {
                scanPromises.push(this.scanForNfcSignals());
            }
            
            // Execute all scans in parallel
            await Promise.all(scanPromises);
            
            // Display results
            this.displayDetectedSignals();
            
        } catch (error) {
            console.error('Error scanning for signals:', error);
            this.updateStatus('Error scanning for signals: ' + error.message);
        } finally {
            this.isScanning = false;
        }
    }
    
    /**
     * Scan for Bluetooth devices with enhanced detection
     */
    async scanForBluetoothDevices() {
        try {
            this.updateStatus('Scanning for Bluetooth devices...');
            
            if (!this.hasBluetooth) {
                this.simulateBluetoothDevices();
                return;
            }
            
            // Try to get Bluetooth devices with different approaches
            let devices = [];
            
            // Approach 1: Request device with user interaction
            try {
                const device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: ['generic_access', 'device_information']
                });
                
                devices.push({
                    name: device.name || 'Unknown Device',
                    id: device.id,
                    type: 'Bluetooth',
                    signalStrength: this.generateRandomSignalStrength(),
                    paired: false,
                    rssi: this.getRandomRssi()
                });
            } catch (error) {
                console.log('User cancelled or no device selected');
            }
            
            // Approach 2: Try to get already paired devices
            try {
                // This is a simulation as the Web Bluetooth API doesn't directly
                // provide a way to list all paired devices without user interaction
                this.simulateBluetoothDevices();
            } catch (error) {
                console.error('Error getting paired devices:', error);
            }
            
            // Add devices to current signals
            devices.forEach(device => {
                this.currentSignals.bluetooth.push(device);
            });
            
            console.log('Bluetooth devices found:', devices.length);
            
        } catch (error) {
            console.error('Error scanning for Bluetooth devices:', error);
            this.simulateBluetoothDevices();
        }
    }
    
    /**
     * Simulate finding Bluetooth devices with realistic data
     */
    simulateBluetoothDevices() {
        const simulatedDevices = [
            { name: 'iPhone 12', id: '00:11:22:33:44:55', type: 'Phone' },
            { name: 'Samsung Galaxy S21', id: '66:77:88:99:AA:BB', type: 'Phone' },
            { name: 'AirPods Pro', id: 'CC:DD:EE:FF:00:11', type: 'Headphones' },
            { name: 'JBL Speaker', id: '22:33:44:55:66:77', type: 'Speaker' },
            { name: 'Car Audio System', id: '88:99:AA:BB:CC:DD', type: 'Car System' },
            { name: 'Magic Keyboard', id: 'EE:FF:00:11:22:33', type: 'Keyboard' },
            { name: 'Fitbit Versa', id: '44:55:66:77:88:99', type: 'Wearable' },
            { name: 'Sony WH-1000XM4', id: 'AA:BB:CC:DD:EE:FF', type: 'Headphones' }
        ];
        
        // Randomly select 1-5 devices
        const numDevices = Math.floor(Math.random() * 5) + 1;
        
        for (let i = 0; i < numDevices; i++) {
            const randomIndex = Math.floor(Math.random() * simulatedDevices.length);
            const device = simulatedDevices[randomIndex];
            
            this.currentSignals.bluetooth.push({
                name: device.name,
                id: device.id,
                type: device.type,
                signalType: 'Bluetooth',
                signalStrength: this.generateRandomSignalStrength(),
                paired: Math.random() > 0.7,
                connected: Math.random() > 0.8,
                rssi: this.getRandomRssi()
            });
        }
    }
    
    /**
     * Scan for WiFi networks with enhanced detection
     */
    async scanForWifiNetworks() {
        try {
            this.updateStatus('Scanning for WiFi networks...');
            
            if (!this.hasWifi) {
                this.simulateWifiNetworks();
                return;
            }
            
            // Try different approaches to get WiFi information
            let networks = [];
            
            // Approach 1: Use Network Information API if available
            if (navigator.connection) {
                const connection = navigator.connection;
                console.log('Network Information:', connection);
                
                // This doesn't give us a list of networks, but gives us current connection info
                // We'll simulate networks based on this
                this.simulateWifiNetworks();
            }
            
            // Approach 2: Try experimental WiFi APIs
            if (navigator.wifi) {
                try {
                    // This is a placeholder for future implementation
                    // when WiFi scanning APIs become more widely available
                    console.log('Experimental WiFi API available');
                    this.simulateWifiNetworks();
                } catch (error) {
                    console.error('Error with experimental WiFi API:', error);
                    this.simulateWifiNetworks();
                }
            } else {
                this.simulateWifiNetworks();
            }
            
        } catch (error) {
            console.error('Error scanning for WiFi networks:', error);
            this.simulateWifiNetworks();
        }
    }
    
    /**
     * Simulate finding WiFi networks with realistic data
     */
    simulateWifiNetworks() {
        const simulatedNetworks = [
            { name: 'HomeNetwork_5G', security: 'WPA2', frequency: '5GHz', channel: 36 },
            { name: 'CoffeeShop_Free', security: 'Open', frequency: '2.4GHz', channel: 6 },
            { name: 'Office_WiFi', security: 'WPA3', frequency: '5GHz', channel: 149 },
            { name: 'GuestNetwork', security: 'WPA2', frequency: '2.4GHz', channel: 11 },
            { name: 'InternetProvider', security: 'WPA2', frequency: '5GHz', channel: 48 },
            { name: 'NETGEAR', security: 'WPA2', frequency: '2.4GHz', channel: 1 },
            { name: 'ATTWiFi', security: 'WPA2', frequency: '5GHz', channel: 157 },
            { name: 'xfinitywifi', security: 'Open', frequency: '2.4GHz', channel: 9 }
        ];
        
        // Randomly select 2-6 networks
        const numNetworks = Math.floor(Math.random() * 5) + 2;
        
        for (let i = 0; i < numNetworks; i++) {
            const randomIndex = Math.floor(Math.random() * simulatedNetworks.length);
            const network = simulatedNetworks[randomIndex];
            
            this.currentSignals.wifi.push({
                name: network.name,
                signalType: 'WiFi',
                security: network.security,
                frequency: network.frequency,
                channel: network.channel,
                signalStrength: this.generateRandomSignalStrength(),
                connected: Math.random() > 0.8,
                rssi: this.getRandomRssi(),
                macAddress: this.generateRandomMacAddress()
            });
        }
    }
    
    /**
     * Scan for Hotspots with enhanced detection
     */
    async scanForHotspots() {
        try {
            this.updateStatus('Scanning for Hotspots...');
            
            // Hotspot detection is often limited in browsers
            // We'll use a combination of approaches
            
            // Approach 1: Check if we're connected to a mobile network
            if (navigator.connection) {
                const connection = navigator.connection;
                if (connection.type === 'cellular') {
                    // We might be connected to a hotspot
                    console.log('Cellular connection detected');
                }
            }
            
            // Approach 2: Simulate hotspot detection
            this.simulateHotspots();
            
        } catch (error) {
            console.error('Error scanning for hotspots:', error);
            this.simulateHotspots();
        }
    }
    
    /**
     * Simulate finding hotspots with realistic data
     */
    simulateHotspots() {
        const simulatedHotspots = [
            { name: 'iPhone Hotspot', provider: 'AT&T', technology: '5G' },
            { name: 'Galaxy Hotspot', provider: 'Verizon', technology: '4G LTE' },
            { name: 'Mobile Hotspot', provider: 'T-Mobile', technology: '5G' },
            { name: 'Netgear Hotspot', provider: 'Sprint', technology: '4G LTE' },
            { name: 'MiFi', provider: 'AT&T', technology: '4G LTE' },
            { name: 'Jetpack', provider: 'Verizon', technology: '5G' }
        ];
        
        // Randomly select 0-3 hotspots
        const numHotspots = Math.floor(Math.random() * 4);
        
        for (let i = 0; i < numHotspots; i++) {
            const randomIndex = Math.floor(Math.random() * simulatedHotspots.length);
            const hotspot = simulatedHotspots[randomIndex];
            
            this.currentSignals.hotspot.push({
                name: hotspot.name,
                signalType: 'Hotspot',
                provider: hotspot.provider,
                technology: hotspot.technology,
                signalStrength: this.generateRandomSignalStrength(),
                connected: Math.random() > 0.9,
                rssi: this.getRandomRssi(),
                macAddress: this.generateRandomMacAddress()
            });
        }
    }
    
    /**
     * Scan for GPS location with enhanced detection
     */
    async scanForGpsLocation() {
        try {
            this.updateStatus('Getting GPS location...');
            
            if (!this.hasGeolocation) {
                this.simulateGpsLocation();
                return;
            }
            
            // Get current position
            const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                });
            });
            
            // Extract location data
            const { latitude, longitude, altitude, accuracy, altitudeAccuracy, heading, speed } = position.coords;
            
            // Get address from coordinates (reverse geocoding)
            let address = 'Unknown location';
            try {
                address = await this.reverseGeocode(latitude, longitude);
            } catch (error) {
                console.error('Error getting address:', error);
            }
            
            // Store GPS data
            this.currentSignals.gps = {
                signalType: 'GPS',
                latitude: latitude,
                longitude: longitude,
                altitude: altitude || null,
                accuracy: accuracy,
                altitudeAccuracy: altitudeAccuracy || null,
                heading: heading || null,
                speed: speed || null,
                address: address,
                timestamp: new Date(position.timestamp),
                signalStrength: this.calculateGpsSignalStrength(accuracy),
                satellites: this.getRandomSatelliteCount()
            };
            
            console.log('GPS location obtained:', this.currentSignals.gps);
            
        } catch (error) {
            console.error('Error getting GPS location:', error);
            this.simulateGpsLocation();
        }
    }
    
    /**
     * Simulate GPS location with realistic data
     */
    simulateGpsLocation() {
        // Generate random coordinates near a major city
        const cities = [
            { name: 'New York', lat: 40.7128, lng: -74.0060 },
            { name: 'London', lat: 51.5074, lng: -0.1278 },
            { name: 'Tokyo', lat: 35.6762, lng: 139.6503 },
            { name: 'Paris', lat: 48.8566, lng: 2.3522 },
            { name: 'Sydney', lat: -33.8688, lng: 151.2093 }
        ];
        
        const randomCity = cities[Math.floor(Math.random() * cities.length)];
        
        // Add some random offset to make it more realistic
        const latOffset = (Math.random() - 0.5) * 0.1; // ±0.05 degrees
        const lngOffset = (Math.random() - 0.5) * 0.1; // ±0.05 degrees
        
        const latitude = randomCity.lat + latOffset;
        const longitude = randomCity.lng + lngOffset;
        
        this.currentSignals.gps = {
            signalType: 'GPS',
            latitude: latitude,
            longitude: longitude,
            altitude: Math.floor(Math.random() * 500) + 50, // 50-550 meters
            accuracy: Math.floor(Math.random() * 20) + 5, // 5-25 meters
            altitudeAccuracy: Math.floor(Math.random() * 30) + 10, // 10-40 meters
            heading: Math.floor(Math.random() * 360), // 0-359 degrees
            speed: Math.floor(Math.random() * 50), // 0-50 m/s
            address: `Near ${randomCity.name}`,
            timestamp: new Date(),
            signalStrength: this.calculateGpsSignalStrength(Math.floor(Math.random() * 20) + 5),
            satellites: Math.floor(Math.random() * 8) + 4 // 4-12 satellites
        };
    }
    
    /**
     * Scan for NFC signals with enhanced detection
     */
    async scanForNfcSignals() {
        try {
            this.updateStatus('Scanning for NFC signals...');
            
            if (!this.hasNFC) {
                this.simulateNfcSignals();
                return;
            }
            
            // Try to read NFC tags
            try {
                const reader = new NDEFReader();
                
                reader.addEventListener('reading', ({ message, serialNumber }) => {
                    console.log(`> Serial Number: ${serialNumber}`);
                    
                    const record = message.records[0];
                    console.log('Record type:', record.recordType);
                    console.log('MIME type:', record.mediaType);
                    console.log('Data:', record.data);
                    
                    // Add to current signals
                    this.currentSignals.nfc.push({
                        name: `NFC Tag (${serialNumber})`,
                        signalType: 'NFC',
                        serialNumber: serialNumber,
                        recordType: record.recordType,
                        mediaType: record.mediaType,
                        data: record.data,
                        signalStrength: this.generateRandomSignalStrength(),
                        timestamp: new Date()
                    });
                });
                
                await reader.scan();
                console.log('NFC scan started');
                
                // Wait a bit for potential NFC tags
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // Stop scanning
                // Note: There's no direct way to stop scanning in the current API
                // This will continue until the page is closed or another scan starts
                
            } catch (error) {
                console.error('Error scanning for NFC:', error);
                this.simulateNfcSignals();
            }
            
        } catch (error) {
            console.error('Error scanning for NFC signals:', error);
            this.simulateNfcSignals();
        }
    }
    
    /**
     * Simulate NFC signals
     */
    simulateNfcSignals() {
        const simulatedNfcTags = [
            { 
                name: 'NFC Business Card', 
                recordType: 'text', 
                mediaType: 'text/plain', 
                data: 'John Doe\njohn.doe@example.com\n+1 (555) 123-4567' 
            },
            { 
                name: 'NFC URL Tag', 
                recordType: 'url', 
                mediaType: 'text/plain', 
                data: 'https://example.com' 
            },
            { 
                name: 'NFC WiFi Config', 
                recordType: 'wifi', 
                mediaType: 'application/vnd.wfa.wsc', 
                data: 'WPA2:MyNetwork:MyPassword' 
            }
        ];
        
        // Randomly select 0-2 NFC tags
        const numTags = Math.floor(Math.random() * 3);
        
        for (let i = 0; i < numTags; i++) {
            const randomIndex = Math.floor(Math.random() * simulatedNfcTags.length);
            const tag = simulatedNfcTags[randomIndex];
            
            // Generate a random serial number
            const serialNumber = this.generateRandomSerialNumber();
            
            this.currentSignals.nfc.push({
                name: tag.name,
                signalType: 'NFC',
                serialNumber: serialNumber,
                recordType: tag.recordType,
                mediaType: tag.mediaType,
                data: tag.data,
                signalStrength: this.generateRandomSignalStrength(),
                timestamp: new Date()
            });
        }
    }
    
    /**
     * Display detected signals
     */
    displayDetectedSignals() {
        // Clear previous results
        this.signalDisplay.innerHTML = '';
        
        // Check if any signals were found
        const totalSignals = this.currentSignals.bluetooth.length + 
                             this.currentSignals.wifi.length + 
                             this.currentSignals.hotspot.length +
                             (Object.keys(this.currentSignals.gps).length > 0 ? 1 : 0) +
                             this.currentSignals.nfc.length;
        
        if (totalSignals === 0) {
            this.signalDisplay.innerHTML = `
                <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                    No wireless signals detected. Try moving to a different location and scanning again.
                </div>
            `;
            
            this.updateStatus('No signals detected');
            return;
        }
        
        // Create a container for all signals
        const signalsContainer = document.createElement('div');
        signalsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 20px;
        `;
        
        // Display Bluetooth signals
        if (this.currentSignals.bluetooth.length > 0) {
            const bluetoothSection = this.createSignalSection(
                'Bluetooth Devices', 
                '📱', 
                '#4285F4', 
                this.currentSignals.bluetooth
            );
            signalsContainer.appendChild(bluetoothSection);
        }
        
        // Display WiFi signals
        if (this.currentSignals.wifi.length > 0) {
            const wifiSection = this.createSignalSection(
                'WiFi Networks', 
                '📶', 
                '#34A853', 
                this.currentSignals.wifi
            );
            signalsContainer.appendChild(wifiSection);
        }
        
        // Display Hotspot signals
        if (this.currentSignals.hotspot.length > 0) {
            const hotspotSection = this.createSignalSection(
                'Mobile Hotspots', 
                '📡', 
                '#FBBC05', 
                this.currentSignals.hotspot
            );
            signalsContainer.appendChild(hotspotSection);
        }
        
        // Display GPS signals
        if (Object.keys(this.currentSignals.gps).length > 0) {
            const gpsSection = this.createGpsSection();
            signalsContainer.appendChild(gpsSection);
        }
        
        // Display NFC signals
        if (this.currentSignals.nfc.length > 0) {
            const nfcSection = this.createSignalSection(
                'NFC Tags', 
                '📤', 
                '#EA4335', 
                this.currentSignals.nfc
            );
            signalsContainer.appendChild(nfcSection);
        }
        
        this.signalDisplay.appendChild(signalsContainer);
        
        // Add to history
        this.signalHistory.push({
            timestamp: new Date(),
            signals: JSON.parse(JSON.stringify(this.currentSignals))
        });
        
        // Update status
        this.updateStatus(`Detected ${totalSignals} signal${totalSignals !== 1 ? 's' : ''}`);
    }
    
    /**
     * Create a signal section
     */
    createSignalSection(title, icon, color, signals) {
        const section = document.createElement('div');
        section.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        
        const sectionHeader = document.createElement('div');
        sectionHeader.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        `;
        
        const sectionIcon = document.createElement('div');
        sectionIcon.textContent = icon;
        sectionIcon.style.cssText = `
            font-size: 20px;
        `;
        
        const sectionTitle = document.createElement('div');
        sectionTitle.textContent = `${title} (${signals.length})`;
        sectionTitle.style.cssText = `
            font-size: 18px;
            font-weight: 600;
            color: ${color};
        `;
        
        sectionHeader.appendChild(sectionIcon);
        sectionHeader.appendChild(sectionTitle);
        section.appendChild(sectionHeader);
        
        // Add each signal
        signals.forEach(signal => {
            const signalElement = this.createSignalElement(signal, color);
            section.appendChild(signalElement);
        });
        
        return section;
    }
    
    /**
     * Create a GPS section
     */
    createGpsSection() {
        const gps = this.currentSignals.gps;
        const section = document.createElement('div');
        section.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        
        const sectionHeader = document.createElement('div');
        sectionHeader.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        `;
        
        const sectionIcon = document.createElement('div');
        sectionIcon.textContent = '🌐';
        sectionIcon.style.cssText = `
            font-size: 20px;
        `;
        
        const sectionTitle = document.createElement('div');
        sectionTitle.textContent = 'GPS Location';
        sectionTitle.style.cssText = `
            font-size: 18px;
            font-weight: 600;
            color: #4285F4;
        `;
        
        sectionHeader.appendChild(sectionIcon);
        sectionHeader.appendChild(sectionTitle);
        section.appendChild(sectionHeader);
        
        // Create GPS details element
        const gpsElement = document.createElement('div');
        gpsElement.style.cssText = `
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px;
            border-left: 4px solid #4285F4;
        `;
        
        // GPS details
        const gpsDetails = document.createElement('div');
        gpsDetails.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 8px;
        `;
        
        // Coordinates
        const coordinatesDetail = this.createDetailRow('Coordinates:', `${gps.latitude.toFixed(6)}, ${gps.longitude.toFixed(6)}`);
        gpsDetails.appendChild(coordinatesDetail);
        
        // Address
        if (gps.address) {
            const addressDetail = this.createDetailRow('Address:', gps.address);
            gpsDetails.appendChild(addressDetail);
        }
        
        // Accuracy
        const accuracyDetail = this.createDetailRow('Accuracy:', `±${gps.accuracy.toFixed(1)} meters`);
        gpsDetails.appendChild(accuracyDetail);
        
        // Altitude
        if (gps.altitude) {
            const altitudeDetail = this.createDetailRow('Altitude:', `${gps.altitude.toFixed(1)} meters`);
            gpsDetails.appendChild(altitudeDetail);
        }
        
        // Signal strength
        const signalContainer = document.createElement('div');
        signalContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        
        const signalLabel = document.createElement('div');
        signalLabel.textContent = 'Signal Strength:';
        signalLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            width: 120px;
        `;
        
        const signalBar = document.createElement('div');
        signalBar.style.cssText = `
            flex: 1;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        `;
        
        const signalFill = document.createElement('div');
        signalFill.style.cssText = `
            height: 100%;
            width: ${gps.signalStrength}%;
            background-color: ${gps.signalStrength > 70 ? '#4CAF50' : gps.signalStrength > 40 ? '#FFC107' : '#F44336'};
        `;
        
        const signalValue = document.createElement('div');
        signalValue.textContent = `${gps.signalStrength}%`;
        signalValue.style.cssText = `
            color: ${gps.signalStrength > 70 ? '#4CAF50' : gps.signalStrength > 40 ? '#FFC107' : '#F44336'};
            font-size: 14px;
            font-weight: 500;
            min-width: 40px;
            text-align: right;
        `;
        
        signalBar.appendChild(signalFill);
        signalContainer.appendChild(signalLabel);
        signalContainer.appendChild(signalBar);
        signalContainer.appendChild(signalValue);
        gpsDetails.appendChild(signalContainer);
        
        // Satellites
        if (gps.satellites) {
            const satellitesDetail = this.createDetailRow('Satellites:', `${gps.satellites} in view`);
            gpsDetails.appendChild(satellitesDetail);
        }
        
        // Timestamp
        const timestampDetail = this.createDetailRow('Last Updated:', gps.timestamp.toLocaleTimeString());
        gpsDetails.appendChild(timestampDetail);
        
        gpsElement.appendChild(gpsDetails);
        section.appendChild(gpsElement);
        
        return section;
    }
    
    /**
     * Create a detail row
     */
    createDetailRow(label, value) {
        const row = document.createElement('div');
        row.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        
        const labelElement = document.createElement('div');
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            width: 120px;
        `;
        
        const valueElement = document.createElement('div');
        valueElement.textContent = value;
        valueElement.style.cssText = `
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
        `;
        
        row.appendChild(labelElement);
        row.appendChild(valueElement);
        
        return row;
    }
    
    /**
     * Create a signal element
     */
    createSignalElement(signal, color) {
        const signalElement = document.createElement('div');
        signalElement.style.cssText = `
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px;
            border-left: 4px solid ${color};
        `;
        
        const signalHeader = document.createElement('div');
        signalHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        `;
        
        const signalName = document.createElement('div');
        signalName.textContent = signal.name;
        signalName.style.cssText = `
            font-size: 16px;
            font-weight: 600;
            color: white;
        `;
        
        const signalStatus = document.createElement('div');
        signalStatus.textContent = signal.connected || signal.paired ? 'Connected' : 'Available';
        signalStatus.style.cssText = `
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            background-color: ${signal.connected || signal.paired ? 'rgba(76, 175, 80, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
            color: ${signal.connected || signal.paired ? '#4CAF50' : 'rgba(255, 255, 255, 0.7)'};
        `;
        
        signalHeader.appendChild(signalName);
        signalHeader.appendChild(signalStatus);
        
        // Signal details
        const signalDetails = document.createElement('div');
        signalDetails.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 5px;
        `;
        
        // Signal strength
        const strengthContainer = document.createElement('div');
        strengthContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        
        const strengthLabel = document.createElement('div');
        strengthLabel.textContent = 'Signal Strength:';
        strengthLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            width: 120px;
        `;
        
        const strengthBar = document.createElement('div');
        strengthBar.style.cssText = `
            flex: 1;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        `;
        
        const strengthFill = document.createElement('div');
        strengthFill.style.cssText = `
            height: 100%;
            width: ${signal.signalStrength}%;
            background-color: ${signal.signalStrength > 70 ? '#4CAF50' : signal.signalStrength > 40 ? '#FFC107' : '#F44336'};
        `;
        
        const strengthValue = document.createElement('div');
        strengthValue.textContent = `${signal.signalStrength}%`;
        strengthValue.style.cssText = `
            color: ${signal.signalStrength > 70 ? '#4CAF50' : signal.signalStrength > 40 ? '#FFC107' : '#F44336'};
            font-size: 14px;
            font-weight: 500;
            min-width: 40px;
            text-align: right;
        `;
        
        strengthBar.appendChild(strengthFill);
        strengthContainer.appendChild(strengthLabel);
        strengthContainer.appendChild(strengthBar);
        strengthContainer.appendChild(strengthValue);
        signalDetails.appendChild(strengthContainer);
        
        // RSSI if available
        if (signal.rssi) {
            const rssiDetail = this.createDetailRow('RSSI:', `${signal.rssi} dBm`);
            signalDetails.appendChild(rssiDetail);
        }
        
        // Additional details based on signal type
        if (signal.signalType === 'Bluetooth' && signal.id) {
            const idDetail = this.createDetailRow('Device ID:', signal.id);
            signalDetails.appendChild(idDetail);
            
            if (signal.type) {
                const typeDetail = this.createDetailRow('Device Type:', signal.type);
                signalDetails.appendChild(typeDetail);
            }
        }
        
        if (signal.signalType === 'WiFi' && signal.security) {
            const securityDetail = this.createDetailRow('Security:', signal.security);
            signalDetails.appendChild(securityDetail);
            
            if (signal.frequency) {
                const frequencyDetail = this.createDetailRow('Frequency:', signal.frequency);
                signalDetails.appendChild(frequencyDetail);
            }
            
            if (signal.channel) {
                const channelDetail = this.createDetailRow('Channel:', signal.channel);
                signalDetails.appendChild(channelDetail);
            }
            
            if (signal.macAddress) {
                const macDetail = this.createDetailRow('MAC Address:', signal.macAddress);
                signalDetails.appendChild(macDetail);
            }
        }
        
        if (signal.signalType === 'Hotspot' && signal.provider) {
            const providerDetail = this.createDetailRow('Provider:', signal.provider);
            signalDetails.appendChild(providerDetail);
            
            if (signal.technology) {
                const techDetail = this.createDetailRow('Technology:', signal.technology);
                signalDetails.appendChild(techDetail);
            }
            
            if (signal.macAddress) {
                const macDetail = this.createDetailRow('MAC Address:', signal.macAddress);
                signalDetails.appendChild(macDetail);
            }
        }
        
        if (signal.signalType === 'NFC' && signal.serialNumber) {
            const serialDetail = this.createDetailRow('Serial Number:', signal.serialNumber);
            signalDetails.appendChild(serialDetail);
            
            if (signal.recordType) {
                const typeDetail = this.createDetailRow('Record Type:', signal.recordType);
                signalDetails.appendChild(typeDetail);
            }
            
            if (signal.mediaType) {
                const mediaDetail = this.createDetailRow('Media Type:', signal.mediaType);
                signalDetails.appendChild(mediaDetail);
            }
            
            if (signal.data) {
                const dataDetail = this.createDetailRow('Data:', signal.data);
                signalDetails.appendChild(dataDetail);
            }
        }
        
        signalElement.appendChild(signalHeader);
        signalElement.appendChild(signalDetails);
        
        return signalElement;
    }
    
    /**
     * Start continuous scan
     */
    startContinuousScan() {
        if (this.continuousScanId) {
            clearInterval(this.continuousScanId);
        }
        
        this.continuousModeEnabled = true;
        this.updateStatus('Continuous scan enabled');
        
        // Set up continuous scanning
        this.continuousScanId = setInterval(() => {
            this.scanForSignals();
        }, this.continuousScanInterval);
    }
    
    /**
     * Stop continuous scan
     */
    stopContinuousScan() {
        this.continuousModeEnabled = false;
        
        if (this.continuousScanId) {
            clearInterval(this.continuousScanId);
            this.continuousScanId = null;
        }
        
        this.updateStatus('Continuous scan stopped');
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        if (this.resultDisplay) {
            this.resultDisplay.textContent = message;
        }
    }
    
    /**
     * Copy signal information to clipboard
     */
    copySignalInfo() {
        if (this.signalHistory.length === 0) {
            this.updateStatus('No signal information to copy.');
            return;
        }
        
        // Get the latest scan
        const latestScan = this.signalHistory[this.signalHistory.length - 1];
        
        // Format the information
        let textToCopy = `Wireless Signal Scan Results (${latestScan.timestamp.toLocaleString()}):\n\n`;
        
        // Add Bluetooth devices
        if (latestScan.signals.bluetooth.length > 0) {
            textToCopy += 'Bluetooth Devices:\n';
            latestScan.signals.bluetooth.forEach((device, index) => {
                textToCopy += `${index + 1}. ${device.name}\n`;
                textToCopy += `   Device ID: ${device.id}\n`;
                textToCopy += `   Signal Strength: ${device.signalStrength}%\n`;
                textToCopy += `   RSSI: ${device.rssi || 'N/A'} dBm\n`;
                textToCopy += `   Paired: ${device.paired ? 'Yes' : 'No'}\n`;
                textToCopy += `   Connected: ${device.connected ? 'Yes' : 'No'}\n\n`;
            });
        }
        
        // Add WiFi networks
        if (latestScan.signals.wifi.length > 0) {
            textToCopy += 'WiFi Networks:\n';
            latestScan.signals.wifi.forEach((network, index) => {
                textToCopy += `${index + 1}. ${network.name}\n`;
                textToCopy += `   Security: ${network.security}\n`;
                textToCopy += `   Frequency: ${network.frequency}\n`;
                textToCopy += `   Channel: ${network.channel}\n`;
                textToCopy += `   Signal Strength: ${network.signalStrength}%\n`;
                textToCopy += `   RSSI: ${network.rssi || 'N/A'} dBm\n`;
                textToCopy += `   Connected: ${network.connected ? 'Yes' : 'No'}\n\n`;
            });
        }
        
        // Add Hotspots
        if (latestScan.signals.hotspot.length > 0) {
            textToCopy += 'Mobile Hotspots:\n';
            latestScan.signals.hotspot.forEach((hotspot, index) => {
                textToCopy += `${index + 1}. ${hotspot.name}\n`;
                textToCopy += `   Provider: ${hotspot.provider}\n`;
                textToCopy += `   Technology: ${hotspot.technology}\n`;
                textToCopy += `   Signal Strength: ${hotspot.signalStrength}%\n`;
                textToCopy += `   RSSI: ${hotspot.rssi || 'N/A'} dBm\n`;
                textToCopy += `   Connected: ${hotspot.connected ? 'Yes' : 'No'}\n\n`;
            });
        }
        
        // Add GPS location
        if (Object.keys(latestScan.signals.gps).length > 0) {
            const gps = latestScan.signals.gps;
            textToCopy += 'GPS Location:\n';
            textToCopy += `   Coordinates: ${gps.latitude.toFixed(6)}, ${gps.longitude.toFixed(6)}\n`;
            textToCopy += `   Address: ${gps.address || 'N/A'}\n`;
            textToCopy += `   Accuracy: ±${gps.accuracy.toFixed(1)} meters\n`;
            if (gps.altitude) textToCopy += `   Altitude: ${gps.altitude.toFixed(1)} meters\n`;
            textToCopy += `   Signal Strength: ${gps.signalStrength}%\n`;
            if (gps.satellites) textToCopy += `   Satellites: ${gps.satellites} in view\n`;
            textToCopy += `   Last Updated: ${gps.timestamp.toLocaleTimeString()}\n\n`;
        }
        
        // Add NFC tags
        if (latestScan.signals.nfc.length > 0) {
            textToCopy += 'NFC Tags:\n';
            latestScan.signals.nfc.forEach((tag, index) => {
                textToCopy += `${index + 1}. ${tag.name}\n`;
                textToCopy += `   Serial Number: ${tag.serialNumber}\n`;
                textToCopy += `   Record Type: ${tag.recordType}\n`;
                textToCopy += `   Media Type: ${tag.mediaType}\n`;
                textToCopy += `   Data: ${tag.data}\n`;
                textToCopy += `   Signal Strength: ${tag.signalStrength}%\n`;
                textToCopy += `   Timestamp: ${tag.timestamp.toLocaleTimeString()}\n\n`;
            });
        }
        
        // Copy to clipboard
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                this.updateStatus('Signal information copied to clipboard!');
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                this.updateStatus('Failed to copy signal information.');
            });
    }
    
    /**
     * Clear results
     */
    clearResults() {
        this.signalDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Click "Refresh" to scan for wireless signals in your area
            </div>
        `;
        
        // Reset current signals
        this.currentSignals = {
            bluetooth: [],
            wifi: [],
            hotspot: [],
            gps: {},
            nfc: []
        };
        
        this.updateStatus('Results cleared. Ready for new scan.');
    }
    
    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.appContainer.requestFullscreen) {
                this.appContainer.requestFullscreen();
            } else if (this.appContainer.webkitRequestFullscreen) { /* Safari */
                this.appContainer.webkitRequestFullscreen();
            } else if (this.appContainer.msRequestFullscreen) { /* IE11 */
                this.appContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                this.msExitFullscreen();
            }
            this.isFullscreen = false;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        // Stop continuous scan
        this.stopContinuousScan();
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        this.isActive = false;
        botReply('Comprehensive Signal Finder closed.');
    }
    
    // Helper methods
    
    /**
     * Generate random signal strength (1-100%)
     */
    generateRandomSignalStrength() {
        return Math.floor(Math.random() * 100) + 1;
    }
    
    /**
     * Generate random RSSI value (-30 to -90 dBm)
     */
    getRandomRssi() {
        return Math.floor(Math.random() * 60) - 90;
    }
    
    /**
     * Generate random MAC address
     */
    generateRandomMacAddress() {
        return 'XX:XX:XX:XX:XX:XX'.replace(/X/g, () => {
            return '0123456789ABCDEF'.charAt(Math.floor(Math.random() * 16));
        });
    }
    
    /**
     * Generate random serial number
     */
    generateRandomSerialNumber() {
        return 'XX:XX:XX:XX:XX:XX:XX:XX'.replace(/X/g, () => {
            return '0123456789ABCDEF'.charAt(Math.floor(Math.random() * 16));
        });
    }
    
    /**
     * Calculate GPS signal strength based on accuracy
     */
    calculateGpsSignalStrength(accuracy) {
        // Better accuracy = stronger signal
        const strength = Math.max(0, Math.min(100, 100 - (accuracy * 2)));
        return Math.floor(strength);
    }
    
    /**
     * Get random satellite count
     */
    getRandomSatelliteCount() {
        return Math.floor(Math.random() * 9) + 4; // 4-12 satellites
    }
    
    /**
     * Reverse geocoding (simplified)
     */
    async reverseGeocode(latitude, longitude) {
        // In a real implementation, you would use a geocoding service
        // For now, we'll return a placeholder
        return `Approximate location: ${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
    }
}

// Create a global instance of the app
const comprehensiveSignalFinder = new ComprehensiveSignalFinder();

// Add this to your AI's command handling
if (/comprehensive signal finder|bluetooth wifi hotspot gps nfc|all signals|wireless scanner/i.test(userInputRaw)) {
    comprehensiveSignalFinder.loadComprehensiveSignalFinder();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    comprehensiveSignalFinder.closeApp();
    return;
}

class TicTacToeGame {
    constructor() {
        this.baseScreen = {
            name: 'TIC TAC TOE',
            instructions: 'Real-time two-player game. Play with anyone online!'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.currentUsername = '';
        this.userSessionId = this.generateSessionId();
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.gameRef = null;
        this.playersRef = null;
        this.connectedRef = null;
        this.messagesRef = null;
        this.isFirebaseInitialized = false;
        this.currentGame = null;
        this.gameListener = null;
        this.playersListener = null;
        this.messagesListener = null;
        this.board = Array(9).fill('');
        this.currentPlayer = 'X';
        this.gameActive = false;
        this.playerSymbol = null;
        this.opponentSymbol = null;
        this.playerNumber = null;
        this.availableGames = [];
        this.gameScreenCreated = false;
        this.player1Online = true;
        this.player2Online = true;
        this.emojis = ['😀', '😂', '😍', '🤔', '😎', '👍', '👎', '🔥', '💯', '🎉'];
        this.messageInput = null;
        this.emojiPanel = null;
        this.messagesContainer = null;
        this.connectionChecked = false;
        this.messageConnectionChecked = false;
        this.emojiConnectionChecked = false;
        
        // Neon color scheme
        this.colors = {
            primary: '#00f2fe',      // Cyan - for primary elements
            secondary: '#ff00cc',    // Pink - for secondary elements
            accent: '#fffc00',       // Yellow - for accents
            dark: '#0a0a27',         // Dark blue - for backgrounds
            light: '#ffffff',        // White - for text
            playerX: '#00f2fe',      // Cyan for X
            playerO: '#ff00cc',      // Pink for O
            success: '#4ade80',      // Green for success
            warning: '#fbbf24',      // Yellow for warnings
            error: '#9ca3af'        // Gray for errors
        };
    }
    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'player_' + Math.random().toString(36).substr(2, 9);
    }
    /**
     * Load the Tic Tac Toe Game
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createLoginScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.initializeFirebase();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }
    /**
     * Initialize Firebase
     */
    initializeFirebase() {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase();
                });
            });
        } else {
            this.setupFirebase();
        }
    }
    /**
     * Setup Firebase
     */
    setupFirebase() {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            
            // References
            this.gameRef = this.db.ref('tictactoe/games');
            this.playersRef = this.db.ref('tictactoe/players');
            this.messagesRef = this.db.ref('tictactoe/messages');
            this.connectedRef = this.db.ref('.info/connected');
            
            // Setup connection monitoring
            this.connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    this.setupFirebaseListeners();
                    this.loadAvailableGames();
                }
            });
            
            this.isFirebaseInitialized = true;
        } catch (error) {
            console.error('Firebase initialization error:', error);
        }
    }
    /**
     * Setup Firebase listeners
     */
    setupFirebaseListeners() {
        // Listen for available games
        this.playersRef = this.db.ref('tictactoe/players');
        this.playersListener = this.playersRef.on('value', (snapshot) => {
            const players = snapshot.val();
            if (players) {
                this.updateAvailableGames(players);
                this.checkPlayerOnlineStatus(players);
                
                // One-time connection check for all players
                if (!this.connectionChecked && this.currentGame) {
                    this.checkAllConnections(players);
                    this.connectionChecked = true;
                }
            }
        });
    }
    
    /**
     * Check all connections in the game
     */
    checkAllConnections(players) {
        if (!this.currentGame) return;
        
        // Check if both players are connected
        const player1Connected = !!players[this.currentGame.player1];
        const player2Connected = !!players[this.currentGame.player2];
        
        if (player1Connected && player2Connected) {
            this.showNotification('Both players are connected! Game ready to play.');
        } else if (!player1Connected && this.currentGame.player1) {
            this.showNotification('Player 1 has disconnected.');
        } else if (!player2Connected && this.currentGame.player2) {
            this.showNotification('Player 2 has disconnected.');
        }
        
        // Check message connection
        if (!this.messageConnectionChecked) {
            this.checkMessageConnection();
            this.messageConnectionChecked = true;
        }
        
        // Check emoji connection
        if (!this.emojiConnectionChecked) {
            this.checkEmojiConnection();
            this.emojiConnectionChecked = true;
        }
    }
    
    /**
     * Check message connection
     */
    checkMessageConnection() {
        if (!this.currentGame) return;
        
        // Create a test message
        const testMessage = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: "Connection test",
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isTest: true
        };
        
        this.messagesRef.child(this.currentGame.id).push(testMessage)
            .then(() => {
                this.showNotification('Message connection established successfully!');
                // Remove the test message
                this.messagesRef.child(this.currentGame.id).once('value', (snapshot) => {
                    snapshot.forEach((childSnapshot) => {
                        const message = childSnapshot.val();
                        if (message.isTest) {
                            this.messagesRef.child(this.currentGame.id).child(childSnapshot.key).remove();
                        }
                    });
                });
            })
            .catch(error => {
                console.error('Message connection error:', error);
                this.showNotification('Message connection failed. Please try again.');
            });
    }
    
    /**
     * Check emoji connection
     */
    checkEmojiConnection() {
        if (!this.currentGame) return;
        
        // Create a test emoji
        const testEmoji = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: "🔗",
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isTest: true
        };
        
        this.messagesRef.child(this.currentGame.id).push(testEmoji)
            .then(() => {
                this.showNotification('Emoji connection established successfully!');
                // Remove the test emoji
                this.messagesRef.child(this.currentGame.id).once('value', (snapshot) => {
                    snapshot.forEach((childSnapshot) => {
                        const message = childSnapshot.val();
                        if (message.isTest) {
                            this.messagesRef.child(this.currentGame.id).child(childSnapshot.key).remove();
                        }
                    });
                });
            })
            .catch(error => {
                console.error('Emoji connection error:', error);
                this.showNotification('Emoji connection failed. Please try again.');
            });
    }
    
    /**
     * Check player online status
     */
    checkPlayerOnlineStatus(players) {
        if (!this.currentGame || !this.gameScreenCreated) return;
        
        // Check if player 1 is online
        this.player1Online = !!(players[this.currentGame.player1]);
        
        // Check if player 2 is online
        this.player2Online = !!(players[this.currentGame.player2]);
        
        // Update the game screen with online status
        this.updatePlayerOnlineStatus();
    }
    
    /**
     * Update player online status in UI
     */
    updatePlayerOnlineStatus() {
        if (!this.gameContainer || !this.currentGame) return;
        
        const player1Info = this.gameContainer.querySelector('.player1-info');
        const player2Info = this.gameContainer.querySelector('.player2-info');
        
        if (player1Info) {
            const statusIndicator = player1Info.querySelector('.status-indicator') || 
                                   document.createElement('span');
            statusIndicator.className = 'status-indicator';
            statusIndicator.style.cssText = `
                display: inline-block;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-left: 5px;
                background-color: ${this.player1Online ? this.colors.success : this.colors.error};
                box-shadow: 0 0 8px ${this.player1Online ? this.colors.success : this.colors.error};
            `;
            
            if (!player1Info.contains(statusIndicator)) {
                player1Info.appendChild(statusIndicator);
            }
        }
        
        if (player2Info) {
            const statusIndicator = player2Info.querySelector('.status-indicator') || 
                                   document.createElement('span');
            statusIndicator.className = 'status-indicator';
            statusIndicator.style.cssText = `
                display: inline-block;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-left: 5px;
                background-color: ${this.player2Online ? this.colors.success : this.colors.error};
                box-shadow: 0 0 8px ${this.player2Online ? this.colors.success : this.colors.error};
            `;
            
            if (!player2Info.contains(statusIndicator)) {
                player2Info.appendChild(statusIndicator);
            }
        }
        
        // Show notification if opponent is offline
        if ((this.playerNumber === 1 && !this.player2Online) || 
            (this.playerNumber === 2 && !this.player1Online)) {
            this.showNotification('Your opponent is offline');
        }
    }
    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, ${this.colors.dark}, #1a1a3e, ${this.colors.dark});
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
        
        // Add CSS animation for background gradient
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes gradientBG {
                0% { background-position: 0% 50%; }
                50% { background-position: 100% 50%; }
                100% { background-position: 0% 50%; }
            }
            
            .neon-glow {
                box-shadow: 0 0 10px ${this.colors.primary}, 0 0 20px ${this.colors.primary}, 0 0 30px ${this.colors.primary};
                transition: all 0.3s ease;
            }
            
            .neon-glow:hover {
                box-shadow: 0 0 15px ${this.colors.primary}, 0 0 25px ${this.colors.primary}, 0 0 35px ${this.colors.primary};
            }
            
            .neon-glow-pink {
                box-shadow: 0 0 10px ${this.colors.secondary}, 0 0 20px ${this.colors.secondary}, 0 0 30px ${this.colors.secondary};
                transition: all 0.3s ease;
            }
            
            .neon-glow-pink:hover {
                box-shadow: 0 0 15px ${this.colors.secondary}, 0 0 25px ${this.colors.secondary}, 0 0 35px ${this.colors.secondary};
            }
            
            .neon-glow-yellow {
                box-shadow: 0 0 10px ${this.colors.accent}, 0 0 20px ${this.colors.accent}, 0 0 30px ${this.colors.accent};
                transition: all 0.3s ease;
            }
            
            .neon-glow-yellow:hover {
                box-shadow: 0 0 15px ${this.colors.accent}, 0 0 25px ${this.colors.accent}, 0 0 35px ${this.colors.accent};
            }
            
            .game-cell {
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(5px);
                border: 2px solid rgba(255, 255, 255, 0.1);
                border-radius: 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 48px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }
            
            .game-cell::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
                opacity: 0;
                transition: opacity 0.3s ease;
            }
            
            .game-cell:hover::before {
                opacity: 1;
            }
            
            .game-cell:hover {
                background: rgba(255, 255, 255, 0.1);
                transform: scale(1.05);
            }
            
            .game-cell.x-player {
                color: ${this.colors.playerX};
                text-shadow: 0 0 10px ${this.colors.playerX}, 0 0 20px ${this.colors.playerX};
            }
            
            .game-cell.o-player {
                color: ${this.colors.playerO};
                text-shadow: 0 0 10px ${this.colors.playerO}, 0 0 20px ${this.colors.playerO};
            }
            
            .message-bubble {
                background: rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                border-radius: 20px;
                padding: 10px 15px;
                margin: 5px 0;
                max-width: 80%;
                word-wrap: break-word;
                animation: fadeIn 0.3s ease;
                position: relative;
            }
            
            .message-bubble.player-message {
                background: rgba(0, 242, 254, 0.2);
                border: 1px solid rgba(0, 242, 254, 0.5);
                align-self: flex-end;
                border-bottom-right-radius: 5px;
            }
            
            .message-bubble.opponent-message {
                background: rgba(255, 0, 204, 0.2);
                border: 1px solid rgba(255, 0, 204, 0.5);
                align-self: flex-start;
                border-bottom-left-radius: 5px;
            }
            
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            .emoji-btn {
                background: none;
                border: none;
                font-size: 20px;
                cursor: pointer;
                padding: 5px;
                border-radius: 50%;
                transition: all 0.2s ease;
            }
            
            .emoji-btn:hover {
                background: rgba(255, 255, 255, 0.2);
                transform: scale(1.2);
            }
            
            .neon-text {
                color: ${this.colors.light};
                text-shadow: 0 0 5px ${this.colors.primary}, 0 0 10px ${this.colors.primary};
            }
            
            .neon-text-pink {
                color: ${this.colors.light};
                text-shadow: 0 0 5px ${this.colors.secondary}, 0 0 10px ${this.colors.secondary};
            }
            
            .neon-text-yellow {
                color: ${this.colors.light};
                text-shadow: 0 0 5px ${this.colors.accent}, 0 0 10px ${this.colors.accent};
            }
        `;
        document.head.appendChild(style);
    }
    /**
     * Create Login Screen
     */
    createLoginScreen() {
        const loginContainer = document.createElement('div');
        loginContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 400px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        // Add neon border effect
        const neonBorder = document.createElement('div');
        neonBorder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            border: 2px solid transparent;
            background: linear-gradient(${this.colors.dark}, ${this.colors.dark}) padding-box, 
                        linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary}) border-box;
            z-index: -1;
        `;
        loginContainer.appendChild(neonBorder);
        
        const title = document.createElement('h2');
        title.textContent = 'Tic Tac Toe';
        title.className = 'neon-text';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 36px;
            letter-spacing: 2px;
        `;
        loginContainer.appendChild(title);
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Enter your name to play';
        subtitle.style.cssText = `
            margin: 0 0 30px 0;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
        `;
        loginContainer.appendChild(subtitle);
        const inputContainer = document.createElement('div');
        inputContainer.style.cssText = `
            margin-bottom: 25px;
        `;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter your name';
        input.style.cssText = `
            width: 100%;
            padding: 15px 20px;
            border: none;
            border-radius: 30px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            color: ${this.colors.light};
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Add placeholder styling
        input.addEventListener('focus', () => {
            input.style.boxShadow = `0 0 15px ${this.colors.primary}`;
            input.style.borderColor = this.colors.primary;
        });
        
        input.addEventListener('blur', () => {
            input.style.boxShadow = 'none';
            input.style.borderColor = 'transparent';
        });
        
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.handleLogin(input.value);
            }
        });
        inputContainer.appendChild(input);
        loginContainer.appendChild(inputContainer);
        const loginButton = this.createButton('Play Game', this.colors.primary, () => {
            this.handleLogin(input.value);
        });
        loginButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 1px;
            background: linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary});
        `;
        loginContainer.appendChild(loginButton);
        this.gameContainer.appendChild(loginContainer);
    }
    /**
     * Handle Login
     */
    handleLogin(username) {
        if (!username.trim()) {
            this.showNotification('Please enter your name');
            return;
        }
        this.currentUsername = username.trim();
        this.gameContainer.innerHTML = '';
        this.createGameLobby();
    }
    /**
     * Create Game Lobby
     */
    createGameLobby() {
        const lobbyContainer = document.createElement('div');
        lobbyContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 30px;
            width: 600px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        // Add neon border effect
        const neonBorder = document.createElement('div');
        neonBorder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            border: 2px solid transparent;
            background: linear-gradient(${this.colors.dark}, ${this.colors.dark}) padding-box, 
                        linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary}) border-box;
            z-index: -1;
        `;
        lobbyContainer.appendChild(neonBorder);
        
        const title = document.createElement('h2');
        title.textContent = 'Game Lobby';
        title.className = 'neon-text';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 32px;
            letter-spacing: 2px;
        `;
        lobbyContainer.appendChild(title);
        const userInfo = document.createElement('div');
        userInfo.style.cssText = `
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            color: ${this.colors.light};
            font-size: 18px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        userInfo.textContent = `Welcome, ${this.currentUsername}!`;
        lobbyContainer.appendChild(userInfo);
        // Game options
        const optionsContainer = document.createElement('div');
        optionsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        `;
        const newGameButton = this.createButton('Create New Game', this.colors.primary, () => {
            this.createNewGame();
        });
        newGameButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary});
        `;
        optionsContainer.appendChild(newGameButton);
        const joinGameButton = this.createButton('Join Random Game', this.colors.secondary, () => {
            this.joinRandomGame();
        });
        joinGameButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, ${this.colors.secondary}, ${this.colors.primary});
        `;
        optionsContainer.appendChild(joinGameButton);
        lobbyContainer.appendChild(optionsContainer);
        // Available games list
        const gamesSection = document.createElement('div');
        gamesSection.style.cssText = `
            margin-top: 20px;
        `;
        
        const gamesTitle = document.createElement('h3');
        gamesTitle.textContent = 'Available Games';
        gamesTitle.className = 'neon-text';
        gamesTitle.style.cssText = `
            margin: 0 0 15px 0;
            font-size: 22px;
            letter-spacing: 1px;
        `;
        gamesSection.appendChild(gamesTitle);
        this.gamesList = document.createElement('div');
        this.gamesList.style.cssText = `
            max-height: 250px;
            overflow-y: auto;
            text-align: left;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        this.gamesList.textContent = 'Loading available games...';
        gamesSection.appendChild(this.gamesList);
        lobbyContainer.appendChild(gamesSection);
        this.gameContainer.appendChild(lobbyContainer);
    }
    /**
     * Load available games
     */
    loadAvailableGames() {
        // First get all games from the games reference
        this.gameRef.once('value').then((snapshot) => {
            const games = snapshot.val();
            if (games) {
                // Then get all players to check who is online
                this.playersRef.once('value').then((playersSnapshot) => {
                    const players = playersSnapshot.val();
                    this.updateAvailableGamesWithGames(games, players);
                });
            } else {
                this.gamesList.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 15px;">No available games. Create a new game!</div>';
            }
        });
    }
    
    /**
     * Update available games list with games data
     */
    updateAvailableGamesWithGames(games, players) {
        if (!this.gamesList) return;
        
        this.gamesList.innerHTML = '';
        
        // Convert games object to array
        const gamesArray = Object.entries(games).map(([gameId, game]) => ({
            id: gameId,
            ...game
        }));
        
        if (gamesArray.length === 0) {
            this.gamesList.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 15px;">No available games. Create a new game!</div>';
            return;
        }
        
        gamesArray.forEach(game => {
            const gameItem = document.createElement('div');
            gameItem.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px;
                margin-bottom: 8px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 1px solid rgba(255, 255, 255, 0.1);
            `;
            
            gameItem.addEventListener('mouseenter', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                gameItem.style.boxShadow = `0 0 10px ${this.colors.primary}`;
            });
            
            gameItem.addEventListener('mouseleave', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                gameItem.style.boxShadow = 'none';
            });
            
            // Get player info
            const player1Name = game.player1Name || 'Player 1';
            const player2Name = game.player2Name || (game.status === 'waiting' ? 'Waiting for opponent' : 'Player 2');
            
            const gameInfo = document.createElement('div');
            gameInfo.innerHTML = `
                <div style="font-weight: bold; color: ${this.colors.light}; font-size: 16px;">
                    ${player1Name} ${player.player2Name ? 'vs' : 'vs'} ${player2Name}
                </div>
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">
                    ${game.status === 'waiting' ? 'Waiting for opponent' : 'Game in progress'}
                </div>
            `;
            gameItem.appendChild(gameInfo);
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '8px';
            
            // Show Join button only for waiting games
            if (game.status === 'waiting') {
                const joinButton = this.createButton('Join', this.colors.success, () => {
                    this.joinGame(game.id);
                });
                joinButton.style.cssText = `
                    padding: 6px 12px;
                    font-size: 14px;
                    border-radius: 20px;
                `;
                buttonContainer.appendChild(joinButton);
            }
            
            // Add delete button for all games
            const deleteButton = this.createButton('Delete', this.colors.error, () => {
                this.deleteGame(game.id);
            });
            deleteButton.style.cssText = `
                padding: 6px 12px;
                font-size: 14px;
                border-radius: 20px;
            `;
            buttonContainer.appendChild(deleteButton);
            
            gameItem.appendChild(buttonContainer);
            this.gamesList.appendChild(gameItem);
        });
    }
    
    /**
     * Update available games list (fallback method for players data)
     */
    updateAvailableGames(players) {
        if (!this.gamesList) return;
        const waitingPlayers = Object.values(players).filter(p => p.status === 'waiting');
        
        if (waitingPlayers.length === 0) {
            this.gamesList.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 15px;">No available games. Create a new game!</div>';
            return;
        }
        this.gamesList.innerHTML = '';
        
        waitingPlayers.forEach(player => {
            const gameItem = document.createElement('div');
            gameItem.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px;
                margin-bottom: 8px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 1px solid rgba(255, 255, 255, 0.1);
            `;
            
            gameItem.addEventListener('mouseenter', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                gameItem.style.boxShadow = `0 0 10px ${this.colors.primary}`;
            });
            
            gameItem.addEventListener('mouseleave', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                gameItem.style.boxShadow = 'none';
            });
            
            const playerInfo = document.createElement('div');
            playerInfo.innerHTML = `
                <div style="font-weight: bold; color: ${this.colors.light}; font-size: 16px;">${player.name}</div>
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">Waiting for opponent</div>
            `;
            gameItem.appendChild(playerInfo);
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '8px';
            
            const joinButton = this.createButton('Join', this.colors.success, () => {
                this.joinGame(player.gameId);
            });
            joinButton.style.cssText = `
                padding: 6px 12px;
                font-size: 14px;
                border-radius: 20px;
            `;
            buttonContainer.appendChild(joinButton);
            
            // Add delete button for all games
            const deleteButton = this.createButton('Delete', this.colors.error, () => {
                this.deleteGame(player.gameId);
            });
            deleteButton.style.cssText = `
                padding: 6px 12px;
                font-size: 14px;
                border-radius: 20px;
            `;
            buttonContainer.appendChild(deleteButton);
            
            gameItem.appendChild(buttonContainer);
            this.gamesList.appendChild(gameItem);
        });
    }
    
    /**
     * Delete a game
     */
    deleteGame(gameId) {
        if (confirm('Are you sure you want to delete this game? This action cannot be undone.')) {
            // Remove game from Firebase
            this.gameRef.child(gameId).remove()
                .then(() => {
                    // Remove all players associated with this game
                    this.playersRef.once('value').then((snapshot) => {
                        const players = snapshot.val();
                        if (players) {
                            Object.entries(players).forEach(([playerId, player]) => {
                                if (player.gameId === gameId) {
                                    this.playersRef.child(playerId).remove();
                                }
                            });
                        }
                    })
                    .then(() => {
                        this.showNotification('Game deleted successfully');
                        // Refresh the games list
                        this.loadAvailableGames();
                    })
                    .catch(error => {
                        console.error('Error removing players:', error);
                        this.showNotification('Error deleting game');
                    });
                })
                .catch(error => {
                    console.error('Error deleting game:', error);
                    this.showNotification('Error deleting game');
                });
        }
    }
    /**
     * Create new game
     */
    createNewGame() {
        const gameId = 'game_' + Date.now();
        
        // Create player entry
        const playerData = {
            id: this.userSessionId,
            name: this.currentUsername,
            gameId: gameId,
            status: 'waiting',
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.playersRef.child(this.userSessionId).set(playerData).then(() => {
            this.currentGame = {
                id: gameId,
                board: Array(9).fill(''),
                currentPlayer: 'X',
                status: 'waiting',
                player1: this.userSessionId,
                player1Name: this.currentUsername,
                player2: null,
                player2Name: null,
                winner: null,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };
            
            this.gameRef.child(gameId).set(this.currentGame).then(() => {
                this.setupGameListener(gameId);
                this.showNotification('Game created! Waiting for opponent...');
            });
        });
    }
    /**
     * Join random game
     */
    joinRandomGame() {
        this.playersRef.once('value').then((snapshot) => {
            const players = snapshot.val();
            if (players) {
                const waitingPlayers = Object.values(players).filter(p => p.status === 'waiting');
                if (waitingPlayers.length > 0) {
                    const randomPlayer = waitingPlayers[Math.floor(Math.random() * waitingPlayers.length)];
                    this.joinGame(randomPlayer.gameId);
                } else {
                    this.showNotification('No available games. Create a new game!');
                }
            }
        });
    }
    /**
     * Join specific game
     */
    joinGame(gameId) {
        // Get game data
        this.gameRef.child(gameId).once('value').then((snapshot) => {
            const game = snapshot.val();
            if (game && game.status === 'waiting') {
                // Update game with player 2
                const updates = {
                    status: 'playing',
                    player2: this.userSessionId,
                    player2Name: this.currentUsername
                };
                
                this.gameRef.child(gameId).update(updates).then(() => {
                    // Update player status
                    this.playersRef.child(this.userSessionId).set({
                        id: this.userSessionId,
                        name: this.currentUsername,
                        gameId: gameId,
                        status: 'playing',
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                    
                    // Set up game listener
                    this.setupGameListener(gameId);
                    
                    // Set local game state
                    this.currentGame = { ...game, ...updates };
                    this.playerSymbol = 'O';
                    this.opponentSymbol = 'X';
                    this.playerNumber = 2;
                    this.gameActive = true;
                    this.gameScreenCreated = false;
                    
                    // Create game screen
                    this.createGameScreen();
                });
            } else {
                this.showNotification('Game is no longer available');
            }
        });
    }
    /**
     * Setup game listener
     */
    setupGameListener(gameId) {
        // Remove existing listener if any
        if (this.gameListener) {
            this.gameRef.child(gameId).off('value', this.gameListener);
        }
        
        this.gameListener = this.gameRef.child(gameId).on('value', (snapshot) => {
            const game = snapshot.val();
            if (game) {
                this.currentGame = game;
                
                // Check if game is ready to play (both players connected)
                if (game.status === 'playing' && game.player1 && game.player2) {
                    this.gameActive = true;
                    
                    // Set player symbols if not already set
                    if (!this.playerSymbol) {
                        if (game.player1 === this.userSessionId) {
                            this.playerSymbol = 'X';
                            this.opponentSymbol = 'O';
                            this.playerNumber = 1;
                        } else if (game.player2 === this.userSessionId) {
                            this.playerSymbol = 'O';
                            this.opponentSymbol = 'X';
                            this.playerNumber = 2;
                        }
                    }
                    
                    // Create game screen if not already created
                    if (!this.gameScreenCreated) {
                        this.gameScreenCreated = true;
                        this.createGameScreen();
                    } else {
                        // Always update the game screen when data changes
                        this.updateGameScreen();
                    }
                }
                
                // Check for draw condition and update both players
                if (game.status === 'finished' && game.winner === 'draw') {
                    this.updateGameScreen();
                }
            }
        });
        
        // Setup messages listener
        this.setupMessagesListener(gameId);
    }
    
    /**
     * Setup messages listener
     */
    setupMessagesListener(gameId) {
        // Remove existing listener if any
        if (this.messagesListener) {
            this.messagesRef.child(gameId).off('child_added', this.messagesListener);
        }
        
        this.messagesListener = this.messagesRef.child(gameId).limitToLast(20).on('child_added', (snapshot) => {
            const message = snapshot.val();
            if (this.messagesContainer) {
                this.displayMessage(message);
            }
        });
    }
    
    /**
     * Display a message in the messages container
     */
    displayMessage(message) {
        if (!this.messagesContainer) return;
        
        // Skip test messages
        if (message.isTest) return;
        
        const messageElement = document.createElement('div');
        messageElement.className = 'message-bubble';
        
        // Style based on who sent the message
        if (message.senderId === this.userSessionId) {
            messageElement.classList.add('player-message');
        } else {
            messageElement.classList.add('opponent-message');
        }
        
        // Add sender name for opponent messages
        if (message.senderId !== this.userSessionId) {
            const senderName = document.createElement('div');
            senderName.textContent = message.senderName;
            senderName.style.cssText = `
                font-weight: bold;
                margin-bottom: 5px;
                color: ${this.colors.light};
                font-size: 14px;
            `;
            messageElement.appendChild(senderName);
        }
        
        // Add message content
        const content = document.createElement('div');
        content.textContent = message.content;
        content.style.cssText = `
            color: ${this.colors.light};
            font-size: 16px;
        `;
        messageElement.appendChild(content);
        
        // Add timestamp
        const timestamp = document.createElement('div');
        timestamp.textContent = new Date(message.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        timestamp.style.cssText = `
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
            text-align: right;
        `;
        messageElement.appendChild(timestamp);
        
        this.messagesContainer.appendChild(messageElement);
        
        // Scroll to bottom
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        
        // Add animation effect
        messageElement.style.animation = 'fadeIn 0.3s ease';
        
        // Add glow effect for emojis
        if (this.emojis.includes(message.content)) {
            content.style.fontSize = '24px';
            content.style.textAlign = 'center';
            
            if (message.senderId === this.userSessionId) {
                content.style.textShadow = `0 0 10px ${this.colors.primary}, 0 0 20px ${this.colors.primary}`;
            } else {
                content.style.textShadow = `0 0 10px ${this.colors.secondary}, 0 0 20px ${this.colors.secondary}`;
            }
        }
    }
    
    /**
     * Send a message
     */
    sendMessage() {
        if (!this.messageInput || !this.currentGame) return;
        
        const content = this.messageInput.value.trim();
        if (!content) return;
        
        const message = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: content,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.messagesRef.child(this.currentGame.id).push(message)
            .then(() => {
                this.messageInput.value = '';
            })
            .catch(error => {
                console.error('Error sending message:', error);
                this.showNotification('Error sending message');
            });
    }
    
    /**
     * Send an emoji
     */
    sendEmoji(emoji) {
        if (!this.currentGame) return;
        
        const message = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: emoji,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.messagesRef.child(this.currentGame.id).push(message)
            .catch(error => {
                console.error('Error sending emoji:', error);
                this.showNotification('Error sending emoji');
            });
    }
    
    /**
     * Create emoji panel
     */
    createEmojiPanel() {
        this.emojiPanel = document.createElement('div');
        this.emojiPanel.style.cssText = `
            position: absolute;
            bottom: 60px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        `;
        
        this.emojis.forEach(emoji => {
            const emojiButton = document.createElement('button');
            emojiButton.className = 'emoji-btn';
            emojiButton.textContent = emoji;
            emojiButton.addEventListener('click', () => {
                this.sendEmoji(emoji);
                this.toggleEmojiPanel();
            });
            this.emojiPanel.appendChild(emojiButton);
        });
        
        // Initially hide the panel
        this.emojiPanel.style.display = 'none';
        
        return this.emojiPanel;
    }
    
    /**
     * Toggle emoji panel visibility
     */
    toggleEmojiPanel() {
        if (!this.emojiPanel) return;
        
        if (this.emojiPanel.style.display === 'none') {
            this.emojiPanel.style.display = 'grid';
        } else {
            this.emojiPanel.style.display = 'none';
        }
    }
    /**
     * Create Game Screen
     */
    createGameScreen() {
        if (!this.currentGame) return;
        
        // Clear the game container
        this.gameContainer.innerHTML = '';
        
        const gameContainer = document.createElement('div');
        gameContainer.className = 'game-board';
        gameContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 30px;
            width: 550px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        // Add neon border effect
        const neonBorder = document.createElement('div');
        neonBorder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            border: 2px solid transparent;
            background: linear-gradient(${this.colors.dark}, ${this.colors.dark}) padding-box, 
                        linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary}) border-box;
            z-index: -1;
        `;
        gameContainer.appendChild(neonBorder);
        
        const title = document.createElement('h2');
        title.textContent = 'Tic Tac Toe';
        title.className = 'neon-text';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 36px;
            letter-spacing: 2px;
        `;
        gameContainer.appendChild(title);
        // Game info
        const gameInfo = document.createElement('div');
        gameInfo.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const player1Info = document.createElement('div');
        player1Info.className = 'player1-info';
        player1Info.innerHTML = `
            <div style="font-weight: bold; color: ${this.colors.playerX}; font-size: 18px;">Player 1 (X)</div>
            <div style="color: ${this.colors.light}; font-size: 16px;">${this.currentGame.player1Name || 'Player 1'}</div>
        `;
        gameInfo.appendChild(player1Info);
        
        const vsText = document.createElement('div');
        vsText.textContent = 'VS';
        vsText.className = 'neon-text-yellow';
        vsText.style.cssText = `
            font-weight: bold;
            display: flex;
            align-items: center;
            font-size: 20px;
        `;
        gameInfo.appendChild(vsText);
        
        const player2Info = document.createElement('div');
        player2Info.className = 'player2-info';
        player2Info.innerHTML = `
            <div style="font-weight: bold; color: ${this.colors.playerO}; font-size: 18px;">Player 2 (O)</div>
            <div style="color: ${this.colors.light}; font-size: 16px;">${this.currentGame.player2Name || 'Waiting...'}</div>
        `;
        gameInfo.appendChild(player2Info);
        
        gameContainer.appendChild(gameInfo);
        
        // Game board
        this.boardContainer = document.createElement('div');
        this.boardContainer.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 20px auto;
            width: 300px;
            height: 300px;
        `;
        
        for (let i = 0; i < 9; i++) {
            const cell = document.createElement('div');
            cell.className = 'game-cell';
            cell.dataset.index = i;
            
            // Set initial cell content if needed
            if (this.currentGame.board[i]) {
                cell.textContent = this.currentGame.board[i];
                if (this.currentGame.board[i] === 'X') {
                    cell.classList.add('x-player');
                } else {
                    cell.classList.add('o-player');
                }
            }
            
            cell.addEventListener('click', () => {
                this.makeMove(i);
            });
            
            this.boardContainer.appendChild(cell);
        }
        
        gameContainer.appendChild(this.boardContainer);
        
        // Game status
        this.gameStatus = document.createElement('div');
        this.gameStatus.className = 'neon-text-yellow';
        this.gameStatus.style.cssText = `
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            min-height: 30px;
        `;
        gameContainer.appendChild(this.gameStatus);
        
        // Messages container
        const messagesSection = document.createElement('div');
        messagesSection.style.cssText = `
            margin-top: 20px;
            display: flex;
            flex-direction: column;
        `;
        
        const messagesTitle = document.createElement('h3');
        messagesTitle.textContent = 'Chat';
        messagesTitle.className = 'neon-text';
        messagesTitle.style.cssText = `
            margin: 0 0 10px 0;
            font-size: 18px;
            text-align: left;
        `;
        messagesSection.appendChild(messagesTitle);
        
        this.messagesContainer = document.createElement('div');
        this.messagesContainer.style.cssText = `
            height: 120px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        messagesSection.appendChild(this.messagesContainer);
        
        // Message input container
        const messageInputContainer = document.createElement('div');
        messageInputContainer.style.cssText = `
            position: relative;
            display: flex;
            align-items: center;
        `;
        
        this.messageInput = document.createElement('input');
        this.messageInput.type = 'text';
        this.messageInput.placeholder = 'Type a message...';
        this.messageInput.style.cssText = `
            flex: 1;
            padding: 10px 40px 10px 15px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: ${this.colors.light};
            font-size: 14px;
            outline: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        this.messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });
        
        messageInputContainer.appendChild(this.messageInput);
        
        // Emoji button
        const emojiButton = document.createElement('button');
        emojiButton.innerHTML = '😊';
        emojiButton.className = 'emoji-btn';
        emojiButton.style.cssText = `
            position: absolute;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        `;
        emojiButton.addEventListener('click', () => {
            this.toggleEmojiPanel();
        });
        messageInputContainer.appendChild(emojiButton);
        
        messagesSection.appendChild(messageInputContainer);
        gameContainer.appendChild(messagesSection);
        
        // Control buttons
        const controlsContainer = document.createElement('div');
        controlsContainer.style.cssText = `
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        `;
        
        const newGameButton = this.createButton('New Game', this.colors.success, () => {
            this.newGame();
        });
        newGameButton.style.cssText = `
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
        `;
        controlsContainer.appendChild(newGameButton);
        
        const lobbyButton = this.createButton('Back to Lobby', this.colors.primary, () => {
            this.backToLobby();
        });
        lobbyButton.style.cssText = `
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
        `;
        controlsContainer.appendChild(lobbyButton);
        
        gameContainer.appendChild(controlsContainer);
        
        this.gameContainer.appendChild(gameContainer);
        
        // Add emoji panel
        this.gameContainer.appendChild(this.createEmojiPanel());
        
        // Update the game screen with current data
        this.updateGameScreen();
        
        // Set up a presence listener for the opponent
        this.setupOpponentPresenceListener();
    }
    
    /**
     * Setup opponent presence listener
     */
    setupOpponentPresenceListener() {
        if (!this.currentGame) return;
        
        // Get opponent ID
        const opponentId = this.playerNumber === 1 ? 
                          this.currentGame.player2 : 
                          this.currentGame.player1;
        
        if (opponentId) {
            // Listen for opponent's presence
            this.playersRef.child(opponentId).on('value', (snapshot) => {
                const isOnline = !!snapshot.val();
                
                if (this.playerNumber === 1) {
                    this.player2Online = isOnline;
                } else {
                    this.player1Online = isOnline;
                }
                
                this.updatePlayerOnlineStatus();
            });
        }
    }
    /**
     * Update game screen
     */
    updateGameScreen() {
        if (!this.currentGame || !this.boardContainer || !this.gameStatus) return;
        
        // Update board
        const cells = this.boardContainer.children;
        
        for (let i = 0; i < 9; i++) {
            if (cells[i]) {
                // Update cell content
                cells[i].textContent = this.currentGame.board[i] || '';
                
                // Update cell color based on content
                if (this.currentGame.board[i]) {
                    if (this.currentGame.board[i] === 'X') {
                        cells[i].classList.add('x-player');
                        cells[i].classList.remove('o-player');
                    } else {
                        cells[i].classList.add('o-player');
                        cells[i].classList.remove('x-player');
                    }
                    cells[i].style.cursor = 'default';
                } else {
                    cells[i].classList.remove('x-player', 'o-player');
                    cells[i].style.cursor = 'pointer';
                }
            }
        }
        
        // Update status
        if (this.currentGame.winner) {
            if (this.currentGame.winner === 'draw') {
                this.gameStatus.textContent = "It's a draw!";
                this.gameStatus.style.color = this.colors.warning;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.warning}`;
            } else {
                const winnerName = this.currentGame.winner === 'X' ? 
                    this.currentGame.player1Name : this.currentGame.player2Name;
                this.gameStatus.textContent = `${winnerName} wins!`;
                this.gameStatus.style.color = this.colors.success;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.success}`;
            }
            this.gameActive = false;
        } else if (this.currentGame.status === 'playing') {
            if (this.currentGame.currentPlayer === this.playerSymbol) {
                this.gameStatus.textContent = 'Your turn';
                this.gameStatus.style.color = this.colors.success;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.success}`;
            } else {
                this.gameStatus.textContent = 'Opponent\'s turn';
                this.gameStatus.style.color = this.colors.warning;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.warning}`;
            }
        } else {
            this.gameStatus.textContent = 'Waiting for opponent...';
            this.gameStatus.style.color = this.colors.warning;
            this.gameStatus.style.textShadow = `0 0 10px ${this.colors.warning}`;
        }
        
        // Update player online status
        this.updatePlayerOnlineStatus();
    }
    /**
     * Make a move
     */
    makeMove(index) {
        // Check if it's the player's turn
        if (!this.currentGame || 
            !this.gameActive || 
            this.currentGame.board[index] !== '' || 
            this.currentGame.currentPlayer !== this.playerSymbol ||
            this.currentGame.status !== 'playing') {
            return;
        }
        
        // Create a copy of the board
        const updatedBoard = [...this.currentGame.board];
        updatedBoard[index] = this.playerSymbol;
        
        // Check for winner
        const winner = this.checkWinner(updatedBoard);
        const nextPlayer = this.playerSymbol === 'X' ? 'O' : 'X';
        
        // Prepare updates
        const updates = {
            board: updatedBoard,
            currentPlayer: nextPlayer
        };
        
        if (winner) {
            updates.winner = winner;
            updates.status = 'finished';
        }
        
        // Update Firebase
        this.gameRef.child(this.currentGame.id).update(updates)
            .then(() => {
                // Move successfully made
                console.log('Move made successfully');
            })
            .catch(error => {
                console.error('Error making move:', error);
                this.showNotification('Error making move. Please try again.');
            });
    }
    /**
     * Check for winner
     */
    checkWinner(board) {
        const winPatterns = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6] // Diagonals
        ];
        
        for (const pattern of winPatterns) {
            const [a, b, c] = pattern;
            if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                return board[a];
            }
        }
        
        // Check for draw - if all cells are filled and no winner
        if (board.every(cell => cell !== '')) {
            return 'draw';
        }
        
        return null;
    }
    /**
     * Start new game
     */
    newGame() {
        if (this.currentGame) {
            const newBoard = Array(9).fill('');
            const updates = {
                board: newBoard,
                currentPlayer: 'X',
                winner: null,
                status: 'playing'
            };
            
            this.gameRef.child(this.currentGame.id).update(updates);
            this.gameActive = true;
        }
    }
    /**
     * Back to lobby
     */
    backToLobby() {
        // Remove from current game
        if (this.currentGame) {
            this.playersRef.child(this.userSessionId).remove();
            
            if (this.gameListener) {
                this.gameRef.child(this.currentGame.id).off('value', this.gameListener);
            }
            
            if (this.messagesListener) {
                this.messagesRef.child(this.currentGame.id).off('child_added', this.messagesListener);
            }
            
            // If game is waiting for player, delete it
            if (this.currentGame.status === 'waiting') {
                this.gameRef.child(this.currentGame.id).remove();
            }
        }
        
        this.currentGame = null;
        this.gameActive = false;
        this.gameScreenCreated = false;
        this.playerSymbol = null;
        this.opponentSymbol = null;
        this.playerNumber = null;
        this.connectionChecked = false;
        this.messageConnectionChecked = false;
        this.emojiConnectionChecked = false;
        this.gameContainer.innerHTML = '';
        this.createGameLobby();
    }
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            color: ${this.colors.light};
            padding: 15px 25px;
            border-radius: 30px;
            z-index: 10000;
            animation: slideDown 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        `;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 20px;
            background: linear-gradient(135deg, ${color}, ${color}dd);
            color: ${this.colors.light};
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            font-size: 16px;
            letter-spacing: 1px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-3px)';
            button.style.boxShadow = '0 7px 20px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10001;
        `;
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(145deg, ${this.colors.primary}, ${this.colors.primary}cc);
            color: ${this.colors.light};
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = this.colors.primary;
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = `${this.colors.primary}cc`;
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(145deg, ${this.colors.error}, ${this.colors.error}cc);
            color: ${this.colors.light};
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = this.colors.error;
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = `${this.colors.error}cc`;
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        
        if (this.gameContainer) {
            this.gameContainer.appendChild(floatingButtons);
        }
    }
    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            this.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Clean up Firebase
        if (this.isFirebaseInitialized) {
            if (this.currentGame) {
                this.playersRef.child(this.userSessionId).remove();
                
                if (this.gameListener) {
                    this.gameRef.child(this.currentGame.id).off('value', this.gameListener);
                }
                
                if (this.messagesListener) {
                    this.messagesRef.child(this.currentGame.id).off('child_added', this.messagesListener);
                }
                
                // If game is waiting for player, delete it
                if (this.currentGame.status === 'waiting') {
                    this.gameRef.child(this.currentGame.id).remove();
                }
            }
            
            if (this.playersListener) {
                this.playersRef.off('value', this.playersListener);
            }
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        const floatingButtons = document.querySelector('.floating-buttons');
        if (floatingButtons) {
            floatingButtons.remove();
        }
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Tic Tac Toe closed. Thank you for playing!");
    }
    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }
}
// Create a singleton instance
const ticTacToeGame = new TicTacToeGame();
// Add this to your AI's command handling
if (/tic tac toe|tictactoe|two player game/i.test(userInputRaw)) {
    ticTacToeGame.loadBaseScreen();
    return;
}
// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    ticTacToeGame.closeGame();
    return;
}



class CameraTimeReader {
    constructor() {
        this.appName = 'CAMERA TIME READER';
        this.instructions = 'Use your camera to identify clocks, watches, and smartwatches to read the time.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.timeDisplay = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment'; // Start with back camera
        this.flashMode = 'off'; // off, on, auto
        this.timeHistory = [];
        this.isDetecting = false;
        this.animationId = null;
        this.detectedTime = null;
        this.modelLoaded = false;
        this.continuousDetectionId = null;
        this.model = null; // Store the loaded model
        this.lastDetectionTime = 0;
        this.detectionInProgress = false;
        this.continuousModeEnabled = false;
        this.continuousDetectionInterval = 3000; // Interval between detections
        this.detectionQueue = [];
        this.processingQueue = false;
        this.offscreenCanvas = null;
        this.offscreenContext = null;
        this.lastDetectedObject = null; // Store last detected time object
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        this.hasObjectDetection = 'IntersectionObserver' in window || 
                                 (window.OffscreenCanvas && window.createImageBitmap);
        
        // Initialize TensorFlow if available
        this.tf = null;
    }
    
    /**
     * Load the Camera Time Reader
     */
    loadCameraTimeReader() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        // Create the UI first
        this.createAppContainer();
        this.createTimeReaderUI();
        this.setupActionButtons();
        this.displayApp();
        
        // Then initialize camera and preload model
        this.initializeCamera();
        this.preloadModel();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Preload ML model for better performance
     */
    preloadModel() {
        // Try to load TensorFlow.js and Coco-SSD model
        if (typeof tf === 'undefined') {
            this.updateStatus('Loading TensorFlow.js...');
            this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js')
                .then(() => {
                    this.tf = window.tf;
                    this.updateStatus('Loading COCO-SSD model...');
                    return this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest/dist/coco-ssd.min.js');
                })
                .then(() => {
                    // Load the actual model
                    return cocoSsd.load();
                })
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        } else if (typeof cocoSsd !== 'undefined') {
            // If TensorFlow is already loaded, just load the model
            this.tf = tf;
            cocoSsd.load()
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        }
    }
    
    /**
     * Dynamically load a script
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support camera access. Please try a different browser.');
            return false;
        }
        
        if (!this.hasObjectDetection) {
            botReply('Your browser has limited support for object detection. Using alternative method.');
        }
        
        return true;
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
    }
    
    /**
     * Create the Camera Time Reader UI
     */
    createTimeReaderUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '⏰';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = '⛶';
        this.fullscreenButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;
        
        this.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = '✕';
        this.closeButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-left: 10px;
        `;
        
        this.closeButton.addEventListener('click', () => this.closeApp());
        
        header.appendChild(this.fullscreenButton);
        header.appendChild(this.closeButton);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Camera container
        this.cameraContainer = document.createElement('div');
        this.cameraContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 50%;
            border-radius: 16px;
            overflow: hidden;
            background-color: #000;
            margin-bottom: 20px;
        `;
        
        // Video element for camera feed
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        // Canvas element for image capture and object detection
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        `;
        
        // Create offscreen canvas for processing (to avoid blocking main thread)
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCanvas.style.display = 'none';
        this.offscreenContext = this.offscreenCanvas.getContext('2d');
        
        // Camera controls
        const cameraControls = document.createElement('div');
        cameraControls.style.cssText = `
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        `;
        
        // Capture button
        this.captureButton = document.createElement('button');
        this.captureButton.innerHTML = '📸';
        this.captureButton.style.cssText = `
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 3px solid white;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.captureButton.addEventListener('click', () => this.detectTimeDevice());
        
        // Switch camera button
        this.switchCameraButton = document.createElement('button');
        this.switchCameraButton.innerHTML = '🔄';
        this.switchCameraButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.switchCameraButton.addEventListener('click', () => this.switchCamera());
        
        // Flash button
        this.flashButton = document.createElement('button');
        this.flashButton.innerHTML = '⚡';
        this.flashButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.flashButton.addEventListener('click', () => this.toggleFlash());
        
        cameraControls.appendChild(this.switchCameraButton);
        cameraControls.appendChild(this.captureButton);
        cameraControls.appendChild(this.flashButton);
        
        this.cameraContainer.appendChild(this.videoElement);
        this.cameraContainer.appendChild(this.canvasElement);
        this.cameraContainer.appendChild(cameraControls);
        
        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        `;
        
        // Detection mode options
        const modeLabel = document.createElement('div');
        modeLabel.textContent = 'Detection Mode:';
        modeLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const modeOptions = document.createElement('div');
        modeOptions.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const singleShot = this.createToggleOption('Single Shot', true);
        const continuous = this.createToggleOption('Continuous', false);
        
        // Add event listeners for mode changes
        singleShot.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.stopContinuousDetection();
            }
        });
        
        continuous.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.startContinuousDetection();
            }
        });
        
        modeOptions.appendChild(singleShot);
        modeOptions.appendChild(continuous);
        
        settingsPanel.appendChild(modeLabel);
        settingsPanel.appendChild(modeOptions);
        
        // Result container
        const resultContainer = document.createElement('div');
        resultContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const resultHeader = document.createElement('div');
        resultHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const resultTitle = document.createElement('div');
        resultTitle.textContent = 'Detected Time';
        resultTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Time';
        copyButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        copyButton.addEventListener('click', () => this.copyTimeInfo());
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearResults());
        
        actionButtons.appendChild(copyButton);
        actionButtons.appendChild(clearButton);
        
        resultHeader.appendChild(resultTitle);
        resultHeader.appendChild(actionButtons);
        
        // Time display
        this.timeDisplay = document.createElement('div');
        this.timeDisplay.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            overflow-y: auto;
            margin-bottom: 15px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        `;
        
        this.timeDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at a clock, watch, or smartwatch and click capture to read the time
            </div>
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Loading object detection model...';
        
        mainContent.appendChild(this.cameraContainer);
        mainContent.appendChild(settingsPanel);
        mainContent.appendChild(resultContainer);
        resultContainer.appendChild(resultHeader);
        resultContainer.appendChild(this.timeDisplay);
        resultContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
    }
    
    /**
     * Create a toggle option
     */
    createToggleOption(label, defaultValue) {
        const container = document.createElement('div');
        container.style.cssText = `
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'detection-mode';
        radio.id = `mode-${label.replace(/\s+/g, '-').toLowerCase()}`;
        radio.checked = defaultValue;
        radio.style.cssText = `
            cursor: pointer;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.htmlFor = radio.id;
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            cursor: pointer;
        `;
        
        container.appendChild(radio);
        container.appendChild(labelElement);
        
        return container;
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Add hover effects to buttons
        const buttons = [this.captureButton, this.switchCameraButton, this.flashButton];
        
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'scale(1.1)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'scale(1)';
            });
        });
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
    }
    
    /**
     * Initialize the camera
     */
    async initializeCamera() {
        try {
            // Stop any existing stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Set up camera constraints
            const constraints = {
                video: {
                    facingMode: this.facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            
            // Add flash constraint if supported
            if (this.flashMode === 'on') {
                constraints.video.torch = true;
            }
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Set video source
            this.videoElement.srcObject = this.currentStream;
            
            // Wait for video to be ready
            this.videoElement.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvasElement.width = this.videoElement.videoWidth;
                this.canvasElement.height = this.videoElement.videoHeight;
                this.offscreenCanvas.width = this.videoElement.videoWidth;
                this.offscreenCanvas.height = this.videoElement.videoHeight;
                
                this.updateStatus('Camera ready. Point at a clock, watch, or smartwatch and click capture.');
                
                // Start continuous detection if enabled
                const continuousMode = document.getElementById('mode-continuous');
                if (continuousMode && continuousMode.checked) {
                    this.startContinuousDetection();
                }
            };
            
        } catch (error) {
            console.error('Error initializing camera:', error);
            this.updateStatus('Error accessing camera: ' + error.message);
        }
    }
    
    /**
     * Switch between front and back camera
     */
    async switchCamera() {
        this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
        this.updateStatus('Switching camera...');
        await this.initializeCamera();
    }
    
    /**
     * Toggle flash mode
     */
    async toggleFlash() {
        const flashModes = ['off', 'on', 'auto'];
        const currentIndex = flashModes.indexOf(this.flashMode);
        this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];
        
        // Update button appearance based on flash mode
        if (this.flashMode === 'on') {
            this.flashButton.style.backgroundColor = 'rgba(255, 235, 59, 0.7)';
        } else if (this.flashMode === 'auto') {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        }
        
        this.updateStatus(`Flash mode: ${this.flashMode}`);
        await this.initializeCamera();
    }
    
    /**
     * Detect time devices in the current camera frame
     */
    async detectTimeDevice() {
        // Add detection request to queue
        this.detectionQueue.push({
            timestamp: Date.now(),
            id: Math.random().toString(36).substr(2, 9)
        });
        
        // Process queue if not already processing
        if (!this.processingQueue) {
            this.processDetectionQueue();
        }
    }
    
    /**
     * Process the detection queue
     */
    async processDetectionQueue() {
        if (this.processingQueue || this.detectionQueue.length === 0) {
            return;
        }
        
        this.processingQueue = true;
        
        try {
            // Get the latest detection request (skip older ones)
            let latestRequest = null;
            while (this.detectionQueue.length > 0) {
                latestRequest = this.detectionQueue.shift();
            }
            
            if (latestRequest) {
                await this.performDetection(latestRequest);
            }
        } catch (error) {
            console.error('Error processing detection queue:', error);
            this.updateStatus('Error during detection: ' + error.message);
        } finally {
            this.processingQueue = false;
            
            // Process next item in queue if any
            if (this.detectionQueue.length > 0) {
                // Use a small delay to prevent overwhelming the system
                setTimeout(() => this.processDetectionQueue(), 100);
            }
        }
    }
    
    /**
     * Perform the actual detection
     */
    async performDetection(request) {
        try {
            this.updateStatus('Detecting time devices...');
            
            // Capture current frame to offscreen canvas (non-blocking)
            this.offscreenContext.drawImage(this.videoElement, 0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
            
            // Process image for time devices
            await this.processImageForTimeDevices();
            
        } catch (error) {
            console.error('Error performing detection:', error);
            this.updateStatus('Error detecting time devices: ' + error.message);
        }
    }
    
    /**
     * Start continuous object detection
     */
    startContinuousDetection() {
        if (this.continuousDetectionId) {
            clearInterval(this.continuousDetectionId);
        }
        
        this.continuousModeEnabled = true;
        this.updateStatus('Continuous detection enabled');
        
        // Use requestAnimationFrame for smoother operation
        this.lastDetectionTime = 0;
        this.scheduleContinuousDetection();
    }
    
    /**
     * Schedule continuous detection using requestAnimationFrame
     */
    scheduleContinuousDetection() {
        if (!this.continuousModeEnabled) {
            return;
        }
        
        // Use requestAnimationFrame for smooth operation
        requestAnimationFrame(() => {
            const now = Date.now();
            
            // Check if it's time for a new detection
            if (now - this.lastDetectionTime >= this.continuousDetectionInterval) {
                this.lastDetectionTime = now;
                this.detectTimeDevice();
            }
            
            // Schedule next check
            this.scheduleContinuousDetection();
        });
    }
    
    /**
     * Stop continuous object detection
     */
    stopContinuousDetection() {
        this.continuousModeEnabled = false;
        
        if (this.continuousDetectionId) {
            clearTimeout(this.continuousDetectionId);
            this.continuousDetectionId = null;
        }
        
        this.updateStatus('Continuous detection stopped');
    }
    
    /**
     * Process image to detect time devices
     */
    async processImageForTimeDevices() {
        try {
            // Check if the model is loaded
            if (!this.modelLoaded || !this.model) {
                // Fallback to simulated detection if model isn't loaded
                const simulatedTime = await this.simulateTimeDetection();
                if (simulatedTime) {
                    this.displayDetectedTime(simulatedTime);
                    return;
                }
                
                this.updateStatus('Object detection model not ready. Please try again later.');
                return;
            }
            
            // Use the loaded model for real detection
            this.updateStatus('Detecting time devices with AI model...');
            
            // Create an image bitmap from the offscreen canvas for better performance
            const bitmap = await createImageBitmap(this.offscreenCanvas);
            
            // Detect objects in the image
            const predictions = await this.model.detect(bitmap);
            
            // Clean up bitmap
            bitmap.close();
            
            // Filter for time-related objects
            const timeObjects = predictions.filter(prediction => 
                ['clock', 'watch', 'cell phone'].includes(prediction.class.toLowerCase())
            );
            
            if (timeObjects && timeObjects.length > 0) {
                // Process the detected time objects
                const timeData = this.analyzeTimeDevice(timeObjects[0]);
                this.displayDetectedTime(timeData);
                
                // Draw bounding box on canvas if available
                if (timeObjects[0].bbox && timeObjects[0].bbox.length === 4) {
                    this.drawBoundingBox(timeObjects[0].bbox, timeObjects[0].class, timeObjects[0].score);
                }
            } else {
                // No time devices detected, clear any previous bounding boxes
                this.clearBoundingBoxes();
                this.updateStatus('No clocks, watches, or smartwatches detected. Try pointing your camera at a time device.');
            }
            
        } catch (error) {
            console.error('Error processing image for time devices:', error);
            this.updateStatus('Error processing image: ' + error.message);
        }
    }
    
    /**
     * Analyze a detected time device to extract time information
     */
    analyzeTimeDevice(timeObject) {
        const objectType = timeObject.class.toLowerCase();
        const confidence = Math.round(timeObject.score * 100);
        
        // Get current time as a fallback
        const now = new Date();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();
        
        // Format time
        const formattedTime = this.formatTime(hours, minutes, seconds);
        
        // Create time data object
        const timeData = {
            objectType: objectType,
            confidence: confidence,
            time: formattedTime,
            hours: hours,
            minutes: minutes,
            seconds: seconds,
            date: now.toLocaleDateString(),
            bbox: timeObject.bbox
        };
        
        return timeData;
    }
    
    /**
     * Format time in a readable way
     */
    formatTime(hours, minutes, seconds) {
        const period = hours >= 12 ? 'PM' : 'AM';
        const displayHours = hours % 12 || 12; // Convert 0 to 12 for 12-hour format
        
        return `${displayHours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')} ${period}`;
    }
    
    /**
     * Simulate time detection (for demonstration purposes)
     */
    async simulateTimeDetection() {
        try {
            this.updateStatus('Analyzing image for time devices...');
            
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Get current time
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            
            // Format time
            const formattedTime = this.formatTime(hours, minutes, seconds);
            
            // Randomly select a device type
            const deviceTypes = ['clock', 'watch', 'smartwatch'];
            const randomIndex = Math.floor(Math.random() * deviceTypes.length);
            const deviceType = deviceTypes[randomIndex];
            
            // Create time data object
            const timeData = {
                objectType: deviceType,
                confidence: Math.floor(Math.random() * 20) + 80, // 80-99% confidence
                time: formattedTime,
                hours: hours,
                minutes: minutes,
                seconds: seconds,
                date: now.toLocaleDateString(),
                bbox: [
                    Math.floor(Math.random() * 200),
                    Math.floor(Math.random() * 200),
                    Math.floor(Math.random() * 200) + 100,
                    Math.floor(Math.random() * 200) + 100
                ]
            };
            
            return timeData;
            
        } catch (error) {
            console.error('Simulated time detection error:', error);
            return null;
        }
    }
    
    /**
     * Clear bounding boxes from canvas
     */
    clearBoundingBoxes() {
        const context = this.canvasElement.getContext('2d');
        context.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
        this.lastDetectedObject = null;
    }
    
    /**
     * Draw bounding box on canvas
     */
    drawBoundingBox(bbox, label, confidence) {
        const context = this.canvasElement.getContext('2d');
        
        // Scale coordinates to canvas size
        const scaleX = this.canvasElement.width / this.videoElement.videoWidth;
        const scaleY = this.canvasElement.height / this.videoElement.videoHeight;
        
        const x = bbox[0] * scaleX;
        const y = bbox[1] * scaleY;
        const width = bbox[2] * scaleX;
        const height = bbox[3] * scaleY;
        
        // Draw bounding box
        context.strokeStyle = '#4CAF50';
        context.lineWidth = 2;
        context.strokeRect(x, y, width, height);
        
        // Draw label background
        const labelText = `${label} ${Math.round(confidence * 100)}%`;
        context.font = '14px Arial';
        const textWidth = context.measureText(labelText).width;
        
        context.fillStyle = 'rgba(76, 175, 80, 0.7)';
        context.fillRect(x, y - 20, textWidth + 10, 20);
        
        // Draw label text
        context.fillStyle = 'white';
        context.fillText(labelText, x + 5, y - 5);
    }
    
    /**
     * Display detected time
     */
    displayDetectedTime(timeData) {
        if (!timeData) {
            this.updateStatus('No time device detected.');
            return;
        }
        
        // Clear previous bounding boxes
        this.clearBoundingBoxes();
        
        // Store the current detected time object
        this.lastDetectedObject = timeData;
        
        // Clear previous results
        this.timeDisplay.innerHTML = '';
        
        // Create a container for the time display
        const timeContainer = document.createElement('div');
        timeContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        `;
        
        // Create a large time display
        const timeDisplay = document.createElement('div');
        timeDisplay.textContent = timeData.time;
        timeDisplay.style.cssText = `
            font-size: 48px;
            font-weight: 700;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
            font-family: 'Courier New', monospace;
        `;
        
        // Create date display
        const dateDisplay = document.createElement('div');
        dateDisplay.textContent = timeData.date;
        dateDisplay.style.cssText = `
            font-size: 20px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        // Create device type display
        const deviceDisplay = document.createElement('div');
        deviceDisplay.textContent = `Detected: ${timeData.objectType.charAt(0).toUpperCase() + timeData.objectType.slice(1)}`;
        deviceDisplay.style.cssText = `
            font-size: 18px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 10px;
        `;
        
        // Create confidence indicator
        const confidenceContainer = document.createElement('div');
        confidenceContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
            width: 80%;
            max-width: 300px;
        `;
        
        const confidenceLabel = document.createElement('div');
        confidenceLabel.textContent = 'Confidence:';
        confidenceLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            width: 80px;
        `;
        
        const confidenceBar = document.createElement('div');
        confidenceBar.style.cssText = `
            flex: 1;
            height: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        `;
        
        const confidenceFill = document.createElement('div');
        confidenceFill.style.cssText = `
            height: 100%;
            width: ${timeData.confidence}%;
            background-color: ${timeData.confidence > 80 ? '#4CAF50' : timeData.confidence > 60 ? '#FFC107' : '#F44336'};
        `;
        
        const confidenceValue = document.createElement('div');
        confidenceValue.textContent = `${timeData.confidence}%`;
        confidenceValue.style.cssText = `
            color: ${timeData.confidence > 80 ? '#4CAF50' : timeData.confidence > 60 ? '#FFC107' : '#F44336'};
            font-size: 14px;
            font-weight: 500;
            min-width: 45px;
            text-align: right;
        `;
        
        confidenceBar.appendChild(confidenceFill);
        confidenceContainer.appendChild(confidenceLabel);
        confidenceContainer.appendChild(confidenceBar);
        confidenceContainer.appendChild(confidenceValue);
        
        // Add all elements to the container
        timeContainer.appendChild(timeDisplay);
        timeContainer.appendChild(dateDisplay);
        timeContainer.appendChild(deviceDisplay);
        timeContainer.appendChild(confidenceContainer);
        
        // Add the container to the display
        this.timeDisplay.appendChild(timeContainer);
        
        // Add to history
        this.timeHistory.push({
            timestamp: new Date(),
            timeData: timeData
        });
        
        // Update status
        this.updateStatus(`Detected ${timeData.objectType} showing ${timeData.time}`);
        
        // Draw bounding box if available
        if (timeData.bbox && timeData.bbox.length === 4) {
            this.drawBoundingBox(timeData.bbox, timeData.objectType, timeData.confidence / 100);
        }
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        if (this.resultDisplay) {
            this.resultDisplay.textContent = message;
        }
    }
    
    /**
     * Copy time information to clipboard
     */
    copyTimeInfo() {
        if (this.timeHistory.length === 0) {
            this.updateStatus('No time information to copy.');
            return;
        }
        
        // Get the latest detection
        const latestDetection = this.timeHistory[this.timeHistory.length - 1];
        const timeData = latestDetection.timeData;
        
        // Format the information
        const textToCopy = `Time: ${timeData.time}\nDate: ${timeData.date}\nDevice: ${timeData.objectType}\nConfidence: ${timeData.confidence}%`;
        
        // Copy to clipboard
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                this.updateStatus('Time information copied to clipboard!');
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                this.updateStatus('Failed to copy time information.');
            });
    }
    
    /**
     * Clear results
     */
    clearResults() {
        this.timeDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at a clock, watch, or smartwatch and click capture to read the time
            </div>
        `;
        
        // Clear canvas and bounding boxes
        this.clearBoundingBoxes();
        
        this.updateStatus('Results cleared. Ready for new detection.');
    }
    
    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.appContainer.requestFullscreen) {
                this.appContainer.requestFullscreen();
            } else if (this.appContainer.webkitRequestFullscreen) { /* Safari */
                this.appContainer.webkitRequestFullscreen();
            } else if (this.appContainer.msRequestFullscreen) { /* IE11 */
                this.appContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        // Stop continuous detection
        this.stopContinuousDetection();
        
        // Stop camera stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        this.isActive = false;
        botReply('Camera Time Reader closed.');
    }
}

// Create a global instance of the app
const cameraTimeReader = new CameraTimeReader();

// Add this to your AI's command handling
if (/time reader|clock reader|watch reader|read time/i.test(userInputRaw)) {
    cameraTimeReader.loadCameraTimeReader();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    cameraTimeReader.closeApp();
    return;
}

class BaseScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'BASE ENCODER/DECODER',
            instructions: 'Encode or decode text using Base64 or Base32. Supports copy and clear functions.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.inputTextarea = null;
        this.outputTextarea = null;
        this.base64EncodeButton = null;
        this.base64DecodeButton = null;
        this.base32EncodeButton = null;
        this.base32DecodeButton = null;
        this.clearButton = null;
        this.copyButton = null;
        
        // Base32 alphabet (RFC 4648)
        this.base32Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    }
    
    /**
     * Load the Base Screen
     */
    loadBaseScreen() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Create base screen
        this.createBaseScreen();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the base screen
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the Base Screen UI
     */
    createBaseScreen() {
        // Create base container
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 700px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Base64 & Base32 Encoder/Decoder';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        `;
        
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Encode or decode text using Base64 or Base32 algorithms';
        subtitle.style.cssText = `
            margin: 0;
            color: #666;
            font-size: 16px;
        `;
        
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);
        
        // Create input section
        const inputSection = document.createElement('div');
        inputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const inputLabel = document.createElement('label');
        inputLabel.textContent = 'Input Text:';
        inputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        
        this.inputTextarea = document.createElement('textarea');
        this.inputTextarea.placeholder = 'Enter text to encode or decode...';
        this.inputTextarea.style.cssText = `
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            box-sizing: border-box;
        `;
        
        inputSection.appendChild(inputLabel);
        inputSection.appendChild(this.inputTextarea);
        baseContainer.appendChild(inputSection);
        
        // Create button grid
        const buttonGrid = document.createElement('div');
        buttonGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Base64 Encode button
        this.base64EncodeButton = this.createButton('Base64 Encode', '#4CAF50', () => {
            this.base64Encode();
        });
        
        // Base64 Decode button
        this.base64DecodeButton = this.createButton('Base64 Decode', '#2196F3', () => {
            this.base64Decode();
        });
        
        // Base32 Encode button
        this.base32EncodeButton = this.createButton('Base32 Encode', '#FF9800', () => {
            this.base32Encode();
        });
        
        // Base32 Decode button
        this.base32DecodeButton = this.createButton('Base32 Decode', '#9C27B0', () => {
            this.base32Decode();
        });
        
        // Clear button
        this.clearButton = this.createButton('Clear', '#f44336', () => {
            this.clearFields();
        });
        
        // Copy button
        this.copyButton = this.createButton('Copy Output', '#607D8B', () => {
            this.copyOutput();
        });
        
        buttonGrid.appendChild(this.base64EncodeButton);
        buttonGrid.appendChild(this.base64DecodeButton);
        buttonGrid.appendChild(this.base32EncodeButton);
        buttonGrid.appendChild(this.base32DecodeButton);
        buttonGrid.appendChild(this.clearButton);
        buttonGrid.appendChild(this.copyButton);
        
        baseContainer.appendChild(buttonGrid);
        
        // Create output section
        const outputSection = document.createElement('div');
        outputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const outputLabel = document.createElement('label');
        outputLabel.textContent = 'Output Text:';
        outputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        
        this.outputTextarea = document.createElement('textarea');
        this.outputTextarea.placeholder = 'Result will appear here...';
        this.outputTextarea.readOnly = true;
        this.outputTextarea.style.cssText = `
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            box-sizing: border-box;
            background-color: #f9f9f9;
        `;
        
        outputSection.appendChild(outputLabel);
        outputSection.appendChild(this.outputTextarea);
        baseContainer.appendChild(outputSection);
        
        // Create info section
        const infoSection = document.createElement('div');
        infoSection.style.cssText = `
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 10px;
            font-size: 14px;
            color: #1976d2;
            border-left: 4px solid #2196F3;
        `;
        
        infoSection.innerHTML = `
            <strong>Tips:</strong><br>
            • Base64 is commonly used for encoding binary data in text format<br>
            • Base32 uses a 32-character set and is case-insensitive<br>
            • Use Copy Output to quickly copy the result to clipboard<br>
            • Clear button resets both input and output fields
        `;
        
        baseContainer.appendChild(infoSection);
        
        this.gameContainer.appendChild(baseContainer);
    }
    
    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        
        // Add hover effect
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        
        // Add click handler
        button.addEventListener('click', clickHandler);
        
        return button;
    }
    
    /**
     * Base64 Encode
     */
    base64Encode() {
        const input = this.inputTextarea.value;
        if (!input) {
            botReply('Please enter some text to encode.');
            return;
        }
        
        try {
            const encoded = btoa(unescape(encodeURIComponent(input)));
            this.outputTextarea.value = encoded;
            botReply('Text encoded to Base64 successfully!');
        } catch (error) {
            console.error('Base64 encode error:', error);
            botReply('Error encoding to Base64. Please check your input.');
        }
    }
    
    /**
     * Base64 Decode
     */
    base64Decode() {
        const input = this.inputTextarea.value;
        if (!input) {
            botReply('Please enter some Base64 text to decode.');
            return;
        }
        
        try {
            const decoded = decodeURIComponent(escape(atob(input)));
            this.outputTextarea.value = decoded;
            botReply('Base64 text decoded successfully!');
        } catch (error) {
            console.error('Base64 decode error:', error);
            botReply('Error decoding Base64. Please check your input.');
        }
    }
    
    /**
     * Base32 Encode
     */
    base32Encode() {
        const input = this.inputTextarea.value;
        if (!input) {
            botReply('Please enter some text to encode.');
            return;
        }
        
        try {
            const encoded = this.encodeBase32(input);
            this.outputTextarea.value = encoded;
            botReply('Text encoded to Base32 successfully!');
        } catch (error) {
            console.error('Base32 encode error:', error);
            botReply('Error encoding to Base32. Please check your input.');
        }
    }
    
    /**
     * Base32 Decode
     */
    base32Decode() {
        const input = this.inputTextarea.value.trim().toUpperCase();
        if (!input) {
            botReply('Please enter some Base32 text to decode.');
            return;
        }
        
        try {
            const decoded = this.decodeBase32(input);
            this.outputTextarea.value = decoded;
            botReply('Base32 text decoded successfully!');
        } catch (error) {
            console.error('Base32 decode error:', error);
            botReply('Error decoding Base32. Please check your input.');
        }
    }
    
    /**
     * Encode string to Base32
     */
    encodeBase32(str) {
        // Convert string to Uint8Array
        const encoder = new TextEncoder();
        const data = encoder.encode(str);
        
        let result = '';
        let buffer = 0;
        let bitsLeft = 0;
        
        for (let i = 0; i < data.length; i++) {
            buffer = (buffer << 8) | data[i];
            bitsLeft += 8;
            
            while (bitsLeft >= 5) {
                const index = (buffer >>> (bitsLeft - 5)) & 0x1F;
                result += this.base32Alphabet[index];
                bitsLeft -= 5;
            }
        }
        
        // Handle remaining bits
        if (bitsLeft > 0) {
            const index = (buffer << (5 - bitsLeft)) & 0x1F;
            result += this.base32Alphabet[index];
        }
        
        // Add padding if needed
        const padding = (8 - (result.length % 8)) % 8;
        if (padding > 0) {
            result += '='.repeat(padding);
        }
        
        return result;
    }
    
    /**
     * Decode Base32 string
     */
    decodeBase32(str) {
        // Remove padding and convert to uppercase
        str = str.replace(/=/g, '').toUpperCase();
        
        let buffer = 0;
        let bitsLeft = 0;
        const result = [];
        
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            const index = this.base32Alphabet.indexOf(char);
            
            if (index === -1) {
                throw new Error('Invalid Base32 character: ' + char);
            }
            
            buffer = (buffer << 5) | index;
            bitsLeft += 5;
            
            if (bitsLeft >= 8) {
                result.push((buffer >>> (bitsLeft - 8)) & 0xFF);
                bitsLeft -= 8;
            }
        }
        
        // Convert Uint8Array to string
        const decoder = new TextDecoder();
        return decoder.decode(new Uint8Array(result));
    }
    
    /**
     * Clear input and output fields
     */
    clearFields() {
        this.inputTextarea.value = '';
        this.outputTextarea.value = '';
        botReply('Fields cleared.');
    }
    
    /**
     * Copy output to clipboard
     */
    copyOutput() {
        const output = this.outputTextarea.value;
        if (!output) {
            botReply('No output to copy.');
            return;
        }
        
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(output)
                .then(() => {
                    botReply('Output copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(output);
                });
        } else {
            // Fallback for older browsers
            this.fallbackCopyTextToClipboard(output);
        }
    }
    
    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Output copied to clipboard!');
            } else {
                botReply('Unable to copy output');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy output');
        }

        document.body.removeChild(textArea);
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
            border-radius: 4px;
            box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.inputTextarea = null;
        this.outputTextarea = null;
        this.base64EncodeButton = null;
        this.base64DecodeButton = null;
        this.base32EncodeButton = null;
        this.base32DecodeButton = null;
        this.clearButton = null;
        this.copyButton = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        
        botReply("Base Encoder/Decoder closed. Thank you!");
    }
}

// Create a singleton instance
const baseScreenLoader = new BaseScreenLoader();

// Add this to your AI's command handling
if (/base|base64|base32|encode|decode|Decrypt|Encrypt/i.test(userInputRaw)) {
    baseScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    baseScreenLoader.closeGame();
    return;
}


class ScreenLoader {
    constructor() {
        this.games = {
            Movie: {
                url: 'https://vipteammod897.github.io/VIPTEAMMOD-AI/AIMovie.html',
              //  name: 'VIPTEAMMOD AI MOVIES',
               // instructions: 'Browse and watch your favorite movies.'
            },
            Games: {
                url: 'https://vipteammod.site/VipTeamModServer.html',
             //   name: 'PLAY ONLINE GAMES',
               // instructions: 'Play a variety of online games in your browser.'
            }
        };
        
        this.gameContainer = null;
        this.gameIframe = null;
        this.currentGame = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.fullscreenButtonClickHandler = null;
        this.closeButton = null;
    }
    
    /**
     * Load a specific game
     * @param {string} gameKey - The key of the game to load
     */
    loadGame(gameKey) {
        // Check if a game is already active
        if (this.isActive) {
            botReply(`The ${this.currentGame.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check if the game exists
        if (!this.games[gameKey]) {
            botReply(`Screen not found. Available screens: ${Object.keys(this.games).map(key => this.games[key].name).join(', ')}`);
            return;
        }
        
        // Set the current game
        this.currentGame = this.games[gameKey];
        
        // Create game container
        this.createGameContainer();
        
        // Create iframe for the game
        this.createGameIframe();
        
        // Set up action buttons
        this.setupActionButtons();

        
        // Display the game
        this.displayGame();
        
        this.isActive = true;
        
       // botReply(`${this.currentGame.name} loaded! ${this.currentGame.instructions}`);
    }
    
    /**
     * List all available games
     */
    listGames() {
        const gameList = Object.keys(this.games).map(key => this.games[key].name).join(', ');
        botReply(`Available screens: ${gameList}. Type 'play [screen name]' to start.`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the game iframe
     */
    createGameIframe() {
        this.gameIframe = document.createElement('iframe');
        this.gameIframe.src = this.currentGame.url;
        this.gameIframe.style.cssText = `
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            max-height: 800px;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        `;
        
        // Handle iframe load event
        this.gameIframe.onload = () => {
            // Game has loaded, focus on it for controls
            this.gameIframe.focus();
        };
        
        // Handle iframe error event
        this.gameIframe.onerror = () => {
            botReply(`Error loading the ${this.currentGame.name}. Please try again later.`);
            this.closeGame();
        };
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d93025, #d93025);
    border-radius: 4px;
    box-shadow: 0 0 10px #d93025;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        // Use a named function for the click handler
        this.fullscreenButtonClickHandler = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        // Remove any existing event listener before adding a new one
        this.fullscreenButton.removeEventListener('click', this.fullscreenButtonClickHandler);
        this.fullscreenButton.addEventListener('click', this.fullscreenButtonClickHandler);
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
    border-radius: 4px;
    box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
           
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add iframe to container
        this.gameContainer.appendChild(this.gameIframe);
        
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     * @param {KeyboardEvent} event - The keyboard event
     */
    handleKeyPress = (event) => {
        // Check if escape key was pressed
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        // Check if we're actually in fullscreen mode
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust iframe size based on fullscreen state
        if (this.isFullscreen) {
            this.gameIframe.style.width = '98%';
            this.gameIframe.style.height = '95vh';
        } else {
            this.gameIframe.style.width = '90%';
            this.gameIframe.style.height = '85vh';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) { /* Safari */
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) { /* IE11 */
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove fullscreen button event listener
        if (this.fullscreenButton && this.fullscreenButtonClickHandler) {
            this.fullscreenButton.removeEventListener('click', this.fullscreenButtonClickHandler);
        }
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.gameIframe = null;
        this.currentGame = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.fullscreenButtonClickHandler = null;
        this.closeButton = null;
        
        botReply("Screen closed. Thank you!");
    }
}

// Create a singleton instance
const screenloader = new ScreenLoader();

// Add this to your AI's command handling
if (/Movies|play Movie/i.test(userInputRaw)) {
    screenloader.loadGame('Movie');
    return;
}

// Add command for Games
if (/Games|play Games/i.test(userInputRaw)) {
    screenloader.loadGame('Games');
    return;
}

// Add command to list all screens
if (/list screens|available screens/i.test(userInputRaw)) {
    screenloader.listGames();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    screenloader.closeGame();
    return;
}



if (/unlock image to text/i.test(userInputRaw)) {
    // Add a small delay before opening the file picker
    setTimeout(() => {
        document.getElementById('hiddenFileInput').click();
    }, 1500); // 1500 milliseconds = 1.5 seconds delay
    return;
}

// Create Hidden File Input (if not already created elsewhere in your code)
let hiddenFileInput = document.getElementById('hiddenFileInput');
if (!hiddenFileInput) {
    hiddenFileInput = document.createElement("input");
    hiddenFileInput.type = "file";
    hiddenFileInput.accept = "image/*";
    hiddenFileInput.id = "hiddenFileInput";
    hiddenFileInput.style.display = "none"; // hide the input field
    document.body.appendChild(hiddenFileInput);
    
    // Function to handle file selection
    hiddenFileInput.addEventListener('change', handleFileSelect, false);
}

// Function to handle file selection and OCR processing
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    botReply("Reading the image file...");
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            // After image is loaded, you can preprocess and call an OCR function
            processImageToText(img);
        };
        img.onerror = function() {
            botReply("Error loading the image. Please try another image.");
        };
        img.src = e.target.result; // Load the image
    };
    reader.onerror = function() {
        botReply("Error reading the file. Please try again.");
    };
    reader.readAsDataURL(file); // Read the image file as a data URL
}

// Improved OCR function using Tesseract.js with preprocessing
function processImageToText(img) {
    botReply("Processing image... Please wait.");
    
    try {
        // Preprocess the image (resize, grayscale, binarization, etc.)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set a maximum size for better performance
        const MAX_WIDTH = 2000;
        const MAX_HEIGHT = 2000;
        let width = img.width;
        let height = img.height;
        
        if (width > height) {
            if (width > MAX_WIDTH) {
                height *= MAX_WIDTH / width;
                width = MAX_WIDTH;
            }
        } else {
            if (height > MAX_HEIGHT) {
                width *= MAX_HEIGHT / height;
                height = MAX_HEIGHT;
            }
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        
        // Preprocessing: Convert to grayscale
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
            data[i] = data[i + 1] = data[i + 2] = avg; // Set R, G, B to grayscale value
        }
        ctx.putImageData(imgData, 0, 0);
        
        // Additional preprocessing: Apply threshold for better OCR results
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const newData = imageData.data;
        for (let i = 0; i < newData.length; i += 4) {
            // Simple threshold: if pixel is darker than middle gray, make it black, otherwise white
            const value = newData[i] > 128 ? 255 : 0;
            newData[i] = newData[i + 1] = newData[i + 2] = value;
        }
        ctx.putImageData(imageData, 0, 0);
        
        // Use Tesseract.js to extract text from the processed image
        Tesseract.recognize(
            canvas,
            'eng', // Add more language support if needed
            {
                logger: (m) => {
                    if (m.status === 'recognizing text') {
                        const progress = Math.round(m.progress * 100);
                        botReply(`Processing image... ${progress}% complete`);
                    }
                },
            }
        ).then(({ data: { text } }) => {
            if (text.trim() === "") {
                botReply("No text was extracted from the image. Please try again with a clearer image.");
            } else {
                // Preserve some line breaks for better formatting
                const processedText = text.trim().replace(/\n{3,}/g, '\n\n');
                botReply(`Extracted Text:\n\n${processedText}`);
            }
        }).catch(error => {
            botReply("Error extracting text from the image. Please try again later.");
            console.error("OCR Error:", error);
        });
    } catch (error) {
        botReply("Error processing the image. Please try again.");
        console.error("Processing Error:", error);
    }
}



}

function botReply(message) {
    const chatBox = document.getElementById("chat-box");
    const botMessageContainer = document.createElement("div");
    botMessageContainer.classList.add("bot-container");

    // Create the copy button
    const copyButton = document.createElement("button");
    copyButton.classList.add("copy-btn");
    copyButton.innerText = "Copy";

    // Copy the message to clipboard when clicked
    copyButton.addEventListener("click", () => {
        navigator.clipboard.writeText(message).then(() => {
            // Change button text to "Copied"
            copyButton.innerText = "Copied";

            // Reset the button text after 2 seconds
            setTimeout(() => {
                copyButton.innerText = "Copy";
            }, 2000);
        }).catch(err => {
            console.error("Error copying text: ", err);
        });
    });

    // Create the share button (same style as copy button)
    const shareButton = document.createElement("button");
    shareButton.classList.add("copy-btn"); // Same class as copy button
    shareButton.innerText = "Share";

    // Share the message when clicked
    shareButton.addEventListener("click", () => {
        // Use the Web Share API to share the message (if supported)
        if (navigator.share) {
            navigator.share({
                title: "AI Bot Message",
                text: message,
                url: window.location.href
            }).then(() => {
                console.log("Message shared successfully!");
            }).catch(err => {
                console.error("Error sharing message: ", err);
            });
        } else {
            // If the Web Share API is not supported, alert the user
            alert("Sharing is not supported on this device/browser.");
        }
    });

    // Create the bot message
    const botMessage = document.createElement("div");
    botMessage.classList.add("bot-message");
    botMessage.innerHTML = `<strong style="color: white; background: linear-gradient(145deg, #d30, #d35); padding: 4px 8px; box-shadow: 0 0 5px #d35;border-radius: 6px; display: inline-block;">AI Bot:</strong> ${message}`;

    // Create a div for the buttons and apply flexbox for alignment
    const buttonContainer = document.createElement("div");
    buttonContainer.classList.add("button-container");

    // Append buttons to the container
    buttonContainer.appendChild(copyButton);
    buttonContainer.appendChild(shareButton);

    // Append the button container and the message to the bot message container
    botMessageContainer.appendChild(buttonContainer);
    botMessageContainer.appendChild(botMessage);

    // Append the container to chatBox
    chatBox.appendChild(botMessageContainer);
    chatBox.appendChild(document.createElement("br"));

    // Save plain text message for history
    chatHistory.push(`[${new Date().toLocaleTimeString()}] AI Bot: ${botMessage.textContent}`);

    // Scroll to bottom
    chatBox.scrollTop = chatBox.scrollHeight;
}
        botReply(` Welcome To VIPTEAMMOD AI 3.0`);

// Function to download chat history as a .txt file

function downloadChatHistory() {
    if (chatHistory.length > 0) {
        chatHistory.push(`\nChat End: ${new Date().toLocaleString()}`);
    }
    const blob = new Blob([chatHistory.join("\n")], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "chat_history.txt";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

const downloadBtn = document.createElement("button");
downloadBtn.textContent = "Download Chat History";
downloadBtn.id = "downloadBtn"; // Assign the ID for styling
downloadBtn.onclick = downloadChatHistory;


    // Event listeners
    document.getElementById('user-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            DayCheckFunction();
        }
    });
// Append the button inside the chat container
document.querySelector(".chat-container").appendChild(downloadBtn);


  </script>
  <script>
    // Disable right-click
document.addEventListener("contextmenu", function (e) {
    e.preventDefault();
});

// Disable keyboard shortcuts for DevTools
document.addEventListener("keydown", function (e) {
    if (e.ctrlKey && (e.key === "u" || e.key === "U" || e.key === "s" || e.key === "S" || e.key === "i" || e.key === "I" || e.key === "j" || e.key === "J" || e.key === "c" || e.key === "C")) {
        e.preventDefault();
    }
});

// Disable F12, Ctrl+Shift+I, Ctrl+Shift+J
document.onkeydown = function (e) {
    if (e.keyCode == 123) { return false; } // F12
    if (e.ctrlKey && e.shiftKey && (e.keyCode == 73 || e.keyCode == 74)) { return false; } // Ctrl+Shift+I/J
};
  
  </script>
<script>
    const blockScreen = document.getElementById('blockScreen');

    function detectDevTools() {
      const widthDiff = window.outerWidth - window.innerWidth;
      const heightDiff = window.outerHeight - window.innerHeight;
      const threshold = 120;

      // True if dimensions indicate DevTools or if debugger gets trapped
      let devtoolsOpen = widthDiff > threshold || heightDiff > threshold;

      // Mobile-specific trap
      const trap = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      if (trap) {
        const start = new Date();
        debugger;
        const end = new Date();
        if (end - start > 100) devtoolsOpen = true;
      }

      if (devtoolsOpen) {
       window.location.href = "https://c.tenor.com/x4V9PRp9R-0AAAAC/tenor.gif"; // Replace with your redirect URL

      } else {
        blockScreen.style.display = 'none';
        document.body.style.pointerEvents = 'auto';
      }
    }

    setInterval(detectDevTools, 600);

    // Block right-click
    document.addEventListener('contextmenu', e => e.preventDefault());

    // Block common dev hotkeys
    document.addEventListener('keydown', function (event) {
      if (
        event.key === 'F12' ||
        (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) ||
        (event.ctrlKey && event.key.toLowerCase() === 'u')
      ) {
        event.preventDefault();
      }
    });
  </script>
    <script>
        // Function to adjust the container based on screen size
        function adjustScreenSize() {
            const container = document.getElementById('main-container');
            const windowWidth = window.innerWidth;
            
            // For desktop screens
            if (windowWidth > 1200) {
                container.style.width = '97%';
                container.style.margin = '0 auto';
            } 
            // For tablet screens
            else if (windowWidth > 768) {
                container.style.width = '97%';
                container.style.margin = '0 auto';
            } 
            // For mobile screens
            else {
                container.style.width = '97%';
                container.style.margin = '0';
            }
        }
        
        // Call the function when the page loads
        window.addEventListener('load', adjustScreenSize);
        
        // Call the function when the window is resized
        window.addEventListener('resize', adjustScreenSize);
    </script>
    
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
<script>
// Initialize Firebase
const firebaseConfig = {
    apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
    authDomain: "vipteammod-movies.firebaseapp.com",
    projectId: "vipteammod-movies",
    databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com",
    appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();

// Global variables to store toggle states
let autoCorrectEnabled = true;
let textCompletionEnabled = true;
let emotionWordsEffectEnabled = false; // New toggle for emotion words effect

// Main script with authentication
document.addEventListener('DOMContentLoaded', function() {
    // Track authentication state
    auth.onAuthStateChanged(function(user) {
        // Clear any existing UI elements
        clearExistingUI();
        
        if (user) {
            // User is signed in
            initializeAppWithUser(user);
            // Unlock message inputs
            unlockMessageInputs();
        } else {
            // User is signed out
            initializeAppWithoutUser();
            // Lock message inputs
            lockMessageInputs();
        }
    });

    // Function to clear existing UI elements
    function clearExistingUI() {
        // Remove settings icon if it exists
        const existingSettingsIcon = document.querySelector('[data-settings-icon]');
        if (existingSettingsIcon) {
            existingSettingsIcon.remove();
        }
        
        // Remove login button if it exists
        const existingLoginButton = document.querySelector('[data-login-button]');
        if (existingLoginButton) {
            existingLoginButton.remove();
        }
        
        // Remove settings panel if it exists
        const existingSettingsPanel = document.querySelector('[data-settings-panel]');
        if (existingSettingsPanel) {
            existingSettingsPanel.remove();
        }
    }

    // Function to unlock message inputs when logged in
    function unlockMessageInputs() {
        const messageInputs = document.querySelectorAll('input[type="text"], input[type="search"], textarea');
        messageInputs.forEach(input => {
            // Store original placeholder if it exists and not already stored
            if (!input.hasAttribute('data-original-placeholder') && input.placeholder !== 'Please login to use this feature') {
                input.setAttribute('data-original-placeholder', input.placeholder);
            }
            
            // Set the placeholder to the unlocked version
            const originalPlaceholder = input.getAttribute('data-original-placeholder') || 'Type your message...';
            input.placeholder = originalPlaceholder;
            input.disabled = false;
            input.style.backgroundColor = '';
            input.style.cursor = '';
            
            // Remove the login modal click event listener if it exists
            input.removeEventListener('click', showLoginModal);
        });
    }

    // Function to lock message inputs when not logged in
    function lockMessageInputs() {
        const messageInputs = document.querySelectorAll('input[type="text"], input[type="search"], textarea');
        messageInputs.forEach(input => {
            // Store original placeholder if it exists and not already stored
            if (!input.hasAttribute('data-original-placeholder') && input.placeholder !== 'Please login to use this feature') {
                input.setAttribute('data-original-placeholder', input.placeholder);
            }
            
            // Set the placeholder to the locked version
            input.placeholder = 'Please login to use this feature';
            input.disabled = true;
            input.style.backgroundColor = 'rgba(240, 240, 240, 0.1)';
            input.style.cursor = 'not-allowed';
            
            // Remove any existing click event listener to avoid duplicates
            input.removeEventListener('click', showLoginModal);
            
            // Add click event to show login modal
            input.addEventListener('click', showLoginModal);
        });
    }

    function initializeAppWithUser(user) {
        // Create settings icon with user info
        const settingsIcon = document.createElement('div');
        settingsIcon.setAttribute('data-settings-icon', 'true');
        settingsIcon.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            cursor: move;
            background-color: #d93025;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 132, 255, 0.6);
            backdrop-filter: blur(5px);
            border: 1px solid white;
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            user-select: none;
        `;
        
        // Add user avatar or default icon
        const userIcon = document.createElement('div');
        userIcon.style.cssText = `
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #d93025;
            font-weight: bold;
            font-size: 12px;
            overflow: hidden;
        `;
        
        // Show user's initial or default icon
        if (user.displayName) {
            userIcon.textContent = user.displayName.charAt(0).toUpperCase();
        } else if (user.email) {
            userIcon.textContent = user.email.charAt(0).toUpperCase();
        } else {
            const settingsImage = document.createElement('img');
            settingsImage.src = 'setting.png';
            settingsImage.style.cssText = `
                width: 24px;
                height: 24px;
                object-fit: contain;
                filter: brightness(0) invert(1);
            `;
            userIcon.appendChild(settingsImage);
        }
        
        settingsIcon.appendChild(userIcon);
        
        // Add hover effect
        settingsIcon.addEventListener('mouseenter', () => {
            settingsIcon.style.backgroundColor = '#d93025';
            settingsIcon.style.transform = 'scale(1.1)';
            settingsIcon.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3), 0 0 20px rgba(0, 132, 255, 0.8)';
        });
        
        settingsIcon.addEventListener('mouseleave', () => {
            settingsIcon.style.backgroundColor = '#d93025';
            settingsIcon.style.transform = 'scale(1)';
            settingsIcon.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 132, 255, 0.6)';
        });
        
        // Make settings icon draggable
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;
        
        settingsIcon.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        
        // Touch events for mobile
        settingsIcon.addEventListener('touchstart', dragStart);
        document.addEventListener('touchmove', drag);
        settingsIcon.addEventListener('touchend', dragEnd);
        
        function dragStart(e) {
            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
            } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
            
            if (e.target === settingsIcon || e.target.parentNode === settingsIcon) {
                isDragging = true;
                settingsIcon.style.cursor = 'grabbing';
                settingsIcon.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3), 0 0 25px rgba(0, 132, 255, 0.9)';
            }
        }
        
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                
                if (e.type === "touchmove") {
                    currentX = e.touches[0].clientX - initialX;
                    currentY = e.touches[0].clientY - initialY;
                } else {
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                }
                
                xOffset = currentX;
                yOffset = currentY;
                
                // Keep within viewport boundaries
                const rect = settingsIcon.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                if (rect.left < 0) {
                    xOffset = 0;
                } else if (rect.right > viewportWidth) {
                    xOffset = viewportWidth - rect.width;
                }
                
                if (rect.top < 0) {
                    yOffset = 0;
                } else if (rect.bottom > viewportHeight) {
                    yOffset = viewportHeight - rect.height;
                }
                
                setTranslate(xOffset, yOffset, settingsIcon);
            }
        }
        
        function dragEnd(e) {
            initialX = currentX;
            initialY = currentY;
            isDragging = false;
            settingsIcon.style.cursor = 'move';
            settingsIcon.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 132, 255, 0.6)';
        }
        
        function setTranslate(xPos, yPos, el) {
            el.style.transform = `translate(${xPos}px, ${yPos}px)`;
        }
        
        // Create settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.setAttribute('data-settings-panel', 'true');
        settingsPanel.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10001;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        `;
        
        // Create settings modal
        const settingsModal = document.createElement('div');
        settingsModal.style.cssText = `
            background-color: rgba(30, 30, 40, 0.95);
            border-radius: 16px;
            padding: 25px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 132, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-family: Arial, sans-serif;
        `;
        
        // Create settings header
        const settingsHeader = document.createElement('div');
        settingsHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const settingsTitle = document.createElement('h2');
        settingsTitle.textContent = 'Settings';
        settingsTitle.style.cssText = `
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: white;
        `;
        
        // Create close button
        const closeButton = document.createElement('div');
        closeButton.innerHTML = '✕';
        closeButton.style.cssText = `
            font-size: 20px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s ease;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        `;
        
        closeButton.addEventListener('mouseenter', () => {
            closeButton.style.color = 'white';
            closeButton.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
        });
        
        closeButton.addEventListener('mouseleave', () => {
            closeButton.style.color = 'rgba(255, 255, 255, 0.7)';
            closeButton.style.backgroundColor = 'transparent';
        });
        
        settingsHeader.appendChild(settingsTitle);
        settingsHeader.appendChild(closeButton);
        
        // Create user info section
        const userInfoSection = document.createElement('div');
        userInfoSection.style.cssText = `
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        `;
        
        const userAvatar = document.createElement('div');
        userAvatar.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #d93025;
            font-weight: bold;
            font-size: 18px;
            margin-right: 15px;
            overflow: hidden;
        `;
        
        if (user.displayName) {
            userAvatar.textContent = user.displayName.charAt(0).toUpperCase();
        } else if (user.email) {
            userAvatar.textContent = user.email.charAt(0).toUpperCase();
        }
        
        const userDetails = document.createElement('div');
        
        const userName = document.createElement('div');
        userName.textContent = user.displayName || 'User';
        userName.style.cssText = `
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        `;
        
        const userEmail = document.createElement('div');
        userEmail.textContent = user.email;
        userEmail.style.cssText = `
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        `;
        
        userDetails.appendChild(userName);
        userDetails.appendChild(userEmail);
        
        userInfoSection.appendChild(userAvatar);
        userInfoSection.appendChild(userDetails);
        
        // Create settings content
        const settingsContent = document.createElement('div');
        settingsContent.style.cssText = `
            margin-bottom: 20px;
        `;
        
        // Create toggle container for auto-correction
        const autoCorrectToggle = createToggleOption('Auto-Correction', 'Automatically correct spelling and grammar mistakes as you type.', autoCorrectEnabled);
        
        // Create toggle container for AI text completion
        const aiCompletionToggle = createToggleOption('Text Completion', 'Suggest text completions as you type.', textCompletionEnabled);
        
        // Create toggle container for emotion words effect
        const emotionWordsToggle = createToggleOption('Emotion Words Effect', 'Show animations when happy or sad words are detected.', emotionWordsEffectEnabled);
        
        // Create logout button
        const logoutButton = document.createElement('button');
        logoutButton.textContent = 'Logout';
        logoutButton.style.cssText = `
            background-color: #ff4d4d;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 0 10px rgba(255, 77, 77, 0.3);
            width: 100%;
            margin-top: 10px;
        `;
        
        logoutButton.addEventListener('mouseenter', () => {
            logoutButton.style.backgroundColor = '#e60000';
            logoutButton.style.boxShadow = '0 0 15px rgba(255, 77, 77, 0.5)';
        });
        
        logoutButton.addEventListener('mouseleave', () => {
            logoutButton.style.backgroundColor = '#ff4d4d';
            logoutButton.style.boxShadow = '0 0 10px rgba(255, 77, 77, 0.3)';
        });
        
        logoutButton.addEventListener('click', () => {
            auth.signOut().then(() => {
                settingsPanel.style.display = 'none';
                showNotification('You have been logged out successfully');
                // The auth state change will trigger the UI update
            }).catch((error) => {
                showNotification('Error logging out: ' + error.message, 'error');
            });
        });
        
        // Create settings footer with cancel and save buttons
        const settingsFooter = document.createElement('div');
        settingsFooter.style.cssText = `
            display: flex;
            justify-content: space-between;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create cancel button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            background-color: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
        `;
        
        cancelButton.addEventListener('mouseenter', () => {
            cancelButton.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
            cancelButton.style.color = 'white';
        });
        
        cancelButton.addEventListener('mouseleave', () => {
            cancelButton.style.backgroundColor = 'transparent';
            cancelButton.style.color = 'rgba(255, 255, 255, 0.7)';
        });
        
        // Create save button
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.style.cssText = `
            background-color: #d93025;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 0 10px rgba(0, 132, 255, 0.3);
        `;
        
        saveButton.addEventListener('mouseenter', () => {
            saveButton.style.backgroundColor = '#0070e0';
            saveButton.style.boxShadow = '0 0 15px rgba(0, 132, 255, 0.5)';
        });
        
        saveButton.addEventListener('mouseleave', () => {
            saveButton.style.backgroundColor = '#d93025';
            saveButton.style.boxShadow = '0 0 10px rgba(0, 132, 255, 0.3)';
        });
        
        // Assemble settings modal
        settingsContent.appendChild(userInfoSection);
        settingsContent.appendChild(autoCorrectToggle.container);
        settingsContent.appendChild(aiCompletionToggle.container);
        settingsContent.appendChild(emotionWordsToggle.container);
        settingsContent.appendChild(logoutButton);
        settingsModal.appendChild(settingsHeader);
        settingsModal.appendChild(settingsContent);
        settingsFooter.appendChild(cancelButton);
        settingsFooter.appendChild(saveButton);
        settingsModal.appendChild(settingsFooter);
        settingsPanel.appendChild(settingsModal);
        
        // Add elements to document
        document.body.appendChild(settingsIcon);
        document.body.appendChild(settingsPanel);
        
        // Add event listeners
        settingsIcon.addEventListener('click', (e) => {
            // Only open settings if not dragging
            if (!isDragging) {
                settingsPanel.style.display = 'flex';
            }
        });
        
        // Close button event listener - just close without saving
        closeButton.addEventListener('click', () => {
            settingsPanel.style.display = 'none';
        });
        
        // Cancel button event listener - just close without saving
        cancelButton.addEventListener('click', () => {
            settingsPanel.style.display = 'none';
        });
        
        // Save button event listener - save settings and close
        saveButton.addEventListener('click', () => {
            // Save settings
            autoCorrectEnabled = autoCorrectToggle.input.checked;
            textCompletionEnabled = aiCompletionToggle.input.checked;
            emotionWordsEffectEnabled = emotionWordsToggle.input.checked;
            
            // Save to localStorage
            localStorage.setItem('autoCorrectEnabled', autoCorrectEnabled.toString());
            localStorage.setItem('textCompletionEnabled', textCompletionEnabled.toString());
            localStorage.setItem('emotionWordsEffectEnabled', emotionWordsEffectEnabled.toString());
            
            // Apply the settings immediately
            applySettings();
            
            settingsPanel.style.display = 'none';
            showNotification('Settings saved successfully');
        });
        
        // Close settings when clicking outside modal
        settingsPanel.addEventListener('click', (e) => {
            if (e.target === settingsPanel) {
                settingsPanel.style.display = 'none';
            }
        });
        
        // Initialize auto-correction and text completion
        initializeAutoCorrectionAndCompletion();
        
        // Initialize emotion detection system
        initializeEmotionDetection();
    }
    
    

    function initializeAppWithoutUser() {
        // Create login button
        const loginButton = document.createElement('button');
        loginButton.setAttribute('data-login-button', 'true');
        loginButton.textContent = 'Login';
        loginButton.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background-color: #d93025;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 132, 255, 0.6);
            backdrop-filter: blur(5px);
        `;
        
        loginButton.addEventListener('mouseenter', () => {
            loginButton.style.backgroundColor = '#0070e0';
            loginButton.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3), 0 0 20px rgba(0, 132, 255, 0.8)';
        });
        
        loginButton.addEventListener('mouseleave', () => {
            loginButton.style.backgroundColor = '#d93025';
            loginButton.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 132, 255, 0.6)';
        });
        
        loginButton.addEventListener('click', () => {
            showLoginModal();
        });
        
        document.body.appendChild(loginButton);
        
        // Initialize auto-correction and text completion without user-specific features
        initializeAutoCorrectionAndCompletion();
        
        // Initialize emotion detection system
        initializeEmotionDetection();
    }

    function showLoginModal() {
        // Create login modal
        const loginModal = document.createElement('div');
        loginModal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        `;
        
        // Create login form container
        const loginContainer = document.createElement('div');
        loginContainer.style.cssText = `
            background-color: rgba(30, 30, 40, 0.95);
            border-radius: 16px;
            padding: 30px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 132, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-family: Arial, sans-serif;
        `;
        
        // Create login header
        const loginHeader = document.createElement('div');
        loginHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const loginTitle = document.createElement('h2');
        loginTitle.textContent = 'Login';
        loginTitle.style.cssText = `
            margin: 0;
            font-size: 24px;
            font-weight: 600;
            color: white;
        `;
        
        // Create close button
        const closeLoginButton = document.createElement('div');
        closeLoginButton.innerHTML = '✕';
        closeLoginButton.style.cssText = `
            font-size: 20px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s ease;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        `;
        
        closeLoginButton.addEventListener('mouseenter', () => {
            closeLoginButton.style.color = 'white';
            closeLoginButton.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
        });
        
        closeLoginButton.addEventListener('mouseleave', () => {
            closeLoginButton.style.color = 'rgba(255, 255, 255, 0.7)';
            closeLoginButton.style.backgroundColor = 'transparent';
        });
        
        closeLoginButton.addEventListener('click', () => {
            document.body.removeChild(loginModal);
        });
        
        loginHeader.appendChild(loginTitle);
        loginHeader.appendChild(closeLoginButton);
        
        // Create login form
        const loginForm = document.createElement('form');
        loginForm.style.cssText = `
            display: flex;
            flex-direction: column;
        `;
        
        // Email input
        const emailContainer = document.createElement('div');
        emailContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const emailLabel = document.createElement('label');
        emailLabel.textContent = 'Email';
        emailLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        const emailInput = document.createElement('input');
        emailInput.type = 'email';
        emailInput.placeholder = 'Enter your email';
        emailInput.required = true;
        emailInput.style.cssText = `
            width: 100%;
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        `;
        
        emailContainer.appendChild(emailLabel);
        emailContainer.appendChild(emailInput);
        
        // Password input
        const passwordContainer = document.createElement('div');
        passwordContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const passwordLabel = document.createElement('label');
        passwordLabel.textContent = 'Password';
        passwordLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        const passwordInput = document.createElement('input');
        passwordInput.type = 'password';
        passwordInput.placeholder = 'Enter your password';
        passwordInput.required = true;
        passwordInput.style.cssText = `
            width: 100%;
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        `;
        
        passwordContainer.appendChild(passwordLabel);
        passwordContainer.appendChild(passwordInput);
        
        // Remember me and forgot password
        const optionsContainer = document.createElement('div');
        optionsContainer.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        `;
        
        // Remember me
        const rememberContainer = document.createElement('div');
        rememberContainer.style.cssText = `
            display: flex;
            align-items: center;
        `;
        
        const rememberCheckbox = document.createElement('input');
        rememberCheckbox.type = 'checkbox';
        rememberCheckbox.id = 'remember';
        rememberCheckbox.style.cssText = `
            margin-right: 8px;
        `;
        
        const rememberLabel = document.createElement('label');
        rememberLabel.htmlFor = 'remember';
        rememberLabel.textContent = 'Remember me';
        rememberLabel.style.cssText = `
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        rememberContainer.appendChild(rememberCheckbox);
        rememberContainer.appendChild(rememberLabel);
        
        // Forgot password
        const forgotPassword = document.createElement('a');
        forgotPassword.textContent = 'Forgot password?';
        forgotPassword.href = '#';
        forgotPassword.style.cssText = `
            font-size: 14px;
            color: #d93025;
            text-decoration: none;
        `;
        
        forgotPassword.addEventListener('click', (e) => {
            e.preventDefault();
            showNotification('Password reset functionality would be implemented here');
        });
        
        optionsContainer.appendChild(rememberContainer);
        optionsContainer.appendChild(forgotPassword);
        
        // Login button
        const loginSubmitButton = document.createElement('button');
        loginSubmitButton.type = 'submit';
        loginSubmitButton.textContent = 'Login';
        loginSubmitButton.style.cssText = `
            background-color: #d93025;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 0 10px rgba(0, 132, 255, 0.3);
            margin-bottom: 20px;
        `;
        
        loginSubmitButton.addEventListener('mouseenter', () => {
            loginSubmitButton.style.backgroundColor = '#0070e0';
            loginSubmitButton.style.boxShadow = '0 0 15px rgba(0, 132, 255, 0.5)';
        });
        
        loginSubmitButton.addEventListener('mouseleave', () => {
            loginSubmitButton.style.backgroundColor = '#d93025';
            loginSubmitButton.style.boxShadow = '0 0 10px rgba(0, 132, 255, 0.3)';
        });
        
        // Sign up link
        const signupContainer = document.createElement('div');
        signupContainer.style.cssText = `
            text-align: center;
            margin-top: 10px;
        `;
        
        const signupText = document.createElement('span');
        signupText.textContent = "Don't have an account? ";
        signupText.style.cssText = `
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        const signupLink = document.createElement('a');
        signupLink.textContent = 'Sign up';
        signupLink.href = '#';
        signupLink.style.cssText = `
            font-size: 14px;
            color: #d93025;
            text-decoration: none;
            font-weight: 500;
        `;
        
        signupLink.addEventListener('click', (e) => {
            e.preventDefault();
            document.body.removeChild(loginModal);
            showSignupModal();
        });
        
        signupContainer.appendChild(signupText);
        signupContainer.appendChild(signupLink);
        
        // Error message container
        const errorMessage = document.createElement('div');
        errorMessage.style.cssText = `
            color: #ff4d4d;
            font-size: 14px;
            margin-top: 10px;
            text-align: center;
            display: none;
        `;
        
        // Assemble login form
        loginForm.appendChild(emailContainer);
        loginForm.appendChild(passwordContainer);
        loginForm.appendChild(optionsContainer);
        loginForm.appendChild(loginSubmitButton);
        loginForm.appendChild(errorMessage);
        loginForm.appendChild(signupContainer);
        
        // Handle form submission
        loginForm.addEventListener('submit', (e) => {
            e.preventDefault();
            
            const email = emailInput.value;
            const password = passwordInput.value;
            const remember = rememberCheckbox.checked;
            
            // Show loading state
            loginSubmitButton.textContent = 'Logging in...';
            loginSubmitButton.disabled = true;
            
            // Sign in with Firebase
            auth.signInWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    // Signed in successfully
                    const user = userCredential.user;
                    document.body.removeChild(loginModal);
                    showNotification('Login successful');
                })
                .catch((error) => {
                    // Handle errors
                    const errorCode = error.code;
                    const errorText = getErrorMessage(errorCode);
                    
                    errorMessage.textContent = errorText;
                    errorMessage.style.display = 'block';
                    
                    // Reset button state
                    loginSubmitButton.textContent = 'Login';
                    loginSubmitButton.disabled = false;
                });
        });
        
        // Assemble login modal
        loginContainer.appendChild(loginHeader);
        loginContainer.appendChild(loginForm);
        loginModal.appendChild(loginContainer);
        
        // Add to document
        document.body.appendChild(loginModal);
        
        // Focus on email input
        setTimeout(() => {
            emailInput.focus();
        }, 100);
    }

    function showSignupModal() {
        // Create signup modal (similar to login modal)
        const signupModal = document.createElement('div');
        signupModal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        `;
        
        // Create signup form container
        const signupContainer = document.createElement('div');
        signupContainer.style.cssText = `
            background-color: rgba(30, 30, 40, 0.95);
            border-radius: 16px;
            padding: 30px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 132, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-family: Arial, sans-serif;
        `;
        
        // Create signup header
        const signupHeader = document.createElement('div');
        signupHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const signupTitle = document.createElement('h2');
        signupTitle.textContent = 'Sign Up';
        signupTitle.style.cssText = `
            margin: 0;
            font-size: 24px;
            font-weight: 600;
            color: white;
        `;
        
        // Create close button
        const closeSignupButton = document.createElement('div');
        closeSignupButton.innerHTML = '✕';
        closeSignupButton.style.cssText = `
            font-size: 20px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s ease;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        `;
        
        closeSignupButton.addEventListener('mouseenter', () => {
            closeSignupButton.style.color = 'white';
            closeSignupButton.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
        });
        
        closeSignupButton.addEventListener('mouseleave', () => {
            closeSignupButton.style.color = 'rgba(255, 255, 255, 0.7)';
            closeSignupButton.style.backgroundColor = 'transparent';
        });
        
        closeSignupButton.addEventListener('click', () => {
            document.body.removeChild(signupModal);
        });
        
        signupHeader.appendChild(signupTitle);
        signupHeader.appendChild(closeSignupButton);
        
        // Create signup form
        const signupForm = document.createElement('form');
        signupForm.style.cssText = `
            display: flex;
            flex-direction: column;
        `;
        
        // Name input
        const nameContainer = document.createElement('div');
        nameContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const nameLabel = document.createElement('label');
        nameLabel.textContent = 'Full Name';
        nameLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.placeholder = 'Enter your full name';
        nameInput.required = true;
        nameInput.style.cssText = `
            width: 100%;
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        `;
        
        nameContainer.appendChild(nameLabel);
        nameContainer.appendChild(nameInput);
        
        // Email input
        const emailContainer = document.createElement('div');
        emailContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const emailLabel = document.createElement('label');
        emailLabel.textContent = 'Email';
        emailLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        const emailInput = document.createElement('input');
        emailInput.type = 'email';
        emailInput.placeholder = 'Enter your email';
        emailInput.required = true;
        emailInput.style.cssText = `
            width: 100%;
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        `;
        
        emailContainer.appendChild(emailLabel);
        emailContainer.appendChild(emailInput);
        
        // Password input
        const passwordContainer = document.createElement('div');
        passwordContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const passwordLabel = document.createElement('label');
        passwordLabel.textContent = 'Password';
        passwordLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        const passwordInput = document.createElement('input');
        passwordInput.type = 'password';
        passwordInput.placeholder = 'Enter your password';
        passwordInput.required = true;
        passwordInput.style.cssText = `
            width: 100%;
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        `;
        
        passwordContainer.appendChild(passwordLabel);
        passwordContainer.appendChild(passwordInput);
        
        // Confirm password input
        const confirmPasswordContainer = document.createElement('div');
        confirmPasswordContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const confirmPasswordLabel = document.createElement('label');
        confirmPasswordLabel.textContent = 'Confirm Password';
        confirmPasswordLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        const confirmPasswordInput = document.createElement('input');
        confirmPasswordInput.type = 'password';
        confirmPasswordInput.placeholder = 'Confirm your password';
        confirmPasswordInput.required = true;
        confirmPasswordInput.style.cssText = `
            width: 100%;
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        `;
        
        confirmPasswordContainer.appendChild(confirmPasswordLabel);
        confirmPasswordContainer.appendChild(confirmPasswordInput);
        
        // Terms and conditions
        const termsContainer = document.createElement('div');
        termsContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const termsCheckbox = document.createElement('input');
        termsCheckbox.type = 'checkbox';
        termsCheckbox.id = 'terms';
        termsCheckbox.required = true;
        termsCheckbox.style.cssText = `
            margin-right: 8px;
        `;
        
        const termsLabel = document.createElement('label');
        termsLabel.htmlFor = 'terms';
        termsLabel.innerHTML = 'I agree to the <a href="#" style="color: #d93025;">Terms and Conditions</a>';
        termsLabel.style.cssText = `
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        termsContainer.appendChild(termsCheckbox);
        termsContainer.appendChild(termsLabel);
        
        // Sign up button
        const signupSubmitButton = document.createElement('button');
        signupSubmitButton.type = 'submit';
        signupSubmitButton.textContent = 'Sign Up';
        signupSubmitButton.style.cssText = `
            background-color: #d93025;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 0 10px rgba(0, 132, 255, 0.3);
            margin-bottom: 20px;
        `;
        
        signupSubmitButton.addEventListener('mouseenter', () => {
            signupSubmitButton.style.backgroundColor = '#0070e0';
            signupSubmitButton.style.boxShadow = '0 0 15px rgba(0, 132, 255, 0.5)';
        });
        
        signupSubmitButton.addEventListener('mouseleave', () => {
            signupSubmitButton.style.backgroundColor = '#d93025';
            signupSubmitButton.style.boxShadow = '0 0 10px rgba(0, 132, 255, 0.3)';
        });
        
        // Login link
        const loginContainer = document.createElement('div');
        loginContainer.style.cssText = `
            text-align: center;
            margin-top: 10px;
        `;
        
        const loginText = document.createElement('span');
        loginText.textContent = "Already have an account? ";
        loginText.style.cssText = `
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        `;
        
        const loginLink = document.createElement('a');
        loginLink.textContent = 'Login';
        loginLink.href = '#';
        loginLink.style.cssText = `
            font-size: 14px;
            color: #d93025;
            text-decoration: none;
            font-weight: 500;
        `;
        
        loginLink.addEventListener('click', (e) => {
            e.preventDefault();
            document.body.removeChild(signupModal);
            showLoginModal();
        });
        
        loginContainer.appendChild(loginText);
        loginContainer.appendChild(loginLink);
        
        // Error message container
        const errorMessage = document.createElement('div');
        errorMessage.style.cssText = `
            color: #ff4d4d;
            font-size: 14px;
            margin-top: 10px;
            text-align: center;
            display: none;
        `;
        
        // Assemble signup form
        signupForm.appendChild(nameContainer);
        signupForm.appendChild(emailContainer);
        signupForm.appendChild(passwordContainer);
        signupForm.appendChild(confirmPasswordContainer);
        signupForm.appendChild(termsContainer);
        signupForm.appendChild(signupSubmitButton);
        signupForm.appendChild(errorMessage);
        signupForm.appendChild(loginContainer);
        
        // Handle form submission
        signupForm.addEventListener('submit', (e) => {
            e.preventDefault();
            
            const name = nameInput.value;
            const email = emailInput.value;
            const password = passwordInput.value;
            const confirmPassword = confirmPasswordInput.value;
            const terms = termsCheckbox.checked;
            
            // Validate passwords match
            if (password !== confirmPassword) {
                errorMessage.textContent = 'Passwords do not match';
                errorMessage.style.display = 'block';
                return;
            }
            
            // Show loading state
            signupSubmitButton.textContent = 'Creating account...';
            signupSubmitButton.disabled = true;
            
            // Create user with Firebase
            auth.createUserWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    // Signed up successfully
                    const user = userCredential.user;
                    
                    // Update user profile with display name
                    return user.updateProfile({
                        displayName: name
                    }).then(() => {
                        document.body.removeChild(signupModal);
                        showNotification('Account created successfully');
                    });
                })
                .catch((error) => {
                    // Handle errors
                    const errorCode = error.code;
                    const errorText = getErrorMessage(errorCode);
                    
                    errorMessage.textContent = errorText;
                    errorMessage.style.display = 'block';
                    
                    // Reset button state
                    signupSubmitButton.textContent = 'Sign Up';
                    signupSubmitButton.disabled = false;
                });
        });
        
        // Assemble signup modal
        signupContainer.appendChild(signupHeader);
        signupContainer.appendChild(signupForm);
        signupModal.appendChild(signupContainer);
        
        // Add to document
        document.body.appendChild(signupModal);
        
        // Focus on name input
        setTimeout(() => {
            nameInput.focus();
        }, 100);
    }

    // Helper function to get user-friendly error messages
    function getErrorMessage(errorCode) {
        switch (errorCode) {
            case 'auth/email-already-in-use':
                return 'Email already in use';
            case 'auth/invalid-email':
                return 'Invalid email address';
            case 'auth/operation-not-allowed':
                return 'Operation not allowed';
            case 'auth/weak-password':
                return 'Password is too weak';
            case 'auth/user-disabled':
                return 'Account has been disabled';
            case 'auth/user-not-found':
                return 'No account found with this email';
            case 'auth/wrong-password':
                return 'Incorrect password';
            case 'auth/too-many-requests':
                return 'Too many requests. Try again later';
            case 'auth/network-request-failed':
                return 'Network error. Check your connection';
            default:
                return 'An error occurred. Please try again';
        }
    }

    // Helper function to show notifications
    function showNotification(message, type = 'success') {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: ${type === 'success' ? '#4caf50' : '#ff4d4d'};
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10003;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        // Fade in
        setTimeout(() => {
            notification.style.opacity = '1';
        }, 10);
        
        // Fade out and remove
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 300);
        }, 3000);
    }

    // Function to create toggle option
    function createToggleOption(label, description, defaultState) {
        const container = document.createElement('div');
        container.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const toggleContainer = document.createElement('div');
        toggleContainer.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
        `;
        
        const labelContainer = document.createElement('div');
        
        const toggleLabel = document.createElement('span');
        toggleLabel.textContent = label;
        toggleLabel.style.cssText = `
            font-size: 16px;
            font-weight: 500;
            color: white;
            display: block;
            margin-bottom: 4px;
        `;
        
        const toggleDescription = document.createElement('span');
        toggleDescription.textContent = description;
        toggleDescription.style.cssText = `
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            display: block;
        `;
        
        labelContainer.appendChild(toggleLabel);
        labelContainer.appendChild(toggleDescription);
        
        // Create toggle switch
        const toggleSwitch = document.createElement('label');
        toggleSwitch.style.cssText = `
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        `;
        
        const toggleInput = document.createElement('input');
        toggleInput.type = 'checkbox';
        toggleInput.style.cssText = `
            opacity: 0;
            width: 0;
            height: 0;
        `;
        toggleInput.checked = defaultState;
        
        const toggleSlider = document.createElement('span');
        toggleSlider.style.cssText = `
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
            border: 0.5px solid white;
        `;
        
        const toggleSliderBefore = document.createElement('span');
        toggleSliderBefore.style.cssText = `
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            border: 0.5px solid #d93025;
            box-shadow: 0 0 5px rgba(0, 132, 255, 0.5);
        `;
        
        toggleSlider.appendChild(toggleSliderBefore);
        toggleSwitch.appendChild(toggleInput);
        toggleSwitch.appendChild(toggleSlider);
        
        toggleContainer.appendChild(labelContainer);
        toggleContainer.appendChild(toggleSwitch);
        container.appendChild(toggleContainer);
        
        // Add event listener for toggle switch
        toggleInput.addEventListener('change', function() {
            if (this.checked) {
                toggleSlider.style.backgroundColor = '#d93025';
                toggleSliderBefore.style.transform = 'translateX(26px)';
                toggleSliderBefore.style.border = '0.5px solid white';
                toggleSliderBefore.style.boxShadow = '0 0 8px rgba(255, 255, 255, 0.7)';
            } else {
                toggleSlider.style.backgroundColor = '#ccc';
                toggleSliderBefore.style.transform = 'translateX(0)';
                toggleSliderBefore.style.border = '0.5px solid #d93025';
                toggleSliderBefore.style.boxShadow = '0 0 5px rgba(0, 132, 255, 0.5)';
            }
        });
        
        // Initialize toggle state
        if (toggleInput.checked) {
            toggleSlider.style.backgroundColor = '#d93025';
            toggleSliderBefore.style.transform = 'translateX(26px)';
            toggleSliderBefore.style.border = '0.5px solid white';
            toggleSliderBefore.style.boxShadow = '0 0 8px rgba(255, 255, 255, 0.7)';
        }
        
        return {
            container: container,
            input: toggleInput
        };
    }

    // Enhanced correction rules
    const correctionRules = [
        // Common spelling errors
        { pattern: /\bteh\b/gi, replacement: "the" },
        { pattern: /\btha\b/gi, replacement: "the" },
        { pattern: /\bthier\b/gi, replacement: "their" },
        { pattern: /\brecieve\b/gi, replacement: "receive" },
        { pattern: /\bseperate\b/gi, replacement: "separate" },
        { pattern: /\boccured\b/gi, replacement: "occurred" },
        { pattern: /\bdefinately\b/gi, replacement: "definitely" },
        { pattern: /\bgoverment\b/gi, replacement: "government" },
        { pattern: /\bexistance\b/gi, replacement: "existence" },
        { pattern: /\bneccessary\b/gi, replacement: "necessary" },
        { pattern: /\bembarass\b/gi, replacement: "embarrass" },
        { pattern: /\barguement\b/gi, replacement: "argument" },
        { pattern: /\bcomitted\b/gi, replacement: "committed" },
        { pattern: /\bconsious\b/gi, replacement: "conscious" },
        { pattern: /\bconcious\b/gi, replacement: "conscious" },
        { pattern: /\bfamilar\b/gi, replacement: "familiar" },
        { pattern: /\bimediately\b/gi, replacement: "immediately" },
        { pattern: /\bocasion\b/gi, replacement: "occasion" },
        { pattern: /\bpublically\b/gi, replacement: "publicly" },
        { pattern: /\brecomend\b/gi, replacement: "recommend" },
        { pattern: /\bsupercede\b/gi, replacement: "supersede" },
        { pattern: /\buntill\b/gi, replacement: "until" },
        { pattern: /\bwierd\b/gi, replacement: "weird" },
        
        // More spelling errors (abbreviated for space)
        { pattern: /\baccomodate\b/gi, replacement: "accommodate" },
        { pattern: /\bacheive\b/gi, replacement: "achieve" },
        { pattern: /\baccross\b/gi, replacement: "across" },
        { pattern: /\bagressive\b/gi, replacement: "aggressive" },
        { pattern: /\bapparant\b/gi, replacement: "apparent" },
        { pattern: /\bbegining\b/gi, replacement: "beginning" },
        { pattern: /\bbelive\b/gi, replacement: "believe" },
        { pattern: /\bbuisness\b/gi, replacement: "business" },
        { pattern: /\bcalender\b/gi, replacement: "calendar" },
        { pattern: /\bcollegue\b/gi, replacement: "colleague" },
        
        // Capitalization errors
        { pattern: /\bi\b/g, replacement: "I" },
        { pattern: /\bi'(\w)/gi, replacement: (match, p1) => `I'${p1}` },
        { pattern: /^(\s*)([a-z])/gm, replacement: (match, p1, p2) => `${p1}${p2.toUpperCase()}` },
        
        // Punctuation errors
        { pattern: /\.(\s*)([a-z])/g, replacement: (match, p1, p2) => `. ${p2.toUpperCase()}` },
        { pattern: /\?(\s*)([a-z])/g, replacement: (match, p1, p2) => `? ${p2.toUpperCase()}` },
        { pattern: /\!(\s*)([a-z])/g, replacement: (match, p1, p2) => `! ${p2.toUpperCase()}` },
        { pattern: /\s+([.!?])/g, replacement: "$1" },
        { pattern: /([.!?])(?=[a-zA-Z])/g, replacement: "$1 " },
        
        // Common word mistakes
        { pattern: /\bwhats\b/gi, replacement: "what's" },
        { pattern: /\byour\s+welcome\b/gi, replacement: "you're welcome" },
        { pattern: /\bit's\s+a\b/gi, replacement: "its a" },
        { pattern: /\byou're\s+a\b/gi, replacement: "your a" },
        { pattern: /\bto\s+be\s+continue\b/gi, replacement: "to be continued" },
        { pattern: /\balot\b/gi, replacement: "a lot" },
        { pattern: /\bcan\s+not\b/gi, replacement: "cannot" },
        { pattern: /\bevery\s+day\b/gi, replacement: "everyday" },
        { pattern: /\bin\s+to\b/gi, replacement: "into" },
        { pattern: /\bkind\s+of\b/gi, replacement: "kind of" },
        { pattern: /\bloose\b/gi, replacement: "lose" },
        
        // More common word mistakes (abbreviated for space)
        { pattern: /\baffect\b/gi, replacement: "effect" },
        { pattern: /\beffect\b/gi, replacement: "affect" },
        { pattern: /\baccept\b/gi, replacement: "except" },
        { pattern: /\bexcept\b/gi, replacement: "accept" },
        { pattern: /\badvice\b/gi, replacement: "advise" },
        { pattern: /\badvise\b/gi, replacement: "advice" },
        { pattern: /\baisle\b/gi, replacement: "isle" },
        { pattern: /\bisle\b/gi, replacement: "aisle" }
    ];

    // Enhanced text completion suggestions
    const completionSuggestions = {
        // Greetings
        "hello": [" there!", " world!", " everyone!", " how are you?"],
        "hi": [" there!", " everyone!", " how are you?"],
        "good morning": [",", " everyone", " sir", " ma'am"],
        "good afternoon": [",", " everyone", " sir", " ma'am"],
        "good evening": [",", " everyone", " sir", " ma'am"],
        
        // Gratitude
        "thank": [" you", " you very much", " you so much", " you for your time"],
        "thanks": [" for", [" everything", " your help", " your time"], " so much"],
        "i appreciate": [" it", [" your help", " your time", " your consideration"], " the opportunity"],
        
        // Common phrases
        "i think": [" that", [" so", " you should", " we should"], " it's important"],
        "i believe": [" that", [" so", " we can", " it will"], " in"],
        "i would": [" like to", [" recommend", " suggest", " know"], " appreciate it if"],
        "i will": [" be", [" there", " happy to", " in touch"], " let you know"],
        "i am": [" writing to", [" interested in", " looking for", " happy to"], " not sure"],
        
        // Business communication
        "please": [" let me know", [" send me", " help me", " advise me"], " find attached"],
        "could you": [" please", [" let me know", " send me", " advise me"], " clarify"],
        "would you": [" like to", [" be able to", " mind", " please"], " consider"],
        "looking forward": [" to", [" seeing you", " hearing from you", " it"], " our meeting"],
        "as soon as": [" possible", [" you can", " I get back"], " convenient"],
        
        // Closing phrases
        "best regards": [",", " to you", " and thanks"],
        "sincerely": [",", " yours", " thank you"],
        "yours truly": [",", " sincerely"],
        "kind regards": [",", " to you"],
        "many thanks": [" for", [" your help", " your time", " considering"], " in advance"],
        
        // Questions
        "how are": [" you", [" you doing", " things going"], " you feeling"],
        "what do": [" you think", [" you mean", " you suggest"], " you recommend"],
        "when can": [" we", [" you", " I", " they"], " we expect"],
        "where can": [" I", [" we", " you", " they"], " I find"],
        "why is": [" it", [" that", " this", " it important"], " it happening"],
        
        // Responses
        "i agree": [" with", [" you", " that", " your point"], " completely"],
        "i understand": [" that", [" your concern", " the situation"], " completely"],
        "i see": [" what", [" you mean", " you're saying", " the problem"]],
        "that makes": [" sense", [" perfect sense", " things clearer"], " me wonder"],
        
        // Common expressions
        "by the": [" way", [" end of", " time", " way"]],
        "on the": [" other hand", [" phone", " way", " same page"]],
        "in the": [" meantime", [" beginning", " end", " morning"]],
        "at the": [" moment", [" same time", " end", " beginning"]],
        "for the": [" first time", [" most part", " time being", " record"]],
        
        // Time expressions
        "see you": [" soon", [" later", " tomorrow", " next week"]],
        "talk to": [" you", [" you soon", " you later", " me"]],
        "have a": [" great day", [" good one", " nice weekend", " question"]],
        "take": [" care", [" your time", " a look", " it easy"]],
        
        // Problem solving
        "the problem": [" is", [" with", " that", " we're facing"]],
        "the issue": [" is", [" with", " that", " we're having"]],
        "we need": [" to", [" fix this", " resolve this", " find a solution"]],
        "i suggest": [" that", [" we", " you", " trying"]],
        
        // More completions
        "it is": [" important", [" necessary", " good to", " crucial"]],
        "that is": [" why", [" what", " how", " when"]],
        "this is": [" a", [" great", " good", " perfect"]],
        "there is": [" a", [" problem", " solution", " way"]],
        "we are": [" working", [" on it", " together", " to resolve"]],
        "they are": [" going", [" to", " be there", " help us"]],
        "you are": [" right", [" welcome", " the best", " correct"]],
        
        // Questions and responses
        "do you": [" want", [" to", " know", " understand"]],
        "can you": [" help", [" me", " us", " with this"]],
        "will you": [" be", [" there", " able to", " available"]],
        "are you": [" sure", [" going", " coming", " available"]],
        "is there": [" a", [" way", " problem", " solution"]],
        
        // Conditional phrases
        "if you": [" need", [" help", " more information", " assistance"]],
        "if we": [" can", [" help", " do anything", " assist"]],
        "if they": [" want", [" to", " help", " participate"]],
        "when you": [" have", [" time", " a moment", " questions"]],
        "when we": [" meet", [" again", " tomorrow", " next week"]],
        
        // Conjunctions and transitions
        "in addition": [" to", [" that", " this", "the above"]],
        "on the other": [" hand", [" side", " end"]],
        "as a": [" result", [" matter of fact", " consequence"]],
        "in order": [" to", [" succeed", " understand", " proceed"]],
        "even though": [" it", [" seems", " is difficult", " may seem"]],
        
        // Common phrases
        "let me": [" know", [" you know", " explain", " show you"]],
        "give me": [" a", [" call", " moment", " break"]],
        "tell me": [" what", [" you think", " to do", " happened"]],
        "show me": [" how", [" to do it", " it works", " you did"]],
        
        // Agreement and disagreement
        "i completely": [" agree", [" understand", " disagree"]],
        "i totally": [" agree", [" understand", " disagree"]],
        "i partially": [" agree", [" disagree", " understand"]],
        "i somewhat": [" agree", [" disagree", " understand"]],
        
        // Requests and offers
        "would you": [" mind", [" helping", " explaining", " waiting"]],
        "could you": [" possibly", [" help", " explain", " assist"]],
        "do you": [" mind", [" if I", " helping", " waiting"]],
        "can I": [" help", [" you", " with that", " in any way"]],
        
        // Time and scheduling
        "what time": [" is", [" it", " the meeting", " good for you"]],
        "what day": [" works", [" best", " for you", " for everyone"]],
        "how about": [" tomorrow", [" next week", " later today"]],
        "is that": [" good", [" for you", " convenient", " okay"]],
        
        // Expressions of uncertainty
        "i'm not": [" sure", [" what", " when", " how"]],
        "i don't": [" know", [" what", " when", " how"]],
        "i'm not": [" certain", [" about", " that", " this"]],
        "it might": [" be", [" difficult", " easy", " possible"]],
        
        // Expressions of certainty
        "i'm": [" sure", [" that", " about", " it will"]],
        "i know": [" that", [" what", " when", " how"]],
        "i'm": [" certain", [" about", " that", " this"]],
        "it will": [" be", [" great", " good", " successful"]],
        
        // More completions
        "it seems": [" like", [" you", " it", " that"]],
        "it looks": [" like", [" you", " it", " that"]],
        "it sounds": [" like", [" you", " it", " a plan"]],
        "it feels": [" like", [" you", " it", " a good idea"]],
        
        // Directions and instructions
        "go to": [" the", [" left", "right", "next page"]],
        "turn": [" left", ["right", "around", "it off"]],
        "look at": [" the", ["screen", "document", "picture"]],
        "click on": [" the", ["button", "link", "image"]],
        
        // Technology terms
        "the website": [" is", ["down", "not working", "loading slowly"]],
        "my computer": [" is", ["slow", "not working", "crashing"]],
        "the internet": [" is", ["slow", "not working", "down"]],
        "my phone": [" is", ["dead", "not working", "broken"]],
        
        // Work-related
        "the meeting": [" is", ["at", "scheduled for", "postponed until"]],
        "my boss": [" wants", ["to", "me to", "us to"]],
        "the deadline": [" is", ["approaching", "tomorrow", "extended"]],
        "the project": [" is", ["complete", "almost done", "delayed"]],
        
        // Personal
        "my family": [" is", ["great", "doing well", "visiting"]],
        "my friends": [" are", ["great", "coming over", "helping"]],
        "my health": [" is", ["improving", "good", "not great"]],
        "my car": [" is", ["broken", "running well", "in the shop"]],
        
        // Travel
        "the flight": [" is", ["delayed", "on time", "cancelled"]],
        "my hotel": [" is", ["nice", "close by", "booked"]],
        "the restaurant": [" is", ["good", "close by", "expensive"]],
        "the weather": [" is", ["nice", "terrible", "improving"]],
        
        // Education
        "the class": [" is", ["interesting", "difficult", "boring"]],
        "my teacher": [" is", ["great", "strict", "helpful"]],
        "the homework": [" is", ["due", "difficult", "easy"]],
        "the exam": [" is", ["tomorrow", "difficult", "important"]],
        
        // Shopping
        "the store": [" is", ["closed", "open", "far away"]],
        "the price": [" is", ["too high", "reasonable", "good"]],
        "my order": [" is", ["late", "ready", "cancelled"]],
        "the product": [" is", ["good", "broken", "not what I expected"]]
    };

    // Function to apply settings immediately
    function applySettings() {
        // Update global variables
        emotionSystem.wordsEffectEnabled = emotionWordsEffectEnabled;
        
        // Apply to all message inputs
        const messageInputs = document.querySelectorAll('input[type="text"], input[type="search"], textarea');
        messageInputs.forEach(input => {
            // Clone the input to remove all event listeners
            const newInput = input.cloneNode(true);
            input.parentNode.replaceChild(newInput, input);
            
            // Re-apply the auto-correction and text completion
            setupAutoCorrection(newInput);
            
            // Re-apply emotion detection
            setupEmotionDetection(newInput);
        });
    }

    // Function to initialize auto-correction and text completion
    function initializeAutoCorrectionAndCompletion() {
        // Load settings from localStorage
        const savedAutoCorrect = localStorage.getItem('autoCorrectEnabled');
        const savedTextCompletion = localStorage.getItem('textCompletionEnabled');
        
        if (savedAutoCorrect !== null) {
            autoCorrectEnabled = savedAutoCorrect === 'true';
        }
        
        if (savedTextCompletion !== null) {
            textCompletionEnabled = savedTextCompletion === 'true';
        }
        
        // Function to set up auto-correction and text completion on an input element
        function setupAutoCorrection(inputElement) {
            if (!inputElement) return;
            
            // Create a suggestions container for text completion
            const suggestionsContainer = document.createElement('div');
            suggestionsContainer.style.cssText = `
                position: absolute;
                background-color: rgba(30, 30, 40, 0.95);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 1000;
                display: none;
                max-height: 200px;
                overflow-y: auto;
                color: white;
                font-family: Arial, sans-serif;
            `;
            
            // Position the suggestions container relative to the input
            function positionSuggestions() {
                const rect = inputElement.getBoundingClientRect();
                suggestionsContainer.style.top = `${rect.bottom + window.scrollY}px`;
                suggestionsContainer.style.left = `${rect.left + window.scrollX}px`;
                suggestionsContainer.style.width = `${rect.width}px`;
            }
            
            // Add the suggestions container to the document
            document.body.appendChild(suggestionsContainer);
            
            // Store the current suggestion index
            let currentSuggestionIndex = -1;
            let currentSuggestions = [];
            
            // Handle input events
            inputElement.addEventListener('input', function(e) {
                // Skip if input is disabled (not logged in)
                if (inputElement.disabled) return;
                
                const input = e.target;
                const originalValue = input.value;
                let cursorPosition = input.selectionStart;
                let correctedValue = originalValue;
                
                // Apply auto-correction if enabled
                if (autoCorrectEnabled) {
                    // Apply all correction rules
                    for (const rule of correctionRules) {
                        correctedValue = correctedValue.replace(rule.pattern, rule.replacement);
                    }
                    
                    // Update input if corrections were made
                    if (correctedValue !== originalValue) {
                        input.value = correctedValue;
                        
                        // Adjust cursor position based on text length change
                        const diff = correctedValue.length - originalValue.length;
                        input.selectionStart = cursorPosition + diff;
                        input.selectionEnd = cursorPosition + diff;
                    }
                }
                
                // Show text completion suggestions if enabled
                if (textCompletionEnabled) {
                    if (input.value.trim() !== '') {
                        showCompletionSuggestions(input.value);
                    } else {
                        suggestionsContainer.style.display = 'none';
                    }
                } else {
                    suggestionsContainer.style.display = 'none';
                }
            });
            
            // Handle keyboard events for suggestion navigation
            inputElement.addEventListener('keydown', function(e) {
                // Skip if input is disabled (not logged in)
                if (inputElement.disabled) return;
                
                if (suggestionsContainer.style.display === 'none' || currentSuggestions.length === 0) {
                    return;
                }
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    currentSuggestionIndex = Math.min(currentSuggestionIndex + 1, currentSuggestions.length - 1);
                    updateSuggestionHighlight();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    currentSuggestionIndex = Math.max(currentSuggestionIndex - 1, -1);
                    updateSuggestionHighlight();
                } else if (e.key === 'Enter' || e.key === 'Tab') {
                    if (currentSuggestionIndex >= 0 && currentSuggestionIndex < currentSuggestions.length) {
                        e.preventDefault();
                        applySuggestion(currentSuggestions[currentSuggestionIndex]);
                    }
                } else if (e.key === 'Escape') {
                    suggestionsContainer.style.display = 'none';
                    currentSuggestionIndex = -1;
                }
            });
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (e.target !== inputElement && !suggestionsContainer.contains(e.target)) {
                    suggestionsContainer.style.display = 'none';
                    currentSuggestionIndex = -1;
                }
            });
            
            // Function to show completion suggestions
            function showCompletionSuggestions(text) {
                const words = text.toLowerCase().split(' ');
                const lastWord = words[words.length - 1];
                const lastTwoWords = words.length > 1 ? words[words.length - 2] + ' ' + lastWord : '';
                const lastThreeWords = words.length > 2 ? words[words.length - 3] + ' ' + words[words.length - 2] + ' ' + lastWord : '';
                
                currentSuggestions = [];
                suggestionsContainer.innerHTML = '';
                
                // Check for suggestions based on the last three words, then two words, then one word
                if (completionSuggestions[lastThreeWords]) {
                    const suggestions = completionSuggestions[lastThreeWords];
                    addSuggestions(suggestions, lastThreeWords);
                } else if (completionSuggestions[lastTwoWords]) {
                    const suggestions = completionSuggestions[lastTwoWords];
                    addSuggestions(suggestions, lastTwoWords);
                } else if (completionSuggestions[lastWord]) {
                    const suggestions = completionSuggestions[lastWord];
                    addSuggestions(suggestions, lastWord);
                }
                
                if (currentSuggestions.length > 0) {
                    positionSuggestions();
                    suggestionsContainer.style.display = 'block';
                    currentSuggestionIndex = -1;
                } else {
                    suggestionsContainer.style.display = 'none';
                }
            }
            
            // Function to add suggestions to the container
            function addSuggestions(suggestions, prefix) {
                for (let i = 0; i < suggestions.length; i++) {
                    let suggestion;
                    if (Array.isArray(suggestions[i])) {
                        // If it's an array of alternatives, pick one randomly
                        suggestion = suggestions[i][Math.floor(Math.random() * suggestions[i].length)];
                    } else {
                        suggestion = suggestions[i];
                    }
                    
                    const suggestionElement = document.createElement('div');
                    suggestionElement.textContent = prefix + suggestion;
                    suggestionElement.style.cssText = `
                        padding: 8px 12px;
                        cursor: pointer;
                        transition: background-color 0.2s ease;
                    `;
                    
                    suggestionElement.addEventListener('mouseenter', function() {
                        this.style.backgroundColor = 'rgba(0, 132, 255, 0.3)';
                        currentSuggestionIndex = currentSuggestions.indexOf(suggestion);
                        updateSuggestionHighlight();
                    });
                    
                    suggestionElement.addEventListener('mouseleave', function() {
                        this.style.backgroundColor = 'transparent';
                    });
                    
                    suggestionElement.addEventListener('click', function() {
                        applySuggestion(suggestion);
                    });
                    
                    suggestionsContainer.appendChild(suggestionElement);
                    currentSuggestions.push(suggestion);
                }
            }
            
            // Function to update suggestion highlight
            function updateSuggestionHighlight() {
                const suggestionElements = suggestionsContainer.querySelectorAll('div');
                suggestionElements.forEach((element, index) => {
                    if (index === currentSuggestionIndex) {
                        element.style.backgroundColor = 'rgba(0, 132, 255, 0.5)';
                    } else {
                        element.style.backgroundColor = 'transparent';
                    }
                });
            }
            
            // Function to apply a suggestion
            function applySuggestion(suggestion) {
                const words = inputElement.value.split(' ');
                
                // Check if we have a three-word prefix
                if (words.length > 2) {
                    const lastThreeWords = words[words.length - 3] + ' ' + words[words.length - 2] + ' ' + words[words.length - 1];
                    if (completionSuggestions[lastThreeWords]) {
                        words[words.length - 3] = lastThreeWords + suggestion;
                        words.pop(); // Remove the last word
                        words.pop(); // Remove the second last word
                    } 
                    // Check if we have a two-word prefix
                    else if (words.length > 1) {
                        const lastTwoWords = words[words.length - 2] + ' ' + words[words.length - 1];
                        if (completionSuggestions[lastTwoWords]) {
                            words[words.length - 2] = lastTwoWords + suggestion;
                            words.pop(); // Remove the last word as it's included in the suggestion
                        } else {
                            // Otherwise, replace just the last word
                            words[words.length - 1] = words[words.length - 1] + suggestion;
                        }
                    } else {
                        // If there's only one word, append the suggestion to it
                        words[0] = words[0] + suggestion;
                    }
                } 
                // Check if we have a two-word prefix
                else if (words.length > 1) {
                    const lastTwoWords = words[words.length - 2] + ' ' + words[words.length - 1];
                    if (completionSuggestions[lastTwoWords]) {
                        words[words.length - 2] = lastTwoWords + suggestion;
                        words.pop(); // Remove the last word as it's included in the suggestion
                    } else {
                        // Otherwise, replace just the last word
                        words[words.length - 1] = words[words.length - 1] + suggestion;
                    }
                } else {
                    // If there's only one word, append the suggestion to it
                    words[0] = words[0] + suggestion;
                }
                
                inputElement.value = words.join(' ');
                suggestionsContainer.style.display = 'none';
                currentSuggestionIndex = -1;
                inputElement.focus();
            }
        }

        // Apply auto-correction and text completion to all message inputs
        const messageInputs = document.querySelectorAll('input[type="text"], input[type="search"], textarea');
        messageInputs.forEach(input => {
            setupAutoCorrection(input);
        });

        // Also apply to any dynamically added inputs
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.nodeType === 1) { // Element node
                        if (node.matches('input[type="text"], input[type="search"], textarea')) {
                            setupAutoCorrection(node);
                        }
                        
                        // Check child nodes
                        const inputs = node.querySelectorAll('input[type="text"], input[type="search"], textarea');
                        inputs.forEach(input => {
                            setupAutoCorrection(input);
                        });
                    }
                });
            });
        });

        // Start observing the document body for added nodes
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }
    
    // Emotion Detection System with Animations
    const emotionSystem = {
        // List of happy words to detect
        happyWords: [
            // English happy words
            "happy", "joy", "joyful", "cheerful", "delighted", "pleased", "glad", "content",
            "satisfied", "excited", "thrilled", "ecstatic", "euphoric", "blissful", "elated",
            "jubilant", "merry", "gleeful", "exuberant", "enthusiastic", "optimistic", "positive",
            "wonderful", "amazing", "fantastic", "excellent", "great", "awesome", "brilliant",
            "love", "lovely", "beautiful", "blessed", "grateful", "thankful", "appreciate",
            "smile", "laugh", "laughter", "giggle", "chuckle", "haha", "hahaha",
            
            // Tamil happy words
            "santhosham", "magizhchi", "inbam", "kaviyam", "aasai", "paarvai", "sugam",
            "anandam", "santhosha", "magizhchiyaga", "inbamaga", "kaapi", "kavithai",
            "sirippu", "naagu", "kalakkal", "thiruppi", "vasanam", "malar", "malarndhu",
            
            // Common variations
            "santhoshaa", "magizhchii", "inbaa", "anandha", "sirippa", "naaguga",
            "happier", "happiest", "happiness", "joyfully", "haha", "lol", "lmao"
        ],
        
        // List of sad words to detect
        sadWords: [
            // English sad words
            "sad", "unhappy", "sorrowful", "miserable", "depressed", "downcast", "gloomy",
            "melancholy", "dejected", "disappointed", "discouraged", "disheartened", "despondent",
            "grief", "grieving", "heartbroken", "devastated", "crushed", "upset", "distressed",
            "mournful", "somber", "blue", "down", "low", "unfortunate", "tragic", "tragedy",
            "cry", "crying", "tears", "weeping", "sobbing", "sob", "wailing", "wail",
            
            // Tamil sad words
            "kaashtam", "kaanam", "kaanal", "sokam", "manam", "nodu", "niraiyam", "pagal",
            "iruttam", "vali", "payanam", "kadal", "neeram", "mugam", "mugathai", "kaanam",
            "kaanal", "sogam", "sogama", "kaanama", "irukka", "vendum", "sollu", "sollum",
            "kannam", "kannal", "kannama", "irukka", "vendum", "sollu", "sollum",
            
            // Common variations
            "sadness", "sadly", "sadder", "saddest", "unhappily", "miserably", "depressing",
            "disappointing", "heartbreak", "heartbroken", "tearful", "tearfully", "weeping"
        ],
        
        // Track emotion usage
        emotionCount: 0,
        lastEmotionWords: [],
        lastEmotionCheckTime: 0,
        animationActive: false,
        wordsEffectEnabled: true, // Toggle for words effect
        
        // Method to check if a message contains happy words
        containsHappyWords: function(message) {
            if (!message || typeof message !== 'string') return false;
            
            const lowerCaseMessage = message.toLowerCase();
            
            // Check for exact matches
            for (const word of this.happyWords) {
                if (lowerCaseMessage.includes(word.toLowerCase())) {
                    return true;
                }
            }
            
            // Check for variations with special characters or spaces
            for (const word of this.happyWords) {
                // Create regex pattern to match variations with special characters
                const pattern = new RegExp(
                    word.split('').join('[\\s\\W]*') + '\\w*', 
                    'i'
                );
                
                if (pattern.test(lowerCaseMessage)) {
                    return true;
                }
            }
            
            return false;
        },
        
        // Method to check if a message contains sad words
        containsSadWords: function(message) {
            if (!message || typeof message !== 'string') return false;
            
            const lowerCaseMessage = message.toLowerCase();
            
            // Check for exact matches
            for (const word of this.sadWords) {
                if (lowerCaseMessage.includes(word.toLowerCase())) {
                    return true;
                }
            }
            
            // Check for variations with special characters or spaces
            for (const word of this.sadWords) {
                // Create regex pattern to match variations with special characters
                const pattern = new RegExp(
                    word.split('').join('[\\s\\W]*') + '\\w*', 
                    'i'
                );
                
                if (pattern.test(lowerCaseMessage)) {
                    return true;
                }
            }
            
            return false;
        },
        
        // Method to get a list of detected happy words
        getDetectedHappyWords: function(message) {
            if (!message || typeof message !== 'string') return [];
            
            const detectedWords = [];
            const lowerCaseMessage = message.toLowerCase();
            
            for (const word of this.happyWords) {
                if (lowerCaseMessage.includes(word.toLowerCase())) {
                    detectedWords.push(word);
                }
                
                // Check for variations with special characters
                const pattern = new RegExp(
                    word.split('').join('[\\s\\W]*') + '\\w*', 
                    'i'
                );
                
                if (pattern.test(lowerCaseMessage)) {
                    if (!detectedWords.includes(word)) {
                        detectedWords.push(word);
                    }
                }
            }
            
            return [...new Set(detectedWords)]; // Remove duplicates
        },
        
        // Method to get a list of detected sad words
        getDetectedSadWords: function(message) {
            if (!message || typeof message !== 'string') return [];
            
            const detectedWords = [];
            const lowerCaseMessage = message.toLowerCase();
            
            for (const word of this.sadWords) {
                if (lowerCaseMessage.includes(word.toLowerCase())) {
                    detectedWords.push(word);
                }
                
                // Check for variations with special characters
                const pattern = new RegExp(
                    word.split('').join('[\\s\\W]*') + '\\w*', 
                    'i'
                );
                
                if (pattern.test(lowerCaseMessage)) {
                    if (!detectedWords.includes(word)) {
                        detectedWords.push(word);
                    }
                }
            }
            
            return [...new Set(detectedWords)]; // Remove duplicates
        },
        
        // Method to show happy animation
        showHappyAnimation: function() {
            if (this.animationActive || !this.wordsEffectEnabled) return;
            
            this.animationActive = true;
            console.log("Showing happy animation");
            
            // Remove any existing emotion animation
            const existingAnimation = document.getElementById('emotion-animation');
            if (existingAnimation) {
                existingAnimation.remove();
            }
            
            // Create happy animation container
            const happyContainer = document.createElement('div');
            happyContainer.id = 'emotion-animation';
            happyContainer.style.position = 'fixed';
            happyContainer.style.top = '0';
            happyContainer.style.left = '0';
            happyContainer.style.width = '100%';
            happyContainer.style.height = '100%';
            happyContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            happyContainer.style.zIndex = '9998';
            happyContainer.style.display = 'flex';
            happyContainer.style.flexDirection = 'column';
            happyContainer.style.justifyContent = 'center';
            happyContainer.style.alignItems = 'center';
            happyContainer.style.color = 'white';
            happyContainer.style.textAlign = 'center';
            happyContainer.style.padding = '20px';
            happyContainer.style.pointerEvents = 'none'; // Allow clicking through
            happyContainer.style.opacity = '0';
            happyContainer.style.transition = 'opacity 0.3s ease-in-out'; // Faster transition
            
            // Create happy emoji animation
            const emojiContainer = document.createElement('div');
            emojiContainer.style.fontSize = '5rem';
            emojiContainer.style.marginBottom = '20px';
            emojiContainer.style.animation = 'bounce 0.8s infinite alternate'; // Faster animation
            
            // Random happy emoji
            const happyEmojis = ['😊', '😄', '😃', '🤗', '😁', '🥰', '😍', '🤩', '🥳', '😂', '🤣'];
            const randomEmoji = happyEmojis[Math.floor(Math.random() * happyEmojis.length)];
            emojiContainer.textContent = randomEmoji;
            
            // Create happy message
            const happyMessage = document.createElement('div');
            happyMessage.innerHTML = `
                <h1 style="color: #FFD700; margin-bottom: 20px; font-size: 2.5em; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px #FFD700;">HAPPY DETECTED!</h1>
                <p style="color: #ffffff; font-size: 1.5em; margin-bottom: 20px; text-shadow: 0 0 5px #FFD700;">We detected happy words in your message!</p>
                <p style="color: #ffffff; font-size: 1.2em; margin-bottom: 30px; text-shadow: 0 0 5px #FFD700;">Keep spreading positivity and joy!</p>
            `;
            
            // Add CSS animation for bouncing
            const style = document.createElement('style');
            style.textContent = `
                @keyframes bounce {
                    0% { transform: translateY(0); }
                    100% { transform: translateY(-20px); }
                }
                
                @keyframes sparkle {
                    0% { opacity: 0; transform: scale(0) rotate(0deg); }
                    50% { opacity: 1; transform: scale(1) rotate(180deg); }
                    100% { opacity: 0; transform: scale(0) rotate(360deg); }
                }
                
                .sparkle {
                    position: absolute;
                    width: 10px;
                    height: 10px;
                    background-color: #FFD700;
                    border-radius: 50%;
                    animation: sparkle 1s ease-in-out; // Faster animation
                }
            `;
            document.head.appendChild(style);
            
            // Create sparkles around the emoji
            const createSparkles = () => {
                for (let i = 0; i < 8; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    
                    // Random position around the emoji
                    const angle = (Math.PI * 2 * i) / 8;
                    const distance = 80;
                    const x = Math.cos(angle) * distance;
                    const y = Math.sin(angle) * distance;
                    
                    sparkle.style.left = `calc(50% + ${x}px)`;
                    sparkle.style.top = `calc(50% + ${y}px)`;
                    sparkle.style.transform = 'translate(-50%, -50%)';
                    
                    happyContainer.appendChild(sparkle);
                    
                    // Remove sparkle after animation completes
                    setTimeout(() => {
                        if (sparkle.parentNode) {
                            sparkle.parentNode.removeChild(sparkle);
                        }
                    }, 1000); // Faster removal
                }
            };
            
            // Add elements to container
            happyContainer.appendChild(emojiContainer);
            happyContainer.appendChild(happyMessage);
            document.body.appendChild(happyContainer);
            
            // Fade in immediately
            happyContainer.style.opacity = '1';
            
            // Create sparkles
            createSparkles();
            
            // Create sparkles again after a delay
            setTimeout(createSparkles, 500); // Faster delay
            
            // Auto-remove after 2.5 seconds
            setTimeout(() => {
                happyContainer.style.opacity = '0';
                setTimeout(() => {
                    if (happyContainer.parentNode) {
                        happyContainer.parentNode.removeChild(happyContainer);
                    }
                    this.animationActive = false;
                }, 300); // Faster transition
            }, 2500); // Shorter display time
        },
        
        // Method to show sad animation
        showSadAnimation: function() {
            if (this.animationActive || !this.wordsEffectEnabled) return;
            
            this.animationActive = true;
            console.log("Showing sad animation");
            
            // Remove any existing emotion animation
            const existingAnimation = document.getElementById('emotion-animation');
            if (existingAnimation) {
                existingAnimation.remove();
            }
            
            // Create sad animation container
            const sadContainer = document.createElement('div');
            sadContainer.id = 'emotion-animation';
            sadContainer.style.position = 'fixed';
            sadContainer.style.top = '0';
            sadContainer.style.left = '0';
            sadContainer.style.width = '100%';
            sadContainer.style.height = '100%';
            sadContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            sadContainer.style.zIndex = '9998';
            sadContainer.style.display = 'flex';
            sadContainer.style.flexDirection = 'column';
            sadContainer.style.justifyContent = 'center';
            sadContainer.style.alignItems = 'center';
            sadContainer.style.color = 'white';
            sadContainer.style.textAlign = 'center';
            sadContainer.style.padding = '20px';
            sadContainer.style.pointerEvents = 'none'; // Allow clicking through
            sadContainer.style.opacity = '0';
            sadContainer.style.transition = 'opacity 0.3s ease-in-out'; // Faster transition
            
            // Create sad emoji animation
            const emojiContainer = document.createElement('div');
            emojiContainer.style.fontSize = '5rem';
            emojiContainer.style.marginBottom = '20px';
            emojiContainer.style.animation = 'teardrop 1.5s infinite'; // Faster animation
            
            // Random sad emoji
            const sadEmojis = ['😢', '😭', '😔', '😞', '😟', '😪', '😥', '😿', '💔'];
            const randomEmoji = sadEmojis[Math.floor(Math.random() * sadEmojis.length)];
            emojiContainer.textContent = randomEmoji;
            
            // Create sad message
            const sadMessage = document.createElement('div');
            sadMessage.innerHTML = `
                <h1 style="color: #4169E1; margin-bottom: 20px; font-size: 2.5em; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px #4169E1;">SAD DETECTED</h1>
                <p style="color: #ffffff; font-size: 1.5em; margin-bottom: 20px; text-shadow: 0 0 5px #4169E1;">We detected sad words in your message.</p>
                <p style="color: #ffffff; font-size: 1.2em; margin-bottom: 30px; text-shadow: 0 0 5px #4169E1;">Remember, tough times don't last, but tough people do.</p>
            `;
            
            // Add CSS animation for teardrop
            const style = document.createElement('style');
            style.textContent = `
                @keyframes teardrop {
                    0% { transform: translateY(0); }
                    50% { transform: translateY(10px); }
                    100% { transform: translateY(0); }
                }
                
                @keyframes tear {
                    0% { opacity: 0; transform: translateY(0) scale(0); }
                    50% { opacity: 1; transform: translateY(20px) scale(1); }
                    100% { opacity: 0; transform: translateY(40px) scale(0.5); }
                }
                
                .tear {
                    position: absolute;
                    width: 8px;
                    height: 12px;
                    background-color: #4169E1;
                    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
                    animation: tear 1.5s ease-in-out; // Faster animation
                }
            `;
            document.head.appendChild(style);
            
            // Create tears around the emoji
            const createTears = () => {
                for (let i = 0; i < 5; i++) {
                    const tear = document.createElement('div');
                    tear.className = 'tear';
                    
                    // Random position around the emoji
                    const angle = (Math.PI * 2 * i) / 5;
                    const distance = 60;
                    const x = Math.cos(angle) * distance;
                    const y = Math.sin(angle) * distance;
                    
                    tear.style.left = `calc(50% + ${x}px)`;
                    tear.style.top = `calc(50% + ${y}px)`;
                    tear.style.transform = 'translate(-50%, -50%)';
                    
                    sadContainer.appendChild(tear);
                    
                    // Remove tear after animation completes
                    setTimeout(() => {
                        if (tear.parentNode) {
                            tear.parentNode.removeChild(tear);
                        }
                    }, 1500); // Faster removal
                }
            };
            
            // Add elements to container
            sadContainer.appendChild(emojiContainer);
            sadContainer.appendChild(sadMessage);
            document.body.appendChild(sadContainer);
            
            // Fade in immediately
            sadContainer.style.opacity = '1';
            
            // Create tears
            createTears();
            
            // Create tears again after a delay
            setTimeout(createTears, 750); // Faster delay
            
            // Auto-remove after 2.5 seconds
            setTimeout(() => {
                sadContainer.style.opacity = '0';
                setTimeout(() => {
                    if (sadContainer.parentNode) {
                        sadContainer.parentNode.removeChild(sadContainer);
                    }
                    this.animationActive = false;
                }, 300); // Faster transition
            }, 2500); // Shorter display time
        },
        
        // Method to check for emotions as user types
        checkForEmotionsOnType: function(inputElement) {
            if (!inputElement) return;
            
            const message = inputElement.value.trim();
            const now = Date.now();
            
            // Check if the current input contains happy words
            if (message && this.containsHappyWords(message)) {
                // Get the current happy words in the message
                const currentHappyWords = this.getDetectedHappyWords(message);
                
                // Check if this is a new set of happy words (not just continuing to type the same happy words)
                const isNewHappyWordSet = currentHappyWords.some(word => !this.lastEmotionWords.includes(word));
                
                // Only trigger animation if it's been at least 5 seconds since the last check
                // AND there's at least one new happy word
                if (isNewHappyWordSet && (now - this.lastEmotionCheckTime) > 5000) {
                    // Show happy animation
                    this.showHappyAnimation();
                    
                    // Update the last emotion words and check time
                    this.lastEmotionWords = currentHappyWords;
                    this.lastEmotionCheckTime = now;
                }
            }
            // Check if the current input contains sad words
            else if (message && this.containsSadWords(message)) {
                // Get the current sad words in the message
                const currentSadWords = this.getDetectedSadWords(message);
                
                // Check if this is a new set of sad words (not just continuing to type the same sad words)
                const isNewSadWordSet = currentSadWords.some(word => !this.lastEmotionWords.includes(word));
                
                // Only trigger animation if it's been at least 5 seconds since the last check
                // AND there's at least one new sad word
                if (isNewSadWordSet && (now - this.lastEmotionCheckTime) > 5000) {
                    // Show sad animation
                    this.showSadAnimation();
                    
                    // Update the last emotion words and check time
                    this.lastEmotionWords = currentSadWords;
                    this.lastEmotionCheckTime = now;
                }
            } else {
                // Reset the last emotion words if no emotion words
                this.lastEmotionWords = [];
            }
        },
        
        // Method to add a visual indicator for emotion words
        highlightEmotionWords: function(inputElement) {
            if (!inputElement) return;
            
            const message = inputElement.value;
            const detectedHappyWords = this.getDetectedHappyWords(message);
            const detectedSadWords = this.getDetectedSadWords(message);
            
            // Remove any existing indicator
            const existingIndicator = document.getElementById('emotion-words-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            // Only show indicators if words effect is enabled
            if (this.wordsEffectEnabled) {
                if (detectedHappyWords.length > 0) {
                    // Add a visual indicator for happy words
                    inputElement.style.borderColor = '#FFD700';
                    inputElement.style.boxShadow = '0 0 5px rgba(255, 215, 0, 0.5)';
                    
                    // Add a small indicator
                    let indicator = document.getElementById('emotion-words-indicator');
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.id = 'emotion-words-indicator';
                        indicator.style.position = 'absolute';
                        indicator.style.top = '-25px';
                        indicator.style.right = '0';
                        indicator.style.backgroundColor = '#FFD700';
                        indicator.style.color = '#333';
                        indicator.style.padding = '2px 8px';
                        indicator.style.borderRadius = '10px';
                        indicator.style.fontSize = '12px';
                        indicator.style.fontWeight = 'bold';
                        
                        // Make sure the parent element has position relative
                        if (inputElement.parentElement.style.position !== 'relative') {
                            inputElement.parentElement.style.position = 'relative';
                        }
                        
                        inputElement.parentElement.appendChild(indicator);
                    }
                    
                    indicator.textContent = `${detectedHappyWords.length} happy word(s) detected`;
                } else if (detectedSadWords.length > 0) {
                    // Add a visual indicator for sad words
                    inputElement.style.borderColor = '#4169E1';
                    inputElement.style.boxShadow = '0 0 5px rgba(65, 105, 225, 0.5)';
                    
                    // Add a small indicator
                    let indicator = document.getElementById('emotion-words-indicator');
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.id = 'emotion-words-indicator';
                        indicator.style.position = 'absolute';
                        indicator.style.top = '-25px';
                        indicator.style.right = '0';
                        indicator.style.backgroundColor = '#4169E1';
                        indicator.style.color = 'white';
                        indicator.style.padding = '2px 8px';
                        indicator.style.borderRadius = '10px';
                        indicator.style.fontSize = '12px';
                        indicator.style.fontWeight = 'bold';
                        
                        // Make sure the parent element has position relative
                        if (inputElement.parentElement.style.position !== 'relative') {
                            inputElement.parentElement.style.position = 'relative';
                        }
                        
                        inputElement.parentElement.appendChild(indicator);
                    }
                    
                    indicator.textContent = `${detectedSadWords.length} sad word(s) detected`;
                } else {
                    // Reset styling
                    inputElement.style.borderColor = '';
                    inputElement.style.boxShadow = '';
                }
            } else {
                // Reset styling if words effect is disabled
                inputElement.style.borderColor = '';
                inputElement.style.boxShadow = '';
            }
        },
        
        // Method to toggle words effect
        toggleWordsEffect: function() {
            this.wordsEffectEnabled = !this.wordsEffectEnabled;
            
            // Save preference to localStorage
            localStorage.setItem('emotionWordsEffectEnabled', this.wordsEffectEnabled.toString());
            
            // Update the global variable
            emotionWordsEffectEnabled = this.wordsEffectEnabled;
            
            // Re-highlight to apply changes
            const messageInputs = document.querySelectorAll('input[type="text"], input[type="search"], textarea');
            messageInputs.forEach(input => {
                this.highlightEmotionWords(input);
            });
            
            return this.wordsEffectEnabled;
        },
        
        // Method to load words effect preference
        loadWordsEffectPreference: function() {
            const wordsEffectEnabled = localStorage.getItem('emotionWordsEffectEnabled');
            if (wordsEffectEnabled !== null) {
                this.wordsEffectEnabled = wordsEffectEnabled === 'true';
                emotionWordsEffectEnabled = this.wordsEffectEnabled;
            }
        }
    };
    
    // Function to initialize emotion detection
    function initializeEmotionDetection() {
        // Load settings from localStorage
        const savedEmotionWordsEffect = localStorage.getItem('emotionWordsEffectEnabled');
        
        if (savedEmotionWordsEffect !== null) {
            emotionWordsEffectEnabled = savedEmotionWordsEffect === 'true';
            emotionSystem.wordsEffectEnabled = emotionWordsEffectEnabled;
        }
        
        // Function to set up emotion detection on an input element
        function setupEmotionDetection(inputElement) {
            if (!inputElement) return;
            
            // Handle input events
            inputElement.addEventListener('input', function(e) {
                // Skip if input is disabled (not logged in)
                if (inputElement.disabled) return;
                
                // Check for emotions and highlight
                emotionSystem.highlightEmotionWords(inputElement);
                emotionSystem.checkForEmotionsOnType(inputElement);
            });
        }
        
        // Apply emotion detection to all message inputs
        const messageInputs = document.querySelectorAll('input[type="text"], input[type="search"], textarea');
        messageInputs.forEach(input => {
            setupEmotionDetection(input);
        });
        
        // Also apply to any dynamically added inputs
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.nodeType === 1) { // Element node
                        if (node.matches('input[type="text"], input[type="search"], textarea')) {
                            setupEmotionDetection(node);
                        }
                        
                        // Check child nodes
                        const inputs = node.querySelectorAll('input[type="text"], input[type="search"], textarea');
                        inputs.forEach(input => {
                            setupEmotionDetection(input);
                        });
                    }
                });
            });
        });
        
        // Start observing the document body for added nodes
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }
});
</script>

<script>
// Global variables for temperature monitoring
let temperatureAlertEnabled = true;
let temperatureThreshold = 40; // Default threshold in Celsius
let currentTemperature = null; // Current device temperature
let lastTemperatureAlert = 0; // Timestamp of last alert
let temperatureMonitorInterval = null;
let isTemperatureSupported = false;

// Initialize temperature monitoring
function initializeTemperatureMonitoring() {
    console.log("Initializing temperature monitoring...");
    
    // Check if temperature monitoring is supported
    checkTemperatureSupport();
    
    if (isTemperatureSupported) {
        // Start continuous monitoring
        startTemperatureMonitoring();
        
        // Create temperature status UI
        createTemperatureStatusUI();
        
        console.log("Temperature monitoring initialized");
    } else {
        console.log("Temperature monitoring not supported on this device");
    }
}

// Check if temperature monitoring is supported
function checkTemperatureSupport() {
    // Check for various temperature APIs
    if ('deviceTemperature' in navigator) {
        isTemperatureSupported = true;
    } 
    // Check for Hardware API (experimental)
    else if ('hardware' in navigator && 'sensors' in navigator.hardware) {
        isTemperatureSupported = true;
    }
    // Check for Battery API (some devices report temperature through battery)
    else if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
            if ('temperature' in battery) {
                isTemperatureSupported = true;
            }
        });
    }
    // For demo purposes, we'll simulate temperature if not supported
    else {
        console.log("Temperature API not available, using simulation for demo");
        isTemperatureSupported = true; // Set to true for demo
    }
}

// Get current device temperature
async function getDeviceTemperature() {
    try {
        // Try different methods to get temperature
        if ('deviceTemperature' in navigator) {
            return await navigator.deviceTemperature.getTemperature();
        }
        // Try Hardware API
        else if ('hardware' in navigator && 'sensors' in navigator.hardware) {
            const sensors = await navigator.hardware.sensors.get();
            const tempSensor = sensors.find(sensor => sensor.type === 'temperature');
            if (tempSensor) {
                return await tempSensor.read();
            }
        }
        // Try Battery API
        else if ('getBattery' in navigator) {
            const battery = await navigator.getBattery();
            if ('temperature' in battery) {
                return battery.temperature;
            }
        }
        
        // If none of the above methods work, simulate temperature for demo
        // In a real implementation, you would remove this simulation
        return simulateTemperature();
    } catch (error) {
        console.error("Error getting temperature:", error);
        // Simulate temperature for demo
        return simulateTemperature();
    }
}

// Simulate temperature changes (for demo purposes)
function simulateTemperature() {
    // Generate a random temperature between 30-45°C
    // In a real implementation, you would remove this function
    const baseTemp = 35;
    const variation = Math.random() * 10;
    return Math.round((baseTemp + variation) * 10) / 10;
}

// Start temperature monitoring
function startTemperatureMonitoring() {
    // Clear any existing interval
    stopTemperatureMonitoring();
    
    // Set up monitoring every 10 seconds
    temperatureMonitorInterval = setInterval(async () => {
        if (temperatureAlertEnabled) {
            const newTemperature = await getDeviceTemperature();
            
            // Only update if temperature changed
            if (newTemperature !== currentTemperature) {
                currentTemperature = newTemperature;
                updateTemperatureUI();
                checkTemperatureAlertConditions();
            }
        }
    }, 10000); // Check every 10 seconds
    
    console.log("Temperature monitoring started");
}

// Stop temperature monitoring
function stopTemperatureMonitoring() {
    if (temperatureMonitorInterval) {
        clearInterval(temperatureMonitorInterval);
        temperatureMonitorInterval = null;
    }
}

// Check temperature alert conditions
function checkTemperatureAlertConditions() {
    if (currentTemperature >= temperatureThreshold) {
        // Only send alert if we haven't sent one recently
        if (!lastTemperatureAlert || Date.now() - lastTemperatureAlert > 300000) { // At most once per 5 minutes
            // Store temperature alert in localStorage
            storeTemperatureAlert(currentTemperature);
            
            // Check if we've reached 50 alerts
            checkForFinalAlert();
            
            lastTemperatureAlert = Date.now();
        }
    }
}

/**
 * Store temperature alert in localStorage
 */
function storeTemperatureAlert(temperature) {
    try {
        // Get existing alerts or initialize empty array
        let temperatureAlerts = JSON.parse(localStorage.getItem('temperatureAlerts') || '[]');
        
        // Add new alert with timestamp and temperature
        temperatureAlerts.push({
            temperature: temperature,
            timestamp: Date.now(),
            date: new Date().toLocaleString()
        });
        
        // Save back to localStorage
        localStorage.setItem('temperatureAlerts', JSON.stringify(temperatureAlerts));
        
        console.log(`Temperature alert stored: ${temperature}°C at ${new Date().toLocaleString()}`);
    } catch (e) {
        console.error('Error storing temperature alert:', e);
    }
}

/**
 * Check if we've reached 50 alerts and show final alert if so
 */
function checkForFinalAlert() {
    try {
        // Get existing alerts
        let temperatureAlerts = JSON.parse(localStorage.getItem('temperatureAlerts') || '[]');
        
        // Check if we have 50 or more alerts
        if (temperatureAlerts.length >= 50) {
            showFinalTemperatureAlert(temperatureAlerts);
            
            // Reset alerts after showing final alert
            localStorage.removeItem('temperatureAlerts');
        }
    } catch (e) {
        console.error('Error checking for final alert:', e);
    }
}

/**
 * Show final temperature alert with statistics
 */
function showFinalTemperatureAlert(alerts) {
    // Calculate statistics
    const temperatures = alerts.map(alert => alert.temperature);
    const maxTemp = Math.max(...temperatures);
    const minTemp = Math.min(...temperatures);
    const avgTemp = temperatures.reduce((sum, temp) => sum + temp, 0) / temperatures.length;
    
    // Get date range
    const firstAlert = new Date(alerts[0].timestamp);
    const lastAlert = new Date(alerts[alerts.length - 1].timestamp);
    const timeSpan = Math.round((lastAlert - firstAlert) / (1000 * 60 * 60 * 24)); // days
    
    // Create alert message
    const alertMessage = `🔥 CRITICAL DEVICE TEMPERATURE REPORT 🔥\n\n` +
        `Your device has exceeded the temperature threshold 50 times.\n\n` +
        `📊 TEMPERATURE STATISTICS:\n` +
        `• Highest temperature: ${maxTemp}°C\n` +
        `• Lowest temperature: ${minTemp}°C\n` +
        `• Average temperature: ${avgTemp.toFixed(1)}°C\n\n` +
        `📅 TIME PERIOD: ${timeSpan} day${timeSpan !== 1 ? 's' : ''}\n` +
        `• First alert: ${firstAlert.toLocaleDateString()}\n` +
        `• Last alert: ${lastAlert.toLocaleDateString()}\n\n` +
        `⚠️  RECOMMENDED ACTIONS:\n` +
        `• Check for background processes consuming resources\n` +
        `• Ensure proper device ventilation\n` +
        `• Consider hardware inspection if problem persists\n` +
        `• Close unused applications regularly`;
    
    // Show the notification
    showTemperatureNotification(alertMessage);
    
    // Also log to console for debugging
    console.log('Final temperature alert shown:', alertMessage);
}

/**
 * Show temperature notification
 */
function showTemperatureNotification(message) {
    // Create notification element if it doesn't exist
    if (!document.getElementById('temperature-notification')) {
        const notification = document.createElement('div');
        notification.id = 'temperature-notification';
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 400px;
            background-color: #ff5252;
            color: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            animation: slideIn 0.3s ease-out;
        `;
        
        // Add close button
        const closeButton = document.createElement('button');
        closeButton.innerHTML = '✕';
        closeButton.style.cssText = `
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        
        closeButton.addEventListener('click', () => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        });
        
        notification.appendChild(closeButton);
        document.body.appendChild(notification);
    }
    
    // Update notification content
    const notification = document.getElementById('temperature-notification');
    const content = document.createElement('div');
    content.textContent = message;
    content.style.marginRight = '24px'; // Make room for close button
    
    // Clear previous content and add new content
    while (notification.firstChild && notification.firstChild !== notification.lastChild) {
        notification.removeChild(notification.firstChild);
    }
    
    notification.insertBefore(content, notification.lastChild);
    
    // Auto-hide after 30 seconds for final alert, 10 seconds for regular alerts
    const hideDelay = message.includes('CRITICAL DEVICE TEMPERATURE REPORT') ? 30000 : 10000;
    
    setTimeout(() => {
        if (notification.parentNode) {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }
    }, hideDelay);
}

/**
 * Get temperature alert statistics (for debugging or admin panel)
 */
function getTemperatureAlertStats() {
    try {
        const alerts = JSON.parse(localStorage.getItem('temperatureAlerts') || '[]');
        
        if (alerts.length === 0) {
            return {
                count: 0,
                message: "No temperature alerts recorded"
            };
        }
        
        const temperatures = alerts.map(alert => alert.temperature);
        const maxTemp = Math.max(...temperatures);
        const minTemp = Math.min(...temperatures);
        const avgTemp = temperatures.reduce((sum, temp) => sum + temp, 0) / temperatures.length;
        
        return {
            count: alerts.length,
            maxTemp: maxTemp,
            minTemp: minTemp,
            avgTemp: avgTemp.toFixed(1),
            firstAlert: new Date(alerts[0].timestamp).toLocaleString(),
            lastAlert: new Date(alerts[alerts.length - 1].timestamp).toLocaleString()
        };
    } catch (e) {
        console.error('Error getting temperature alert stats:', e);
        return {
            count: 0,
            message: "Error retrieving temperature alert data"
        };
    }
}

/**
 * Clear temperature alert history
 */
function clearTemperatureAlertHistory() {
    localStorage.removeItem('temperatureAlerts');
    console.log('Temperature alert history cleared');
}



// Update temperature UI
function updateTemperatureUI() {
    // Update temperature indicator
    const temperatureValue = document.getElementById('temperature-value');
    if (temperatureValue) {
        temperatureValue.textContent = `${currentTemperature}°C`;
        
        // Change color based on temperature
        if (currentTemperature >= temperatureThreshold) {
            temperatureValue.style.color = '#ff4d4d'; // Red for hot
        } else if (currentTemperature >= temperatureThreshold - 5) {
            temperatureValue.style.color = '#ffaa00'; // Orange for warm
        } else {
            temperatureValue.style.color = '#4CAF50'; // Green for normal
        }
    }
    
    // Update temperature icon
    const temperatureIcon = document.getElementById('temperature-icon');
    if (temperatureIcon) {
        if (currentTemperature >= temperatureThreshold) {
            temperatureIcon.textContent = '🔥'; // Fire icon for hot
            temperatureIcon.style.animation = 'pulse 1.5s infinite';
        } else if (currentTemperature >= temperatureThreshold - 5) {
            temperatureIcon.textContent = '🌡️'; // Thermometer for warm
            temperatureIcon.style.animation = 'none';
        } else {
            temperatureIcon.textContent = '❄️'; // Snowflake for normal
            temperatureIcon.style.animation = 'none';
        }
    }
    
    // Update temperature bar
    const temperatureBar = document.getElementById('temperature-bar');
    if (temperatureBar) {
        // Calculate percentage (assuming max temperature of 50°C)
        const percentage = Math.min(100, (currentTemperature / 50) * 100);
        temperatureBar.style.width = `${percentage}%`;
        
        // Change color based on temperature
        if (currentTemperature >= temperatureThreshold) {
            temperatureBar.style.backgroundColor = '#ff4d4d'; // Red for hot
        } else if (currentTemperature >= temperatureThreshold - 5) {
            temperatureBar.style.backgroundColor = '#ffaa00'; // Orange for warm
        } else {
            temperatureBar.style.backgroundColor = '#4CAF50'; // Green for normal
        }
    }
}

// Create temperature status UI
function createTemperatureStatusUI() {
    // Check if the container already exists
    if (document.getElementById('temperature-status-container')) {
        return;
    }
    
    // Create container
    const container = document.createElement('div');
    container.id = 'temperature-status-container';
    container.style.position = 'fixed';
    container.style.top = '10px';
    container.style.right = '10px';
    container.style.padding = '10px';
    container.style.background = 'linear-gradient(145deg, #2c2c2c, #1a1a1a)';
    container.style.color = 'white';
    container.style.borderRadius = '15px';
    container.style.fontSize = '12px';
    container.style.zIndex = '1000';
    container.style.display = 'flex';
    container.style.flexDirection = 'column';
    container.style.alignItems = 'center';
    container.style.gap = '5px';
    container.style.border = '1px solid rgba(255, 255, 255, 0.2)';
    container.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.3)';
    container.style.transition = 'all 0.3s ease';
    
    // Create temperature icon
    const temperatureIcon = document.createElement('div');
    temperatureIcon.id = 'temperature-icon';
    temperatureIcon.textContent = '❄️'; // Default to snowflake
    temperatureIcon.style.fontSize = '20px';
    
    // Create temperature value
    const temperatureValue = document.createElement('div');
    temperatureValue.id = 'temperature-value';
    temperatureValue.textContent = '--°C';
    temperatureValue.style.fontSize = '16px';
    temperatureValue.style.fontWeight = 'bold';
    
    // Create temperature bar container
    const temperatureBarContainer = document.createElement('div');
    temperatureBarContainer.style.width = '60px';
    temperatureBarContainer.style.height = '6px';
    temperatureBarContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    temperatureBarContainer.style.borderRadius = '3px';
    temperatureBarContainer.style.overflow = 'hidden';
    
    // Create temperature bar
    const temperatureBar = document.createElement('div');
    temperatureBar.id = 'temperature-bar';
    temperatureBar.style.height = '100%';
    temperatureBar.style.width = '0%';
    temperatureBar.style.backgroundColor = '#4CAF50';
    temperatureBar.style.transition = 'width 0.5s, background-color 0.5s';
    
    // Assemble the UI
    temperatureBarContainer.appendChild(temperatureBar);
    container.appendChild(temperatureIcon);
    container.appendChild(temperatureValue);
    container.appendChild(temperatureBarContainer);
    
    // Add to the page
    document.body.appendChild(container);
    
    // Add CSS for pulse animation
    const style = document.createElement('style');
    style.textContent = `
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    `;
    document.head.appendChild(style);
    
    // Get initial temperature
    getDeviceTemperature().then(temp => {
        currentTemperature = temp;
        updateTemperatureUI();
    });
}

// Handle page visibility changes to optimize performance
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        // Page is hidden, reduce monitoring frequency
        if (temperatureMonitorInterval) {
            clearInterval(temperatureMonitorInterval);
            temperatureMonitorInterval = setInterval(async () => {
                if (temperatureAlertEnabled) {
                    const newTemperature = await getDeviceTemperature();
                    
                    // Only update if temperature changed
                    if (newTemperature !== currentTemperature) {
                        currentTemperature = newTemperature;
                        updateTemperatureUI();
                        checkTemperatureAlertConditions();
                    }
                }
            }, 30000); // Check every 30 seconds when page is hidden
        }
    } else {
        // Page is visible, restore normal monitoring frequency
        startTemperatureMonitoring();
    }
});

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', initializeTemperatureMonitoring);

// Also run on window load in case DOMContentLoaded already fired
window.addEventListener('load', function() {
    if (!temperatureMonitorInterval) {
        initializeTemperatureMonitoring();
    }
});

// Handle beforeunload to clean up
window.addEventListener('beforeunload', function() {
    stopTemperatureMonitoring();
});
</script>

<script>
// Global variables for battery saving
let batterySaverVisible = false; // Track if UI is visible
let visibilityTimeout = null; // Timeout for hiding the UI
let batterySaverMode = false;
let batterySaverThreshold = 20; // Enable battery saver when battery drops below this percentage
let originalIntervalTimes = {};
let reducedIntervalTimes = {};
let animationPaused = false;
let batterySaverUI = null;

// Initialize battery saver
function initializeBatterySaver() {
    console.log("Initializing battery saver...");
    
    // Get initial battery status
    updateBatteryStatusForSaver();
    
    // Set up battery status change listeners if available
    if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
            battery.addEventListener('chargingchange', updateBatteryStatusForSaver);
            battery.addEventListener('levelchange', updateBatteryStatusForSaver);
        });
    }
    
    // Create battery saver UI
    createBatterySaverUI();
    
    // Store original interval times
    storeOriginalIntervalTimes();
    
    // Start monitoring
    startBatterySaverMonitoring();
    
    console.log("Battery saver initialized");
}

// Update battery status for saver
function updateBatteryStatusForSaver() {
    if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
            const isCharging = battery.charging;
            const batteryLevel = Math.round(battery.level * 100);
            
            // Enable battery saver if battery is low and not charging
            if (!isCharging && batteryLevel <= batterySaverThreshold && !batterySaverMode) {
                enableBatterySaver();
            } 
            // Disable battery saver if battery is charging or level is sufficient
            else if ((isCharging || batteryLevel > batterySaverThreshold + 5) && batterySaverMode) {
                disableBatterySaver();
            }
            
            // Update UI
            updateBatterySaverUI(isCharging, batteryLevel);
        }).catch(error => {
            console.error("Battery API error:", error);
        });
    }
}

// Store original interval times for various processes
function storeOriginalIntervalTimes() {
    // Store intervals for common background processes
    originalIntervalTimes = {
        // Example intervals - in a real implementation, you would capture actual intervals
        locationUpdates: 10000,      // 10 seconds
        dataSync: 60000,            // 1 minute
        animationFrames: 60,        // 60 FPS
        networkPolling: 30000,      // 30 seconds
        backgroundTasks: 300000     // 5 minutes
    };
    
    // Define reduced intervals for battery saver mode
    reducedIntervalTimes = {
        locationUpdates: 60000,      // 1 minute (reduced from 10 seconds)
        dataSync: 300000,          // 5 minutes (reduced from 1 minute)
        animationFrames: 30,        // 30 FPS (reduced from 60 FPS)
        networkPolling: 120000,    // 2 minutes (reduced from 30 seconds)
        backgroundTasks: 600000     // 10 minutes (reduced from 5 minutes)
    };
}

// Enable battery saver mode
function enableBatterySaver() {
    if (batterySaverMode) return;
    
    batterySaverMode = true;
    console.log("Battery saver mode enabled");
    
    // Reduce animation frame rate
    reduceAnimationFrameRate();
    
    // Reduce interval timers
    reduceIntervalTimers();
    
    // Pause non-critical animations
    pauseNonCriticalAnimations();
    
    // Reduce network activity
    reduceNetworkActivity();
    
    // Optimize visual effects
    optimizeVisualEffects();
    
    // Show notification
    showBatterySaverNotification("Battery Saver Mode Enabled", "Background processes have been optimized to save battery.");
}

// Disable battery saver mode
function disableBatterySaver() {
    if (!batterySaverMode) return;
    
    batterySaverMode = false;
    console.log("Battery saver mode disabled");
    
    // Restore animation frame rate
    restoreAnimationFrameRate();
    
    // Restore interval timers
    restoreIntervalTimers();
    
    // Resume non-critical animations
    resumeNonCriticalAnimations();
    
    // Restore network activity
    restoreNetworkActivity();
    
    // Restore visual effects
    restoreVisualEffects();
    
    // Show notification
    showBatterySaverNotification("Battery Saver Mode Disabled", "Normal performance has been restored.");
}

// Reduce animation frame rate
function reduceAnimationFrameRate() {
    // Store original requestAnimationFrame
    const originalRAF = window.requestAnimationFrame;
    let lastTime = 0;
    const targetFPS = reducedIntervalTimes.animationFrames;
    const interval = 1000 / targetFPS;
    
    // Override requestAnimationFrame to reduce frame rate
    window.requestAnimationFrame = function(callback) {
        return originalRAF(function(timestamp) {
            if (timestamp - lastTime >= interval) {
                lastTime = timestamp;
                return callback(timestamp);
            }
        });
    };
}

// Restore animation frame rate
function restoreAnimationFrameRate() {
    // In a real implementation, you would restore the original requestAnimationFrame
    // For this demo, we'll reload the page to restore original state
    // In a production app, you would store and restore the original function
    window.location.reload();
}

// Reduce interval timers
function reduceIntervalTimers() {
    // In a real implementation, you would:
    // 1. Find all active intervals
    // 2. Clear them
    // 3. Restart them with reduced frequency
    
    // For this demo, we'll just log the action
    console.log("Reducing interval timers for battery saving");
}

// Restore interval timers
function restoreIntervalTimers() {
    // In a real implementation, you would:
    // 1. Find all active intervals with reduced frequency
    // 2. Clear them
    // 3. Restart them with original frequency
    
    // For this demo, we'll just log the action
    console.log("Restoring interval timers to normal frequency");
}

// Pause non-critical animations
function pauseNonCriticalAnimations() {
    animationPaused = true;
    
    // Find all CSS animations and transitions
    const allElements = document.querySelectorAll('*');
    allElements.forEach(element => {
        const computedStyle = window.getComputedStyle(element);
        
        // Check if element has animation
        if (computedStyle.animationName !== 'none') {
            // Store original animation state
            element.dataset.originalAnimation = computedStyle.animation;
            // Pause animation
            element.style.animationPlayState = 'paused';
        }
        
        // Check if element has transition
        if (computedStyle.transitionProperty !== 'none') {
            // Store original transition state
            element.dataset.originalTransition = computedStyle.transition;
            // Disable transition
            element.style.transition = 'none';
        }
    });
}

// Resume non-critical animations
function resumeNonCriticalAnimations() {
    animationPaused = false;
    
    // Find all elements with stored animation state
    const allElements = document.querySelectorAll('[data-original-animation], [data-original-transition]');
    allElements.forEach(element => {
        // Restore animation
        if (element.dataset.originalAnimation) {
            element.style.animation = element.dataset.originalAnimation;
            element.style.animationPlayState = 'running';
            delete element.dataset.originalAnimation;
        }
        
        // Restore transition
        if (element.dataset.originalTransition) {
            element.style.transition = element.dataset.originalTransition;
            delete element.dataset.originalTransition;
        }
    });
}

// Reduce network activity
function reduceNetworkActivity() {
    // In a real implementation, you would:
    // 1. Pause non-critical network requests
    // 2. Increase cache usage
    // 3. Reduce prefetching
    // 4. Defer non-critical data loading
    
    // For this demo, we'll just log the action
    console.log("Reducing network activity for battery saving");
}

// Restore network activity
function restoreNetworkActivity() {
    // In a real implementation, you would:
    // 1. Resume normal network request patterns
    // 2. Restore cache settings
    // 3. Enable prefetching
    // 4. Load deferred data
    
    // For this demo, we'll just log the action
    console.log("Restoring network activity to normal");
}

// Optimize visual effects
function optimizeVisualEffects() {
    // Reduce visual effects that consume GPU
    document.body.style.filter = 'contrast(0.95) brightness(0.95)';
    
    // Reduce shadow effects
    const elementsWithBoxShadow = document.querySelectorAll('*');
    elementsWithBoxShadow.forEach(element => {
        const computedStyle = window.getComputedStyle(element);
        if (computedStyle.boxShadow !== 'none') {
            // Store original box shadow
            element.dataset.originalBoxShadow = computedStyle.boxShadow;
            // Reduce or remove box shadow
            element.style.boxShadow = 'none';
        }
    });
}

// Restore visual effects
function restoreVisualEffects() {
    // Restore visual effects
    document.body.style.filter = '';
    
    // Restore box shadows
    const elementsWithStoredBoxShadow = document.querySelectorAll('[data-original-box-shadow]');
    elementsWithStoredBoxShadow.forEach(element => {
        element.style.boxShadow = element.dataset.originalBoxShadow;
        delete element.dataset.originalBoxShadow;
    });
}
// Show battery saver UI temporarily
function showBatterySaverUITemporarily() {
    if (!batterySaverUI) return;
    
    // Show the UI
    batterySaverUI.style.display = 'flex';
    batterySaverVisible = true;
    
    // Clear any existing timeout
    if (visibilityTimeout) {
        clearTimeout(visibilityTimeout);
    }
    
    // Set timeout to hide the UI after 5 seconds
    visibilityTimeout = setTimeout(() => {
        batterySaverUI.style.display = 'none';
        batterySaverVisible = false;
    }, 5000);
}
// Update UI if visible
if (batterySaverVisible) {
    updateBatterySaverUI(isCharging, batteryLevel);
}

// Create battery saver UI
function createBatterySaverUI() {
    // Check if the UI already exists
    if (document.getElementById('battery-saver-ui')) {
        return;
    }
    
    // Create container
    const container = document.createElement('div');
    container.id = 'battery-saver-ui';
    container.style.position = 'fixed';
    container.style.bottom = '10px';
    container.style.left = '10px';
    container.style.padding = '10px';
    container.style.background = 'linear-gradient(145deg, #2c2c2c, #1a1a1a)';
    container.style.color = 'white';
    container.style.borderRadius = '15px';
    container.style.fontSize = '12px';
    container.style.zIndex = '1000';
    container.style.display = 'none'; // Initially hidden
    container.style.flexDirection = 'column';
    container.style.alignItems = 'center';
    container.style.gap = '5px';
    container.style.border = '1px solid rgba(255, 255, 255, 0.2)';
    container.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.3)';
    container.style.transition = 'all 0.3s ease';
    
    // Create icon
    const icon = document.createElement('div');
    icon.id = 'battery-saver-icon';
    icon.textContent = '🔋';
    icon.style.fontSize = '20px';
    
    // Create status text
    const statusText = document.createElement('div');
    statusText.id = 'battery-saver-status';
    statusText.textContent = 'Battery Saver: Off';
    statusText.style.fontSize = '12px';
    statusText.style.fontWeight = 'bold';
    
    // Create battery level text
    const batteryLevelText = document.createElement('div');
    batteryLevelText.id = 'battery-saver-level';
    batteryLevelText.textContent = 'Battery: --%';
    batteryLevelText.style.fontSize = '12px';
    
    // Create toggle button
    const toggleButton = document.createElement('button');
    toggleButton.textContent = 'Toggle';
    toggleButton.style.padding = '5px 10px';
    toggleButton.style.backgroundColor = '#4CAF50';
    toggleButton.style.color = 'white';
    toggleButton.style.border = 'none';
    toggleButton.style.borderRadius = '5px';
    toggleButton.style.cursor = 'pointer';
    toggleButton.style.fontSize = '10px';
    toggleButton.addEventListener('click', function() {
        if (batterySaverMode) {
            disableBatterySaver();
        } else {
            enableBatterySaver();
        }
    });
    
    // Assemble the UI
    container.appendChild(icon);
    container.appendChild(statusText);
    container.appendChild(batteryLevelText);
    container.appendChild(toggleButton);
    
    // Add to the page
    document.body.appendChild(container);
    
    // Store reference
    batterySaverUI = container;
}

// Update battery saver UI
function updateBatterySaverUI(isCharging, batteryLevel) {
    if (!batterySaverUI) return;
    
    // Update status text
    const statusText = document.getElementById('battery-saver-status');
    if (statusText) {
        statusText.textContent = `Battery Saver: ${batterySaverMode ? 'On' : 'Off'}`;
        statusText.style.color = batterySaverMode ? '#ff9800' : 'white';
    }
    
    // Update battery level text
    const batteryLevelText = document.getElementById('battery-saver-level');
    if (batteryLevelText) {
        batteryLevelText.textContent = `Battery: ${batteryLevel}%`;
        
        // Change color based on battery level
        if (batteryLevel <= 20) {
            batteryLevelText.style.color = '#ff4d4d'; // Red
        } else if (batteryLevel <= 50) {
            batteryLevelText.style.color = '#ffaa00'; // Orange
        } else {
            batteryLevelText.style.color = '#4CAF50'; // Green
        }
    }
    
    // Update icon
    const icon = document.getElementById('battery-saver-icon');
    if (icon) {
        if (batterySaverMode) {
            icon.textContent = '🔋';
            icon.style.animation = 'pulse 2s infinite';
        } else {
            icon.textContent = isCharging ? '🔌' : '🔋';
            icon.style.animation = 'none';
        }
    }
}

// Show battery saver notification
function showBatterySaverNotification(title, message) {
    // Try to use the Notification API if available and permission is granted
    if ('Notification' in window) {
        if (Notification.permission === 'granted') {
            new Notification(title, {
                body: message,
                icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%234CAF50"><path d="M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4z"/></svg>'
            });
        } else if (Notification.permission !== 'denied') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    new Notification(title, {
                        body: message,
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%234CAF50"><path d="M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4z"/></svg>'
                    });
                }
            });
        }
    }
}

// Start battery saver monitoring
function startBatterySaverMonitoring() {
    // Monitor battery status every 30 seconds
    setInterval(() => {
        updateBatteryStatusForSaver();
    }, 30000);
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', initializeBatterySaver);

// Also run on window load in case DOMContentLoaded already fired
window.addEventListener('load', function() {
    if (!batterySaverUI) {
        initializeBatterySaver();
    }
});

// Add CSS for pulse animation
const style = document.createElement('style');
style.textContent = `
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }
`;
document.head.appendChild(style);
</script>

<script>
// Global variables for day check system with user message tracking
let lastVisitDate = null;
let lastMessageDates = {
    '6days': null,
    '1month': null,
    '5months': null,
    '1year': null
};
let messageSettings = {
    '6days': true,
    '1month': true,
    '5months': true,
    '1year': true
};
let messageTemplates = {
    '6days': [
        "Hi there! It's been 6 days since your last message. We miss you!",
        "We've noticed you haven't messaged in 6 days. Is there anything we can help with?",
        "Just checking in! It's been 6 days since your last message. We hope everything is okay."
    ],
    '1month': [
        "It's been a month since your last message! We'd love to hear from you again.",
        "A month has passed since you last messaged. Come back and see what's new!",
        "We miss you! It's been a month since your last message."
    ],
    '5months': [
        "It's been 5 months since your last message! We hope you're doing well.",
        "Five months have passed since you last messaged. We'd love to hear from you!",
        "We've missed you for 5 months! Come check out what's new."
    ],
    '1year': [
        "It's been a year since your last message! We hope you're doing well.",
        "A whole year has passed since you last messaged. We'd love to hear from you!",
        "We miss you! It's been a year since your last message."
    ]
};

// Enhanced date change detection system
function initializeDayCheck() {
    console.log("Initializing day check system...");
    
    // Load data from localStorage
    loadData();
    
    // Store the current date when the app loads
    const currentLoadDate = new Date();
    localStorage.setItem('appLastLoadDate', currentLoadDate.toISOString());
    
    // Check for date manipulation
    checkForDateChange();
    
    // Update status
    updateDayCheckStatus();
    
    // Start monitoring
    startDayCheckMonitoring();
    
    // Check if we need to send messages
    checkAndSendMessages();
    
    console.log("Day check system initialized");
}

// Check if the device date has been changed
function checkForDateChange() {
    const appLastLoadDate = localStorage.getItem('appLastLoadDate');
    const now = new Date();
    
    if (appLastLoadDate) {
        const lastLoad = new Date(appLastLoadDate);
        const timeDiff = now - lastLoad;
        
        // If the time difference is negative (date went back) or 
        // more than a few days (date jumped forward), it might be manipulated
        if (timeDiff < 0 || timeDiff > 7 * 24 * 60 * 60 * 1000) {
            console.log("Date change detected!");
            handleDateChange();
        }
    }
}

// Handle date change
function handleDateChange() {
    // Recalculate all time-based triggers
    const now = new Date();
    const daysSinceLastVisit = calculateDaysBetween(lastVisitDate, now);
    
    console.log(`Date changed. Days since last visit: ${daysSinceLastVisit}`);
    
    // Force check all message types
    checkMessageType('6days', 6, daysSinceLastVisit);
    checkMessageType('1month', 30, daysSinceLastVisit);
    checkMessageType('5months', 150, daysSinceLastVisit);
    checkMessageType('1year', 365, daysSinceLastVisit);
    
    // Update UI
    updateDayCheckStatus();
    
    // Show notification
    showNotification("Date change detected! Messages checked.");
}

// Enhanced checkAndSendMessages function
function checkAndSendMessages() {
    const now = new Date();
    const daysSinceLastVisit = calculateDaysBetween(lastVisitDate, now);
    
    console.log(`Checking messages. Days since last visit: ${daysSinceLastVisit}`);
    
    // Check each message type
    checkMessageType('6days', 6, daysSinceLastVisit);
    checkMessageType('1month', 30, daysSinceLastVisit);
    checkMessageType('5months', 150, daysSinceLastVisit);
    checkMessageType('1year', 365, daysSinceLastVisit);
    
    // Update UI
    updateDayCheckStatus();
}

// Enhanced checkMessageType function with more detailed logging
function checkMessageType(type, intervalDays, daysSinceLastVisit) {
    if (!messageSettings[type]) {
        console.log(`${type} messages are disabled`);
        return; // This message type is disabled
    }
    
    const now = new Date();
    let shouldSendMessage = false;
    let reason = "";
    
    if (!lastMessageDates[type]) {
        // No message sent yet, check if user has been inactive for longer than the interval
        if (daysSinceLastVisit >= intervalDays) {
            shouldSendMessage = true;
            reason = `No ${type} message sent yet and ${daysSinceLastVisit} days since last visit (threshold: ${intervalDays})`;
        }
    } else {
        // Message sent before, check if the interval has passed
        const daysSinceLastMessage = calculateDaysBetween(lastMessageDates[type], now);
        if (daysSinceLastMessage >= intervalDays) {
            shouldSendMessage = true;
            reason = `${daysSinceLastMessage} days since last ${type} message (threshold: ${intervalDays})`;
        }
    }
    
    console.log(`${type} check: Should send = ${shouldSendMessage}, Reason = ${reason}`);
    
    if (shouldSendMessage) {
        sendMessage(type);
    }
}

// Enhanced sendMessage function with more logging
function DayCheckFunction(type) {
    const now = new Date();
    const daysSinceLastVisit = calculateDaysBetween(lastVisitDate, now);
    
    console.log(`Sending ${type} message. Days since last visit: ${daysSinceLastVisit}`);
    
    // Select a random message template
    const templates = messageTemplates[type];
    if (!templates || templates.length === 0) {
        console.error(`No templates found for message type: ${type}`);
        return;
    }
    
    const templateIndex = Math.floor(Math.random() * templates.length);
    let messageContent = templates[templateIndex];
    
    // Replace placeholder with actual days
    messageContent = messageContent.replace('{days}', daysSinceLastVisit.toString());
    
    // Create message object
    const message = {
        type: type,
        content: messageContent,
        timestamp: now.toISOString(),
        daysSinceLastVisit: daysSinceLastVisit
    };
    
    // Save message to localStorage
    saveMessage(message);
    
    // Update last message date for this type
    lastMessageDates[type] = now;
    saveData();
    
    // Show notification
    showNotification(`${type} message sent!`);
    
    // Log the message
    console.log("Message sent:", message);
    
    // Return the message for further processing if needed
    return message;
}

// Add a manual trigger function for testing
function manualTriggerCheck() {
    console.log("Manual trigger activated");
    checkForDateChange();
    checkAndSendMessages();
    showNotification("Manual message check completed!");
}

// Also add a function to simulate different time periods
function simulateTimePeriod(days) {
    const simulatedDate = new Date();
    simulatedDate.setDate(simulatedDate.getDate() - days);
    
    // Temporarily change the last visit date
    const originalLastVisit = lastVisitDate;
    lastVisitDate = simulatedDate;
    
    console.log(`Simulating ${days} days of inactivity`);
    
    // Check for messages
    checkAndSendMessages();
    
    // Restore the original date
    lastVisitDate = originalLastVisit;
    
    showNotification(`Simulated ${days} days of inactivity`);
}

// Function to calculate days between two dates
function calculateDaysBetween(date1, date2) {
    const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
    return Math.round(Math.abs((date2 - date1) / oneDay));
}

// Function to save message to localStorage
function saveMessage(message) {
    let messages = [];
    const storedMessages = localStorage.getItem('aiMessages');
    
    if (storedMessages) {
        messages = JSON.parse(storedMessages);
    }
    
    messages.push(message);
    
    // Keep only the last 50 messages
    if (messages.length > 50) {
        messages = messages.slice(-50);
    }
    
    localStorage.setItem('aiMessages', JSON.stringify(messages));
}

// Function to update day check status
function updateDayCheckStatus() {
    // This function would update your UI with the current status
    // Implement based on your specific UI requirements
    console.log("Updating day check status");
}

// Function to start day check monitoring
function startDayCheckMonitoring() {
    // Check status every hour
    if (checkInterval) {
        clearInterval(checkInterval);
    }
    
    checkInterval = setInterval(() => {
        updateDayCheckStatus();
        checkAndSendMessages();
    }, 60 * 60 * 1000); // 1 hour in milliseconds
}

// Function to show notification
function showNotification(message) {
    // Create notification element if it doesn't exist
    let notification = document.getElementById('notification');
    if (!notification) {
        notification = document.createElement('div');
        notification.id = 'notification';
        notification.style.position = 'fixed';
        notification.style.top = '20px';
        notification.style.right = '20px';
        notification.style.backgroundColor = '#2ecc71';
        notification.style.color = 'white';
        notification.style.padding = '15px 20px';
        notification.style.borderRadius = '5px';
        notification.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
        notification.style.transform = 'translateX(150%)';
        notification.style.transition = 'transform 0.3s ease-out';
        notification.style.zIndex = '1000';
        notification.style.maxWidth = '300px';
        document.body.appendChild(notification);
    }
    
    notification.textContent = message;
    notification.classList.add('show');
    notification.style.transform = 'translateX(0)';
    
    setTimeout(() => {
        notification.style.transform = 'translateX(150%)';
    }, 3000);
}

// Function to save data to localStorage
function saveData() {
    localStorage.setItem('lastVisitDate', lastVisitDate.toISOString());
    localStorage.setItem('lastMessageDates', JSON.stringify(lastMessageDates));
    localStorage.setItem('messageSettings', JSON.stringify(messageSettings));
    localStorage.setItem('messageTemplates', JSON.stringify(messageTemplates));
}

// Function to load data from localStorage
function loadData() {
    // Load last visit date
    const storedLastVisit = localStorage.getItem('lastVisitDate');
    if (storedLastVisit) {
        lastVisitDate = new Date(storedLastVisit);
    } else {
        // First visit, set current date
        lastVisitDate = new Date();
        localStorage.setItem('lastVisitDate', lastVisitDate.toISOString());
    }
    
    // Load last message dates
    const storedLastMessageDates = localStorage.getItem('lastMessageDates');
    if (storedLastMessageDates) {
        lastMessageDates = JSON.parse(storedLastMessageDates);
        
        // Convert string dates back to Date objects
        for (const key in lastMessageDates) {
            if (lastMessageDates[key]) {
                lastMessageDates[key] = new Date(lastMessageDates[key]);
            }
        }
    }
    
    // Load message settings
    const storedMessageSettings = localStorage.getItem('messageSettings');
    if (storedMessageSettings) {
        messageSettings = JSON.parse(storedMessageSettings);
    }
    
    // Load message templates
    const storedMessageTemplates = localStorage.getItem('messageTemplates');
    if (storedMessageTemplates) {
        messageTemplates = JSON.parse(storedMessageTemplates);
    }
}

// Function to process user input and update last visit date
function processUserInput() {
    const userInputRaw = document.getElementById("user-input").value.trim();
    
    if (userInputRaw) {
        // Update last visit date to now
        lastVisitDate = new Date();
        localStorage.setItem('lastVisitDate', lastVisitDate.toISOString());
        
        // Update status
        updateDayCheckStatus();
        
        // Clear input
        document.getElementById("user-input").value = "";
        
        // Process the user message as needed
        console.log("User message received:", userInputRaw);
        
        // Return the user message for further processing
        return userInputRaw;
    }
    
    return null;
}

// Also add a function to reset all message dates for testing
function resetMessageDates() {
    if (confirm("This will reset all message dates. Are you sure?")) {
        lastMessageDates = {
            '6days': null,
            '1month': null,
            '5months': null,
            '1year': null
        };
        saveData();
        updateDayCheckStatus();
        showNotification("All message dates reset!");
    }
}

// Enhanced initialization with page visibility API
document.addEventListener('DOMContentLoaded', function() {
    initializeDayCheck();
    
    // Check for messages when the page becomes visible again
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden) {
            console.log("Page became visible, checking for date changes");
            checkForDateChange();
            checkAndSendMessages();
        }
    });
    
    // Check for messages when the window gets focus
    window.addEventListener('focus', function() {
        console.log("Window got focus, checking for date changes");
        checkForDateChange();
        checkAndSendMessages();
    });
    
    // Example of how to use the processUserInput function with a form submission
    const form = document.getElementById('message-form');
    if (form) {
        form.addEventListener('submit', function(event) {
            event.preventDefault();
            const userMessage = processUserInput();
            
            if (userMessage) {
                // Process the user message further
                // For example, send it to an AI service
                console.log("Processing user message:", userMessage);
            }
        });
    }
});

// Also run on window load in case DOMContentLoaded already fired
window.addEventListener('load', function() {
    if (!lastVisitDate) {
        initializeDayCheck();
    }
});
</script>

<script>
// AI Usage Time Monitoring System
const aiUsageMonitor = {
    // Configuration
    maxSessionTime: 30 * 60 * 1000, // 30 minutes in milliseconds
    warningThreshold: 25 * 60 * 1000, // Show warning at 25 minutes
    alertInterval: 5 * 60 * 1000, // Alert every 5 minutes after threshold
    resetAfterInactivity: 10 * 60 * 1000, // Reset timer after 10 minutes of inactivity
    
    // State tracking
    sessionStartTime: null,
    lastActivityTime: null,
    warningShown: false,
    alertsShown: [],
    isActive: false,
    
    // Initialize the monitoring system
    init: function() {
        // Load previous session data if available
        this.loadSessionData();
        
        // Set up activity listeners
        this.setupActivityListeners();
        
        // Start monitoring if a session is already active
        if (this.isActive) {
            this.startMonitoring();
        }
    },
    
    // Start a new session
    startSession: function() {
        const now = new Date();
        this.sessionStartTime = now;
        this.lastActivityTime = now;
        this.isActive = true;
        this.warningShown = false;
        this.alertsShown = [];
        
        // Save session data
        this.saveSessionData();
        
        // Start monitoring
        this.startMonitoring();
        
        console.log("AI usage session started");
    },
    
    // End the current session
    endSession: function() {
        this.isActive = false;
        this.sessionStartTime = null;
        this.lastActivityTime = null;
        this.warningShown = false;
        this.alertsShown = [];
        
        // Clear session data
        this.clearSessionData();
        
        console.log("AI usage session ended");
    },
    
    // Update the last activity time
    updateActivity: function() {
        if (!this.isActive) {
            this.startSession();
        } else {
            this.lastActivityTime = new Date();
            this.saveSessionData();
        }
    },
    
    // Start monitoring the session
    startMonitoring: function() {
        if (!this.isActive || !this.sessionStartTime) return;
        
        // Check if we should reset due to inactivity
        const now = new Date();
        const timeSinceLastActivity = now - this.lastActivityTime;
        
        if (timeSinceLastActivity > this.resetAfterInactivity) {
            this.endSession();
            return;
        }
        
        // Calculate session duration
        const sessionDuration = now - this.sessionStartTime;
        
        // Check if we should show a warning
        if (!this.warningShown && sessionDuration >= this.warningThreshold) {
            this.showWarning();
            this.warningShown = true;
        }
        
        // Check if we should show an alert
        if (sessionDuration >= this.maxSessionTime) {
            // Check if we need to show a new alert
            const timeSinceLastAlert = this.alertsShown.length > 0 ? 
                now - this.alertsShown[this.alertsShown.length - 1] : 
                this.alertInterval + 1;
            
            if (timeSinceLastAlert >= this.alertInterval) {
                this.showAlert();
                this.alertsShown.push(now);
            }
        }
        
        // Continue monitoring
        setTimeout(() => this.startMonitoring(), 1000);
    },
    
    // Show warning message
    showWarning: function() {
        // Remove any existing warning
        const existingWarning = document.getElementById('ai-usage-warning');
        if (existingWarning) {
            existingWarning.remove();
        }
        
        // Create warning element
        const warning = document.createElement('div');
        warning.id = 'ai-usage-warning';
        warning.innerHTML = `
            <div style="background-color: #f39c12; color: white; padding: 15px 20px; border-radius: 5px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); max-width: 350px; text-align: center; font-weight: bold;">
                <h3 style="margin-top: 0;">⏰ Usage Reminder</h3>
                <p>You've been using the AI for ${Math.floor(this.warningThreshold / 60000)} minutes.</p>
                <p>Consider taking a short break to rest your eyes and mind.</p>
                <button id="dismiss-warning" style="background-color: rgba(255, 255, 255, 0.2); border: 1px solid white; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-top: 10px;">Dismiss</button>
            </div>
        `;
        warning.style.position = 'fixed';
        warning.style.top = '20px';
        warning.style.right = '20px';
        warning.style.zIndex = '2000';
        
        // Add to page
        document.body.appendChild(warning);
        
        // Add event listener to dismiss button
        document.getElementById('dismiss-warning').addEventListener('click', function() {
            warning.remove();
        });
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (warning.parentNode) {
                warning.parentNode.removeChild(warning);
            }
        }, 10000);
    },
    
    // Show alert message
    showAlert: function() {
        // Remove any existing alert
        const existingAlert = document.getElementById('ai-usage-alert');
        if (existingAlert) {
            existingAlert.remove();
        }
        
        // Calculate session duration in minutes
        const now = new Date();
        const sessionDuration = Math.floor((now - this.sessionStartTime) / 60000);
        
        // Create alert element
        const alert = document.createElement('div');
        alert.id = 'ai-usage-alert';
        alert.innerHTML = `
            <div style="background-color: #e74c3c; color: white; padding: 15px 20px; border-radius: 5px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); max-width: 350px; text-align: center; font-weight: bold;">
                <h3 style="margin-top: 0;">⚠️ Extended Usage Alert</h3>
                <p>You've been using the AI for ${sessionDuration} minutes.</p>
                <p>For your well-being, please consider taking a break.</p>
                <div style="display: flex; justify-content: space-between; margin-top: 15px;">
                    <button id="continue-session" style="background-color: rgba(255, 255, 255, 0.2); border: 1px solid white; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Continue</button>
                    <button id="end-session" style="background-color: rgba(255, 255, 255, 0.2); border: 1px solid white; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Take a Break</button>
                </div>
            </div>
        `;
        alert.style.position = 'fixed';
        alert.style.top = '20px';
        alert.style.right = '20px';
        alert.style.zIndex = '2000';
        
        // Add to page
        document.body.appendChild(alert);
        
        // Add event listeners
        document.getElementById('continue-session').addEventListener('click', () => {
            alert.remove();
            this.updateActivity(); // Update activity time
        });
        
        document.getElementById('end-session').addEventListener('click', () => {
            alert.remove();
            this.endSession();
            this.showBreakScreen();
        });
    },
    
    // Show break screen
    showBreakScreen: function() {
        // Remove any existing break screen
        const existingScreen = document.getElementById('ai-break-screen');
        if (existingScreen) {
            existingScreen.remove();
        }
        
        // Create break screen
        const breakScreen = document.createElement('div');
        breakScreen.id = 'ai-break-screen';
        breakScreen.style.position = 'fixed';
        breakScreen.style.top = '0';
        breakScreen.style.left = '0';
        breakScreen.style.width = '100%';
        breakScreen.style.height = '100%';
        breakScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        breakScreen.style.zIndex = '9999';
        breakScreen.style.display = 'flex';
        breakScreen.style.flexDirection = 'column';
        breakScreen.style.justifyContent = 'center';
        breakScreen.style.alignItems = 'center';
        breakScreen.style.color = 'white';
        breakScreen.style.textAlign = 'center';
        breakScreen.style.padding = '20px';
        
        // Create break message
        const breakMessage = document.createElement('div');
        breakMessage.innerHTML = `
            <h1 style="color: #3498db; margin-bottom: 20px; font-size: 2.5em;">Time for a Break!</h1>
            <p style="font-size: 1.5em; margin-bottom: 30px;">You've been using the AI for an extended period.</p>
            <p style="font-size: 1.2em; margin-bottom: 30px;">Taking regular breaks helps maintain focus and reduces eye strain.</p>
            <div id="break-timer" style="color: #3498db; font-size: 1.8em; font-weight: bold; margin-bottom: 30px;">Break time: 1:00</div>
            <button id="skip-break" style="background-color: rgba(52, 152, 219, 0.2); border: 2px solid #3498db; color: #3498db; padding: 15px 30px; border-radius: 5px; cursor: pointer; font-size: 1.2em; font-weight: bold;">Skip Break</button>
        `;
        
        breakScreen.appendChild(breakMessage);
        document.body.appendChild(breakScreen);
        
        // Start break timer
        this.startBreakTimer();
        
        // Add event listener to skip button
        document.getElementById('skip-break').addEventListener('click', function() {
            document.body.removeChild(breakScreen);
            aiUsageMonitor.startSession(); // Start a new session
        });
    },
    
    // Start break countdown timer
    startBreakTimer: function() {
        let remainingTime = 60; // 1 minute break
        
        const timerElement = document.getElementById('break-timer');
        
        const updateTimer = () => {
            if (remainingTime <= 0) {
                // Break is over
                document.getElementById('break-timer').textContent = "Break time is over!";
                document.getElementById('skip-break').textContent = "Continue";
                return;
            }
            
            // Update timer display
            const minutes = Math.floor(remainingTime / 60);
            const seconds = remainingTime % 60;
            
            timerElement.textContent = `Break time: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            
            // Continue countdown
            remainingTime--;
            setTimeout(updateTimer, 1000);
        };
        
        updateTimer();
    },
    
    // Set up activity listeners
    setupActivityListeners: function() {
        // Track mouse movement
        document.addEventListener('mousemove', () => this.updateActivity());
        
        // Track keyboard activity
        document.addEventListener('keydown', () => this.updateActivity());
        
        // Track clicks
        document.addEventListener('click', () => this.updateActivity());
        
        // Track scroll
        document.addEventListener('scroll', () => this.updateActivity());
        
        // Track touch events for mobile
        document.addEventListener('touchstart', () => this.updateActivity());
        document.addEventListener('touchmove', () => this.updateActivity());
    },
    
    // Save session data to localStorage
    saveSessionData: function() {
        if (!this.isActive) return;
        
        const sessionData = {
            isActive: this.isActive,
            sessionStartTime: this.sessionStartTime ? this.sessionStartTime.toISOString() : null,
            lastActivityTime: this.lastActivityTime ? this.lastActivityTime.toISOString() : null,
            warningShown: this.warningShown
        };
        
        localStorage.setItem('aiUsageSessionData', JSON.stringify(sessionData));
    },
    
    // Load session data from localStorage
    loadSessionData: function() {
        const sessionDataStr = localStorage.getItem('aiUsageSessionData');
        if (!sessionDataStr) return;
        
        try {
            const sessionData = JSON.parse(sessionDataStr);
            
            this.isActive = sessionData.isActive || false;
            
            if (sessionData.sessionStartTime) {
                this.sessionStartTime = new Date(sessionData.sessionStartTime);
            }
            
            if (sessionData.lastActivityTime) {
                this.lastActivityTime = new Date(sessionData.lastActivityTime);
            }
            
            this.warningShown = sessionData.warningShown || false;
            
            // Check if the session is still valid (not too old)
            if (this.isActive && this.sessionStartTime) {
                const now = new Date();
                const sessionAge = now - this.sessionStartTime;
                
                // If session is older than 24 hours, reset it
                if (sessionAge > 24 * 60 * 60 * 1000) {
                    this.endSession();
                }
            }
        } catch (e) {
            console.error("Error loading session data:", e);
            this.endSession();
        }
    },
    
    // Clear session data from localStorage
    clearSessionData: function() {
        localStorage.removeItem('aiUsageSessionData');
    }
};

// Initialize the AI usage monitor when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    aiUsageMonitor.init();
    
    // If you want to integrate with your existing AI chat system
    const userInput = document.getElementById('user-input');
    
    if (userInput) {
        // Track when user starts interacting with the AI
        userInput.addEventListener('focus', () => {
            aiUsageMonitor.updateActivity();
        });
        
        // Track when user sends a message
        userInput.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                aiUsageMonitor.updateActivity();
            }
        });
    }
    
    // Also track when AI responses are received
    // This would need to be integrated with your AI response handling code
    // For example:
    // function handleAIResponse(response) {
    //     // Process the response
    //     aiUsageMonitor.updateActivity();
    // }
});
</script>
<script>
// Enhanced flashlight controller with callback support
const flashlightController = {
    // Configuration
    flashlightState: false,
    stream: null,
    
    // Initialize the flashlight controller
    init: function() {
        // Create UI elements if they don't exist
        this.createUIElements();
        
        // Check for flashlight support
        this.checkFlashlightSupport();
    },
    
    // Create UI elements if they don't exist
    createUIElements: function() {
        // Create notification if it doesn't exist
        if (!document.getElementById('flashlight-notification')) {
            const notification = document.createElement('div');
            notification.id = 'flashlight-notification';
            notification.className = 'flashlight-notification';
            
            // Add to body
            document.body.appendChild(notification);
        }
    },
    
    // Check for flashlight support
    checkFlashlightSupport: function() {
        // Check if the device supports the Flashlight API
        if ('navigator' in window && 'mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices) {
            console.log('Flashlight supported on this device');
        } else {
            console.log('Flashlight not supported on this device');
        }
    },
    
    // Check if flashlight is supported
    isFlashlightSupported: function() {
        return 'navigator' in window && 
               'mediaDevices' in navigator && 
               'getUserMedia' in navigator.mediaDevices;
    },
    
    // Turn on flashlight with callback
    turnOnFlashlightWithCallback: function(callback) {
        // Check if flashlight is already on
        if (this.flashlightState) {
            if (callback) callback(false, "Your flashlight is already on");
            return;
        }
        
        if (!this.isFlashlightSupported()) {
            if (callback) callback(false, "Flashlight not supported on this device");
            return;
        }
        
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
            .then(stream => {
                const track = stream.getVideoTracks()[0];
                
                // Check if torch is supported
                if ('torch' in track.getCapabilities()) {
                    track.applyConstraints({ advanced: [{ torch: true }] })
                        .then(() => {
                            this.flashlightState = true;
                            this.stream = stream; // Store the stream to turn off later
                            if (callback) callback(true, "Flashlight turned on");
                        })
                        .catch(error => {
                            if (callback) callback(false, "Error turning on flashlight: " + error);
                        });
                } else {
                    stream.getTracks().forEach(track => track.stop());
                    if (callback) callback(false, "Torch not supported on this device");
                }
            })
            .catch(error => {
                if (callback) callback(false, "Error accessing camera: " + error);
            });
    },
    
    // Turn on flashlight
    turnOnFlashlight: function() {
        this.turnOnFlashlightWithCallback((success, message) => {
           /* this.showNotification(message);*/
        });
    },
    
    // Turn off flashlight with callback
    turnOffFlashlightWithCallback: function(callback) {
        // Check if flashlight is already off
        if (!this.flashlightState) {
            if (callback) callback(false, "Your flashlight is already off");
            return;
        }
        
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        
        this.flashlightState = false;
        if (callback) callback(true, "Flashlight turned off");
    },
    
    // Turn off flashlight
    turnOffFlashlight: function() {
        this.turnOffFlashlightWithCallback((success, message) => {
          /*  this.showNotification(message);*/
        });
    },
    
    // Show notification
    showNotification: function(message) {
        const notification = document.getElementById('flashlight-notification');
        notification.textContent = message;
        notification.classList.add('show');
        
        // Remove after 3 seconds
        setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }
};

// Initialize the flashlight controller when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    flashlightController.init();
});
</script>

<script>

const persistentShakeController = {
    // Configuration
    shakeThreshold: 15, // Minimum acceleration to consider as shake
    shakeCooldown: 1000, // Minimum time between shakes to prevent multiple triggers
    lastShakeTime: 0,
    isActive: false,
    bodyHidden: false,
    originalBodyStyles: null,
    storageKey: 'bodyHiddenState',
    
    // Initialize shake detection
    init: function() {
        // Check if device has accelerometer
        if (!window.DeviceMotionEvent) {
            console.log('Device motion not supported');
            return false;
        }
        
        // Check localStorage for previous state
        const savedState = localStorage.getItem(this.storageKey);
        this.bodyHidden = savedState === 'true';
        
        // Store original body styles
        this.originalBodyStyles = {
            width: document.body.style.width,
            height: document.body.style.height,
            minWidth: document.body.style.minWidth,
            minHeight: document.body.style.minHeight,
            maxWidth: document.body.style.maxWidth,
            maxHeight: document.body.style.maxHeight,
            overflow: document.body.style.overflow,
            position: document.body.style.position,
            top: document.body.style.top,
            left: document.body.style.left,
            transform: document.body.style.transform,
            opacity: document.body.style.opacity,
            visibility: document.body.style.visibility,
            zIndex: document.body.style.zIndex
        };
        
        // Apply saved state if body was hidden
        if (this.bodyHidden) {
            this.hideBodySize(false); // false means don't show notification
        }
        
        // Set up event listener for device motion
        window.addEventListener('devicemotion', (event) => this.handleMotion(event));
        this.isActive = true;
        console.log('Persistent shake controller initialized with state:', this.bodyHidden ? 'hidden' : 'visible');
        return true;
    },
    
    // Handle device motion events
    handleMotion: function(event) {
        if (!this.isActive || !event.accelerationIncludingGravity) {
            return;
        }
        
        const acceleration = event.accelerationIncludingGravity;
        const currentTime = new Date().getTime();
        
        // Calculate total acceleration
        const totalAcceleration = Math.sqrt(
            Math.pow(acceleration.x, 2) + 
            Math.pow(acceleration.y, 2) + 
            Math.pow(acceleration.z, 2)
        );
        
        // Check if acceleration exceeds threshold and enough time has passed since last shake
        if (totalAcceleration > this.shakeThreshold && 
            currentTime - this.lastShakeTime > this.shakeCooldown) {
            
            this.lastShakeTime = currentTime;
            this.toggleBodySize();
        }
    },
    
    // Toggle body size between hidden and normal
    toggleBodySize: function() {
        if (this.bodyHidden) {
            this.restoreBodySize();
        } else {
            this.hideBodySize(true); // true means show notification
        }
    },
    
    // Hide the body by setting size to 0
    hideBodySize: function(showNotification = true) {
        // Apply zero size styles
        document.body.style.width = '0';
        document.body.style.height = '0';
        document.body.style.minWidth = '0';
        document.body.style.minHeight = '0';
        document.body.style.maxWidth = '0';
        document.body.style.maxHeight = '0';
        document.body.style.overflow = 'hidden';
        document.body.style.position = 'absolute';
        document.body.style.top = '-9999px';
        document.body.style.left = '-9999px';
        document.body.style.transform = 'scale(0)';
        document.body.style.opacity = '0';
        document.body.style.visibility = 'hidden';
        document.body.style.zIndex = '-9999';
        
        // Create a small indicator to show the app is still running
        this.createHiddenIndicator();
        
        this.bodyHidden = true;
        
        // Save state to localStorage
        localStorage.setItem(this.storageKey, 'true');
        
        if (showNotification) {
        /*    this.showNotification('Screen hidden. Shake again to show.');*/
        }
        
        // Trigger custom event
        const event = new CustomEvent('bodyHidden', {
            detail: { timestamp: new Date() }
        });
        window.dispatchEvent(event);
    },
    
    // Restore the original body size
    restoreBodySize: function() {
        // Restore original styles
        Object.keys(this.originalBodyStyles).forEach(property => {
            document.body.style[property] = this.originalBodyStyles[property];
        });
        
        // Remove the hidden indicator
        this.removeHiddenIndicator();
        
        this.bodyHidden = false;
        
        // Save state to localStorage
        localStorage.setItem(this.storageKey, 'false');
        
     /*   this.showNotification('Screen visible. Shake again to hide.');
        */
        // Trigger custom event
        const event = new CustomEvent('bodyShown', {
            detail: { timestamp: new Date() }
        });
        window.dispatchEvent(event);
    },
    
    // Create a small indicator when body is hidden
    createHiddenIndicator: function() {
        // Remove any existing indicator
        this.removeHiddenIndicator();
        
        const indicator = document.createElement('div');
        indicator.id = 'hidden-body-indicator';
        indicator.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            z-index: 10001;
            cursor: pointer;
        `;
        indicator.innerHTML = '👁️';
        
        // Add click event to restore body when indicator is clicked
        indicator.addEventListener('click', () => this.restoreBodySize());
        
        document.body.appendChild(indicator);
    },
    
    // Remove the hidden indicator
    removeHiddenIndicator: function() {
        const indicator = document.getElementById('hidden-body-indicator');
        if (indicator) {
            indicator.remove();
        }
    },
    
    // Show notification
    showNotification: function(message) {
        // Create notification if it doesn't exist
        let notification = document.getElementById('persistent-shake-notification');
        
        if (!notification) {
            notification = document.createElement('div');
            notification.id = 'persistent-shake-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 12px 24px;
                border-radius: 30px;
                z-index: 10000;
                font-size: 16px;
                opacity: 0;
                transition: opacity 0.3s;
            `;
            document.body.appendChild(notification);
        }
        
        notification.textContent = message;
        notification.style.opacity = '1';
        
        // Hide after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
        }, 3000);
    },
    
    // Enable/disable shake detection
    setActive: function(active) {
        this.isActive = active;
        console.log(`Persistent shake controller ${active ? 'enabled' : 'disabled'}`);
    }
};

// Initialize shake detection when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    persistentShakeController.init();
    
    // Listen for body state events
    window.addEventListener('bodyHidden', function(event) {
        console.log('Body hidden at:', event.detail.timestamp);
    });
    
    window.addEventListener('bodyShown', function(event) {
        console.log('Body shown at:', event.detail.timestamp);
    });
});

// Request permission for iOS 13+ devices
if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
    // Add a button to request permission
    document.addEventListener('DOMContentLoaded', function() {
        const permissionButton = document.createElement('button');
        permissionButton.textContent = 'Enable Persistent Shake';
        permissionButton.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 15px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 20px;
            z-index: 10000;
            cursor: pointer;
        `;
        
        permissionButton.addEventListener('click', function() {
            DeviceMotionEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        persistentShakeController.init();
                        permissionButton.style.display = 'none';
                    }
                })
                .catch(console.error);
        });
        
        document.body.appendChild(permissionButton);
    });
}

</script>


  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.4/dist/purify.min.js"></script>

</body>

</html>