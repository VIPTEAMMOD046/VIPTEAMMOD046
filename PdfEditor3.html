<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Editor</title>

    <!-- QR Code Library -->
    <script src="Pdf/qrcode.min.js"></script>
    
     <!-- Add this line to load the Roboto font from Google -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
<style>
/* Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}


/* ==========================================
   UPDATED MODERN COLOR PALETTE
   Theme: "Midnight & Electric Teal"
   ========================================== */
:root {
    /* ========== VIBRANT RED THEME ========== */
    
    /* Core Brand Colors - Red Dominant */
    --primary-color: #1a1a2e;           /* Deep Navy for contrast */
    --secondary-color: #850000;         /* Deep Crimson Red */
    
    /* Accent & Highlights - Red Variations */
    --accent-color: #d10000;           /* Vibrant Primary Red */
    --accent-hover: #ff3333;           /* Bright Red Hover */
    --accent-light: #ff6b6b;           /* Light Coral Red */
    --accent-dark: #990000;            /* Dark Red */
    
    /* Complementary Colors */
    --complementary-1: #ff9500;        /* Orange for highlights */
    --complementary-2: #ffd166;        /* Gold/Yellow */
    --complementary-3: #06d6a0;        /* Teal for success states */
    
    /* Surfaces & Backgrounds */
    --background-color: #ffffff;       /* Pure White */
    --surface-color: #f8f9fa;          /* Very Light Gray */
    --light-accent-bg: #fff5f5;        /* Very Light Red Tint */
    --card-bg: #ffffff;                /* Card Background */
    
    /* Typography */
    --text-primary: #1a1a1a;           /* Near Black for headings */
    --text-secondary: #4a4a4a;         /* Dark Gray for body */
    --text-tertiary: #666666;          /* Medium Gray */
    --text-on-red: #ffffff;            /* White text on red backgrounds */
    
    /* Functional Colors */
    --border-color: #e0e0e0;           /* Light Gray Borders */
    --error-color: #ff3860;            /* Bright Red for errors */
    --warning-color: #ffdd57;          /* Yellow for warnings */
    --success-color: #23d160;          /* Green for success */
    --info-color: #209cee;             /* Blue for info */
    
    /* Gradient Colors */
    --gradient-red: linear-gradient(135deg, #d10000 0%, #ff3333 100%);
    --gradient-dark-red: linear-gradient(135deg, #850000 0%, #d10000 100%);
    --gradient-subtle: linear-gradient(135deg, #fff5f5 0%, #ffffff 100%);
    
    /* Shadows with Red Tint */
    --shadow-sm: 0 2px 8px rgba(209, 0, 0, 0.08);
    --shadow-md: 0 4px 16px rgba(209, 0, 0, 0.12);
    --shadow-lg: 0 8px 32px rgba(209, 0, 0, 0.16);
    --shadow-glow: 0 0 20px rgba(209, 0, 0, 0.3);
    --shadow-red: 0 4px 14px rgba(209, 0, 0, 0.4);
    
    /* Hover Effects */
    --hover-red: rgba(209, 0, 0, 0.1);
    --hover-light-red: rgba(255, 107, 107, 0.1);
    
    /* Button Specific */
    --button-primary-bg: var(--gradient-red);
    --button-primary-hover: var(--gradient-dark-red);
    --button-secondary-bg: #ffffff;
    --button-secondary-border: #d10000;
    --button-secondary-text: #d10000;
    
    /* Input Fields */
    --input-focus-border: #d10000;
    --input-focus-shadow: 0 0 0 3px rgba(209, 0, 0, 0.2);
    
    /* Status Indicators */
    --status-active: #d10000;
    --status-inactive: #cccccc;
    --status-pending: #ff9500;
    --status-completed: #23d160;
    
    /* Chart Colors */
    --chart-red: #d10000;
    --chart-orange: #ff9500;
    --chart-yellow: #ffd166;
    --chart-green: #06d6a0;
    --chart-blue: #118ab2;
    --chart-purple: #7209b7;
    
    /* ========== LEGACY VARIABLES (for compatibility) ========== */
    --bg-color: #f8f9fa;
    --header-bg: #1a1a2e;
    --text-color: #1a1a1a;
    --button-bg: #d10000;
    --button-text: #ffffff;
    --border-color: #e0e0e0;
}

body {
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: background-color 0.3s, color 0.3s;

   font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    line-height: 1.6;
   
    overflow-x: hidden;
}



/* Header with Modern Theme */
header {
    background: var(--primary-color);
    color: white;
    padding: 15px 25px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: var(--shadow-md);
    position: relative;
 border-bottom: 1px solid var(--border-color);
    overflow: hidden;
}

/* Modern, clean background - no animation */
body::before {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--light-accent-bg);
    z-index: -2;

}

/* Removed animated elements for a cleaner, more professional look */
.forest-canopy, .birds {
    display: none;
}

/* Login Container */
.login-container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
    position: relative;
    z-index: 1;
}

/* Modern Professional Login Card */
.login-card {
    background: var(--background-color);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    box-shadow: var(--shadow-lg);
    width: 100%;
    max-width: 400px;
    padding: 40px;
    position: relative;
    overflow: hidden;
    border: 1px solid var(--border-color);
    transform: translateY(0);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.login-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 12px 28px rgba(0,0,0,0.15);
}

/* Subtle geometric decorations instead of nature theme */
.login-card::before, .login-card::after {
    content: "";
    position: absolute;
    background: var(--accent-color);
    opacity: 0.05;
    border-radius: 50%;
    z-index: -1;
}

.login-card::before {
    width: 200px;
    height: 200px;
    top: -50px;
    right: -50px;
}

.login-card::after {
    width: 150px;
    height: 150px;
    bottom: -30px;
    left: -30px;
}

/* Login Title */
.login-title {
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 30px;
    text-align: center;
    color: var(--primary-color);
    position: relative;
}

.login-title::after {
    content: "";
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 50px;
    height: 3px;
    background: var(--accent-color);
    border-radius: 3px;
}

/* Form Groups */
.form-group {
    margin-bottom: 25px;
    position: relative;
}

.form-label {
    display: block;
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.form-input {
    width: 100%;
    padding: 15px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background-color);
    font-size: 16px;
    transition: all 0.3s ease;
    position: relative;
}

.form-input:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.2);
}

/* Modern, clean icons for input fields */
.form-input.username {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%236C757D'%3E%3Cpath d='M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: 15px center;
    background-size: 20px;
    padding-left: 50px;
}

.form-input.password {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%236C757D'%3E%3Cpath d='M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: 15px center;
    background-size: 20px;
    padding-left: 50px;
}

/* Login Button */
.login-btn {
    width: 100%;
    padding: 15px;
    background: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0, 180, 216, 0.3);
    position: relative;
    overflow: hidden;
}

.login-btn::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.login-btn:hover::before {
    left: 100%;
}

.login-btn:hover {
    background: var(--secondary-color);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 180, 216, 0.4);
}

.login-btn:active {
    transform: translateY(0);
}

.login-btn:disabled {
    background: var(--text-secondary);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Error Message */
.error-message {
    color: var(--error-color);
    margin-top: 10px;
    font-size: 14px;
    display: none;
    text-align: center;
}

/* App Container */
.app-container {
    display: none;
    flex-direction: column;
    min-height: 100vh;
    position: relative;
    z-index: 1;
}


/* Removed animated leaves from header */
header::before {
    display: none;
}

/* Title with Modern Icon */
.title {
    font-size: 22px;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 10px;
}

.title::before {
    content: "ðŸ“„"; /* Changed icon to be more relevant */
    font-size: 24px;
}

/* Header Controls */
.header-controls {
    display: flex;
    gap: 15px;
}

.save-btn {
    padding: 10px 20px;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 5px;
    background-color: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
}

.save-btn::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.save-btn:hover::before {
    left: 100%;
}

.save-btn:hover {
    background-color: rgba(255, 255, 255, 0.25);
    transform: translateY(-2px);
}

/* Form Section with Modern Theme */
.form-section {
    background: var(--surface-color);
    padding: 20px 25px;
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    align-items: flex-end;
    box-shadow: var(--shadow-sm);
    border-bottom: 1px solid var(--border-color);
    position: relative;
    max-height: 240px;
    overflow-y: auto;
}

/* Removed nature decorations from form section */
.form-section::before {
    display: none;
}

/* Custom Scrollbar */
.form-section::-webkit-scrollbar {
    width: 8px;
}

.form-section::-webkit-scrollbar-track {
    background: var(--light-accent-bg);
    border-radius: 10px;
}

.form-section::-webkit-scrollbar-thumb {
    background: var(--text-secondary);
    border-radius: 10px;
}

.form-section::-webkit-scrollbar-thumb:hover {
    background: var(--primary-color);
}

/* Form Groups in App */
.form-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
    flex: 1;
    min-width: 200px;
    position: relative;
}

.form-label {
    font-size: 14px;
    color: var(--text-secondary);
    font-weight: 600;
}

.form-input {
    padding: 10px 14px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background-color);
    font-family: inherit;
    font-size: 14px;
    width: 100%;
    transition: all 0.3s ease;
}

.form-input:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.2);
}

/* Distance Input Group */
.distance-input-group {
    display: flex;
    align-items: center;
}

.distance-input {
    flex: 1;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
}

.distance-suffix {
    background-color: var(--surface-color);
    border: 1px solid var(--border-color);
    border-left: none;
    border-top-right-radius: 8px;
    border-bottom-right-radius: 8px;
    padding: 10px 14px;
    font-family: inherit;
    font-size: 14px;
    color: var(--text-secondary);
    font-weight: 600;
}

/* Radio Group with Modern Theme */
.radio-group {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
    margin-top: 5px;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 8px;
}

.radio-option input[type="radio"] {
    margin: 0;
    width: 18px;
    height: 18px;
    accent-color: var(--accent-color);
}

.radio-option label {
    font-size: 14px;
    color: var(--text-primary);
    cursor: pointer;
    font-weight: 500;
}

/* For the last item that should span full width */
.radio-option:last-child {
    grid-column: span 2;
}

/* Apply Button with Modern Theme */
.apply-btn {
    padding: 10px 20px;
    background: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    height: 42px;
    box-shadow: 0 4px 12px rgba(0, 180, 216, 0.3);
    position: relative;
    overflow: hidden;
}

.apply-btn::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.apply-btn:hover::before {
    left: 100%;
}

.apply-btn:hover {
    background: var(--secondary-color);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 180, 216, 0.4);
}

/* Toolbar with Modern Theme */
.toolbar {
    background-color: var(--surface-color);
    padding: 15px 25px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: var(--shadow-sm);
}

.toolbar-group {
    display: flex;
    align-items: center;
    gap: 10px;
}

.toolbar-label {
    font-size: 14px;
    color: var(--text-secondary);
    font-weight: 600;
}

/* Page Navigation */
.page-nav {
    display: flex;
    align-items: center;
    gap: 10px;
}

.page-btn {
    width: 36px;
    height: 36px;
    border: 1px solid var(--border-color);
    background-color: var(--background-color);
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    transition: all 0.3s ease;
    color: var(--text-primary);
}

.page-btn:hover:not(:disabled) {
    background-color: var(--light-accent-bg);
    transform: translateY(-2px);
    box-shadow: var(--shadow-sm);
}

.page-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.page-info {
    font-size: 14px;
    font-weight: 600;
    min-width: 80px;
    text-align: center;
    color: var(--text-secondary);
}

/* Zoom Controls */
.zoom-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}

.zoom-btn {
    width: 36px;
    height: 36px;
    border: 1px solid var(--border-color);
    background-color: var(--background-color);
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    transition: all 0.3s ease;
    color: var(--text-primary);
}

.zoom-btn:hover {
    background-color: var(--light-accent-bg);
    transform: translateY(-2px);
    box-shadow: var(--shadow-sm);
}

.zoom-level {
    font-size: 14px;
    font-weight: 600;
    min-width: 50px;
    text-align: center;
    color: var(--text-secondary);
}

/* PDF Container */
.pdf-container {
    flex: 1;
    overflow: auto;
    background-color: var(--light-accent-bg);
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 20px;
    position: relative;
}

/* PDF Page */
.pdf-page {
    position: relative;
    box-shadow: var(--shadow-lg);
    background-color: white;
    margin: 20px;
    border-radius: 4px;
}

/* Canvas Wrapper */
.canvas-wrapper {
    position: relative;
    display: inline-block;
}

#pdf-canvas, #edit-canvas {
    display: block;
}

#edit-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10;
}

/* Text Box with Modern Theme */
.text-box {
    position: absolute;
    border: 2px dashed var(--accent-color);
    background-color: rgba(0, 180, 216, 0.1);
    cursor: pointer;
    z-index: 20;
    transition: all 0.3s ease;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    border-radius: 6px;
}

.text-box:hover {
    background-color: rgba(0, 180, 216, 0.2);
    border-color: var(--secondary-color);
    transform: scale(1.02);
}

.text-box.edited {
    border-color: #0A2463;
    background-color: rgba(62, 146, 204, 0.1);
}

/* Text Input */
.text-input {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px;
    border: 1px solid var(--border-color);
    background-color: var(--background-color);
    font-family: inherit;
    z-index: 10000;
    outline: none;
    box-shadow: var(--shadow-lg);
    border-radius: 12px;
    font-size: 16px;
    min-width: 400px;
    max-width: 80%;
}

.text-input:focus {
    box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.2);
}

/* Edit Controls */
.edit-controls {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--border-color);
    flex-wrap: wrap;
}

.control-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.control-label {
    font-size: 14px;
    color: var(--text-secondary);
    font-weight: 600;
    min-width: 50px;
}

.color-input {
    width: 50px;
    height: 35px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
}

.font-select {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background-color);
    font-family: inherit;
    cursor: pointer;
    font-size: 14px;
}

.font-btn, .bold-btn {
    padding: 8px 15px;
    border: 1px solid var(--border-color);
    background-color: var(--background-color);
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s ease;
    color: var(--text-primary);
}

.font-btn.active, .bold-btn.active {
    background: var(--accent-color);
    color: white;
    border-color: var(--accent-color);
}

.font-btn:hover, .bold-btn:hover {
    background-color: var(--light-accent-bg);
}

/* Dialog Buttons */
.dialog-buttons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 20px;
}

.dialog-btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.dialog-btn-save {
    background: var(--accent-color);
    color: white;
}

.dialog-btn-save:hover {
    background: var(--secondary-color);
}

.dialog-btn-cancel {
    background-color: var(--surface-color);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}

.dialog-btn-cancel:hover {
    background-color: var(--light-accent-bg);
}

/* Notification */
.notification {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    background: var(--primary-color);
    color: white;
    padding: 15px 25px;
    border-radius: 8px;
    box-shadow: var(--shadow-lg);
    z-index: 1000;
    opacity: 0;
    transition: all 0.3s ease;
    font-size: 16px;
    font-weight: 500;
}

.notification.show {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
}

/* Loading Overlay */
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.loading-overlay.show {
    opacity: 1;
    pointer-events: all;
}

/* Modern Themed Spinner */
.spinner {
    width: 50px;
    height: 50px;
    border: 5px solid rgba(0, 180, 216, 0.2);
    border-radius: 50%;
    border-top-color: var(--accent-color);
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Modal with Modern Theme */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    overflow: auto;
}

.modal-content {
    background-color: var(--background-color);
    margin: 15% auto;
    padding: 20px;
    border: none;
    border-radius: 12px;
    width: 50%;
    max-width: 500px;
    box-shadow: var(--shadow-lg);
    position: relative;
}

/* Removed nature decorations from modal */
.modal-content::before {
    display: none;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
}

.modal-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-primary);
}

.close {
    color: var(--text-secondary);
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    transition: color 0.3s ease;
}

.close:hover {
    color: var(--text-primary);
}

.modal-body {
    margin-bottom: 20px;
}

.modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.modal-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.modal-btn-primary {
    background: var(--accent-color);
    color: white;
}

.modal-btn-primary:hover {
    background: var(--secondary-color);
}

.modal-btn-secondary {
    background-color: var(--surface-color);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}

.modal-btn-secondary:hover {
    background-color: var(--light-accent-bg);
}

/* File Input Wrapper */
.file-input-wrapper {
    position: relative;
    overflow: hidden;
    display: inline-block;
    width: 100%;
}

.file-input-wrapper input[type=file] {
    position: absolute;
    left: -9999px;
}

.file-input-label {
    display: block;
    padding: 10px 14px;
    border: 2px dashed var(--accent-color);
    border-radius: 8px;
    background-color: rgba(0, 180, 216, 0.05);
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    color: var(--text-primary);
    font-weight: 500;
}

.file-input-label:hover {
    background-color: rgba(0, 180, 216, 0.1);
}

.file-name {
    margin-top: 10px;
    font-size: 14px;
    color: var(--text-secondary);
    word-break: break-all;
}

/* QR Code Modal */
#qr-modal .modal-content {
    width: 60%;
    max-width: 600px;
}

#qr-code-container {
    display: flex;
    justify-content: center;
    margin: 20px 0;
}

#qr-code-preview {
    border: 1px solid var(--border-color);
    padding: 15px;
    background-color: white;
    border-radius: 8px;
}

.qr-size-controls {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.qr-size-slider {
    flex: 1;
    display: none;
}

.qr-size-value {
    min-width: 60px;
    text-align: center;
    font-weight: 600;
    color: var(--text-secondary);
}

.qr-position-controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 15px;
}

.position-btn {
    padding: 10px;
    border: 1px solid var(--border-color);
    background-color: var(--background-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
    color: var(--text-primary);
}

.position-btn:hover {
    background-color: var(--light-accent-bg);
}

.position-btn.active {
    background: var(--accent-color);
    color: white;
    border-color: var(--accent-color);
}

/* QR Code Box */
.qr-box {
    position: absolute;
    border: 2px dashed var(--accent-color);
    background-color: rgba(0, 180, 216, 0.1);
    cursor: move;
    z-index: 25;
    transition: all 0.3s ease;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.qr-box:hover {
    background-color: rgba(0, 180, 216, 0.2);
    border-color: var(--secondary-color);
    transform: scale(1.02);
}

.qr-box img {
    max-width: 100%;
    max-height: 100%;
}

.qr-box .resize-handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: var(--accent-color);
    border: 1px solid white;
    border-radius: 50%;
}

.qr-box .resize-handle.se {
    bottom: -5px;
    right: -5px;
    cursor: se-resize;
}

/* Image Box */
.image-box {
    position: absolute;
    border: 2px dashed var(--accent-color);
    cursor: pointer;
    z-index: 20;
    transition: all 0.2s;
    background-color: rgba(0, 180, 216, 0.1);
    border-radius: 6px;
}

.image-box:hover {
    border-color: var(--secondary-color);
    background-color: rgba(0, 180, 216, 0.2);
}
/* Quality Selection with Red Theme */
.quality-selection {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 15px 20px;
    background: linear-gradient(135deg, #fff5f5 0%, #ffffff 100%);
    border-radius: 10px;
    box-shadow: var(--shadow-md);
    margin-bottom: 25px;
    border: 1px solid rgba(209, 0, 0, 0.1);
    border-left: 4px solid var(--accent-color);
    position: relative;
    overflow: hidden;
}

.quality-selection::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 4px;
    height: 100%;
    background: var(--gradient-red);
}

.quality-selection label {
    font-family: inherit;
    font-size: 16px;
    font-weight: 700;
    color: var(--text-primary);
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.quality-selection label::before {
    content: '';
    font-size: 18px;
    color: var(--accent-color);
}

.quality-select {
    padding: 12px 40px 12px 16px;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background-color);
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23d10000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2.5' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
    
background-repeat: no-repeat;
    background-position: right 12px center;
    background-size: 18px;
    font-family: inherit;
    font-size: 16px;
    font-weight: 600;
    color: var(--text-primary);
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    min-width: 180px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    position: relative;
    z-index: 1;
}

.quality-select:hover {
    border-color: var(--accent-color);
    background-color: var(--light-accent-bg);
    transform: translateY(-1px);
    box-shadow: var(--shadow-sm);
}

.quality-select:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 0 3px rgba(209, 0, 0, 0.2);
    background-color: #fff;
}

/* Quality Options Styling */
.quality-select option {
    padding: 12px;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-primary);
    background-color: white;
    transition: all 0.2s ease;
}

.quality-select option:hover {
    background-color: var(--light-accent-bg);
    color: var(--accent-color);
}

.quality-select option:checked {
    background: linear-gradient(135deg, var(--light-accent-bg) 0%, #ffffff 100%);
    color: var(--accent-color);
    font-weight: 700;
    position: relative;
}

.quality-select option:checked::before {
    content: 'âœ“';
    position: absolute;
    right: 12px;
    color: var(--accent-color);
    font-weight: bold;
}

/* Quality Badge Indicator */
.quality-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    margin-left: auto;
    padding: 6px 12px;
    background: rgba(209, 0, 0, 0.1);
    border-radius: 20px;
    font-size: 13px;
    font-weight: 600;
    color: var(--accent-color);
    border: 1px solid rgba(209, 0, 0, 0.2);
}

.quality-badge::before {
    content: 'ðŸŸ¥';
    font-size: 12px;
}

/* Quality Info Tooltip */
.quality-info {
    position: relative;
    display: inline-flex;
    align-items: center;
    margin-left: 8px;
    cursor: help;
}

.quality-info:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 14px;
    background: var(--accent-dark);
    color: white;
    font-size: 13px;
    font-weight: 500;
    border-radius: 6px;
    white-space: nowrap;
    z-index: 1000;
    box-shadow: var(--shadow-lg);
    margin-top: 8px;
}

.quality-info:hover::before {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-bottom-color: var(--accent-dark);
    margin-top: 2px;
    z-index: 1001;
}

/* Quality Level Indicators */
.quality-level {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    margin-left: 8px;
}

.quality-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--border-color);
    transition: all 0.3s ease;
}

.quality-select:focus ~ .quality-level .quality-dot,
.quality-select:hover ~ .quality-level .quality-dot {
    background-color: var(--accent-light);
}

/* Selected Quality Highlight */
.quality-select option[value="HD"] {
    background: linear-gradient(135deg, #fff5f5 0%, #ffffff 100%);
    color: var(--accent-color);
    font-weight: 700;
}

.quality-select option[value="print"] {
    background: linear-gradient(135deg, #ffeaea 0%, #ffffff 100%);
    color: var(--accent-dark);
    font-weight: 700;
}

/* Quality Preset Buttons */
.quality-presets {
    display: flex;
    gap: 10px;
    margin-left: auto;
}

.quality-preset-btn {
    padding: 6px 14px;
    border: 2px solid var(--border-color);
    background: white;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 600;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.quality-preset-btn:hover {
    border-color: var(--accent-light);
    color: var(--accent-color);
    background: var(--light-accent-bg);
}

.quality-preset-btn.active {
    background: var(--gradient-red);
    color: white;
    border-color: var(--accent-color);
    box-shadow: var(--shadow-sm);
}

/* Responsive Design */
@media (max-width: 768px) {
    .quality-selection {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
        padding: 15px;
    }
    
    .quality-select {
        width: 100%;
        min-width: unset;
    }
    
    .quality-presets {
        width: 100%;
        justify-content: space-between;
    }
    
    .quality-preset-btn {
        flex: 1;
        text-align: center;
    }
}

/* Animation for Quality Change */
@keyframes qualityChange {
    0% { transform: scale(1); }
    50% { transform: scale(1.02); }
    100% { transform: scale(1); }
}

.quality-select:focus {
    animation: qualityChange 0.3s ease;
}

/* Quality Meter */
.quality-meter {
    width: 100%;
    height: 4px;
    background: var(--surface-color);
    border-radius: 2px;
    margin-top: 8px;
    overflow: hidden;
    position: relative;
}

.quality-meter-fill {
    height: 100%;
    background: var(--gradient-red);
    border-radius: 2px;
    transition: width 0.5s ease;
    width: 75%; /* Default for HD */
}

.quality-select[value="standard"] ~ .quality-meter .quality-meter-fill { width: 25%; }
.quality-select[value="high"] ~ .quality-meter .quality-meter-fill { width: 40%; }
.quality-select[value="ultra"] ~ .quality-meter .quality-meter-fill { width: 60%; }
.quality-select[value="HD"] ~ .quality-meter .quality-meter-fill { width: 75%; }
.quality-select[value="pc"] ~ .quality-meter .quality-meter-fill { width: 85%; }
.quality-select[value="ultraHD"] ~ .quality-meter .quality-meter-fill { width: 90%; }
.quality-select[value="print"] ~ .quality-meter .quality-meter-fill { width: 100%; }

/* Quality Description */
.quality-description {
    font-size: 13px;
    color: var(--text-secondary);
    margin-top: 6px;
    font-style: italic;
    padding-left: 24px;
    position: relative;
}

.quality-description::before {
    content: 'ðŸ’¡';
    position: absolute;
    left: 0;
    color: var(--complementary-1);
}
/* Validation Message */
.validation-message {
    font-size: 12px;
    margin-top: 5px;
    min-height: 16px;
}

.validation-message.error {
    color: var(--error-color);
}

.validation-message.success {
    color: var(--success-color);
}

.form-input.error {
    border-color: var(--error-color);
}

.form-input.success {
    border-color: var(--success-color);
}

/* Saved Data List */
.saved-data-list {
    max-height: 400px;
    overflow-y: auto;
}

.saved-data-item {
    padding: 15px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    background-color: var(--background-color);
}

.saved-data-item:hover {
    background-color: var(--light-accent-bg);
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.saved-data-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.saved-data-item-date {
    font-weight: 600;
    color: var(--accent-color);
}

.saved-data-item-delete {
    color: var(--error-color);
    cursor: pointer;
    font-size: 18px;
}

.saved-data-item-content {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}

.saved-data-item-field {
    font-size: 14px;
}

.saved-data-item-field-name {
    font-weight: 600;
    color: var(--text-secondary);
}

.saved-data-item-field-value {
    color: var(--text-primary);
}

.empty-list-message {
    text-align: center;
    padding: 20px;
    color: var(--text-secondary);
    font-style: italic;
}

/* QR Code Download Button */
#qr-download-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    margin-right: 10px;
    background-color: var(--accent-color);
    color: white;
}

#qr-download-btn:hover {
    background-color: var(--secondary-color);
    transform: translateY(-1px);
}

#qr-download-btn:active {
    transform: translateY(0);
}

#qr-download-btn:disabled {
    background-color: var(--text-secondary);
    cursor: not-allowed;
    transform: none;
}

/* Maintenance Container */
.maintenance-container {
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: var(--primary-color);
    color: white;
    font-family: inherit;
    text-align: center;
    padding: 20px;
    position: relative;
    overflow: hidden;
}

/* Removed animated nature elements from maintenance screen */
.maintenance-container::before {
    display: none;
}

.maintenance-icon {
    font-size: 64px;
    margin-bottom: 20px;
}

.maintenance-title {
    font-size: 32px;
    margin-bottom: 15px;
    color: white;
}

.maintenance-message {
    font-size: 18px;
    max-width: 600px;
    line-height: 1.5;
}

.maintenance-eta {
    margin-top: 15px;
    font-size: 16px;
    font-style: italic;
}

.countdown {
    font-weight: bold;
    color: white;
}

/* Locked Apply Button */
.apply-btn.locked {
    background-color: var(--text-secondary);
    color: white;
    cursor: not-allowed;
    opacity: 0.7;
}

.apply-btn.locked:hover {
    background-color: var(--text-secondary);
    transform: none;
}

/* Message Alert */
.message-alert {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    padding: 15px;
    text-align: center;
    z-index: 9999;
    transform: translateY(-100%);
    transition: transform 0.4s ease-in-out, opacity 0.4s ease-in-out;
    opacity: 0;
    box-shadow: var(--shadow-md);
}

.message-alert.show {
    transform: translateY(0);
    opacity: 1;
}

.alert-content {
    display: flex;
    justify-content: center;
    align-items: center;
    max-width: 1200px;
    margin: 0 auto;
    font-size: 16px;
    font-weight: 500;
}

#alert-message-text {
    flex-grow: 1;
}

.alert-close-btn {
    background: none;
    border: none;
    color: inherit;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    margin-left: 20px;
    opacity: 0.7;
    transition: opacity 0.2s;
}

.alert-close-btn:hover {
    opacity: 1;
}

/* Alert Type Styles */
.message-alert.info {
    background-color: var(--accent-color);
    color: white;
}

.message-alert.warning {
    background-color: #ffc107;
    color: #212529;
}

.message-alert.success {
    background-color: var(--success-color);
    color: white;
}

.message-alert.error {
    background-color: var(--error-color);
    color: white;
}

/* Site Auto Restart Modal */
.restart-modal {
    display: none;
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75);
    justify-content: center;
    align-items: center;
    animation: fadeIn 0.3s;
}

.restart-modal.show {
    display: flex;
}

.restart-modal-content {
    background-color: var(--background-color);
    padding: 30px;
    border-radius: 12px;
    text-align: center;
    max-width: 400px;
    box-shadow: var(--shadow-lg);
    animation: slideIn 0.4s;
    position: relative;
    overflow: hidden;
}

/* Removed nature decorations from restart modal */
.restart-modal-content::before {
    display: none;
}

.restart-icon {
    font-size: 48px;
    margin-bottom: 15px;
    color: var(--accent-color);
}

.restart-title {
    font-size: 24px;
    margin-top: 0;
    margin-bottom: 10px;
    color: var(--text-primary);
}

.restart-message {
    font-size: 16px;
    color: var(--text-secondary);
    margin-bottom: 20px;
    line-height: 1.5;
}

.restart-countdown {
    font-size: 48px;
    font-weight: bold;
    color: var(--accent-color);
    margin: 20px 0;
    font-family: 'Courier New', Courier, monospace;
}

.restart-now-btn {
    background-color: var(--accent-color);
    color: white;
    border: none;
    padding: 12px 25px;
    border-radius: 8px;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.restart-now-btn:hover {
    background-color: var(--secondary-color);
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from { transform: translateY(-50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

/* Browser Lock Screen */
.browser-lock-screen {
    display: none;
    position: fixed;
    z-index: 20000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: var(--primary-color);
    color: white;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-family: inherit;
    overflow: hidden;
}

/* Removed animated nature elements from browser lock screen */
.browser-lock-screen::before {
    display: none;
}

.browser-lock-screen.show {
    display: flex;
}

.lock-content {
    max-width: 500px;
    padding: 40px;
    position: relative;
    z-index: 1;
}

.lock-icon {
    font-size: 64px;
    margin-bottom: 20px;
}

.lock-title {
    font-size: 32px;
    margin-top: 0;
    margin-bottom: 20px;
    color: white;
}

.lock-message {
    font-size: 18px;
    line-height: 1.6;
    margin-bottom: 15px;
}

.browser-detected {
    margin-top: 30px;
    font-size: 16px;
    color: var(--accent-color);
}

.browser-detected strong {
    color: white;
    font-weight: bold;
}

/* Locked Buttons */
.header-controls button.locked {
    background-color: var(--text-secondary);
    color: white;
    cursor: not-allowed;
    opacity: 0.7;
}

.header-controls button.locked:hover {
    background-color: var(--text-secondary);
    transform: none;
}

/* Connection Status Indicator */
.connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    display: none;
    z-index: 1000;
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 14px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 500;
    color: white;
    transition: all 0.3s ease;
    box-shadow: var(--shadow-sm);
}

.status-indicator.online {
    background-color: var(--success-color);
}

.status-indicator.offline {
    background-color: var(--error-color);
    animation: pulse-red 2s infinite;
}

.status-indicator.slow {
    background-color: #ffc107;
    color: #212529;
    animation: pulse-yellow 1.5s infinite;
}

@keyframes pulse-red {
    0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
    100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
}

@keyframes pulse-yellow {
    0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
    100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
}

/* Error Overlay */
.error-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 5px 10px;
    background-color: rgba(220, 53, 69, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10;
    border-radius: 4px;
    opacity: 0;
    transform: scale(0.8);
    transition: opacity 0.3s ease-out, transform 0.3s ease-out;
    pointer-events: none;
}

.error-overlay.is-visible {
    opacity: 1;
    transform: scale(1);
    pointer-events: all;
}

.error-overlay-text {
    color: white;
    font-size: 1.5em;
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
    animation: error-text-pulse 1.5s infinite ease-in-out;
}

@keyframes error-text-pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
}

/* The full-screen ban overlay */
#fullscreen-ban-flag {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
}

/* The content box inside the overlay */
.ban-content {
    text-align: center;
    color: #ffffff;
    padding: 2rem;
}

.ban-content .ban-icon {
    font-size: 5rem;
    margin-bottom: 1rem;
    color: var(--error-color);
}

.ban-content h1 {
    font-size: 3rem;
    margin: 0;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.ban-content p {
    font-size: 1.5rem;
    margin-top: 0.5rem;
    opacity: 0.9;
}

/* Class to show the notification with a fade-in effect */
#fullscreen-ban-flag.show {
    opacity: 1;
}


        /* --- NEW: Toast Notification Styles --- */
        #toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            background-color: #333;
            color: #fff;
            padding: 16px 24px;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.4s ease, transform 0.4s ease;
            min-width: 250px;
            text-align: center;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        /* Toast types for different messages */
        .toast.success { background-color: #28a745; }
        .toast.error { background-color: #dc3545; }
        .toast.warning { background-color: #ffc107; color: #212529; }
 
</style>
</head>
<body>

<!-- Internet Connection Status Indicator -->
<div id="connection-status" class="connection-status">
    <div class="status-indicator offline">
        <i class="fas fa-wifi"></i>
        <span id="status-text">Checking...</span>
    </div>
</div>

<!-- Browser Lock Screen -->
<div id="browser-lock-screen" class="browser-lock-screen">
    <div class="lock-content">
        <div class="lock-icon">ðŸš«</div>
        <h1 class="lock-title">Unsupported Browser</h1>
        <p class="lock-message">
            Sorry, the browser you are using is not supported for security and compatibility reasons.
        </p>
        <p class="lock-message">
            Please try accessing this site using a supported browser like Google Chrome, Mozilla Firefox, or Microsoft Edge.
        </p>
        <p class="browser-detected">
            Your detected browser: <strong id="detected-browser-name">Unknown</strong>
        </p>
    </div>
</div>

<!-- Site Restart Modal -->
<div id="restart-modal" class="modal">
    <div class="modal-content">
        <h2><i class="fas fa-exclamation-triangle"></i> Site Restart Required</h2>
        <p>The administrator has scheduled a site restart to apply important updates.</p>
        <p>The page will automatically refresh in: <span id="restart-countdown">30</span> seconds.</p>
        <button id="restart-now-btn" class="btn btn-primary">Refresh Now</button>
    </div>
</div>

<!-- Message Alert Container -->
<div id="message-alert" class="message-alert">
    <div class="alert-content">
        <span id="alert-message-text"></span>
        <button id="alert-close-btn" class="alert-close-btn">&times;</button>
    </div>
</div>

<!-- Add maintenance mode HTML -->
<div id="maintenance-container" class="maintenance-container">
    <div class="maintenance-icon">ðŸ”§</div>
    <h1 class="maintenance-title">Server Under Maintenance</h1>
    <p class="maintenance-message">We're currently performing scheduled maintenance to improve our services. We apologize for any inconvenience.</p>
    <p class="maintenance-eta">Estimated time remaining: <span id="maintenance-countdown" class="countdown">--:--:--</span></p>
</div>

<!-- Login Page -->
<div class="login-container" id="login-container">
    <div class="login-card">
        <h1 class="login-title">PDF Form Editor</h1>
        <p style="margin-bottom: 30px; color: #7f8c8d;">Please sign in to continue</p>
        
        <form id="login-form">
            <div class="form-group">
                <label class="form-label" for="username">Username</label>
                <input type="text" id="username" class="form-input" placeholder="Enter your username" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="password">Password</label>
                <input type="password" id="password" class="form-input" placeholder="Enter your password" required>
            </div>
            <button type="submit" class="login-btn" id="login-btn">Login</button>
            <div class="error-message" id="login-error"></div>
        </form>
    </div>
</div>

<!-- App Container - THIS WAS MISSING! -->
<div class="app-container" id="app-container" style="display: none;">
    
<header>
    <div class="title">PDF Form Editor</div>
    <div class="header-controls">
        
        <!-- Editing Controls -->
        <button class="save-btn" id="save-btn">ðŸ’¾ Save PDF</button>
        <button class="save-btn" id="save-edits-btn">ðŸ’¾ Save Edits</button>
        <button class="save-btn" id="load-edits-btn">ðŸ“‚ Load Edits</button>
        
        <!-- Additional Controls -->
       
        
        <!-- User Controls -->
        <button class="save-btn" id="logout-btn">ðŸšª Logout</button>

        <button class="save-btn" id="FScreen-btn">ðŸ’» FULLSCREEN</button>
 <button class="save-btn" id="qr-btn">ðŸ”² QR Code</button>
    </div>
</header>
    <div class="quality-selection">
        <label for="quality-select">Output Quality:</label>
        <select id="quality-select">
            <option value="standard">Standard</option>
            <option value="high">High</option>
            <option value="ultra">Ultra</option>
            <option value="HD" selected>HD</option>
            <option value="pc">PC</option>
            <option value="ultraHD">Ultra HD</option>
            <option value="print">Print Quality</option>
        </select>
    </div>

    <!-- Hidden file input for images -->
    <input type="file" id="image-input" accept="image" style="display: none;">
    
    <div class="form-section">
        <div class="form-group">
            <label class="form-label" for="purchaser-input">Name of Purchaser:</label>
            <input type="text" id="purchaser-input" class="form-input" placeholder="BIG B TRANZ" required>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="Bulk-input">Bulk Transit Pass No:</label>
            <input type="text" id="Bulk-input" class="form-input" placeholder="THNSY250001534" required>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="security-input">Security Paper Serial No:</label>
            <input type="text" id="security-input" class="form-input" placeholder="TSPS01907125" required>
        </div>
        <div class="form-group">
            <label class="form-label" for="transit-input">Transit Pass Serial No:</label>
            <input type="text" id="transit-input" class="form-input" placeholder="THN000000056770/2025" required>
        </div>
        <div class="form-group">
            <label class="form-label">Destination and State:</label>
            <div class="radio-group">
                <div class="radio-option">
                    <input type="radio" id="tamilnadu-radio" name="destination-option" value="tamilnadu">
                    <label for="tamilnadu-radio">Tamilnadu</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="kerala-radio" name="destination-option" value="kerala" checked>
                    <label for="kerala-radio">Kerala</label>
                </div>
            </div>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="address-input">Address of the Purchaser:</label>
            <input type="text" id="address-input" class="form-input" placeholder="ANACHAL" required>
            <div id="address-validation-message" class="validation-message"></div>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="driver-input">Name of Vehicle Driver:</label>
            <input type="text" id="driver-input" class="form-input" placeholder="SREEJITH" required>
            <div id="driver-validation-message" class="validation-message"></div>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="vehicle-input">Vehicle No:</label>
            <input type="text" id="vehicle-input" class="form-input" placeholder="KL69D3996" required>
            <div id="vehicle-validation-message" class="validation-message"></div>
        </div>

        <div class="form-group">
            <label class="form-label">Name of Mineral / Mineral Products:</label>
            <div class="radio-group">
                <div class="radio-option">
                    <input type="radio" id="msand-radio" name="mineral-option" value="Rough Stone / M-Sand" checked>
                    <label for="msand-radio">M-Sand</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="psand-radio" name="mineral-option" value="Rough Stone / P-Sand">
                    <label for="psand-radio">P-Sand</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="jelly-radio" name="mineral-option" value="Rough Stone / Jelly">
                    <label for="jelly-radio">Jelly</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="dust-radio" name="mineral-option" value="Rough Stone / Dust">
                    <label for="dust-radio">Dust</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="roughstone-radio" name="mineral-option" value="Rough Stone / Rough Stone">
                    <label for="roughstone-radio">Rough Stone</label>
                </div>
            </div>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="quantity-input">Quantity(in MT):</label>
            <input type="number" id="quantity-input" class="form-input" placeholder="35" required>
            <div id="quantity-validation-message" class="validation-message"></div>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="hours-input">Duration (hours):</label>
            <input type="number" id="hours-input" class="form-input" placeholder="5" min="1" max="24" required>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="timestart-input">Start Time:</label>
            <input type="text" id="timestart-input" class="form-input" placeholder="19-11-2025 08:32" required>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="timeend-input">End Time:</label>
            <input type="text" id="timeend-input" class="form-input" placeholder="13-11-2025 13:32" required>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="dispatchdatetime-input">Date & Time of Dispatch:</label>
            <input type="text" id="dispatchdatetime-input" class="form-input" placeholder="17-11-2025 09:00" required>
        </div>
        
        <div class="form-group">
            <label class="form-label" for="distance-input">Approximate Distance:</label>
            <div class="distance-input-group">
                <input type="number" id="distance-input" class="form-input distance-input" placeholder="151" min="0" required>
                <div class="distance-suffix">kms</div>
            </div>
        </div>
        
        <button class="apply-btn" id="apply-btn">Apply to PDF</button>
    </div>
    
    <div class="toolbar">
        <div class="page-nav">
            <button class="page-btn" id="prev-page">â€¹</button>
            <span class="page-info" id="page-info">Page 1 of 1</span>
            <button class="page-btn" id="next-page">â€º</button>
        </div>
        
        <div class="zoom-controls">
            <button class="zoom-btn" id="zoom-out">âˆ’</button>
            <span class="zoom-level" id="zoom-level">150%</span>
            <button class="zoom-btn" id="zoom-in">+</button>
        </div>
    </div>
    
    <div class="pdf-container" id="pdf-container">
        <div class="pdf-page" id="pdf-page">
            <div class="canvas-wrapper" id="canvas-wrapper">
                <canvas id="pdf-canvas"></canvas>
                <canvas id="edit-canvas"></canvas>
            </div>
            <div class="loading-overlay" id="loading-overlay">
                <div class="spinner"></div>
            </div>
        </div>
    </div>
    
    <!-- Save Edits Modal -->
    <div id="save-edits-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Save PDF Edits</h2>
                <span class="close" id="save-modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <p>Save your PDF edits to a file for later use.</p>
                <div class="form-group">
                    <label class="form-label" for="save-filename">File Name:</label>
                    <input type="text" id="save-filename" class="form-input" placeholder="My PDF Edits" value="My PDF Edits">
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" id="save-modal-cancel">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="save-modal-confirm">Save</button>
            </div>
        </div>
    </div>

    <!-- Load Edits Modal -->
    <div id="load-edits-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Load PDF Edits</h2>
                <span class="close" id="load-modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <p>Load your previously saved PDF edits from a file.</p>
                <div class="file-input-wrapper">
                    <input type="file" id="load-file-input" accept=".json">
                    <label for="load-file-input" class="file-input-label">
                        Choose a file
                    </label>
                    <div class="file-name" id="load-file-name">No file selected</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" id="load-modal-cancel">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="load-modal-confirm">Load</button>
            </div>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qr-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">QR Code Generator</h2>
                <span class="close" id="qr-modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="qr-text-input">QR Code Content:</label>
                    <input type="text" id="qr-text-input" class="form-input" placeholder="Enter text or URL for QR code">
                </div>
                
                <div class="qr-size-controls">
                    <label class="form-label" for="qr-size-slider">Size:</label>
                    <input type="range" id="qr-size-slider" class="qr-size-slider" min="50" max="300" value="198">
                    <div class="qr-size-value" id="qr-size-value">198px</div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Position on PDF:</label>
                    <div class="qr-position-controls">
                        <button class="position-btn" data-position="top-left">Top Left</button>
                        <button class="position-btn" data-position="top-center">Top Center</button>
                        <button class="position-btn" data-position="top-right">Top Right</button>
                        <button class="position-btn" data-position="middle-left">Middle Left</button>
                        <button class="position-btn active" data-position="middle-center">Middle Center</button>
                        <button class="position-btn" data-position="middle-right">Middle Right</button>
                        <button class="position-btn" data-position="bottom-left">Bottom Left</button>
                        <button class="position-btn" data-position="bottom-center">Bottom Center</button>
                        <button class="position-btn" data-position="bottom-right">Bottom Right</button>
                    </div>
                </div>
                
                <div id="qr-code-container">
                    <div id="qr-code-preview"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-primary" id="qr-download-btn">Download QR Code</button>
                <button class="modal-btn modal-btn-secondary" id="qr-modal-cancel">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="qr-modal-confirm">Add to PDF</button>
            </div>
        </div>
    </div>

    <!-- Saved Data List Modal -->
    <div id="saved-data-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Saved Form Data</h2>
                <span class="close" id="saved-data-modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <div id="saved-data-list" class="saved-data-list">
                    <!-- Saved data items will be added here dynamically -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" id="saved-data-modal-close-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Dialog -->
    <div class="text-input" id="edit-dialog" style="display: none;">
        <div class="edit-controls">
            <div class="control-group">
                <label class="control-label">Font:</label>
                <select class="font-select" id="font-select">
                    <option value="Roboto Thin">Roboto Thin</option>
                    <option value="Roboto Light">Roboto Light</option>
                    <option value="Roboto" selected>Roboto Regular</option>
                    <option value="Roboto Medium">Roboto Medium</option>
                    <option value="Roboto Bold">Roboto Bold</option>
                    <option value="Roboto Black">Roboto Black</option>
                    <option value="Arial">Arial</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                </select>
            </div>
            <div class="control-group">
                <label class="control-label">Color:</label>
                <input type="color" class="color-input" id="text-color" value="#000000">
            </div>
            <div class="control-group">
                <label class="control-label">Style:</label>
                <button class="font-btn" id="thin-btn">Thin</button>
                <button class="bold-btn" id="bold-btn">B</button>
            </div>
        </div>
        <input type="text" id="dialog-input" placeholder="Enter new text...">
        <div class="dialog-buttons">
            <button class="dialog-btn dialog-btn-save" id="dialog-save">Save</button>
            <button class="dialog-btn dialog-btn-cancel" id="dialog-cancel">Cancel</button>
        </div>
    </div>
    
    <div class="notification" id="notification"></div>

</div> <!-- This closes the app-container -->

      <script>
        // Performance optimization script
        document.addEventListener('DOMContentLoaded', function() {
            // Check if the user prefers reduced motion
            if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                // Disable animations for users who prefer reduced motion
                document.querySelectorAll('*').forEach(el => {
                    el.style.animation = 'none';
                    el.style.transition = 'none';
                });
            }
            
            // Reduce the number of animated elements on low-end devices
            function checkPerformance() {
                // Simple performance check - adjust thresholds as needed
                const isLowEnd = navigator.hardwareConcurrency <= 2 || 
                                 (navigator.deviceMemory && navigator.deviceMemory <= 2);
                
                if (isLowEnd) {
                    // Reduce number of elements
                    const elementsToRemove = [
                        '.cloud2',
                        '.bird3', '.bird4',
                        '.particle3', '.particle4', '.particle5',
                        '.leaf5', '.leaf6', '.leaf7', '.leaf8',
                        '.star5', '.star6', '.star7', '.star8',
                        '.tree-left-3', '.tree-right-3'
                    ];
                    
                    elementsToRemove.forEach(selector => {
                        const elements = document.querySelectorAll(selector);
                        elements.forEach(el => el.remove());
                    });
                }
            }
            
            checkPerformance();
            
            // Throttle scroll events if needed
            let ticking = false;
            function requestTick() {
                if (!ticking) {
                    requestAnimationFrame(updateAnimations);
                    ticking = true;
                }
            }
            
            function updateAnimations() {
                // Update any scroll-based animations here
                ticking = false;
            }
            
            // Only add scroll listener if needed
            // window.addEventListener('scroll', requestTick);
        });
    </script>
     <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js"></script>
    
    <!-- PDF.js and other libraries -->
    
    <script src="Pdf/jspdf.umd.min.js"></script>
    <script src="Pdf/crypto-js.min.js"></script>
    
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="Pdf/pdf.min.js"></script>
<script>
// --- Your Firebase Configuration ---
const firebaseConfig = {
    apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
    authDomain: "vipteammod-movies.firebaseapp.com",
    projectId: "vipteammod-movies",
    storageBucket: "vipteammod-movies.appspot.com",
    messagingSenderId: "1024721077525",
    appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
    databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
};

// --- START OF THE MERGED SCRIPT ---

// Initialize Firebase (SINGLE INITIALIZATION)
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

// --- DOM ELEMENT REFERENCES ---
const body = document.body;
const loginContainer = document.getElementById('login-container');
const appContainer = document.getElementById('app-container');
const maintenanceContainer = document.getElementById('maintenance-container');
const loginForm = document.getElementById('login-form');
const loginBtn = document.getElementById('login-btn');
const loginError = document.getElementById('login-error');
const logoutBtn = document.getElementById('logout-btn');
const notificationEl = document.getElementById('notification');

// Elements for the Vehicle Data Form
const vehicleInput = document.getElementById('vehicle-input');
const quantityInput = document.getElementById('quantity-input');
const vehicleValidationMessage = document.getElementById('vehicle-validation-message');

// --- FIREBASE REFERENCES ---
const featureControlRef = db.ref("featureControl");

// --- STATE VARIABLES ---
let isAppLocked = false;
let isMaintenanceMode = false;
let maintenanceEndTime = null;
let maintenanceCountdownInterval = null;
let vehicleData = {};
let saveTimeout;
let userVehicleDataRef = null; // To hold the user-specific database reference

// --- HELPER FUNCTIONS ---

/**
 * Shows a notification message to the user.
 * @param {string} message - The message to display.
 */
function showNotification(message) {
    if (notificationEl) {
        notificationEl.textContent = message;
        notificationEl.classList.add('show');
        setTimeout(() => {
            notificationEl.classList.remove('show');
        }, 3000);
    }
}

/**
 * Displays a message in the vehicle validation div.
 * @param {string} message - The text to display.
 * @param {'success'|'info'|'error'} type - The type of message for styling.
 */
function showVehicleMessage(message, type) {
    if (!vehicleValidationMessage) return;
    vehicleValidationMessage.textContent = message;
    vehicleValidationMessage.className = 'validation-message ' + type;
    
    if (type === 'success' || type === 'info') {
        setTimeout(() => {
            if (vehicleValidationMessage.textContent === message) {
                vehicleValidationMessage.textContent = '';
            }
        }, 3000);
    }
}

/**
 * Debounce function to limit how often a function can be called.
 * @param {Function} func The function to debounce.
 * @param {number} delay The delay in milliseconds.
 * @returns {Function} The debounced function.
 */
function debounce(func, delay) {
    return function(...args) {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => func.apply(this, args), delay);
    };
}

/**
 * Checks redirect conditions and performs the redirect if valid.
 * @param {string} redirectUrl - The URL to redirect to.
 * @param {boolean} isRedirectEnabled - The status of the redirect feature.
 */
function checkAndRedirect(redirectUrl, isRedirectEnabled) {
    if (redirectUrl && redirectUrl.trim() !== '' && isRedirectEnabled === true) {
        try {
            const url = new URL(redirectUrl);
            showNotification(`ðŸ”— Redirecting to: ${redirectUrl}`);
            setTimeout(() => {
                window.location.href = redirectUrl;
            }, 1500);
        } catch (e) {
            console.error("Invalid redirect URL received from Firebase:", redirectUrl);
        }
    }
}

/**
 * Formats seconds into HH:MM:SS format.
 * @param {number} seconds - The number of seconds to format.
 * @returns {string} The formatted time string.
 */
function formatTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    return [
        hours.toString().padStart(2, '0'),
        minutes.toString().padStart(2, '0'),
        secs.toString().padStart(2, '0')
    ].join(':');
}

/**
 * Updates the maintenance countdown timer.
 */
function updateMaintenanceCountdown() {
    if (!maintenanceEndTime) return;
    
    const now = new Date().getTime();
    const distance = maintenanceEndTime - now;
    
    if (distance < 0) {
        clearInterval(maintenanceCountdownInterval);
        document.getElementById('maintenance-countdown').textContent = "00:00:00";
        return;
    }
    
    const totalSeconds = Math.floor(distance / 1000);
    document.getElementById('maintenance-countdown').textContent = formatTime(totalSeconds);
}

/**
 * Handles the application maintenance mode state.
 * @param {boolean} isMaintenance - True if the app should be in maintenance mode.
 * @param {number} endTime - Timestamp when maintenance is expected to end.
 */
 
 // --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- DOM ELEMENTS FOR BROWSER LOCK ---
const browserLockScreen = document.getElementById('browser-lock-screen');
const detectedBrowserNameEl = document.getElementById('detected-browser-name');

// --- FIREBASE REFERENCE FOR BROWSER LOCK ---
const browserLockRef = db.ref("featureControl/browserLock");

// --- STATE VARIABLES ---
let lockedBrowsers = [];
let isSiteLocked = false;

/**
 * Detects the user's browser name.
 * @returns {string} The name of the browser (e.g., "Chrome", "Firefox").
 */
function detectBrowser() {
    const userAgent = navigator.userAgent;
    let browserName = "Unknown";

    if (userAgent.indexOf("Firefox") > -1) {
        browserName = "Firefox";
    } else if (userAgent.indexOf("UCBrowser") > -1) {
        browserName = "UC Browser";
    } else if (userAgent.indexOf("Edge") > -1) {
        browserName = "Edge";
    } else if (userAgent.indexOf("Chrome") > -1) {
        // Chrome must be checked after Edge and UCBrowser as their userAgents also contain "Chrome"
        browserName = "Chrome";
    } else if (userAgent.indexOf("Safari") > -1) {
        browserName = "Safari";
    } else if (userAgent.indexOf("MSIE") > -1 || userAgent.indexOf("Trident/") > -1) {
        browserName = "Internet Explorer";
    }
    return browserName;
}

/**
 * Checks if the current browser is locked and shows/hides the lock screen.
 */
function checkBrowserLockStatus() {
    const currentUserBrowser = detectBrowser();
    
    // Update the displayed browser name
    if (detectedBrowserNameEl) {
        detectedBrowserNameEl.textContent = currentUserBrowser;
    }

    // If the site is locked overall, or the specific browser is on the lock list
    if (isSiteLocked || lockedBrowsers.includes(currentUserBrowser)) {
        console.warn(`Access denied. Browser "${currentUserBrowser}" is locked or the site is locked.`);
        if (browserLockScreen) {
            browserLockScreen.classList.add('show');
        }
        // Hide the main app content
        if (loginContainer) loginContainer.style.display = 'none';
        if (appContainer) appContainer.style.display = 'none';
    } else {
        // If not locked, ensure the lock screen is hidden
        if (browserLockScreen) {
            browserLockScreen.classList.remove('show');
        }
        // Note: We don't show the login/app here. The main auth listener handles that.
    }
}

// Listen for changes to the browser lock settings in Firebase
browserLockRef.on("value", (snapshot) => {
    const data = snapshot.val() || {};
    
    // Check for a global site lock
    isSiteLocked = data.globalLock === true;
    
    // Get the list of locked browsers
    if (data.lockedBrowsers && Array.isArray(data.lockedBrowsers)) {
        lockedBrowsers = data.lockedBrowsers;
    } else {
        lockedBrowsers = [];
    }
    
    console.log("Browser lock settings updated:", { isSiteLocked, lockedBrowsers });
    
    // Run the check whenever settings change
    checkBrowserLockStatus();
});

// IMPORTANT: Run the check once on initial page load
checkBrowserLockStatus();
 // --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCES FOR BRIGHTNESS CONTROL ---
const brightnessControlRef = db.ref("featureControl/brightness");

/**
 * Applies a brightness filter to the entire page.
 * @param {number} brightnessValue - The brightness level (e.g., 0.5 for 50%, 1.2 for 120%).
 */
function applyBrightness(brightnessValue) {
    // Ensure the value is a valid number and within a reasonable range
    const value = parseFloat(brightnessValue);
    if (isNaN(value)) {
        console.warn("Invalid brightness value received, resetting to default.");
        body.style.filter = ''; // Remove filter if invalid
        return;
    }
    
    // Apply the filter. This will scale images, colors, etc.
    body.style.filter = `brightness(${value})`;
    console.log(`Brightness applied: ${value * 100}%`);
}

/**
 * Detects if the user is on a mobile device.
 * @returns {boolean} True if on a mobile device.
 */
function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// Listen for changes to the brightness setting in Firebase
brightnessControlRef.on("value", (snapshot) => {
    const data = snapshot.val();
    if (!data) {
        // If no data is present, remove any existing filter
        body.style.filter = '';
        console.log("Brightness control data not found, filter removed.");
        return;
    }

    // Check for mobile/desktop specific settings
    const brightnessForMobile = data.mobile;
    const brightnessForDesktop = data.desktop;

    let brightnessToApply = null;

    if (isMobileDevice() && brightnessForMobile !== undefined) {
        brightnessToApply = brightnessForMobile;
    } else if (!isMobileDevice() && brightnessForDesktop !== undefined) {
        brightnessToApply = brightnessForDesktop;
    }

    // If a specific value was found for the user's device type, apply it
    if (brightnessToApply !== null) {
        applyBrightness(brightnessToApply);
    } else {
        // Otherwise, remove any existing filter
        body.style.filter = '';
    }
});

// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- DOM ELEMENTS FOR CONNECTION STATUS ---
const connectionStatusEl = document.getElementById('connection-status');
const statusIndicatorEl = connectionStatusEl ? connectionStatusEl.querySelector('.status-indicator') : null;
const statusTextEl = document.getElementById('status-text');

// --- STATE VARIABLES ---
let isOnline = navigator.onLine;
let isSlowConnection = false;
let connectionCheckInterval;

/**
 * Updates the UI of the connection status indicator.
 * @param {'online'|'offline'|'slow'} status - The current connection status.
 */
function updateConnectionUI(status) {
    if (!statusIndicatorEl || !statusTextEl) return;

    // Remove all status classes
    statusIndicatorEl.classList.remove('online', 'offline', 'slow');
    // Add the new status class
    statusIndicatorEl.classList.add(status);

    switch (status) {
        case 'online':
            statusTextEl.textContent = 'Online';
            break;
        case 'offline':
            statusTextEl.textContent = 'Offline';
            showNotification('Connection lost. Please check your internet.', 'error');
            break;
        case 'slow':
            statusTextEl.textContent = 'Slow Connection';
            showNotification('Slow internet detected. Some features may be slow.', 'warning');
            break;
    }
}

/**
 * Checks the actual speed of the connection by pinging Firebase.
 */
async function checkConnectionSpeed() {
    if (!isOnline) {
        updateConnectionUI('offline');
        return;
    }

    const startTime = new Date().getTime();
    try {
        // A lightweight call to Firebase to check latency
        await db.ref('.info/connected').once('value');
        const endTime = new Date().getTime();
        const latency = endTime - startTime;

        // Consider over 1500ms as a slow connection
        if (latency > 1500) {
            if (!isSlowConnection) {
                isSlowConnection = true;
                updateConnectionUI('slow');
            }
        } else {
            if (isSlowConnection) {
                isSlowConnection = false;
                updateConnectionUI('online');
            }
        }
    } catch (error) {
        console.error("Connection speed check failed:", error);
        updateConnectionUI('offline');
    }
}






/**
 * Initializes the connection status monitoring.
 */
function initializeConnectionCheck() {
    // Initial status check
    updateConnectionUI(isOnline ? 'online' : 'offline');

    // Listen for browser online/offline events
    window.addEventListener('online', () => {
        isOnline = true;
        isSlowConnection = false; // Reset slow status on reconnect
        updateConnectionUI('online');
        showNotification('Connection restored.', 'success');
    });

    window.addEventListener('offline', () => {
        isOnline = false;
        updateConnectionUI('offline');
    });

    // Periodically check connection speed every 10 seconds
    connectionCheckInterval = setInterval(checkConnectionSpeed, 10000);
}

// Start the connection monitoring when the page loads
initializeConnectionCheck();

// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR THE SCHEDULER ---
const schedulerRef = db.ref("featureControl/scheduler");

// --- STATE VARIABLES ---
let schedulerCheckInterval;
let isSchedulerActive = false;

/**
 * Applies a set of site controls based on a task object.
 * @param {object} task - The task object from the scheduler.
 */
function applyScheduledChanges(task) {
    console.log("Scheduler: Applying scheduled changes:", task);
    showNotification('Scheduled site changes are now being applied.', 'warning');

    // 1. Site Lock
    if (task.lockSite === true) {
        handleAppLock(true);
    }

    // 2. Site Fully Hide
    if (task.hideSite === true) {
        document.body.style.display = 'none';
    }

    // 3. Site Restart
    if (task.restartSite === true) {
        performPageRefresh(); // Use the same refresh function from the restart control
    }

    // 4. Theme Change
    if (task.themeName) {
        // Assuming you have a function to change themes
        if (typeof changeTheme === 'function') {
            changeTheme(task.themeName);
        }
    }

    // 5. Button Hide (Example: Apply to PDF button)
    if (task.hideApplyPdfButton === true) {
        const applyPdfBtn = document.getElementById('apply-btn');
        if (applyPdfBtn) {
            applyPdfBtn.style.display = 'none';
        }
    }

    // 6. PDF Loader Lock
    if (task.lockPdfLoader === true) {
        handlePdfLoaderState(false); // Use the handler from the PDF loader control
    }
    
    // 7. PDF Button Lock
    if (task.lockPdfButton === true) {
        handlePdfButtonLock(true); // Use the handler from the PDF button lock control
    }

    // After applying, clear the task so it doesn't run again
    schedulerRef.set({
        active: false,
        task: null
    }).then(() => {
        console.log("Scheduler: Task executed and cleared.");
    });
}

/**
 * Checks if a scheduled task needs to be executed.
 */
function checkScheduler() {
    if (!isSchedulerActive) return;

    schedulerRef.once('value')
        .then((snapshot) => {
            const schedulerData = snapshot.val();
            
            if (!schedulerData || !schedulerData.active || !schedulerData.task) {
                return; // No active task
            }

            const task = schedulerData.task;
            const executionTime = new Date(task.executionTime).getTime();
            const currentTime = new Date().getTime();

            if (currentTime >= executionTime) {
                // It's time to execute the task!
                applyScheduledChanges(task);
            }
        })
        .catch((error) => {
            console.error("Scheduler: Error checking for tasks:", error);
        });
}

/**
 * Initializes the scheduler to check for tasks every 5 seconds.
 */
function initializeScheduler() {
    console.log("Scheduler: Initializing...");
    isSchedulerActive = true;
    
    // Check every 5 seconds (5000 milliseconds)
    schedulerCheckInterval = setInterval(checkScheduler, 5000);
    
    // Also, listen for real-time changes to the scheduler's active state
    schedulerRef.child("active").on("value", (snapshot) => {
        isSchedulerActive = snapshot.val() === true;
        if (!isSchedulerActive) {
            console.log("Scheduler: Deactivated by admin.");
            clearInterval(schedulerCheckInterval);
        }
    });
}

// --- INTEGRATION STEP ---
// Call this new function from your main init() function or when the script loads.
// If you have an existing init() function, add this line to it:
// initializeScheduler();

// If you don't have a central init function, you can call it directly.
// Make sure this runs after Firebase is initialized.
// initializeScheduler();

// --- DOM ELEMENTS ---
const restartModal = document.getElementById('restart-modal');
const restartCountdownEl = document.getElementById('restart-countdown');
const restartNowBtn = document.getElementById('restart-now-btn');

// --- CORRECTED FIREBASE REFERENCE ---
// We listen to the parent node to get both 'enabled' and 'command' at once.
const siteRestartRef = db.ref("featureControl/siteRestart");

// --- STATE ---
let restartCountdownInterval = null;

/**
 * Starts the countdown and shows the modal.
 * @param {number} delaySeconds - The delay before refreshing.
 */
function startSiteRestart(delaySeconds) {
    if (restartCountdownInterval) clearInterval(restartCountdownInterval);

    let timeLeft = delaySeconds;
    restartCountdownEl.textContent = timeLeft;
    restartModal.style.display = 'block';

    restartCountdownInterval = setInterval(() => {
        timeLeft--;
        restartCountdownEl.textContent = timeLeft;
        if (timeLeft <= 0) {
            clearInterval(restartCountdownInterval);
            performPageRefresh();
        }
    }, 1000);
}

/**
 * Performs the page refresh.
 */
function performPageRefresh() {
    console.log("Performing page refresh as commanded.");
    window.location.reload(true);
}

/**
 * Handles the data from Firebase and decides whether to trigger a restart.
 * @param {object|null} data - The data snapshot from Firebase.
 */
function handleSiteRestartData(data) {
    const isEnabled = data && data.enabled === true;
    const command = data && data.command;

    // If the feature is disabled, hide the modal and do nothing.
    if (!isEnabled) {
        console.log("Site Restart feature is disabled.");
        if (restartModal) {
            restartModal.style.display = 'none';
        }
        return;
    }

    // If the feature is enabled, check for a valid command.
    if (command && command.timestamp && command.delaySeconds) {
        console.log("Restart command received:", command);

        // Use localStorage to prevent re-triggering on a manual page refresh
        const lastProcessedTimestamp = localStorage.getItem('lastRestartTimestamp');
        if (lastProcessedTimestamp === command.timestamp.toString()) {
            console.log("Already processed this command, ignoring.");
            return;
        }

        // Mark this command as processed
        localStorage.setItem('lastRestartTimestamp', command.timestamp.toString());
        
        // Start the countdown
        startSiteRestart(command.delaySeconds);
    } else {
        // If the command is null or invalid, hide the modal
        if (restartModal) {
            restartModal.style.display = 'none';
        }
    }
}


// --- EVENT LISTENERS ---

// Listen for changes to the entire 'siteRestart' node
siteRestartRef.on("value", (snapshot) => {
    const data = snapshot.val();
    handleSiteRestartData(data);
});

// Allow the user to refresh immediately
if (restartNowBtn) {
    restartNowBtn.addEventListener('click', () => {
        if (restartCountdownInterval) {
            clearInterval(restartCountdownInterval);
        }
        performPageRefresh();
    });
}


// Assumes 'db' is your initialized firebase.database() instance.
// const db = firebase.database();

// --- User Side Active Code (Final Corrected Version) ---

// Reference to the main 'scheduleControl' node
const scheduleRef = db.ref('scheduleControl');
let isFeatureEnabled = false;
let targetRestartTime = null;

// A unique key for storing the restart state in the browser's local storage
const RESTART_LOCK_KEY = 'pageRestartLock';

// Listen for any changes from the admin
scheduleRef.on('value', (snapshot) => {
    const data = snapshot.val();
    isFeatureEnabled = data && data.enabled === true;
    targetRestartTime = data ? data.restartTime : null;

    console.log(`Restart feature enabled: ${isFeatureEnabled}, Time: ${targetRestartTime}`);

    // If the admin sets a NEW time, clear the old lock to allow a new restart
    if (targetRestartTime) {
        const lastRestartTime = localStorage.getItem(RESTART_LOCK_KEY);
        if (lastRestartTime !== targetRestartTime) {
            console.log("Admin set a new restart time. Clearing previous restart lock.");
            localStorage.removeItem(RESTART_LOCK_KEY);
        }
    }
});

// This function runs every second to check the time
function checkForRestart() {
    // 1. Do nothing if the feature is disabled or no time is set
    if (!isFeatureEnabled || !targetRestartTime) {
        return;
    }

    // 2. CRITICAL FIX: Check if we have already restarted for this specific time
    if (localStorage.getItem(RESTART_LOCK_KEY) === targetRestartTime) {
        return; // Stop immediately if we've already restarted for this time
    }

    const now = new Date();
    const [targetHours, targetMinutes] = targetRestartTime.split(':').map(Number);
    const currentTotalMinutes = (now.getHours() * 60) + now.getMinutes();
    
    // --- LOGIC: Check for the target time and the target time + 30 minutes ---
    const targetTimeSlot1 = (targetHours * 60 + targetMinutes);
    const targetTimeSlot2 = targetTimeSlot1 + 30;

    if (currentTotalMinutes === targetTimeSlot1 || currentTotalMinutes === targetTimeSlot2) {
        console.log(`Restart time reached! Locking and restarting now.`);
        
        // 3. CRITICAL FIX: Set the lock in localStorage BEFORE reloading
        // This ensures that when the page reloads, this script will see the lock and stop.
        localStorage.setItem(RESTART_LOCK_KEY, targetRestartTime);

        // 4. CRITICAL FIX: Stop the Firebase listener immediately
        // This prevents any last-minute updates from interfering.
        scheduleRef.off(); 
        
        // 5. Perform the restart
        window.location.reload();
    }
}

// Start the check every second (1000 milliseconds)
setInterval(checkForRestart, 1000);
// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR THEME CONTROL ---
const themeControlRef = db.ref("featureControl/theme");

/**
 * Applies a theme to the website by changing the body's class.
 * @param {string} themeName - The name of the theme to apply.
 */
function applyTheme(themeName) {
    // Define a list of all possible theme classes
    const allThemes = ['theme-default', 'theme-dark', 'theme-ocean', 'theme-sunset', 'theme-forest'];
    
    // Remove all existing theme classes from the body
    body.classList.remove(...allThemes);
    
    // Add the new theme class if it's valid
    if (themeName && allThemes.includes(themeName)) {
        body.classList.add(themeName);
        console.log(`Theme applied: ${themeName}`);
    } else {
        // If the theme is invalid or null, apply the default
        body.classList.add('theme-default');
        console.log("Invalid or no theme specified, applying default.");
    }
}

// Listen for changes to the theme in Firebase
themeControlRef.on("value", (snapshot) => {
    const selectedTheme = snapshot.val();
    console.log(`Theme change command received: ${selectedTheme}`);
    applyTheme(selectedTheme);
});
 // --- CORRECTED USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCES ---
const zoomLimitsRef = db.ref("featureControl/zoomLimits");

// --- STATE VARIABLES FOR ZOOM LIMITS ---
let minZoom = 0.5; // Default minimum zoom
let maxZoom = 4.0; // Default maximum zoom

// --- ZOOM LIMITS LOGIC ---

// Listen for real-time updates to the zoom limits from Firebase
zoomLimitsRef.on("value", (snapshot) => {
    if (snapshot.exists()) {
        const limits = snapshot.val();
        minZoom = limits.minZoom || 0.5;
        maxZoom = limits.maxZoom || 4.0;
    } else {
        // If the node is deleted, revert to hardcoded defaults
        minZoom = 0.5;
        maxZoom = 4.0;
    }
    console.log(`Zoom limits updated: Min=${minZoom}, Max=${maxZoom}`);
    
    // If the current scale is now outside the new limits, adjust it and re-render
    if (typeof scale !== 'undefined' && typeof pageNum !== 'undefined') {
        if (scale > maxZoom) {
            scale = maxZoom;
            renderPage(pageNum);
        } else if (scale < minZoom) {
            scale = minZoom;
            renderPage(pageNum);
        }
    }
});

// --- ZOOM EVENT LISTENERS ---

// Attach event listeners once the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');

    if (zoomInBtn) {
        zoomInBtn.addEventListener('click', () => { 
            // Use the dynamic maxZoom variable
            scale = Math.min(scale * 1.2, maxZoom); 
            renderPage(pageNum); 
        });
    }

    if (zoomOutBtn) {
        zoomOutBtn.addEventListener('click', () => { 
            // Use the dynamic minZoom variable
            scale = Math.max(scale / 1.2, minZoom); 
            renderPage(pageNum); 
        });
    }
});

 // --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// A reference to listen specifically for the PDF button lock status
const pdfButtonLockRef = db.ref("featureControl/pdfButtonLock");

// Get the DOM element for the button
const applyPdfBtn = document.getElementById('apply-btn');

/**
 * Handles the lock/unlock state of the PDF button.
 * @param {boolean} isLocked - True if the button should be locked (disabled).
 */
function handlePdfButtonLock(isLocked) {
    if (!applyPdfBtn) {
        console.warn("Apply to PDF button not found on this page.");
        return;
    }

    if (isLocked) {
        applyPdfBtn.disabled = true;
        // Add a class to style the disabled state
        applyPdfBtn.classList.add('locked');
        // Optionally, change the button text to indicate it's locked
        applyPdfBtn.dataset.originalText = applyPdfBtn.textContent;
        applyPdfBtn.textContent = 'Locked by Admin';
        showNotification('The "Apply to PDF" feature has been temporarily disabled.', 'info');
    } else {
        applyPdfBtn.disabled = false;
        // Remove the locked class
        applyPdfBtn.classList.remove('locked');
        // Restore the original text
        if (applyPdfBtn.dataset.originalText) {
            applyPdfBtn.textContent = applyPdfBtn.dataset.originalText;
        }
    }
}



// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- DOM ELEMENTS FOR ALL FORM FIELDS ---
const formFields = {
    purchaser: document.getElementById('purchaser-input'),
    bulkTransit: document.getElementById('Bulk-input'),
    stoneYes: document.getElementById('Stone-Yes'),
    stoneNo: document.getElementById('Stone-No'),
    security: document.getElementById('security-input'),
    transit: document.getElementById('transit-input'),
    address: document.getElementById('address-input'),
    driver: document.getElementById('driver-input'),
    driver2: document.getElementById('driver-input2'),
    driver3: document.getElementById('driver-input3'),
    driver4: document.getElementById('driver-input4'),
    vehicle: document.getElementById('vehicle-input'),
    vehicle2: document.getElementById('vehicle-input2'),
    quantity: document.getElementById('quantity-input'),
    hours: document.getElementById('hours-input'),
    timestart: document.getElementById('timestart-input'),
    timeend: document.getElementById('timeend-input'),
    distance: document.getElementById('distance-input')
};

// --- FIREBASE REFERENCES FOR TRACKING ---
// FIX 1: Declare references at a higher scope but don't assign them until the user is logged in.
let onlineUsersRef;
let userPresenceRef;
let userFormDataRef;

// --- STATE VARIABLES ---
let isUserOnline = false;
let formFieldListeners = []; // To store event listeners for easy removal

/**
 * Initializes the user tracking and form data sync.
 * This should be called after a successful login.
 */
function initializeUserTracking(user) {
    if (!user) return;

    // FIX 1: Now that we have the user, we can safely define the references.
    onlineUsersRef = db.ref(".info/connected");
    userPresenceRef = db.ref(`onlineUsers/${user.uid}`);
    userFormDataRef = db.ref(`liveFormData/${user.uid}`);

    // 1. --- PRESENCE TRACKING (Online/Offline) ---
    onlineUsersRef.on("value", (snapshot) => {
        if (snapshot.val() === false) {
            return;
        }

        // When we connect, set our status to online
        userPresenceRef.onDisconnect().remove(); // Remove user data when they disconnect
        userPresenceRef.set({
            uid: user.uid,
            email: user.email,
            lastSeen: firebase.database.ServerValue.TIMESTAMP,
            isOnline: true
        });

        // Also clear form data on disconnect
        userFormDataRef.onDisconnect().remove();
        
        isUserOnline = true;
        console.log("User is now online and being tracked.");
    });

    // 2. --- LIVE FORM DATA SYNC ---
    setupFormListeners();
}

/**
 * Attaches listeners to all form fields to sync their data to Firebase.
 */
function setupFormListeners() {
    Object.keys(formFields).forEach(key => {
        const field = formFields[key];
        if (!field) return;

        const eventType = field.type === 'radio' ? 'change' : 'input';
        
        const listenerCallback = () => {
            let value;
            if (field.type === 'radio') {
                // For radio buttons, find the selected value within the group
                const checkedRadio = document.querySelector(`input[name="${field.name}"]:checked`);
                value = checkedRadio ? checkedRadio.value : null;
            } else {
                value = field.value.trim();
            }
            
            // Update the specific field in Firebase
            if (userFormDataRef) { // Ensure ref is not null
                userFormDataRef.child(key).set(value)
                    .then(() => {
                        console.log(`Form field '${key}' synced to Firebase.`);
                    })
                    .catch(error => {
                        console.error(`Error syncing field '${key}':`, error);
                    });
            }
        };

        field.addEventListener(eventType, listenerCallback);
        // FIX 2: Store the listener and element so we can remove it later
        formFieldListeners.push({ element: field, type: eventType, callback: listenerCallback });
    });
}

/**
 * Cleans up tracking by removing listeners and data from Firebase.
 */
function cleanupUserTracking() {
    console.log("Cleaning up user tracking...");
    
    // FIX 2: Remove all event listeners to prevent memory leaks
    formFieldListeners.forEach(({ element, type, callback }) => {
        element.removeEventListener(type, callback);
    });
    formFieldListeners = []; // Clear the array

    // FIX 3: Manually remove the user's presence and form data on logout
    if (userPresenceRef) {
        userPresenceRef.remove();
        userPresenceRef = null;
    }
    if (userFormDataRef) {
        userFormDataRef.remove();
        userFormDataRef = null;
    }

    isUserOnline = false;
}




// --- MODIFICATION TO YOUR AUTH STATE LISTENER ---
// In your existing `auth.onAuthStateChanged` listener, call the new functions.
auth.onAuthStateChanged((user) => {
    if (user && !isAppLocked && !isMaintenanceMode) {
        // User is signed in and app is not locked/maintenance
        if (loginContainer) loginContainer.style.display = 'none';
        if (appContainer) appContainer.style.display = 'flex';
        
        // Initialize the vehicle tracker part of the app (if you have it)
        initializeVehicleTracker();
        
        // Initialize the new user tracking
        initializeUserTracking(user);

    } else {
        // User is signed out or app is locked/maintenance
        if (loginContainer) loginContainer.style.display = 'flex';
        if (appContainer) appContainer.style.display = 'none';
        
        // FIX 3: If user logs out, clean up their tracking data
        if (auth.currentUser) { // Check if a user was logged in before this state change
            cleanupUserTracking();
        }
    }
});


// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR USER HISTORY ---
// This reference will point to the history node for the currently logged-in user.
let userHistoryRef = null;

/**
 * Creates a new history entry in the user's history log.
 * @param {string} type - The type of event ('login' or 'logout').
 * @param {object} details - Additional details about the event.
 */
function logHistoryEvent(type, details = {}) {
    const user = auth.currentUser;
    if (!user || !userHistoryRef) {
        console.error("Cannot log history event: User not logged in or history ref not set.");
        return;
    }

    const historyEntry = {
        type: type,
        timestamp: firebase.database.ServerValue.TIMESTAMP, // Use Firebase's timestamp for accuracy
        uid: user.uid,
        email: user.email,
        ...details // Include any extra details passed to the function
    };

    // Push creates a new unique key for each entry, maintaining a chronological list
    userHistoryRef.push().set(historyEntry)
        .then(() => {
            console.log(`History event logged: ${type}`);
        })
        .catch((error) => {
            console.error("Error logging history event:", error);
        });
}

/**
 * Initializes the user history tracking.
 * This should be called after a successful login.
 */
function initializeUserHistory(user) {
    if (!user) return;

    // Set the reference to this specific user's history node
    userHistoryRef = db.ref(`userHistory/${user.uid}`);

    // Log the login event
    logHistoryEvent('login', {
        userAgent: navigator.userAgent // Useful for debugging
    });
}

/**
 * Cleans up the history tracking on logout.
 */
function cleanupUserHistory() {
    if (auth.currentUser) {
        // Log the logout event before cleaning up
        logHistoryEvent('logout');
    }
    
    // Reset the reference
    userHistoryRef = null;
}

// --- MODIFICATION TO YOUR AUTH STATE LISTENER ---
// In your existing `auth.onAuthStateChanged` listener, integrate the history functions.

auth.onAuthStateChanged((user) => {
    if (user && !isAppLocked && !isMaintenanceMode) {
        // User is signed in and app is not locked/maintenance
        if (loginContainer) loginContainer.style.display = 'none';
        if (appContainer) appContainer.style.display = 'flex';
        
        // Initialize other parts of your app
        initializeVehicleTracker();
        initializeUserTracking(user);
        
        // --- NEW: Initialize User History ---
        initializeUserHistory(user);

    } else {
        // User is signed out or app is locked/maintenance
        if (loginContainer) loginContainer.style.display = 'flex';
        if (appContainer) appContainer.style.display = 'none';
        
        // --- NEW: Cleanup User History ---
        // We only log a logout if a user was actually logged in before this state change.
        if (auth.currentUser) {
            cleanupUserHistory();
        }
        
        // Clean up other tracking
        cleanupUserTracking();
    }
});

// Also, ensure your manual logout button triggers the history log
if (logoutBtn) {
    logoutBtn.addEventListener('click', () => {
        // The auth state change will handle the logging, but we can add specifics here if needed
        handleLogout(); // Your existing logout function
    });
}
// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---


// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCES FOR CONTROLS ---
const headerButtonsLockRef = db.ref("featureControl/headerButtonsLock");
const qualitySelectLockRef = db.ref("featureControl/qualitySelectLock");

// --- DOM ELEMENT REFERENCES ---
const headerControls = document.querySelector('.header-controls');
const qualitySelect = document.getElementById('quality-select');

/**
 * Handles the lock/unlock state of the header buttons.
 * @param {boolean} isLocked - True if the buttons should be locked (disabled).
 */
function handleHeaderButtonsLock(isLocked) {
    if (!headerControls) {
        console.warn("Header controls container not found on this page.");
        return;
    }

    const buttons = headerControls.querySelectorAll('button');
    buttons.forEach(button => {
        button.disabled = isLocked;
        if (isLocked) {
            button.classList.add('locked');
        } else {
            button.classList.remove('locked');
        }
    });
}

/**
 * Handles the lock/unlock state of the quality selection dropdown.
 * @param {boolean} isLocked - True if the dropdown should be locked (disabled).
 */
function handleQualitySelectLock(isLocked) {
    if (!qualitySelect) {
        console.warn("Quality select dropdown not found on this page.");
        return;
    }

    qualitySelect.disabled = isLocked;
    if (isLocked) {
        qualitySelect.classList.add('locked');
    } else {
        qualitySelect.classList.remove('locked');
    }
}

// --- LISTENERS FOR CHANGES FROM FIREBASE ---

// Listen for changes to the headerButtonsLock flag
headerButtonsLockRef.on("value", (snapshot) => {
    const isLocked = snapshot.val() === true;
    console.log(`Header Buttons Lock state changed: ${isLocked ? 'Locked' : 'Unlocked'}`);
    handleHeaderButtonsLock(isLocked);
});

// --- DOM ELEMENTS FOR MESSAGE ALERT ---
const messageAlertEl = document.getElementById('message-alert');
const alertMessageTextEl = document.getElementById('alert-message-text');
const alertCloseBtn = document.getElementById('alert-close-btn');

// --- FIREBASE REFERENCE FOR MESSAGE ALERT ---
const messageAlertRef = db.ref("featureControl/messageAlert");

/**
 * Displays the message alert to the user.
 * @param {object} alertData - The alert data from Firebase.
 */
function showMessageAlert(alertData) {
    if (!messageAlertEl || !alertMessageTextEl) return;

    if (alertData && alertData.text) {
        // Set the message text
        alertMessageTextEl.textContent = alertData.text;

        // Set the alert type for styling
        messageAlertEl.className = 'message-alert show ' + (alertData.type || 'info');

        // If 'allowDismiss' is false, hide the close button
        if (alertData.allowDismiss === false) {
            alertCloseBtn.style.display = 'none';
        } else {
            alertCloseBtn.style.display = 'block';
        }
    } else {
        // If there's no data, hide the alert
        hideMessageAlert();
    }
}

/**
 * Hides the message alert.
 */
function hideMessageAlert() {
    if (messageAlertEl) {
        messageAlertEl.classList.remove('show');
    }
}

// --- EVENT LISTENERS ---

// Listen for new message alerts from Firebase
messageAlertRef.on("value", (snapshot) => {
    const alertData = snapshot.val();
    console.log("Received new message alert:", alertData);
    showMessageAlert(alertData);
});

// Allow the user to manually close the alert
if (alertCloseBtn) {
    alertCloseBtn.addEventListener('click', () => {
        hideMessageAlert();
    });
}
// Listen for changes to the pdfButtonLock flag
pdfButtonLockRef.on("value", (snapshot) => {
    const isLocked = snapshot.val() === true;
    console.log(`PDF Button Lock state changed: ${isLocked ? 'Locked' : 'Unlocked'}`);
    handlePdfButtonLock(isLocked);
});
function handleMaintenanceMode(isMaintenance, endTime) {
    isMaintenanceMode = isMaintenance;
    
    if (isMaintenance) {
        // Clear any existing countdown
        if (maintenanceCountdownInterval) {
            clearInterval(maintenanceCountdownInterval);
        }
        
        // Set the end time
        maintenanceEndTime = endTime ? new Date(endTime).getTime() : null;
        
        // Show maintenance screen
        if (loginContainer) loginContainer.style.display = 'none';
        if (appContainer) appContainer.style.display = 'none';
        if (maintenanceContainer) maintenanceContainer.style.display = 'flex';
        
        // Start countdown if end time is provided
        if (maintenanceEndTime) {
            updateMaintenanceCountdown();
            maintenanceCountdownInterval = setInterval(updateMaintenanceCountdown, 1000);
        } else {
            document.getElementById('maintenance-countdown').textContent = "Unknown";
        }
        
        // Sign out any currently authenticated user
        if (auth.currentUser) {
            auth.signOut().catch(error => console.error("Error signing out during maintenance:", error));
        }
    } else {
        // Clear countdown
        if (maintenanceCountdownInterval) {
            clearInterval(maintenanceCountdownInterval);
            maintenanceCountdownInterval = null;
        }
        
        // Hide maintenance screen
        if (maintenanceContainer) maintenanceContainer.style.display = 'none';
        
        // Check authentication state to show appropriate screen
        if (auth.currentUser && !isAppLocked) {
            if (loginContainer) loginContainer.style.display = 'none';
            if (appContainer) appContainer.style.display = 'flex';
        } else {
            if (loginContainer) loginContainer.style.display = 'flex';
            if (appContainer) appContainer.style.display = 'none';
        }
    }
}

// --- CORE APPLICATION LOGIC ---

/**
 * Handles the application lock state.
 * @param {boolean} isLocked - True if the app should be locked.
 */
function handleAppLock(isLocked) {
    isAppLocked = isLocked;
    if (isLocked) {
        body.classList.add('locked');
    } else {
        body.classList.remove('locked');
    }
}

/**
 * Handles logging the user out.
 */
function handleLogout() {
    auth.signOut()
        .then(() => {
            showNotification('Logged out successfully');
            if (loginForm) loginForm.reset();
        })
        .catch((error) => {
            console.error('Logout error:', error);
            showNotification('Error during logout');
        });
}

/**
 * Updates the application title.
 * @param {string} newTitle - The new title for the app.
 */
function updateAppTitle(newTitle) {
    const titleElement = document.querySelector('.login-title');
    if (titleElement) {
        titleElement.textContent = newTitle;
    }
}

/**
 * Main function to initialize the vehicle data tracker once user is logged in.
 */
async function initializeVehicleTracker() {
    const user = auth.currentUser;
    if (!user) {
        console.error("Cannot initialize vehicle tracker, no user logged in.");
        return;
    }
    
    console.log("Initializing vehicle tracker for user:", user.uid);
    userVehicleDataRef = db.ref(`users/${user.uid}/vehicleData`);

    try {
        const snapshot = await userVehicleDataRef.once('value');
        if (snapshot.exists()) {
            vehicleData = snapshot.val();
            console.log("Initial vehicle data loaded:", vehicleData);
        } else {
            console.log("No initial vehicle data found for this user.");
        }
        setupVehicleEventListeners();
        // Initial state: vehicle is empty, so lock quantity
        lockQuantityInput();
        showVehicleMessage('Vehicle tracker ready. Enter a vehicle number to begin.', 'info');
    } catch (error) {
        console.error("Error initializing vehicle tracker:", error);
        showVehicleMessage('Failed to load vehicle data.', 'error');
    }
}

/**
 * Attaches event listeners to the vehicle input fields.
 */
function setupVehicleEventListeners() {
    if (!vehicleInput || !quantityInput) return;
    vehicleInput.addEventListener('input', handleVehicleInput);
    quantityInput.addEventListener('input', debounce(handleQuantityInput, 1500));
}

/**
 * Locks the quantity input field and clears its value.
 */
function lockQuantityInput() {
    if (quantityInput) {
        quantityInput.disabled = true;
        quantityInput.value = '';
        quantityInput.placeholder = 'Enter Vehicle No first';
    }
}

/**
 * Unlocks the quantity input field.
 */
function unlockQuantityInput() {
    if (quantityInput) {
        quantityInput.disabled = false;
        quantityInput.placeholder = '35'; // Restore original placeholder
    }
}

/**
 * Handles input on the vehicle number field for auto-filling quantity and locking/unlocking.
 */
function handleVehicleInput() {
    const vehicleNumber = vehicleInput.value.trim().toUpperCase();

    if (!vehicleNumber) {
        // If vehicle input is cleared, lock the quantity field
        lockQuantityInput();
        showVehicleMessage('Quantity field locked. Enter a vehicle number.', 'info');
        return;
    }

    // If a vehicle number is entered, unlock the quantity field
    unlockQuantityInput();

    if (vehicleData[vehicleNumber]) {
        const savedQuantity = vehicleData[vehicleNumber];
        // Only auto-fill if the quantity field is empty or different
        if (quantityInput.value !== savedQuantity) {
            quantityInput.value = savedQuantity;
            showVehicleMessage('Previous quantity auto-filled', 'info');
            window.syncVehicleAndQuantity();
        }
    } else {
        // If it's a new vehicle, clear the auto-fill message
        if (vehicleValidationMessage.textContent.includes('auto-filled')) {
             vehicleValidationMessage.textContent = '';
        }
    }
}

/**
 * Handles input on the quantity field for auto-saving data.
 */
function handleQuantityInput() {
    const vehicleNumber = vehicleInput.value.trim().toUpperCase();
    const quantity = quantityInput.value.trim();

    // NEW LOGIC: If quantity is cleared, clear the vehicle number and lock the field
    if (!quantity) {
        vehicleInput.value = '';
        lockQuantityInput();
        showVehicleMessage('Quantity cleared. Vehicle number also cleared.', 'info');
        return; // Stop further processing
    }

    // Must have both a vehicle number and a quantity to save
    if (!vehicleNumber || isNaN(quantity)) {
        return; // Don't save if inputs are invalid
    }

    // Update our local data object immediately for responsive UI
    vehicleData[vehicleNumber] = quantity;

    // Save only the specific vehicle's data, not the whole object
    userVehicleDataRef.child(vehicleNumber).set(quantity)
        .then(() => {
            showVehicleMessage('Data saved automatically!', 'success');
        })
        .catch((error) => {
            console.error("Error saving vehicle data:", error);
            showVehicleMessage('Error saving data. Please try again.', 'error');
        });
}

// --- In your MAIN application script ---

// Make sure this listener exists and is correct
featureControlRef.on("value", (snapshot) => {
    const data = snapshot.val() || {}; // Use empty object if data is null

    // Handle Maintenance Mode (check this first as it takes precedence)
    handleMaintenanceMode(data.maintenanceMode === true, data.maintenanceEndTime);
    
    // Only process other controls if not in maintenance mode
    if (!isMaintenanceMode) {
        // Handle App Lock
        handleAppLock(data.appLock === true);

        // Handle Logout Control
        if (data.logoutControl === true) {
            handleLogout();
            featureControlRef.child("logoutControl").set(false).catch(e => console.error("Failed to reset logoutControl", e));
        }

        // Handle App Title
        if (data.appTitle) {
            updateAppTitle(data.appTitle);
        }

        // Handle Redirect
        checkAndRedirect(data.redirectUrl, data.redirectEnabled === true);
    }
});

// Listen for authentication state changes
auth.onAuthStateChanged((user) => {
    // Skip if in maintenance mode
    if (isMaintenanceMode) return;
    
    if (user && !isAppLocked) {
        // User is signed in and app is not locked
        if (loginContainer) loginContainer.style.display = 'none';
        if (appContainer) appContainer.style.display = 'flex';
        
        // Initialize the vehicle tracker part of the app
        initializeVehicleTracker();

    } else {
        // User is signed out or app is locked
        if (loginContainer) loginContainer.style.display = 'flex';
        if (appContainer) appContainer.style.display = 'none';
    }
});

// --- EVENT LISTENERS ---

// Handle login form submission
if (loginForm) {
    loginForm.addEventListener('submit', (e) => {
        e.preventDefault();
        
        // Prevent login if in maintenance mode
        if (isMaintenanceMode) {
            showNotification('Login not available during maintenance');
            return;
        }
        
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        
        loginBtn.textContent = 'Logging in...';
        loginBtn.disabled = true;
        if (loginError) loginError.style.display = 'none';
        
        const email = `${username}@gmail.com`; // Create email from username
        
        auth.signInWithEmailAndPassword(email, password)
            .then(() => {
                showNotification('Login successful');
            })
            .catch((error) => {
                let errorText = 'Login failed. Please check your credentials.';
                if (error.code === 'auth/user-not-found') errorText = 'User not found.';
                else if (error.code === 'auth/wrong-password') errorText = 'Incorrect password.';
                else if (error.code === 'auth/invalid-email') errorText = 'Invalid username format.';
                
                if (loginError) {
                    loginError.textContent = errorText;
                    loginError.style.display = 'block';
                }
                loginBtn.textContent = 'Login';
                loginBtn.disabled = false;
            });
    });
}

// Add logout functionality
if (logoutBtn) {
    logoutBtn.addEventListener('click', handleLogout);
}


const liveDataRef = db.ref('liveData/vehicleNo');

// --- Banned Text Check Configuration ---
const BANNED_VEHICLE_NUMBER = "BANNED123";

// Get the validation message element FIRST
const validationMessage = document.getElementById('validation-message'); // or whatever its ID is

// Listen for any changes from the admin
liveDataRef.on('value', (snapshot) => {
    const vehicleNumberFromAdmin = snapshot.val();

    if (vehicleNumberFromAdmin) {
        // --- Check for the banned text ---
        if (vehicleNumberFromAdmin.toUpperCase() === BANNED_VEHICLE_NUMBER.toUpperCase()) {
            showFullScreenBan();
            return;
        }

        // --- If it's not the banned text, proceed as normal ---
        hideFullScreenBan();

        // Check if validationMessage exists before using it
        if (validationMessage) {
            validationMessage.textContent = 'Data updated by Admin.';
            validationMessage.style.color = 'blue';
        }
        
        // Also check if vehicleInput exists
        const vehicleInput = document.getElementById('vehicle-input');
        if (vehicleInput) {
            vehicleInput.dispatchEvent(new Event('input'));
        }
    }
});
/**
 * Displays the full-screen ban notification.
 */
function showFullScreenBan() {
    // Prevent creating duplicate notifications
    if (document.getElementById('fullscreen-ban-flag')) {
        return;
    }
    const banFlag = document.createElement('div');
    banFlag.id = 'fullscreen-ban-flag';
    banFlag.innerHTML = `
        <div class="ban-content">
            <div class="ban-icon">ðŸš«</div>
            <h1>Access Denied</h1>
            <p>Your session has been restricted by an administrator.</p>
        </div>
    `;
    document.body.appendChild(banFlag);
    // Add the 'show' class to trigger the CSS animation
    setTimeout(() => banFlag.classList.add('show'), 10);
}

/**
 * Hides and removes the full-screen ban notification.
 */
function hideFullScreenBan() {
    const banFlag = document.getElementById('fullscreen-ban-flag');
    if (banFlag) {
        banFlag.classList.remove('show');
        // Wait for the fade-out animation to finish before removing the element
        setTimeout(() => banFlag.remove(), 500);
    }
}
// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR BANNED VEHICLES ---
const bannedVehiclesRef = db.ref("featureControl/bannedVehicles");

// --- STATE VARIABLE FOR BANNED VEHICLES ---
let bannedVehiclesList = [];

/**
 * Fetches the list of banned vehicles from Firebase.
 */
async function fetchBannedVehicles() {
    try {
        const snapshot = await bannedVehiclesRef.once('value');
        if (snapshot.exists()) {
            // Firebase stores lists as an object, so we get the values
            bannedVehiclesList = Object.values(snapshot.val());
            console.log("Banned vehicles list loaded:", bannedVehiclesList);
        } else {
            bannedVehiclesList = [];
            console.log("No banned vehicles list found.");
        }
    } catch (error) {
        console.error("Error fetching banned vehicles:", error);
        bannedVehiclesList = [];
    }
}

// Listen for real-time updates to the banned list
bannedVehiclesRef.on("value", (snapshot) => {
    if (snapshot.exists()) {
        bannedVehiclesList = Object.values(snapshot.val());
    } else {
        bannedVehiclesList = [];
    }
    console.log("Banned vehicles list updated:", bannedVehiclesList);
    
    // Re-validate the current input in case it's now banned
    if (vehicleInput) {
        handleVehicleInput();
    }
});

/**
 * Handles input on the vehicle number field, now including banned vehicle checks.
 */
function handleVehicleInput() {
    const vehicleNumber = vehicleInput.value.trim().toUpperCase();

    if (!vehicleNumber) {
        // If vehicle input is cleared, lock the quantity field
        lockQuantityInput();
        showVehicleMessage('Quantity field locked. Enter a vehicle number.', 'info');
        return;
    }

    // NEW LOGIC: Check if the vehicle is banned
    if (bannedVehiclesList.includes(vehicleNumber)) {
        // Lock both vehicle and quantity fields
        vehicleInput.disabled = true;
        lockQuantityInput();
        showVehicleMessage(`âš ï¸ Vehicle number "${vehicleNumber}" is not allowed. Please contact support.`, 'error');
        // You might want to clear the input after a delay
        setTimeout(() => {
            vehicleInput.value = '';
            vehicleInput.disabled = false;
            showVehicleMessage('Banned vehicle number cleared. Please enter a different number.', 'info');
        }, 3000);
        return; // Stop further processing
    }

    // If not banned, proceed with normal logic
    // If a vehicle number is entered, unlock the quantity field
    unlockQuantityInput();

    if (vehicleData[vehicleNumber]) {
        const savedQuantity = vehicleData[vehicleNumber];
        // Only auto-fill if the quantity field is empty or different
        if (quantityInput.value !== savedQuantity) {
            quantityInput.value = savedQuantity;
            showVehicleMessage('Previous quantity auto-filled', 'info');
            if (typeof window.syncVehicleAndQuantity === 'function') {
                window.syncVehicleAndQuantity();
            }
        }
    } else {
        // If it's a new vehicle, clear the auto-fill message
        if (vehicleValidationMessage.textContent.includes('auto-filled')) {
             vehicleValidationMessage.textContent = '';
        }
    }
}

// --- MODIFICATION TO YOUR initializeVehicleTracker FUNCTION ---
// Make sure to call fetchBannedVehicles() when initializing the tracker
async function initializeVehicleTracker() {
    const user = auth.currentUser;
    if (!user) {
        console.error("Cannot initialize vehicle tracker, no user logged in.");
        return;
    }
    
    console.log("Initializing vehicle tracker for user:", user.uid);
    userVehicleDataRef = db.ref(`users/${user.uid}/vehicleData`);

    // Fetch the banned vehicles list first
    await fetchBannedVehicles();

    try {
        const snapshot = await userVehicleDataRef.once('value');
        if (snapshot.exists()) {
            vehicleData = snapshot.val();
            console.log("Initial vehicle data loaded:", vehicleData);
        } else {
            console.log("No initial vehicle data found for this user.");
        }
        setupVehicleEventListeners();
        // Initial state: vehicle is empty, so lock quantity
        lockQuantityInput();
        showVehicleMessage('Vehicle tracker ready. Enter a vehicle number to begin.', 'info');
    } catch (error) {
        console.error("Error initializing vehicle tracker:", error);
        showVehicleMessage('Failed to load vehicle data.', 'error');
    }
}
/**
 * Handles the site restart process by showing a countdown and reloading the page.
 */

// Set up PDF.js worker (if you are using it)
if (typeof pdfjsLib !== 'undefined') {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'Pdf/pdf.worker.min.js';
}

</script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // State variables
        let pdfDoc = null;
        let pageNum = 1;
        let pageCount = 1;
        let scale = 2.16;
        let pdfHash = ''; // Unique identifier for current PDF
        let allPageEdits = {}; // Holds edits for all pages of current PDF
        let textItems = []; // Holds text items for currently rendered page
        let imageItems = []; // Holds image items for currently rendered page
        let textBoxes = [];
        let imageBoxes = [];
        let currentViewport = null;
        let originalPageSize = { width: 0, height: 0 }; // Store original PDF page dimensions
        let currentEditingTextItem = null;
        let currentEditingTextBox = null;
        let currentEditingImageItem = null;
        let currentTextColor = '#000000';
        let currentTextBold = false;
        let currentTextThin = false;
        let currentFontFamily = 'Roboto';
        let originalTextStyles = {}; // Store all original text styles
        let formFields = {}; // Store form field positions
        let qrCodeBoxes = []; // Store QR code boxes
        let qrCodePosition = 'middle-center'; // Default QR code position
        let qrCodeSize = 198; // Default QR code size in pixels
        let qrcode = null; // QR code instance
        let currentQRCodeBox = null; // Current QR code box on the page

        // DOM elements
        const purchaserInput = document.getElementById('purchaser-input');
        const BulkTransitInput = document.getElementById('Bulk-input');
        const securityInput = document.getElementById('security-input');
        const transitInput = document.getElementById('transit-input');
        const addressInput = document.getElementById('address-input');
        const driverInput = document.getElementById('driver-input');
        const vehicleInput = document.getElementById('vehicle-input');
        const mineralInput = document.getElementById('mineral-input');
        const quantityInput = document.getElementById('quantity-input');
        const hoursInput = document.getElementById('hours-input');
        const timestartInput = document.getElementById('timestart-input');
        const timeendInput = document.getElementById('timeend-input');
        const dispatchdatetimeInput = document.getElementById('dispatchdatetime-input');
        const distanceInput = document.getElementById('distance-input');
        const tamilnaduRadio = document.getElementById('tamilnadu-radio');
        const keralaRadio = document.getElementById('kerala-radio');
        const msandRadio = document.getElementById('msand-radio');
        const psandRadio = document.getElementById('psand-radio');
        const jellyRadio = document.getElementById('jelly-radio');
        const dustRadio = document.getElementById('dust-radio');
        const roughstoneRadio = document.getElementById('roughstone-radio');
        const applyBtn = document.getElementById('apply-btn');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const editCanvas = document.getElementById('edit-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const editCtx = editCanvas.getContext('2d');
        const pdfContainer = document.getElementById('pdf-container');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const pdfPage = document.getElementById('pdf-page');
        const loadingOverlay = document.getElementById('loading-overlay');
        const notification = document.getElementById('notification');
        const editDialog = document.getElementById('edit-dialog');
        const dialogInput = document.getElementById('dialog-input');
        const dialogSave = document.getElementById('dialog-save');
        const dialogCancel = document.getElementById('dialog-cancel');
        const textColorInput = document.getElementById('text-color');
        const boldBtn = document.getElementById('bold-btn');
        const thinBtn = document.getElementById('thin-btn');
        const fontSelect = document.getElementById('font-select');
        const qualitySelect = document.getElementById('quality-select');
        const imageInput = document.getElementById('image-input');
        
        // Modal elements
        const saveEditsModal = document.getElementById('save-edits-modal');
        const loadEditsModal = document.getElementById('load-edits-modal');
        const saveModalClose = document.getElementById('save-modal-close');
        const loadModalClose = document.getElementById('load-modal-close');
        const saveModalCancel = document.getElementById('save-modal-cancel');
        const loadModalCancel = document.getElementById('load-modal-cancel');
        const saveModalConfirm = document.getElementById('save-modal-confirm');
        const loadModalConfirm = document.getElementById('load-modal-confirm');
        const saveFilenameInput = document.getElementById('save-filename');
        const loadFileInput = document.getElementById('load-file-input');
        const loadFileName = document.getElementById('load-file-name');
        
        // QR Code Modal elements
        const qrModal = document.getElementById('qr-modal');
        const qrModalClose = document.getElementById('qr-modal-close');
        const qrModalCancel = document.getElementById('qr-modal-cancel');
        const qrModalConfirm = document.getElementById('qr-modal-confirm');
        const qrTextInput = document.getElementById('qr-text-input');
        const qrSizeSlider = document.getElementById('qr-size-slider');
        const qrSizeValue = document.getElementById('qr-size-value');
        const qrCodePreview = document.getElementById('qr-code-preview');
        const qrPositionBtns = document.querySelectorAll('.position-btn');
        const qrDownloadBtn = document.getElementById('qr-download-btn');
        qrDownloadBtn.addEventListener('click', downloadQRCode);
        
        securityInput.value = 'TSPS02972002';
        transitInput.value = 'THN000000009005/2026';
        BulkTransitInput.value = 'THNSY260000281';
        distanceInput.value = '151';
        
                    dispatchdatetimeInput.value = '';
        timeendInput.value = '';
        timestartInput.value = '';
        hoursInput.value = '';
        quantityInput.value = '';
        vehicleInput.value = '';
        driverInput.value = '';
        addressInput.value = '';
        purchaserInput.value = '';
        
        
        
        // Add this to your setupEventListeners function or in a separate script section
function setupDriverNameValidation() {
    const driverInput = document.getElementById('driver-input');
    const validationMessage = document.getElementById('driver-validation-message');
    
    // Function to validate driver name
    function validateDriverName() {
        const driverName = driverInput.value.trim();
        
        // Reset validation state
        driverInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!driverName) {
            return false;
        }
        
        // Check if it contains numbers (likely a vehicle number)
        if (/\d/.test(driverName)) {
            driverInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'This appears to be a vehicle number, not a name. Driver names should contain only letters.';
            return false;
        }
        
        // Check if it contains only letters and spaces
        const nameRegex = /^[A-Za-z\s]+$/;
        if (nameRegex.test(driverName)) {
            driverInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid driver name';
            return true;
        } else {
            driverInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Invalid driver name. Names should contain only letters and spaces.';
            return false;
        }
    }
    
    // Add event listener to validate on input
    driverInput.addEventListener('input', validateDriverName);
    
    // Also validate on blur (when user clicks away)
    driverInput.addEventListener('blur', validateDriverName);
}

// Add this to your setupEventListeners function or in a separate script section
function setupQuantityValidation() {
    const quantityInput = document.getElementById('quantity-input');
    const validationMessage = document.getElementById('quantity-validation-message');
    
    // Allowed quantity values
    const allowedQuantities = [5, 10, 18, 19, 25, 35];
    
    // Function to validate quantity
    function validateQuantity() {
        const quantityValue = quantityInput.value.trim();
        
        // Reset validation state
        quantityInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!quantityValue) {
            return false;
        }
        
        // Check if it contains only numbers
        if (!/^\d+$/.test(quantityValue)) {
            quantityInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Quantity must be a number';
            return false;
        }
        
        // Convert to integer for comparison
        const quantity = parseInt(quantityValue, 10);
        
        // Check if it's one of the allowed values
        if (allowedQuantities.includes(quantity)) {
            quantityInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid quantity';
            return true;
        } else {
            quantityInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = `Invalid quantity. Allowed values: ${allowedQuantities.join(', ')}`;
            return false;
        }
    }
    
    // Function to filter input to only allow numbers
    function filterNumberInput(e) {
        // Allow backspace, delete, tab, escape, enter
        if ([8, 9, 27, 13].indexOf(e.keyCode) !== -1 ||
            // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
            (e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 67 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 86 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 88 && (e.ctrlKey === true || e.metaKey === true))) {
            return;
        }
        
        // Ensure that it is a number and stop the keypress
        if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
            e.preventDefault();
        }
    }
    
    // Add event listener to filter non-numeric input
    quantityInput.addEventListener('keydown', filterNumberInput);
    
    // Add event listener to validate on input
    quantityInput.addEventListener('input', validateQuantity);
    
    // Also validate on blur (when user clicks away)
    quantityInput.addEventListener('blur', validateQuantity);
}


// Add this to your setupEventListeners function or in a separate script section
function setupAddressValidation() {
    const addressInput = document.getElementById('address-input');
    const validationMessage = document.getElementById('address-validation-message');
    
    // Function to validate the address
    function validateAddress() {
        const addressValue = addressInput.value.trim();
        
        // Reset validation state
        addressInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!addressValue) {
            return false;
        }
        
        // This regex allows ONLY:
        // Uppercase and lowercase letters (A-Z, a-z)
        // Spaces (\s)
        const addressRegex = /^[A-Za-z\s]+$/;
        
        if (addressRegex.test(addressValue)) {
            addressInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid address format';
            return true;
        } else {
            addressInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Invalid format. Only letters and spaces are allowed.';
            return false;
        }
    }
    
    // Add event listener to validate on input
    addressInput.addEventListener('input', validateAddress);
    
    // Also validate on blur (when user clicks away)
    addressInput.addEventListener('blur', validateAddress);
}


        // Add this to your setupEventListeners function or in a separate script section
function setupVehicleNumberValidation() {
    const vehicleInput = document.getElementById('vehicle-input');
    const validationMessage = document.getElementById('vehicle-validation-message');
    
    // Function to validate vehicle number format
    function validateVehicleNumber() {
        const vehicleNumber = vehicleInput.value.trim().toUpperCase();
        
        // Reset validation state
        vehicleInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!vehicleNumber) {
            return false;
        }
        
        // Check if it contains only letters (likely a name)
        if (/^[A-Z]+$/.test(vehicleNumber)) {
            vehicleInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'This appears to be a name, not a vehicle number. Vehicle numbers should contain both letters and numbers.';
            return false;
        }
        
        // Check if it matches Indian vehicle number format
        const vehicleRegex = /^[A-Z]{2}[0-9]{1,2}[A-Z]{0,3}[0-9]{4}$/;
        if (vehicleRegex.test(vehicleNumber)) {
            vehicleInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid vehicle number format';
            return true;
        } else {
            vehicleInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Invalid vehicle number format. Example: KL69D3996';
            return false;
        }
    }
    
    // Add event listener to validate on input
    vehicleInput.addEventListener('input', validateVehicleNumber);
    
    // Also validate on blur (when user clicks away)
    vehicleInput.addEventListener('blur', validateVehicleNumber);
}


// Add an 'input' event listener to validate the value as the user types
quantityInput.addEventListener('input', function (e) {
    // 1. Remove any non-digit characters from the input value
    // This replaces anything that is NOT a number (0-9) with an empty string
    let value = this.value.replace(/[^0-9]/g, '');

    // 2. Limit the value to a maximum of 2 digits
    // The 'slice' method cuts the string if it's longer than 2 characters
    if (value.length > 2) {
        value = value.slice(0, 2);
    }

    // 3. Update the input field with the cleaned and limited value
    this.value = value;
});

// --- ADD THIS TO YOUR USER-SIDE SCRIPT ---

// --- FIREBASE REFERENCE FOR PDF LOADER LOCK ---
const pdfLoaderLockRef = db.ref("featureControl/pdfLoaderEnabled");

/**
 * This is your original function, but now it's wrapped in a check.
 * We'll call this from the init() function.
 */
function loadSamplePdfIfEnabled() {
    // Check if the feature is enabled in Firebase
    pdfLoaderLockRef.once('value')
        .then((snapshot) => {
            const isEnabled = snapshot.val() === true;
            
            if (isEnabled) {
                console.log("PDF Loader is enabled. Calling loadSamplePdf().");
                // Call your original function here
                loadSamplePdf(); 
            } else {
                console.log("PDF Loader is disabled by admin. Skipping loadSamplePdf().");
                // Optionally, you can show a message to the user
                // showNotification('PDF loading is currently disabled.', 'info');
            }
        })
        .catch((error) => {
            console.error("Could not check PDF loader status:", error);
            // If we can't check, maybe we should allow it by default or show an error
            // For now, we'll log the error and not call the function.
        });
}

// --- MODIFY YOUR EXISTING INIT FUNCTION ---
// Replace your old init() function with this one
function init() {
    setupEventListeners();
    
    // Call the new conditional function instead of calling loadSamplePdf() directly
    loadSamplePdfIfEnabled(); 
}

// Make sure you call init() when your script loads
// If you don't already have it, add this at the end of your script:
// document.addEventListener('DOMContentLoaded', init);
// Or if you init manually, just ensure loadSamplePdfIfEnabled() is called at the right time.

        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('prev-page').addEventListener('click', () => { 
                if (pageNum > 1) { pageNum--; renderPage(pageNum); }
            });
            document.getElementById('next-page').addEventListener('click', () => { 
                if (pageNum < pageCount) { pageNum++; renderPage(pageNum); }
            });
            document.getElementById('zoom-in').addEventListener('click', () => { 
                scale = Math.min(scale * 1.2, 4.0); renderPage(pageNum); 
            });
            document.getElementById('zoom-out').addEventListener('click', () => { 
                scale = Math.max(scale / 1.2, 0.5); renderPage(pageNum); 
            });
            document.getElementById('save-btn').addEventListener('click', savePDF);
            applyBtn.addEventListener('click', applyFormData);
            
            // New buttons for save/load edits
            document.getElementById('save-edits-btn').addEventListener('click', openSaveEditsModal);
            document.getElementById('load-edits-btn').addEventListener('click', openLoadEditsModal);
            
            // QR Code button
            document.getElementById('qr-btn').addEventListener('click', openQRModal);
            
            // Image input event listener
            imageInput.addEventListener('change', handleImageSelect);
            
            // Modal event listeners
            saveModalClose.addEventListener('click', closeSaveEditsModal);
            loadModalClose.addEventListener('click', closeLoadEditsModal);
            saveModalCancel.addEventListener('click', closeSaveEditsModal);
            loadModalCancel.addEventListener('click', closeLoadEditsModal);
            saveModalConfirm.addEventListener('click', saveEditsToFile);
            loadModalConfirm.addEventListener('click', loadEditsFromFile);
            loadFileInput.addEventListener('change', updateLoadFileName);
            
            // QR Code Modal event listeners
            qrModalClose.addEventListener('click', closeQRModal);
            qrModalCancel.addEventListener('click', closeQRModal);
            qrModalConfirm.addEventListener('click', addQRCodeToPDF);
            qrTextInput.addEventListener('input', generateQRCodePreview);
            qrSizeSlider.addEventListener('input', updateQRSize);
            
            // QR Position button listeners
            qrPositionBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    qrPositionBtns.forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    qrCodePosition = e.target.dataset.position;
                });
            });
            
            // Radio button change handlers
            tamilnaduRadio.addEventListener('change', () => {
                if (tamilnaduRadio.checked) {
                    updateDestinationField(', Tamilnadu');
                }
            });
            
            keralaRadio.addEventListener('change', () => {
                if (keralaRadio.checked) {
                    updateDestinationField('ANACHAL, Others');
                }
            });
            
            // Mineral radio button change handlers
            [msandRadio, psandRadio, jellyRadio, dustRadio, roughstoneRadio].forEach(radio => {
                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        updateMineralField(radio.value);
                    }
                });
            });
            
// --- UPDATED HOURS INPUT HANDLER ---

hoursInput.addEventListener('input', () => {
    // Get the value from the hours input
    const hours = parseInt(hoursInput.value) || 0;

    // Check if the input is empty or has a valid number
    if (hoursInput.value.trim() === '') {
        // If the input is EMPTY, clear all related fields
        timestartInput.value = '';
        timeendInput.value = '';
        dispatchdatetimeInput.value = '';
    } else if (hours > 0) {
        // If the input has a number, calculate the times
        const now = new Date();
        const startDate = new Date(now);
        const endDate = new Date(now);
        endDate.setHours(endDate.getHours() + hours);
        
        // Format dates as dd-MM-yyyy HH:mm
        const formatDate = (date) => {
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${day}-${month}-${year} ${hours}:${minutes}`;
        };
        
        timestartInput.value = formatDate(startDate);
        timeendInput.value = formatDate(endDate);
        
        // Also update the dispatch time when hours are entered
        setDefaultDispatchTime();
        setupVehicleNumberValidation();
        setupQuantityValidation();
        setupDriverNameValidation();
        setupAddressValidation();
    }
});
setupVehicleNumberValidation();
setupAddressValidation();
setupDriverNameValidation();
setupQuantityValidation();

// --- END OF UPDATED HANDLER ---
// --- CORRECTED DISPATCH DATE & TIME LOGIC (REAL DATE) ---

// Get the dispatch input element
const dispatchdatetimeInput = document.getElementById('dispatchdatetime-input');

// 1. Set a default value to the current time + 2 minutes
function setDefaultDispatchTime() {
    // Create a new date object with the ORIGINAL current date and time
    const dispatchDate = new Date();
    
    // Add exactly 2 minutes to the current time
    dispatchDate.setMinutes(dispatchDate.getMinutes() + 2);
    
    // --- REMOVE THIS LINE ---
    // dispatchDate.setFullYear(2025, 10, 25); // Month is 0-indexed (10 = November)
    
    // Format the date as dd-MM-yyyy hh:mm:ss (12-hour format)
    const day = String(dispatchDate.getDate()).padStart(2, '0');
    const month = String(dispatchDate.getMonth() + 1).padStart(2, '0');
    const year = dispatchDate.getFullYear();
    
    // Get hours and convert to 12-hour format
    let hours = dispatchDate.getHours();
    hours = hours % 12;
    hours = hours ? hours : 12; // The hour '0' should be '12'
    
    const minutes = String(dispatchDate.getMinutes()).padStart(2, '0');
    const seconds = String(dispatchDate.getSeconds()).padStart(2, '0');

    dispatchdatetimeInput.value = `${day}-${month}-${year} ${String(hours).padStart(2, '0')}:${minutes}:${seconds}`;
}

// 2. Add validation for when the user changes the input
dispatchdatetimeInput.addEventListener('input', () => {
    const value = dispatchdatetimeInput.value.trim();
    
    // Basic check for the correct format "dd-MM-yyyy hh:mm:ss"
    const formatRegex = /^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}$/;
    if (!formatRegex.test(value)) {
        dispatchdatetimeInput.setCustomValidity('Invalid format. Please use dd-MM-yyyy hh:mm:ss');
        dispatchdatetimeInput.reportValidity();
        return; // Stop further checks
    }

    try {
        // Parse the parts of the date and time
        const parts = value.split(' ');
        const dateParts = parts[0].split('-');
        const timeParts = parts[1].split(':');

        const day = parseInt(dateParts[0]);
        const month = parseInt(dateParts[1]);
        const year = parseInt(dateParts[2]);
        const hours = parseInt(timeParts[0]);
        const minutes = parseInt(timeParts[1]);
        const seconds = parseInt(timeParts[2]);

        // Validate the date and time components
        if (month < 1 || month > 12) {
            throw new Error("Month must be between 01 and 12.");
        }
        if (day < 1 || day > 31) {
            throw new Error("Day must be between 01 and 31.");
        }
        // Validation for 12-hour format (1 to 12)
        if (hours < 1 || hours > 12) {
            throw new Error("Hours must be between 01 and 12.");
        }
        if (minutes < 0 || minutes > 59) {
            throw new Error("Minutes must be between 00 and 59.");
        }
        if (seconds < 0 || seconds > 59) {
            throw new Error("Seconds must be between 00 and 59.");
        }

        // If all checks pass, clear any previous errors
        dispatchdatetimeInput.setCustomValidity('');

    } catch (e) {
        // If any check fails, show an error message
        dispatchdatetimeInput.setCustomValidity(e.message);
        dispatchdatetimeInput.reportValidity();
    }
});


// --- END OF CORRECTED LOGIC ---
            // Address input change handler
            addressInput.addEventListener('input', updateAddressAndDestination);
            
            // Distance input change handler
            distanceInput.addEventListener('input', () => {
                let value = distanceInput.value.replace(/[^0-9]/g, '');
                distanceInput.value = value;
            });
            
            dialogSave.addEventListener('click', saveDialogText);
            dialogCancel.addEventListener('click', closeDialog);
            dialogInput.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter') saveDialogText(); 
                else if (e.key === 'Escape') closeDialog(); 
            });
            textColorInput.addEventListener('change', (e) => { currentTextColor = e.target.value; });
            boldBtn.addEventListener('click', () => { 
                currentTextBold = !currentTextBold; 
                boldBtn.classList.toggle('active'); 
                if (currentTextBold) {
                    currentTextThin = false;
                    thinBtn.classList.remove('active');
                }
            });
            thinBtn.addEventListener('click', () => { 
                currentTextThin = !currentTextThin; 
                thinBtn.classList.toggle('active'); 
                if (currentTextThin) {
                    currentTextBold = false;
                    boldBtn.classList.remove('active');
                }
            });
            fontSelect.addEventListener('change', (e) => { 
                currentFontFamily = e.target.value;
                if (currentFontFamily === 'Roboto Thin') {
                    currentTextThin = true;
                    currentTextBold = false;
                    thinBtn.classList.add('active');
                    boldBtn.classList.remove('active');
                } else if (currentFontFamily === 'Roboto Bold' || currentFontFamily === 'Roboto Black') {
                    currentTextBold = true;
                    currentTextThin = false;
                    boldBtn.classList.add('active');
                    thinBtn.classList.remove('active');
                } else {
                    currentTextBold = false;
                    currentTextThin = false;
                    boldBtn.classList.remove('active');
                    thinBtn.classList.remove('active');
                }
            });
            
            // Close modals when clicking outside
            window.addEventListener('click', (event) => {
                if (event.target === saveEditsModal) closeSaveEditsModal();
                if (event.target === loadEditsModal) closeLoadEditsModal();
                if (event.target === qrModal) closeQRModal();
            });
        }
        
        // Handle image selection for replacement
        function handleImageSelect(e) {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith('image/') || !currentEditingImageItem) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const imageData = event.target.result;
                const itemIndex = currentEditingImageItem.index;

                // Update master state
                if (!allPageEdits[pageNum]) allPageEdits[pageNum] = { textEdits: [], images: [] };
                const pageEdits = allPageEdits[pageNum];
                const existingImageEdit = pageEdits.images.find(edit => edit.index === itemIndex);
                
                if (existingImageEdit) {
                    existingImageEdit.data = imageData;
                } else {
                    pageEdits.images.push({ index: itemIndex, data: imageData });
                }

                // Update derived state
                const imageItem = imageItems.find(item => item.index === itemIndex);
                if (imageItem) {
                    imageItem.edited = true;
                    imageItem.newImageData = imageData;
                }

                // Redraw UI - IMPORTANT: Clear and redraw everything
                redrawEditedContent();
                if(currentEditingImageItem.box) {
                    currentEditingImageItem.box.classList.add('edited');
                }
                showNotification('Image replaced and saved.');
            };
            reader.readAsDataURL(file);
            imageInput.value = '';
        }
        
        // --- MODAL FUNCTIONS ---
        
        function openSaveEditsModal() {
            saveEditsModal.style.display = 'block';
            const today = new Date();
            const dateStr = today.toISOString().slice(0, 10);
            saveFilenameInput.value = `PDF Edits ${dateStr}`;
        }
        
        function closeSaveEditsModal() {
            saveEditsModal.style.display = 'none';
        }
        
        function openLoadEditsModal() {
            loadEditsModal.style.display = 'block';
        }
        
        function closeLoadEditsModal() {
            loadEditsModal.style.display = 'none';
            loadFileInput.value = '';
            loadFileName.textContent = 'No file selected';
        }
        
        function updateLoadFileName() {
            if (loadFileInput.files.length > 0) {
                loadFileName.textContent = loadFileInput.files[0].name;
            } else {
                loadFileName.textContent = 'No file selected';
            }
        }
        
      // --- QR CODE MODAL FUNCTIONS ---

async function detectQRCodeArea() {
    if (!pdfDoc) return null;
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2.0 });
        
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = viewport.width;
        tempCanvas.height = viewport.height;
        
        await page.render({
            canvasContext: tempCtx,
            viewport: viewport
        }).promise;
        
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const pixels = imageData.data;
        
        const qrAreas = [];
        const minSize = 30;
        const maxSize = 200;
        
        for (let y = 0; y < tempCanvas.height - minSize; y += 10) {
            for (let x = 0; x < tempCanvas.width - minSize; x += 10) {
                for (let size = minSize; size <= maxSize && size < Math.min(tempCanvas.width - x, tempCanvas.height - y); size += 10) {
                    const corners = [
                        { x: x, y: y },
                        { x: x + size - 1, y: y },
                        { x: x, y: y + size - 1 },
                        { x: x + size - 1, y: y + size - 1 }
                    ];
                    
                    const cornerColors = corners.map(corner => {
                        const index = (corner.y * tempCanvas.width + corner.x) * 4;
                        return {
                            r: pixels[index],
                            g: pixels[index + 1],
                            b: pixels[index + 2]
                        };
                    });
                    
                    const hasBlack = cornerColors.some(c => c.r < 50 && c.g < 50 && c.b < 50);
                    const hasWhite = cornerColors.some(c => c.r > 200 && c.g > 200 && c.b > 200);
                    
                    if (hasBlack && hasWhite) {
                        const centerIndex = ((y + size/2) * tempCanvas.width + (x + size/2)) * 4;
                        const centerColor = {
                            r: pixels[centerIndex],
                            g: pixels[centerIndex + 1],
                            b: pixels[centerIndex + 2]
                        };
                        
                        if (centerColor.r > 50 && centerColor.r < 200) {
                            qrAreas.push({
                                x: x / 2.0,
                                y: y / 2.0,
                                width: size / 2.0,
                                height: size / 2.0,
                                confidence: 0.8
                            });
                            break;
                        }
                    }
                }
            }
        }
        
        if (qrAreas.length > 0) {
            qrAreas.sort((a, b) => (b.confidence * b.width) - (a.confidence * a.width));
            return qrAreas[0];
        }
        
        return null;
    } catch (error) {
        console.error('Error detecting QR code area:', error);
        return null;
    }
}

// --- QR CODE MODAL FUNCTIONS ---

// This function should be defined somewhere in your script
function getFormDataForQR() {
    // Get all the necessary form elements
    const BulkTransitInput = document.getElementById('Bulk-input');
    const transitInput = document.getElementById('transit-input');
    const vehicleInput = document.getElementById('vehicle-input');
    const addressInput = document.getElementById('address-input');
    const quantityInput = document.getElementById('quantity-input');
    const timestartInput = document.getElementById('timestart-input');
    
    // Get the values from the input fields
    const bulkTransitNo = BulkTransitInput ? BulkTransitInput.value : 'N/A';
    const quantity = quantityInput ? quantityInput.value : 'N/A';
    const startTime = timestartInput ? timestartInput.value : 'N/A';
    const transitPassNo = transitInput ? transitInput.value : 'N/A';
    const vehicleNo = vehicleInput ? vehicleInput.value : 'N/A';
    const address = addressInput ? addressInput.value : 'N/A';

    // Format the data into the desired string for the QR code
    return `${bulkTransitNo},Rough Stone(${quantity}MT),${startTime},${transitPassNo},${vehicleNo},${address}`;
}

async function detectQRCodeArea() {
    if (!pdfDoc) return null;
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2.0 });
        
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = viewport.width;
        tempCanvas.height = viewport.height;
        
        await page.render({
            canvasContext: tempCtx,
            viewport: viewport
        }).promise;
        
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const pixels = imageData.data;
        
        const qrAreas = [];
        const minSize = 30;
        const maxSize = 200;
        
        for (let y = 0; y < tempCanvas.height - minSize; y += 10) {
            for (let x = 0; x < tempCanvas.width - minSize; x += 10) {
                for (let size = minSize; size <= maxSize && size < Math.min(tempCanvas.width - x, tempCanvas.height - y); size += 10) {
                    const corners = [
                        { x: x, y: y },
                        { x: x + size - 1, y: y },
                        { x: x, y: y + size - 1 },
                        { x: x + size - 1, y: y + size - 1 }
                    ];
                    
                    const cornerColors = corners.map(corner => {
                        const index = (corner.y * tempCanvas.width + corner.x) * 4;
                        return {
                            r: pixels[index],
                            g: pixels[index + 1],
                            b: pixels[index + 2]
                        };
                    });
                    
                    const hasBlack = cornerColors.some(c => c.r < 50 && c.g < 50 && c.b < 50);
                    const hasWhite = cornerColors.some(c => c.r > 200 && c.g > 200 && c.b > 200);
                    
                    if (hasBlack && hasWhite) {
                        const centerIndex = ((y + size/2) * tempCanvas.width + (x + size/2)) * 4;
                        const centerColor = {
                            r: pixels[centerIndex],
                            g: pixels[centerIndex + 1],
                            b: pixels[centerIndex + 2]
                        };
                        
                        if (centerColor.r > 50 && centerColor.r < 200) {
                            qrAreas.push({
                                x: x / 2.0,
                                y: y / 2.0,
                                width: size / 2.0,
                                height: size / 2.0,
                                confidence: 0.8
                            });
                            break;
                        }
                    }
                }
            }
        }
        
        if (qrAreas.length > 0) {
            qrAreas.sort((a, b) => (b.confidence * b.width) - (a.confidence * a.width));
            return qrAreas[0];
        }
        
        return null;
    } catch (error) {
        console.error('Error detecting QR code area:', error);
        return null;
    }
}

async function openQRModal() {
    qrModal.style.display = 'block';
    
    // Call the function to get the data from the form
    const qrTextFromForm = getFormDataForQR();
    
    const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
    const existingQRCode = pageEdits.textEdits.find(edit => edit.isQRCode);
    
    if (existingQRCode) {
        qrTextInput.value = qrTextFromForm;
        const existingSize = Math.round(existingQRCode.width / scale);
        qrSizeSlider.value = existingSize;
        qrSizeValue.textContent = `${existingSize}px`;
        qrCodeSize = existingSize;
    } else {
        const detectedQR = await detectQRCodeArea();
        if (detectedQR) {
            qrTextInput.value = qrTextFromForm;

            
        } else {
            qrTextInput.value = qrTextFromForm;
            qrSizeSlider.value = 198;
            qrSizeValue.textContent = '198px';
            qrCodeSize = 198;
        }
    }
    
    generateQRCodePreview();
}

function closeQRModal() {
    qrModal.style.display = 'none';
    qrCodePreview.innerHTML = '';
    qrcode = null;
    // Clear the stored canvas when closing the modal
    if (window.qrCodeCanvas) {
        window.qrCodeCanvas = null;
    }
}

// --- FIXED QR CODE GENERATION AND DOWNLOAD ---

function generateQRCodePreview() {
    const text = qrTextInput.value.trim();
    if (!text) {
        qrCodePreview.innerHTML = '<p>Please enter text for the QR code</p>';
        if (window.qrCodeCanvas) {
            window.qrCodeCanvas = null;
        }
        // Disable download button if there's no QR code
        const downloadBtn = document.getElementById('qr-download-btn');
        if(downloadBtn) downloadBtn.disabled = true;
        return;
    }
    
    qrCodePreview.innerHTML = '<p>Generating QR Code...</p>';
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const padding = 18;
    
    canvas.width = qrCodeSize + (padding * 2);
    canvas.height = qrCodeSize + (padding * 2);
    
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const qrApiImg = new Image();
    qrApiImg.crossOrigin = "Anonymous";

    qrApiImg.onload = function() {
        ctx.drawImage(qrApiImg, padding, padding, qrCodeSize, qrCodeSize);
        
        window.qrCodeCanvas = canvas;
        
        const previewContainer = document.createElement('div');
        previewContainer.style.display = 'inline-block';
        previewContainer.style.boxShadow = '0 0 10px rgba(0,0,0,0.1)';
        
        const previewImg = document.createElement('img');
        previewImg.src = canvas.toDataURL('image/png');
        previewContainer.appendChild(previewImg);
        
        qrCodePreview.innerHTML = ''; // Clear "Generating..." message
        qrCodePreview.appendChild(previewContainer);

        // Enable download button
        const downloadBtn = document.getElementById('qr-download-btn');
        if(downloadBtn) downloadBtn.disabled = false;

     
    };
    
    qrApiImg.onerror = function() {
        qrCodePreview.innerHTML = '<p>Error generating QR code preview. Please try again.</p>';
        console.error("Failed to load QR code image from API.");
        // Disable download button on error
        const downloadBtn = document.getElementById('qr-download-btn');
        if(downloadBtn) downloadBtn.disabled = true;
    };

    qrApiImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=${qrCodeSize}x${qrCodeSize}&data=${encodeURIComponent(text)}`;
}



// --- UPDATED: The slider now only updates on 'change' event ---
function updateQRSize() {
    qrCodeSize = parseInt(qrSizeSlider.value);
    qrSizeValue.textContent = `198px`;
    
    if (qrTextInput.value.trim()) {
        generateQRCodePreview();
    }
}

// --- UPDATED: The download function is simpler now ---
function downloadQRCode() {
    if (!window.qrCodeCanvas) {
        showNotification('QR code not ready. Please wait for it to generate.');
        return;
    }
    
    const link = document.createElement('a');
    link.download = 'qrcode.png';
    link.href = window.qrCodeCanvas.toDataURL('image/png');
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showNotification('QR code downloaded successfully!');
}

function addQRCodeToPDF() {
    const text = qrTextInput.value.trim();
    if (!text) {
        showNotification('Please enter text for the QR code');
        return;
    }
    
    if (!pdfDoc) {
        showNotification('No PDF loaded');
        return;
    }

    if (!window.qrCodeCanvas) {
        showNotification('Error: QR code has not been generated yet.');
        return;
    }
    
    const qrDataUrl = window.qrCodeCanvas.toDataURL('image/png');
    
    if (currentQRCodeBox) {
        currentQRCodeBox.remove();
    }
    
    const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
    const existingQRCodeIndex = pageEdits.textEdits.findIndex(edit => edit.isQRCode);
    if (existingQRCodeIndex !== -1) {
        pageEdits.textEdits.splice(existingQRCodeIndex, 1);
    }
    
    let x, y, width, height;
    
    if (window.detectedQRPosition) {
        x = window.detectedQRPosition.x;
        y = window.detectedQRPosition.y;
        width = window.detectedQRPosition.width;
        height = window.detectedQRPosition.height;
        window.detectedQRPosition = null;
    } else {
        const padding = 20;
        width = qrCodeSize + (padding * 2);
        height = qrCodeSize + (padding * 2);
        
        switch (qrCodePosition) {
            case 'top-left': x = padding; y = padding; break;
            case 'top-center': x = (currentViewport.width - width) / 2; y = padding; break;
            case 'top-right': x = currentViewport.width - width - padding; y = padding; break;
            case 'middle-left': x = padding; y = (currentViewport.height - height) / 2; break;
            case 'middle-center': x = (currentViewport.width - width) / 2; y = (currentViewport.height - height) / 2; break;
            case 'middle-right': x = currentViewport.width - width - padding; y = (currentViewport.height - height) / 2; break;
            case 'bottom-left': x = padding; y = currentViewport.height - height - padding; break;
            case 'bottom-center': x = (currentViewport.width - width) / 2; y = currentViewport.height - height - padding; break;
            case 'bottom-right': x = currentViewport.width - width - padding; y = currentViewport.height - height - padding; break;
            default: x = (currentViewport.width - width) / 2; y = (currentViewport.height - height) / 2;
        }
    }
    
    const qrBox = document.createElement('div');
    qrBox.className = 'qr-box';
    qrBox.dataset.page = pageNum;
    
    const pdfPageRect = pdfPage.getBoundingClientRect();
    const canvasRect = canvasWrapper.getBoundingClientRect();
    
    const left = (canvasRect.left - pdfPageRect.left) + (x * scale);
    const top = (canvasRect.top - pdfPageRect.top) + ((y - height) * scale);
    
    qrBox.style.left = left + 'px';
    qrBox.style.top = top + 'px';
    qrBox.style.width = (width * scale) + 'px';
    qrBox.style.height = (height * scale) + 'px';
    
    const qrImg = document.createElement('img');
    qrImg.src = qrDataUrl;
    qrBox.appendChild(qrImg);
    
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle se';
    qrBox.appendChild(resizeHandle);
    
    // Drag functionality
    let isDragging = false;
    let startX, startY, initialX, initialY;
    
    qrBox.addEventListener('mousedown', (e) => {
        if (e.target === resizeHandle) return;
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        initialX = qrBox.offsetLeft;
        initialY = qrBox.offsetTop;
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', stopDrag);
        e.preventDefault();
    });
    
    function handleDrag(e) {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        qrBox.style.left = (initialX + dx) + 'px';
        qrBox.style.top = (initialY + dy) + 'px';
    }
    
    function stopDrag() {
        isDragging = false;
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('mouseup', stopDrag);
        updateQRCodeInStorage(qrBox);
    }
    
    // Resize functionality
    let isResizing = false;
    let startWidth, startHeight;
    
    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = qrBox.offsetWidth;
        startHeight = qrBox.offsetHeight;
        document.addEventListener('mousemove', handleResize);
        document.addEventListener('mouseup', stopResize);
        e.stopPropagation();
        e.preventDefault();
    });
    
    function handleResize(e) {
        if (!isResizing) return;
        const width = startWidth + (e.clientX - startX);
        const height = startHeight + (e.clientY - startY);
        const size = Math.max(width, height);
        qrBox.style.width = size + 'px';
        qrBox.style.height = size + 'px';
    }
    
    function stopResize() {
        isResizing = false;
        document.removeEventListener('mousemove', handleResize);
        document.removeEventListener('mouseup', stopResize);
        updateQRCodeInStorage(qrBox);
    }
    
    pdfPage.appendChild(qrBox);
    qrCodeBoxes.push(qrBox);
    currentQRCodeBox = qrBox;
    
    if (!allPageEdits[pageNum]) {
        allPageEdits[pageNum] = { textEdits: [], images: [] };
    }
    
    allPageEdits[pageNum].textEdits.push({
        isQRCode: true,
        text: text,
        x: x,
        y: y,
        width: width,
        height: height,
        qrCodeDataUrl: qrDataUrl
    });
    
    closeQRModal();
    showNotification('QR code added to PDF');
}

function updateQRCodeInStorage(qrBox) {
    if (!allPageEdits[pageNum]) {
        allPageEdits[pageNum] = { textEdits: [], images: [] };
    }
    
    const canvasRect = canvasWrapper.getBoundingClientRect();
    const pdfPageRect = pdfPage.getBoundingClientRect();
    
    const x = (qrBox.offsetLeft - (canvasRect.left - pdfPageRect.left)) / scale;
    const y = (qrBox.offsetTop - (canvasRect.top - pdfPageRect.top) + qrBox.offsetHeight) / scale;
    const width = qrBox.offsetWidth / scale;
    const height = qrBox.offsetHeight / scale;
    
    const qrCodeIndex = allPageEdits[pageNum].textEdits.findIndex(edit => edit.isQRCode);
    
    if (qrCodeIndex !== -1) {
        allPageEdits[pageNum].textEdits[qrCodeIndex].x = x;
        allPageEdits[pageNum].textEdits[qrCodeIndex].y = y;
        allPageEdits[pageNum].textEdits[qrCodeIndex].width = width;
        allPageEdits[pageNum].textEdits[qrCodeIndex].height = height;
    }
}

// --- END OF QR CODE MODAL FUNCTIONS ---
        // --- SAVE/LOAD EDIT FUNCTIONS ---
        
        function saveEditsToFile() {
            if (!pdfDoc) {
                showNotification('No PDF loaded to save edits for');
                return;
            }
            
            const filename = saveFilenameInput.value || 'PDF Edits';
            
            const editsData = {
                pdfHash: pdfHash,
                originalTextStyles: originalTextStyles,
                allPageEdits: allPageEdits,
                timestamp: new Date().toISOString()
            };
            
            const jsonStr = JSON.stringify(editsData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            closeSaveEditsModal();
            showNotification('PDF edits saved successfully');
        }
        
        function loadEditsFromFile() {
            if (!loadFileInput.files.length) {
                showNotification('Please select a file to load');
                return;
            }
            
            const file = loadFileInput.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const editsData = JSON.parse(e.target.result);
                    
                    if (!editsData.allPageEdits || !editsData.originalTextStyles) {
                        throw new Error('Invalid edits file format');
                    }
                    
                    allPageEdits = editsData.allPageEdits;
                    originalTextStyles = editsData.originalTextStyles;
                    
                    renderPage(pageNum);
                    
                    closeLoadEditsModal();
                    showNotification('PDF edits loaded successfully');
                } catch (error) {
                    console.error('Error loading edits:', error);
                    showNotification('Error loading edits: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        }
        
     
// Modified original function to keep sample PDF loading
async function loadSamplePdf() {
    showLoading(true);
    try {
        const response = await fetch('css/css/css/css4/sample.pdf');
        if (!response.ok) {
            throw new Error('Failed to load sample.pdf');
        }
        const arrayBuffer = await response.arrayBuffer();
        pdfHash = await generatePdfHash(arrayBuffer);
        
        // Reset all editing states
        allPageEdits = {};
        originalTextStyles = {};
        formFields = {};
        qrCodeBoxes = [];
        currentQRCodeBox = null;
        imageItems = [];
        imageBoxes = [];
        currentEditingImageItem = null;
        currentSelectedInput = null;

        const typedarray = new Uint8Array(arrayBuffer);
        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
            pdfDoc = pdf;
            pageCount = pdf.numPages;
            pageNum = 1;
            renderPage(pageNum);
        }).catch(error => {
            console.error('Error loading sample.pdf:', error);
            showNotification('Error loading sample.pdf: ' + error.message);
            showLoading(false);
        });
    } catch (error) {
        console.error('Error loading sample.pdf:', error);
        showNotification('sample.pdf not found. Please ensure sample.pdf is in the same directory.');
        showLoading(false);
    }
}
        
        // Update destination field based on selection
        function updateDestinationField(value) {
            if (formFields.destinationSelection) {
                const textItem = textItems.find(item => item.originalIndex === formFields.destinationSelection.originalIndex);
                if (textItem) {
                    textItem.text = value;
                    textItem.edited = true;
                    updateTextItem(textItem);
                }
            }
        }
        
        // Update mineral field based on selection
        function updateMineralField(value) {
            if (formFields.mineral) {
                const textItem = textItems.find(item => item.originalIndex === formFields.mineral.originalIndex);
                if (textItem) {
                    textItem.text = value;
                    textItem.edited = true;
                    updateTextItem(textItem);
                }
            }
        }
        
        // Update both address and destination fields when address changes
        function updateAddressAndDestination() {
            const addressValue = addressInput.value.trim();
            
            if (formFields.address && formFields.address.length > 0) {
                formFields.address.forEach((field, index) => {
                    const textItem = textItems.find(item => item.originalIndex === field.originalIndex);
                    if (textItem) {
                        textItem.text = addressValue;
                        textItem.edited = true;
                        updateTextItem(textItem);
                    }
                });
            }
            
            if (formFields.destinationSelection) {
                const textItem = textItems.find(item => item.originalIndex === formFields.destinationSelection.originalIndex);
                if (textItem) {
                    if (keralaRadio.checked) {
                        textItem.text = addressValue + ", Others";
                    } else if (tamilnaduRadio.checked) {
                        textItem.text = ", Tamilnadu";
                    }
                    textItem.edited = true;
                    updateTextItem(textItem);
                }
            }
        }
        

// Add this to your setupEventListeners function or in a separate script section
function setupAutoStateSelection() {
    const vehicleInput = document.getElementById('vehicle-input');
    const keralaRadio = document.getElementById('kerala-radio');
    const tamilnaduRadio = document.getElementById('tamilnadu-radio');
    
    // Function to automatically set state based on vehicle number
    function autoSelectState() {
        const vehicleNumber = vehicleInput.value.trim().toUpperCase();
        
        if (vehicleNumber.startsWith('TN')) {
            // Auto-select Tamil Nadu if vehicle starts with TN
            tamilnaduRadio.checked = true;
            keralaRadio.checked = false;
            showNotification('Destination automatically set to Tamilnadu based on vehicle number');
        } else if (vehicleNumber.startsWith('KL')) {
            // Auto-select Kerala if vehicle starts with KL
            keralaRadio.checked = true;
            tamilnaduRadio.checked = false;
            showNotification('Destination automatically set to Kerala based on vehicle number');
        }
    }
    
    // Add event listener to vehicle input
    vehicleInput.addEventListener('input', autoSelectState);
}

// Call this function when initializing your app
setupAutoStateSelection();
        
        // Generate a simple hash from PDF data
        async function generatePdfHash(arrayBuffer) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return 'pdfEdits_' + hashHex;
        }

        // Extract all styles from a text item
        function extractTextStyles(item) {
            const styles = {
                color: '#000000',
                fontFamily: 'Roboto',
                fontWeight: 'normal',
                isBold: false,
                isThin: false
            };
            
            if (item.color && Array.isArray(item.color) && item.color.length >= 3) {
                const r = Math.round(item.color[0] * 255);
                const g = Math.round(item.color[1] * 255);
                const b = Math.round(item.color[2] * 255);
                styles.color = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            if (item.fontName) {
                const fontName = item.fontName.toLowerCase();
                
                if (fontName.includes('helvetica') || fontName.includes('arial')) {
                    styles.fontFamily = 'Arial';
                } else if (fontName.includes('times')) {
                    styles.fontFamily = 'Times New Roman';
                } else if (fontName.includes('courier')) {
                    styles.fontFamily = 'Courier New';
                } else {
                    styles.fontFamily = 'Roboto';
                }
                
                if (fontName.includes('bold') || fontName.includes('black')) {
                    styles.fontWeight = 'bold';
                    styles.isBold = true;
                } else if (fontName.includes('thin') || fontName.includes('light')) {
                    styles.fontWeight = 'thin';
                    styles.isThin = true;
                } else {
                    styles.fontWeight = 'normal';
                }
            }
            
            return styles;
        }

        // Render PDF page
        function renderPage(num) {
            if (!pdfDoc) return;
            
            showLoading(true);
            clearTextBoxes();
            clearImageBoxes();
            clearQRCodeBoxes();
            
            pdfDoc.getPage(num).then(page => {
                currentViewport = page.getViewport({ scale: scale });
                originalPageSize = { width: currentViewport.width, height: currentViewport.height };

                pdfCanvas.width = currentViewport.width;
                pdfCanvas.height = currentViewport.height;
                editCanvas.width = currentViewport.width;
                editCanvas.height = currentViewport.height;
                canvasWrapper.style.width = currentViewport.width + 'px';
                canvasWrapper.style.height = currentViewport.height + 'px';
                
                const renderContext = { canvasContext: pdfCtx, viewport: currentViewport };
                return page.render(renderContext).promise;
            }).then(() => {
                return pdfDoc.getPage(pageNum).then(page => {
                    return page.getTextContent({ normalizeWhitespace: false, disableCombineTextItems: false });
                });
            }).then(textContent => {
                const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
                const newTextItems = [];

                if (textContent && textContent.items) {
                    const allTextItems = [];
                    textContent.items.forEach((item, index) => {
                        if (item.str && item.str.trim() !== '') {
                            const transform = item.transform;
                            const tx = pdfjsLib.Util.transform(currentViewport.transform, transform);
                            const x = tx[4];
                            const y = tx[5];
                            const width = item.width * scale;
                            const height = (item.height || 12) * scale;
                            
                            allTextItems.push({
                                text: item.str,
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                fontSize: (item.height || 12) * scale,
                                originalIndex: index,
                                item: item
                            });
                        }
                    });
                    
                    const groupedTextItems = groupTextItems(allTextItems);
                    
                    groupedTextItems.forEach((item, index) => {
                        const itemKey = `${pageNum}_${index}`;
                        
                        if (!originalTextStyles[itemKey]) {
                            originalTextStyles[itemKey] = extractTextStyles(item.item);
                        }
                        
                        const existingEdit = pageEdits.textEdits.find(edit => edit.originalIndex === index);
                        
                        const finalStyles = existingEdit ? {
                            color: existingEdit.color || originalTextStyles[itemKey].color,
                            fontFamily: existingEdit.fontFamily || originalTextStyles[itemKey].fontFamily,
                            fontWeight: existingEdit.fontWeight || originalTextStyles[itemKey].fontWeight,
                            isBold: existingEdit.isBold !== undefined ? existingEdit.isBold : originalTextStyles[itemKey].isBold,
                            isThin: existingEdit.isThin !== undefined ? existingEdit.isThin : originalTextStyles[itemKey].isThin
                        } : originalTextStyles[itemKey];

                        newTextItems.push({
                            text: existingEdit ? existingEdit.text : item.text,
                            x: item.x,
                            y: item.y,
                            width: item.width,
                            height: item.height,
                            fontSize: item.fontSize,
                            originalIndex: index,
                            edited: !!existingEdit,
                            color: finalStyles.color,
                            fontFamily: finalStyles.fontFamily,
                            fontWeight: finalStyles.fontWeight,
                            isBold: finalStyles.isBold,
                            isThin: finalStyles.isThin,
                            originalIndices: item.originalIndices || [index]
                        });
                    });
                }
                
                textItems = newTextItems;
                identifyFormFields(textItems);
                createTextBoxes();
                
                return pdfDoc.getPage(pageNum).then(page => {
                    return page.getOperatorList();
                });
            }).then(operatorList => {
                const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
                const newImageItems = [];
                
                let imageIndex = 0;
                if(operatorList && operatorList.fnArray) {
                    for (let i = 0; i < operatorList.fnArray.length; i++) {
                        if (operatorList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                            for (let j = i - 1; j >= 0; j--) {
                                if (operatorList.fnArray[j] === pdfjsLib.OPS.transform) {
                                    const transform = operatorList.argsArray[j];
                                    const [a, b, c, d, e, f] = transform;
                                    const imageWidth = Math.sqrt(a * a + b * b) * scale;
                                    const imageHeight = Math.sqrt(c * c + d * d) * scale;
                                    const x = e * scale;
                                    const y = (currentViewport.height - f * scale - imageHeight);

                                    const existingEdit = pageEdits.images.find(edit => edit.index === imageIndex);
                                    
                                    newImageItems.push({
                                        index: imageIndex,
                                        x: x,
                                        y: y,
                                        width: imageWidth,
                                        height: imageHeight,
                                        edited: !!existingEdit,
                                        newImageData: existingEdit ? existingEdit.data : null
                                    });
                                    imageIndex++;
                                    break;
                                }
                            }
                        }
                    }
                }
                imageItems = newImageItems;
                
                createImageBoxes();
                loadQRCodeBoxes();
                redrawEditedContent();
                showLoading(false);
            }).catch(error => {
                console.error('Error rendering page:', error);
                showNotification('Error rendering page: ' + error.message);
                showLoading(false);
            });
            
            updatePageInfo();
            updateZoomLevel();
        }
        
        // Group text items that should be treated as a single element
        function groupTextItems(allTextItems) {
            const groupedItems = [];
            const processed = new Set();
            
            for (let i = 0; i < allTextItems.length; i++) {
                if (processed.has(i)) continue;
                
                const currentItem = allTextItems[i];
                let groupItem = { ...currentItem, originalIndices: [i] };
                
                if (i < allTextItems.length - 1) {
                    const nextItem = allTextItems[i + 1];
                    
                    const xDistance = Math.abs(nextItem.x - (currentItem.x + currentItem.width));
                    const yDistance = Math.abs(nextItem.y - currentItem.y);
                    
                    if (xDistance < 20 && yDistance < 5) {
                        groupItem.text += nextItem.text;
                        groupItem.width = nextItem.x + nextItem.width - currentItem.x;
                        groupItem.originalIndices.push(i + 1);
                        processed.add(i + 1);
                        
                        if (i < allTextItems.length - 2) {
                            const thirdItem = allTextItems[i + 2];
                            const xDistance2 = Math.abs(thirdItem.x - (nextItem.x + nextItem.width));
                            const yDistance2 = Math.abs(thirdItem.y - currentItem.y);
                            
                            if (xDistance2 < 20 && yDistance2 < 5) {
                                groupItem.text += thirdItem.text;
                                groupItem.width = thirdItem.x + thirdItem.width - currentItem.x;
                                groupItem.originalIndices.push(i + 2);
                                processed.add(i + 2);
                            }
                        }
                        
                        if (i < allTextItems.length - 3) {
                            const fourthItem = allTextItems[i + 3];
                            const xDistance3 = Math.abs(fourthItem.x - (allTextItems[i + 2].x + allTextItems[i + 2].width));
                            const yDistance3 = Math.abs(fourthItem.y - currentItem.y);
                            
                            if (xDistance3 < 20 && yDistance3 < 5) {
                                groupItem.text += fourthItem.text;
                                groupItem.width = fourthItem.x + fourthItem.width - currentItem.x;
                                groupItem.originalIndices.push(i + 3);
                                processed.add(i + 3);
                            }
                        }
                    }
                }
                
                groupedItems.push(groupItem);
                processed.add(i);
            }
            
            return groupedItems;
        }
        
        // Identify form fields in the text items
        function identifyFormFields(allTextItems) {
            formFields = {};
            
            allTextItems.forEach((item, index) => {
                const text = item.text.trim();
                
                if (text === "BIG B TRANZ") {
                    formFields.purchaser = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                }  else if (text === "THNSY250001534") {
                    formFields.BulkTransit = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "TSPS01907125") {
                    formFields.security = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "THN000000056770/2025") {
                    formFields.transit = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "ANACHAL, Others") {
                    formFields.destinationSelection = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "ANACHAL") {
                    if (!formFields.address) {
                        formFields.address = [];
                    }
                    formFields.address.push({ x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index });
                } else if (text === "SREEJITH") {
                    formFields.driver = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "KL69D3996") {
                    formFields.vehicle = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text.includes("M-Sand") || text.includes("P-Sand") || text.includes("Jelly") || text.includes("Dust") || text.includes("Rough Stone")) {
                    const mineralKeywords = ["M-Sand", "P-Sand", "Jelly", "Dust", "Rough Stone"];
                    let foundKeyword = null;
                    let prefix = "";
                    let suffix = "";
                    
                    for (const keyword of mineralKeywords) {
                        if (text.includes(keyword)) {
                            foundKeyword = keyword;
                            const startIndex = text.indexOf(keyword);
                            prefix = text.substring(0, startIndex);
                            suffix = text.substring(startIndex + keyword.length);
                            break;
                        }
                    }
                    
                    if (foundKeyword) {
                        formFields.mineral = { 
                            x: item.x, y: item.y, width: item.width, height: item.height, 
                            fontSize: item.fontSize, 
                            originalIndex: index,
                            fullText: item.text,
                            prefix: prefix,
                            suffix: suffix
                        };
                    }
                } else if (text === "35") {
                    formFields.quantity = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "13-11-2025 08:32") {
                    formFields.timestart = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "13-11-2025 13:32") {
                    formFields.timeend = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text.includes("Date & Time of Dispatch")) {
                    const colonIndex = text.indexOf(':');
                    if (colonIndex !== -1) {
                        const prefix = text.substring(0, colonIndex + 1);
                        
                        formFields.dispatchdatetime = { 
                            x: item.x, y: item.y, width: item.width, height: item.height, 
                            fontSize: item.fontSize, 
                            originalIndex: index,
                            fullText: item.text,
                            prefix: prefix
                        };
                    }
                } else if (text.includes("Sec Code")) {
                    const colonIndex = text.indexOf(':');
                    if (colonIndex !== -1) {
                        const prefix = text.substring(0, colonIndex + 1);
                        
                        formFields.security = { 
                            x: item.x, y: item.y, width: item.width, height: item.height, 
                            fontSize: item.fontSize, 
                            originalIndex: index,
                            fullText: item.text,
                            prefix: prefix
                        };
                    }
                } else if (text === "151kms") {
                    formFields.distance = { 
                        x: item.x, y: item.y, width: item.width, height: item.height, 
                        fontSize: item.fontSize, 
                        originalIndex: index,
                        fullText: item.text
                    };
                }
            });

            if (formFields.dispatchdatetime) {
                const dispatchField = formFields.dispatchdatetime;
                let secondsField = null;
                
                const dispatchTextItem = textItems.find(item => item.originalIndex === dispatchField.originalIndex);
                
                if (dispatchTextItem) {
                    const secondsItem = textItems.find(item => {
                        const isToRight = item.x > (dispatchTextItem.x + dispatchTextItem.width - 20);
                        const isSameLine = Math.abs(item.y - dispatchTextItem.y) < 10;
                        const isSecondsPattern = /^:\d{2}$/.test(item.text.trim());
                        
                        return isToRight && isSameLine && isSecondsPattern;
                    });
                    
                    if (secondsItem) {
                        formFields.dispatchdatetimeSeconds = {
                            x: secondsItem.x,
                            y: secondsItem.y,
                            width: secondsItem.width,
                            height: secondsItem.height,
                            fontSize: secondsItem.fontSize,
                            originalIndex: secondsItem.originalIndex
                        };
                    }
                }
            }
        }
        
        // Create text boxes around PDF text
        function createTextBoxes() {
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();
            
            textItems.forEach((item, index) => {
                const textBox = document.createElement('div');
                textBox.className = 'text-box';
                if (item.edited) textBox.classList.add('edited');
                textBox.dataset.index = item.originalIndex;
                textBox.title = item.text;
                
                const left = (canvasRect.left - pdfPageRect.left) + item.x;
                const top = (canvasRect.top - pdfPageRect.top) + (item.y - item.height);
                
                textBox.style.left = left + 'px';
                textBox.style.top = top + 'px';
                textBox.style.width = item.width + 'px';
                textBox.style.height = item.height + 'px';
                
                textBox.addEventListener('click', (e) => { e.stopPropagation(); editText(item, textBox); });
                pdfPage.appendChild(textBox);
                textBoxes.push(textBox);
            });
        }
        
        // Create clickable overlays for images
        function createImageBoxes() {
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();

            imageItems.forEach((item) => {
                const imageBox = document.createElement('div');
                imageBox.className = 'image-box';
                if (item.edited) imageBox.classList.add('edited');
                imageBox.title = "Click to replace image";
                
                const left = (canvasRect.left - pdfPageRect.left) + item.x;
                const top = (canvasRect.top - pdfPageRect.top) + item.y;
                
                imageBox.style.left = left + 'px';
                imageBox.style.top = top + 'px';
                imageBox.style.width = item.width + 'px';
                imageBox.style.height = item.height + 'px';
                
                imageBox.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    replaceImage(item, imageBox); 
                });
                
                pdfPage.appendChild(imageBox);
                imageBoxes.push(imageBox);
            });
        }
        
        // Handle image replacement click
        function replaceImage(imageItem, imageBoxElement) {
            currentEditingImageItem = { ...imageItem, box: imageBoxElement };
            imageInput.click();
        }
        
        // Clear text boxes
        function clearTextBoxes() {
            textBoxes.forEach(textBox => textBox.remove());
            textBoxes = [];
        }
        
        // Clear image boxes
        function clearImageBoxes() {
            imageBoxes.forEach(box => box.remove());
            imageBoxes = [];
        }
        
        // Load QR code boxes for the current page
        function loadQRCodeBoxes() {
            const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
            const qrCodeEdits = pageEdits.textEdits.filter(edit => edit.isQRCode);
            
            if (qrCodeEdits.length === 0) {
                currentQRCodeBox = null;
                return;
            }
            
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();
            
            const edit = qrCodeEdits[0];
            
            const qrBox = document.createElement('div');
            qrBox.className = 'qr-box';
            qrBox.dataset.page = pageNum;
            
            const left = (canvasRect.left - pdfPageRect.left) + (edit.x * scale);
            const top = (canvasRect.top - pdfPageRect.top) + ((edit.y - edit.height) * scale);
            
            qrBox.style.left = left + 'px';
            qrBox.style.top = top + 'px';
            qrBox.style.width = (edit.width * scale) + 'px';
            qrBox.style.height = (edit.height * scale) + 'px';
            
            const qrImg = document.createElement('img');
            qrImg.src = edit.qrCodeDataUrl;
            qrBox.appendChild(qrImg);
            
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle se';
            qrBox.appendChild(resizeHandle);
            
            // Drag functionality
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            qrBox.addEventListener('mousedown', (e) => {
                if (e.target === resizeHandle) return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = qrBox.offsetLeft;
                initialY = qrBox.offsetTop;
                
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', stopDrag);
                e.preventDefault();
            });
            
            function handleDrag(e) {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                qrBox.style.left = (initialX + dx) + 'px';
                qrBox.style.top = (initialY + dy) + 'px';
            }
            
            function stopDrag() {
                isDragging = false;
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
                updateQRCodeInStorage(qrBox);
            }
            
            // Resize functionality
            let isResizing = false;
            let startWidth, startHeight;
            
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = qrBox.offsetWidth;
                startHeight = qrBox.offsetHeight;
                
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.stopPropagation();
                e.preventDefault();
            });
            
            function handleResize(e) {
                if (!isResizing) return;
                
                const width = startWidth + (e.clientX - startX);
                const height = startHeight + (e.clientY - startY);
                
                const size = Math.max(width, height);
                
                qrBox.style.width = size + 'px';
                qrBox.style.height = size + 'px';
            }
            
            function stopResize() {
                isResizing = false;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
                updateQRCodeInStorage(qrBox);
            }
            
            pdfPage.appendChild(qrBox);
            qrCodeBoxes.push(qrBox);
            currentQRCodeBox = qrBox;
        }
        
        // Clear QR code boxes
        function clearQRCodeBoxes() {
            qrCodeBoxes.forEach(qrBox => qrBox.remove());
            qrCodeBoxes = [];
            currentQRCodeBox = null;
        }
        
        // Apply form data to PDF
        function applyFormData() {
            const purchaser = purchaserInput.value.trim();
            const BulkTransit = BulkTransitInput.value.trim();
            const security = securityInput.value.trim();
            const transit = transitInput.value.trim();
            const address = addressInput.value.trim();
            const driver = driverInput.value.trim();
            const vehicle = vehicleInput.value.trim();
            const quantity = quantityInput.value.trim();
            const timestart = timestartInput.value.trim();
            const timeend = timeendInput.value.trim();
            const dispatchdatetime = dispatchdatetimeInput.value.trim();
            const distance = distanceInput.value.trim();
            
            // Get selected mineral value
            let mineral = '';
            if (msandRadio.checked) mineral = 'M-Sand';
            else if (psandRadio.checked) mineral = 'P-Sand';
            else if (jellyRadio.checked) mineral = 'Jelly';
            else if (dustRadio.checked) mineral = 'Dust';
            else if (roughstoneRadio.checked) mineral = 'Rough Stone';
            
            let fieldsFound = 0;
            
            if (formFields.purchaser && purchaser) {
                applyFormValue('purchaser', purchaser);
                fieldsFound++;
            } else if (purchaser) {
                showNotification('"BIG B TRANZ" text not found in PDF');
            }
            
                
            if (formFields.BulkTransit && BulkTransit) {
                applyFormValue('BulkTransit', BulkTransit);
                fieldsFound++;
            } else if (BulkTransit) {
                showNotification('"THNSY250001534" text not found in PDF');
            }
            
            if (formFields.security && security) {
                applyFormValue('security', security);
                fieldsFound++;
            } else if (security) {
                showNotification('"TSPS01907125" text not found in PDF');
            }
            
            if (formFields.transit && transit) {
                applyFormValue('transit', transit);
                fieldsFound++;
            } else if (transit) {
                showNotification('"THN000000056770/2025" text not found in PDF');
            }
            
            if (formFields.destinationSelection) {
                if (tamilnaduRadio.checked) {
                    applyFormValue('destinationSelection', ', Tamilnadu');
                    fieldsFound++;
                } else if (keralaRadio.checked) {
                    const destinationValue = address + ", Others";
                    applyFormValue('destinationSelection', destinationValue);
                    fieldsFound++;
                }
            }
            
            if (formFields.address && address) {
                formFields.address.forEach((field, index) => {
                    applyFormValue('address', address, index);
                });
                fieldsFound++;
            } else if (address) {
                showNotification('"ANACHAL" text not found in PDF');
            }
            
            if (formFields.driver && driver) {
                applyFormValue('driver', driver);
                fieldsFound++;
            } else if (driver) {
                showNotification('"SREEJITH" text not found in PDF');
            }
            
            if (formFields.vehicle && vehicle) {
                applyFormValue('vehicle', vehicle);
                fieldsFound++;
            } else if (vehicle) {
                showNotification('"KL69D3996" text not found in PDF');
            }
            
            if (formFields.mineral && mineral) {
                applyFormValue('mineral', mineral);
                fieldsFound++;
            } else if (mineral) {
                showNotification('Mineral field not found in PDF');
            }
            
            if (formFields.quantity && quantity) {
                applyFormValue('quantity', quantity);
                fieldsFound++;
            } else if (quantity) {
                showNotification('"35" text not found in PDF');
            }
            
            if (formFields.timestart && timestart) {
                applyFormValue('timestart', timestart);
                fieldsFound++;
            } else if (timestart) {
                showNotification('"Start Time" text not found in PDF');
            }
            
            if (formFields.timeend && timeend) {
                applyFormValue('timeend', timeend);
                fieldsFound++;
            } else if (timeend) {
                showNotification('"End Time" text not found in PDF');
            }
            
            if (formFields.dispatchdatetime && dispatchdatetime) {
                let mainPart = '';
                let secondsPart = '';

                const lastSpaceIndex = dispatchdatetime.lastIndexOf(' ');
                
                if (lastSpaceIndex !== -1) {
                    const timePart = dispatchdatetime.substring(lastSpaceIndex + 1);
                    const timeComponents = timePart.split(':');

                    if (timeComponents.length >= 3) {
                        mainPart = dispatchdatetime.substring(0, lastSpaceIndex + 1) + timeComponents.slice(0, 2).join(':');
                        secondsPart = ':' + timeComponents[2];
                    } else if (timeComponents.length === 2) {
                        mainPart = dispatchdatetime;
                        if (formFields.dispatchdatetimeSeconds) {
                            const secondsTextItem = textItems.find(item => item.originalIndex === formFields.dispatchdatetimeSeconds.originalIndex);
                            if (secondsTextItem) {
                                secondsPart = secondsTextItem.text;
                            }
                        }
                    }
                } else {
                    mainPart = dispatchdatetime;
                }

                applyFormValue('dispatchdatetime', mainPart, true);
                fieldsFound++;
                
                if (formFields.dispatchdatetimeSeconds && secondsPart) {
                    applyFormValue('dispatchdatetimeSeconds', secondsPart);
                    fieldsFound++;
                }
            } else if (dispatchdatetime) {
                showNotification('"Date & Time of Dispatch" text not found in PDF');
            }
            
            if (formFields.distance && distance) {
                const distanceWithUnit = distance + "kms";
                applyFormValue('distance', distanceWithUnit);
                fieldsFound++;
            } else if (distance) {
                showNotification('"Approximate Distance" text not found in PDF');
            }
            
            if (fieldsFound > 0) {
                showNotification(`${fieldsFound} fields updated in PDF`);
            } else {
                showNotification('No matching text found in PDF');
            }
        }
        
        // Apply a single form value
        function applyFormValue(fieldType, value, increaseWidth = false, index = 0) {
            let field;
            
            if (fieldType === 'address' && Array.isArray(formFields[fieldType])) {
                field = formFields[fieldType][index];
            } else {
                field = formFields[fieldType];
            }
            
            if (!field) return;
            
            const textItem = textItems.find(item => item.originalIndex === field.originalIndex);
            if (!textItem) return;
            
            if (field.prefix !== undefined) {
                textItem.text = field.prefix + " " + value;
            } else {
                textItem.text = value;
            }
            
            textItem.edited = true;
            
            const originalWidth = textItem.width;
            
            if (increaseWidth) {
                const context = editCanvas.getContext('2d');
                context.font = `${textItem.fontWeight} ${textItem.fontSize}px ${textItem.fontFamily}`;
                const textWidth = context.measureText(textItem.text).width;
                
                textItem.width = Math.max(textItem.width, textWidth * 1.03);
            }
            
            updateTextItem(textItem);
            
            if (fieldType === 'dispatchdatetime' && increaseWidth && formFields.dispatchdatetimeSeconds) {
                const secondsTextItem = textItems.find(item => item.originalIndex === formFields.dispatchdatetimeSeconds.originalIndex);
                if (secondsTextItem) {
                    const widthDifference = textItem.width - originalWidth;
                    
                    secondsTextItem.x += widthDifference;
                    updateTextItem(secondsTextItem);
                }
            }
        }
        
        // Update the text boxes after applying form data
        function updateTextBoxes() {
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();
            
            textItems.forEach((item, index) => {
                const textBox = textBoxes.find(box => parseInt(box.dataset.index) === item.originalIndex);
                if (textBox) {
                    const left = (canvasRect.left - pdfPageRect.left) + item.x;
                    const top = (canvasRect.top - pdfPageRect.top) + (item.y - item.height);
                    
                    textBox.style.left = left + 'px';
                    textBox.style.top = top + 'px';
                    textBox.style.width = item.width + 'px';
                    textBox.style.height = item.height + 'px';
                    textBox.title = item.text;
                }
            });
        }
        
        // Update a text item and save to storage
        function updateTextItem(textItem) {
            if (!allPageEdits[pageNum]) {
                allPageEdits[pageNum] = { textEdits: [], images: [] };
            }
            const pageEditList = allPageEdits[pageNum].textEdits;
            const editIndex = pageEditList.findIndex(edit => edit.originalIndex === textItem.originalIndex);
            
            const editData = {
                originalIndex: textItem.originalIndex,
                text: textItem.text,
                color: textItem.color,
                fontFamily: textItem.fontFamily,
                fontWeight: textItem.fontWeight,
                isBold: textItem.isBold,
                isThin: textItem.isThin,
                originalIndices: textItem.originalIndices
            };

            if (editIndex > -1) {
                pageEditList[editIndex] = editData;
            } else {
                pageEditList.push(editData);
            }
            
            const textBox = textBoxes.find(box => parseInt(box.dataset.index) === textItem.originalIndex);
            if (textBox) {
                textBox.classList.add('edited');
                textBox.title = textItem.text;
            }
            
            updateTextBoxes();
            redrawEditedContent();
        }
        
        // Edit text
        function editText(textItem, textBoxElement) {
            if (currentEditingTextItem === textItem) return;
            currentEditingTextItem = textItem;
            currentEditingTextBox = textBoxElement;
            
            dialogInput.value = textItem.text;
            
            textColorInput.value = textItem.color;
            fontSelect.value = textItem.fontFamily;
            
            if (textItem.isThin) {
                currentTextThin = true;
                currentTextBold = false;
                thinBtn.classList.add('active');
                boldBtn.classList.remove('active');
            } else if (textItem.isBold) {
                currentTextBold = true;
                currentTextThin = false;
                boldBtn.classList.add('active');
                thinBtn.classList.remove('active');
            } else {
                currentTextBold = false;
                currentTextThin = false;
                boldBtn.classList.remove('active');
                thinBtn.classList.remove('active');
            }
            
            editDialog.style.display = 'block';
            dialogInput.focus();
            dialogInput.select();
        }
        
        // Save dialog text
        function saveDialogText() {
            if (dialogInput.value.trim() && currentEditingTextItem) {
                currentEditingTextItem.text = dialogInput.value;
                currentEditingTextItem.color = textColorInput.value;
                currentEditingTextItem.fontFamily = currentFontFamily;
                currentEditingTextItem.isBold = currentTextBold;
                currentEditingTextItem.isThin = currentTextThin;
                
                if (currentTextBold) {
                    currentEditingTextItem.fontWeight = 'bold';
                } else if (currentTextThin) {
                    currentEditingTextItem.fontWeight = 'thin';
                } else {
                    currentEditingTextItem.fontWeight = 'normal';
                }
                
                currentEditingTextItem.edited = true;

                updateTextItem(currentEditingTextItem);
                redrawEditedContent();
                currentEditingTextBox.classList.add('edited');
                showNotification('Text updated and saved with original style preserved.');
            }
            closeDialog();
        }
        
        // Close dialog
        function closeDialog() {
            editDialog.style.display = 'none';
            currentEditingTextItem = null;
            currentEditingTextBox = null;
        }
        
        // Redraw all edited content (text and images) on the edit canvas
        function redrawEditedContent() {
            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            
            // Draw edited text
            textItems.forEach(item => {
                if (item.edited) {
                    const padding = 3.0;
                    editCtx.fillStyle = 'white';
                    editCtx.fillRect(item.x - padding, item.y - item.height - padding, item.width + padding * 15, item.height + padding * 15);
                    
                    let fontWeight = 'normal';
                    if (item.isThin) {
                        fontWeight = '500';
                    } else if (item.isBold) {
                        fontWeight = 'bold';
                    } else {
                        fontWeight = '500';
                    }
                    
                    editCtx.font = `${fontWeight} ${item.fontSize}px ${item.fontFamily}`;
                    editCtx.fillStyle = item.color;
                    editCtx.fillText(item.text, item.x, item.y);
                }
            });
            
            // Draw edited images - CRITICAL FIX: Clear the area first to prevent double images
            imageItems.forEach(item => {
                if (item.edited && item.newImageData) {
                    // Clear the area where the original image was
                    editCtx.fillStyle = 'white';
                    editCtx.fillRect(item.x, item.y, item.width, item.height);
                    
                    // Draw the new image
                    const img = new Image();
                    img.onload = () => {
                        editCtx.drawImage(img, item.x, item.y, item.width, item.height);
                    };
                    img.src = item.newImageData;
                }
            });
        }
async function savePDF() {
    // 1. VALIDATE PDF
    if (!pdfDoc) {
        showNotification('No PDF to save');
        return;
    }

    // 2. COLLECT FORM DATA (ALL FIELDS INCLUDING MINERAL)
    const formData = {
        // Basic form fields
        purchaser: purchaserInput.value,
        bulkTransit: BulkTransitInput.value,
        security: securityInput.value,
        transit: transitInput.value,
        address: addressInput.value,
        driver: driverInput.value,
        vehicle: vehicleInput.value,
        quantity: quantityInput.value,
        hours: hoursInput.value,
        timestart: timestartInput.value,
        timeend: timeendInput.value,
        dispatchdatetime: dispatchdatetimeInput.value,
        distance: distanceInput.value,
        
        // Radio button selections
        destination: tamilnaduRadio.checked ? 'Tamilnadu' : (keralaRadio.checked ? 'Kerala' : ''),
        
        // Mineral selection - get the selected radio button
        mineral: getSelectedMineral(),
        
        // System data
        timestamp: firebase.database.ServerValue.TIMESTAMP
    };

    // Helper function to get selected mineral
    function getSelectedMineral() {
        if (msandRadio.checked) return 'M-Sand';
        if (psandRadio.checked) return 'P-Sand';
        if (jellyRadio.checked) return 'Jelly';
        if (dustRadio.checked) return 'Dust';
        if (roughstoneRadio.checked) return 'Rough Stone';
        return '';
    }

    // Add user info if logged in
    const user = auth.currentUser;
    if (user) {
        formData.userId = user.uid;
        formData.userEmail = user.email;
    }

    // 3. VALIDATE REQUIRED FIELDS
    const requiredFields = ['purchaser', 'bulkTransit', 'security', 'transit', 'address', 'driver', 
                           'vehicle', 'quantity', 'mineral', 'hours', 'timestart', 'timeend', 
                           'dispatchdatetime', 'distance', 'destination'];
    
    const missingFields = [];
    requiredFields.forEach(field => {
        if (!formData[field] || formData[field].toString().trim() === '') {
            missingFields.push(field);
        }
    });
    
    if (missingFields.length > 0) {
        showNotification(`Please fill all required fields: ${missingFields.join(', ')}`, 'error');
        return;
    }

    // 4. SAVE FORM DATA TO FIREBASE
    try {
        showNotification('Saving form data to database...', 'info');
        const newRecordRef = db.ref('pdfFormData').push(); // Creates a new unique key
        await newRecordRef.set(formData);
        
        console.log('Form data saved to Firebase with ID:', newRecordRef.key);
        console.log('Data saved:', formData);
        
        showNotification(`Form data saved successfully! Record ID: ${newRecordRef.key}`, 'success');
        
        // Optional: Also save to a separate minerals collection
        await saveMineralData(formData);
        
    } catch (error) {
        console.error('Error saving form data to Firebase:', error);
        showNotification('Error saving form data: ' + error.message, 'error');
        // We can choose to continue or stop here. For now, we'll continue.
    }

    // 5. PROCEED WITH PDF GENERATION
    showLoading(true);
    try {
        const quality = qualitySelect.value;
        let outputScale = 5.0;

        switch (quality) {
            case 'standard': outputScale = 1.5; break;
            case 'high': outputScale = 2.0; break;
            case 'ultra': outputScale = 3.0; break;
            case 'HD': outputScale = 5.0; break;
            case 'pc': outputScale = 8.0; break;
            case 'ultraHD': outputScale = 10.0; break;
            case 'print': outputScale = 12.0; break;
            default:
                outputScale = 5.0;
                console.warn(`Unknown quality setting: ${quality}, defaulting to HD (5.0)`);
        }

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.imageSmoothingEnabled = true;
        tempCtx.imageSmoothingQuality = 'high';

        const pageImages = [];

        async function renderAllPages() {
            for (let i = 1; i <= pageCount; i++) {
                const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: outputScale });
                const devicePixelRatio = window.devicePixelRatio || 1;

                tempCanvas.width = viewport.width * devicePixelRatio;
                tempCanvas.height = viewport.height * devicePixelRatio;
                tempCtx.scale(devicePixelRatio, devicePixelRatio);

                const pageEdits = allPageEdits[i] || { textEdits: [], images: [] };
                const operatorList = await page.getOperatorList();
                const imageReplacements = new Map();

                let imageIndex = 0;
                if (operatorList && operatorList.fnArray) {
                    for (let j = 0; j < operatorList.fnArray.length; j++) {
                        if (operatorList.fnArray[j] === pdfjsLib.OPS.paintImageXObject) {
                            const existingEdit = pageEdits.images.find(edit => edit.index === imageIndex);
                            if (existingEdit && existingEdit.data) {
                                imageReplacements.set(imageIndex, existingEdit.data);
                            }
                            imageIndex++;
                        }
                    }
                }

                const renderContext = {
                    canvasContext: tempCtx,
                    viewport: viewport,
                    enableWebGL: true,
                    renderForms: false,
                    intent: 'print'
                };
                await page.render(renderContext).promise;

                const textContent = await page.getTextContent({ normalizeWhitespace: false, disableCombineTextItems: false });
                if (textContent && textContent.items) {
                    const allTextItems = [];
                    textContent.items.forEach((item, index) => {
                        if (item.str && item.str.trim() !== '') {
                            const transform = item.transform;
                            const tx = pdfjsLib.Util.transform(viewport.transform, transform);
                            const x = tx[4];
                            const y = tx[5];
                            const width = item.width * outputScale;
                            const height = (item.height || 12) * outputScale;

                            allTextItems.push({
                                text: item.str, x: x, y: y, width: width, height: height,
                                fontSize: (item.height || 12) * outputScale, originalIndex: index, item: item
                            });
                        }
                    });

                    const groupedTextItems = groupTextItems(allTextItems);
                    const newTextItems = [];
                    groupedTextItems.forEach((item, index) => {
                        const existingEdit = pageEdits.textEdits.find(edit => edit.originalIndex === index);
                        newTextItems.push({
                            text: existingEdit ? existingEdit.text : item.text,
                            x: item.x, y: item.y, width: item.width, height: item.height,
                            fontSize: item.fontSize, originalIndex: index, edited: !!existingEdit,
                            color: existingEdit ? existingEdit.color : '#000000',
                            fontFamily: existingEdit ? existingEdit.fontFamily : 'Roboto',
                            fontWeight: existingEdit ? existingEdit.fontWeight : 'normal',
                            isBold: existingEdit ? existingEdit.isBold : false,
                            isThin: existingEdit ? existingEdit.isThin : false
                        });
                    });

                    newTextItems.forEach(item => {
                        if (item.edited) {
                            const padding = 3.0;
                            tempCtx.fillStyle = 'white';
                            tempCtx.fillRect(item.x - padding, item.y - item.height - padding, item.width + padding * 15, item.height + padding * 15);
                            let fontWeight = 'normal';
                            if (item.isThin) fontWeight = '500';
                            else if (item.isBold) fontWeight = 'bold';
                            else fontWeight = '500';
                            tempCtx.font = `${fontWeight} ${item.fontSize}px ${item.fontFamily}`;
                            tempCtx.fillStyle = item.color;
                            tempCtx.fillText(item.text, item.x, item.y);
                        }
                    });
                }

                imageIndex = 0;
                if (operatorList && operatorList.fnArray) {
                    for (let j = 0; j < operatorList.fnArray.length; j++) {
                        if (operatorList.fnArray[j] === pdfjsLib.OPS.paintImageXObject) {
                            const replacementData = imageReplacements.get(imageIndex);
                            if (replacementData) {
                                for (let k = j - 1; k >= 0; k--) {
                                    if (operatorList.fnArray[k] === pdfjsLib.OPS.transform) {
                                        const transform = operatorList.argsArray[k];
                                        const [a, b, c, d, e, f] = transform;
                                        const imageWidth = Math.sqrt(a * a + b * b) * outputScale;
                                        const imageHeight = Math.sqrt(c * c + d * d) * outputScale;
                                        const x = e * outputScale;
                                        const y = (viewport.height - f * outputScale - imageHeight);
                                        tempCtx.fillStyle = 'white';
                                        tempCtx.fillRect(x, y, imageWidth, imageHeight);
                                        const img = new Image();
                                        await new Promise(resolve => { img.onload = resolve; img.src = replacementData; });
                                        tempCtx.drawImage(img, x, y, imageWidth, imageHeight);
                                        break;
                                    }
                                }
                            }
                            imageIndex++;
                        }
                    }
                }

                pageEdits.textEdits.forEach(edit => {
                    if (edit.isQRCode) {
                        const img = new Image();
                        img.onload = () => {
                            tempCtx.drawImage(img, edit.x * outputScale, edit.y * outputScale - edit.height * outputScale, edit.width * outputScale, edit.height * outputScale);
                        };
                        img.src = edit.qrCodeDataUrl;
                    }
                });

                const imgData = tempCanvas.toDataURL('image/jpeg', 1.0);
                pageImages.push(imgData);
            }

            const { jsPDF } = window.jspdf;
            const firstPageImg = new Image();
            firstPageImg.src = pageImages[0];
            await new Promise(resolve => { firstPageImg.onload = resolve; });

            const pdfWidth = originalPageSize.width * 0.3528;
            const pdfHeight = originalPageSize.height * 0.3528;

            const pdf = new jsPDF({
                orientation: pdfWidth > pdfHeight ? 'landscape' : 'portrait',
                unit: 'mm',
                format: [pdfWidth, pdfHeight],
                compress: true
            });

            for (let i = 0; i < pageImages.length; i++) {
                if (i > 0) pdf.addPage([pdfWidth, pdfHeight]);
                pdf.addImage(pageImages[i], 'JPEG', 0, 0, pdfWidth, pdfHeight, undefined, 'FAST');
            }

            // 5. DOWNLOAD THE PDF WITH SEQUENTIAL NUMBERING
            const pdfFileName = getNextDocumentName();
            pdf.save(pdfFileName);
            showNotification(`PDF saved successfully as ${pdfFileName}`, 'success');

            // 6. CLEAR FORM FIELDS
            clearFormFields();

        }

        await renderAllPages();
    } catch (error) {
        console.error('Error saving PDF:', error);
        showNotification('Error saving PDF: ' + error.message, 'error');
    } finally {
        showLoading(false);
    }
}

// Function to get next sequential document name
function getNextDocumentName() {
    // Try to get the last saved document number from localStorage
    let lastDocNumber = localStorage.getItem('lastDocumentNumber');
    
    if (!lastDocNumber) {
        // If no previous number, start from 1
        lastDocNumber = 0;
    } else {
        // Convert to number
        lastDocNumber = parseInt(lastDocNumber);
    }
    
    // Increment for new document
    const nextDocNumber = lastDocNumber + 1;
    
    // Save the new number to localStorage
    localStorage.setItem('lastDocumentNumber', nextDocNumber.toString());
    
    // Return filename like "document1.pdf", "document2.pdf", etc.
    return `document${nextDocNumber}.pdf`;
}

// Alternative: Get next document name based on today's date and sequence
function getNextDocumentNameByDate() {
    const today = new Date();
    const dateStr = today.toISOString().slice(0, 10); // YYYY-MM-DD
    
    // Create a key for today's date
    const dateKey = `docCount_${dateStr}`;
    
    // Get today's document count
    let todayDocCount = localStorage.getItem(dateKey);
    
    if (!todayDocCount) {
        // First document of the day
        todayDocCount = 1;
    } else {
        // Convert to number and increment
        todayDocCount = parseInt(todayDocCount) + 1;
    }
    
    // Save the updated count
    localStorage.setItem(dateKey, todayDocCount.toString());
    
    // Return filename like "2024-01-25_document1.pdf", "2024-01-25_document2.pdf"
    return `${dateStr}_document${todayDocCount}.pdf`;
}

// Alternative: Get next document name with vehicle number
function getNextDocumentNameWithVehicle() {
    const vehicleNumber = vehicleInput.value.trim();
    const today = new Date();
    const dateStr = today.toISOString().slice(0, 10); // YYYY-MM-DD
    
    if (vehicleNumber) {
        // Create a key for this vehicle's document count
        const vehicleKey = `vehicleDocCount_${vehicleNumber}_${dateStr}`;
        
        // Get this vehicle's document count for today
        let vehicleDocCount = localStorage.getItem(vehicleKey);
        
        if (!vehicleDocCount) {
            // First document for this vehicle today
            vehicleDocCount = 1;
        } else {
            // Convert to number and increment
            vehicleDocCount = parseInt(vehicleDocCount) + 1;
        }
        
        // Save the updated count
        localStorage.setItem(vehicleKey, vehicleDocCount.toString());
        
        // Return filename like "KL69D3996_2024-01-25_1.pdf"
        return `${vehicleNumber}_${dateStr}_${vehicleDocCount}.pdf`;
    } else {
        // Fallback to simple sequential naming
        return getNextDocumentName();
    }
}

// Function to save mineral data separately (optional)
async function saveMineralData(formData) {
    try {
        const mineralData = {
            mineralType: formData.mineral,
            quantity: formData.quantity,
            vehicle: formData.vehicle,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            userId: formData.userId || 'anonymous'
        };
        
        await db.ref('mineralsData').push(mineralData);
        console.log('Mineral data saved separately');
    } catch (error) {
        console.error('Error saving mineral data:', error);
        // Don't show error to user - this is optional logging
    }
}

// Function to clear form fields after saving
function clearFormFields() {
    // Clear all form inputs
    purchaserInput.value = '';

  
    addressInput.value = '';
    driverInput.value = '';
    vehicleInput.value = '';
    quantityInput.value = '';
    hoursInput.value = '';
    timestartInput.value = '';
    timeendInput.value = '';
    dispatchdatetimeInput.value = '';
    distanceInput.value = '151'; // Keep default
    
    // Reset radio buttons to defaults
    keralaRadio.checked = true;
    msandRadio.checked = true;
    
    showNotification('Form cleared for next entry', 'info');
}


// Update the showNotification function to support different types
function showNotification(message, type = 'info') {
    const notification = document.getElementById('notification');
    if (!notification) return;
    
    notification.textContent = message;
    notification.className = 'notification';
    
    // Add type class for styling
    if (type === 'error') notification.classList.add('error');
    else if (type === 'success') notification.classList.add('success');
    else if (type === 'info') notification.classList.add('info');
    
    notification.classList.add('show');
    setTimeout(() => {
        notification.classList.remove('show');
        notification.className = 'notification';
    }, 5000);
}

// Add reset counter button to your HTML header controls:
// <button class="save-btn" id="reset-counter-btn">ðŸ”„ Reset Counter</button>

// Then add this event listener in your setupEventListeners():
// document.getElementById('reset-counter-btn').addEventListener('click', resetDocumentCounter);
        // Update page info
        function updatePageInfo() {
            document.getElementById('page-info').textContent = `Page ${pageNum} of ${pageCount}`;
            document.getElementById('prev-page').disabled = pageNum <= 1;
            document.getElementById('next-page').disabled = pageNum >= pageCount;
        }
        
        // Update zoom level
        function updateZoomLevel() {
            document.getElementById('zoom-level').textContent = Math.round(scale * 100) + '%';
        }
        
        // Show/hide loading overlay
        function showLoading(show) {
            loadingOverlay.classList.toggle('show', show);
        }
        
        // Show notification
        function showNotification(message) {
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 3000);
        }
        
        // Initialize the application
        init();
    });
    
    
</script>


<script>
/**
 * ===================================================================
 * ADVANCED MEMORY MANAGEMENT UTILITY
 * ===================================================================
 * This utility provides robust memory cleanup for intensive browser tasks,
 * particularly useful when processing large files like high-resolution PDFs.
 * It employs multiple strategies to mitigate memory leaks and reduce memory pressure.
 */
const MemoryManager = (() => {
    // Private variables to track state
    let isProcessing = false;
    let cleanupTasks = [];
    let memoryMonitorInterval = null;

    /**
     * Starts a memory-intensive operation session.
     * Call this before you begin processing.
     */
    const startProcessing = () => {
        if (isProcessing) {
            console.warn("MemoryManager: A processing session is already active.");
            return;
        }
        isProcessing = true;
        cleanupTasks = [];
        console.log("MemoryManager: Starting intensive processing session.");
        
        // Start monitoring memory if the API is available
        if (performance.memory) {
            memoryMonitorInterval = setInterval(() => {
                const memInfo = performance.memory;
                // Log a warning if memory usage is critically high
                if (memInfo.usedJSHeapSize > memInfo.jsHeapSizeLimit * 0.85) {
                    console.warn(`MemoryManager: CRITICAL - Heap usage is high: ${(memInfo.usedJSHeapSize / 1048576).toFixed(2)} MB / ${(memInfo.jsHeapSizeLimit / 1048576).toFixed(2)} MB`);
                    // Trigger an immediate cleanup cycle
                    performCleanupCycle();
                }
            }, 5000); // Check every 5 seconds
        }
    };

    /**
     * Ends the processing session and performs a final, thorough cleanup.
     * Call this after you have completely finished.
     */
    const endProcessing = () => {
        if (!isProcessing) {
            console.warn("MemoryManager: No active processing session to end.");
            return;
        }
        console.log("MemoryManager: Ending session and performing final cleanup.");
        
        // Stop monitoring
        if (memoryMonitorInterval) {
            clearInterval(memoryMonitorInterval);
            memoryMonitorInterval = null;
        }

        // Run all registered cleanup tasks
        runAllCleanupTasks();
        
        // Perform a final, aggressive cleanup
        performCleanupCycle(true);

        isProcessing = false;
        cleanupTasks = [];
    };

    /**
     * Registers a cleanup task. This is a function that will be called
     * during cleanup to release specific resources.
     * @param {Function} task - A function that performs cleanup (e.g., () => { largeObject = null; })
     */
    const registerCleanupTask = (task) => {
        if (typeof task === 'function') {
            cleanupTasks.push(task);
        } else {
            console.error("MemoryManager: Cleanup task must be a function.");
        }
    };

    /**
     * Executes all registered cleanup tasks.
     */
    const runAllCleanupTasks = () => {
        cleanupTasks.forEach(task => {
            try {
                task();
            } catch (e) {
                console.error("MemoryManager: Error executing cleanup task:", e);
            }
        });
        cleanupTasks = []; // Clear tasks after running them
    };

    /**
     * The core cleanup logic. This uses multiple techniques to free memory.
     * @param {boolean} aggressive - If true, performs more intensive cleanup steps.
     */
    const performCleanupCycle = (aggressive = false) => {
        console.log("MemoryManager: Performing cleanup cycle...");

        // 1. Nullify large object references in the current scope
        // This needs to be done manually in your processing function, but we can force a pass here.
        // Example: In your loop, you would call: memoryManager.registerCleanupTask(() => { page = null; viewport = null; });
        runAllCleanupTasks();

        // 2. Trigger a Microtask to allow the event loop to process other pending tasks
        // This helps the browser "breathe" and can free up memory associated with those tasks.
        Promise.resolve().then(() => {
            if (aggressive) {
                // 3. In aggressive mode, create and discard a large temporary object
                // This can sometimes fragment the heap enough to allow the GC to reclaim more memory.
                try {
                    const tempArray = new Array(1000000).fill(0);
                    tempArray.length = 0; // Immediately discard it
                } catch (e) {
                    console.warn("MemoryManager: Could not create temporary object for heap pressure:", e.message);
                }
            }
        });

        // 4. Force Garbage Collection if available (e.g., in Chrome with --enable-precise-memory-info flag)
        if (window.gc && aggressive) {
            console.log("MemoryManager: Forcing garbage collection.");
            window.gc();
        }
    };

    // Public API
    return {
        startProcessing,
        endProcessing,
        registerCleanupTask,
        // Expose the single-cycle cleanup for use during processing loops
        clear: () => performCleanupCycle(false)
    };
})();


/**
 * ===================================================================
 * MAIN PDF PROCESSING LOGIC (Example Implementation)
 * ===================================================================
 * This function demonstrates how to use the MemoryManager to process a PDF
 * page-by-page, preventing memory issues.
 * 
 * NOTE: This is a template. You must integrate your actual PDF library calls
 * (e.g., from PDF.js) where indicated.
 */
async function processPdfSafely(pdfDocument, qualitySelect) {
    // 1. START the memory management session
    MemoryManager.startProcessing();

    const quality = qualitySelect.value;
    let outputScale = 5.0;
    
    switch(quality) {
        case 'standard': outputScale = 1.5; break;
        case 'high': outputScale = 2.0; break;
        case 'ultra': outputScale = 3.0; break;
        case 'HD': outputScale = 5.0; break;
        case 'pc': outputScale = 8.0; break;
        default: outputScale = 5.0; break;
    }

    // --- This array will hold the data for the final PDF ---
    const finalPdfPages = [];

    try {
        // --- ASSUMPTION: Your PDF library has a way to get the number of pages ---
        const totalPages = pdfDocument.numPages; 

        for (let i = 1; i <= totalPages; i++) {
            console.log(`Processing page ${i} of ${totalPages} at ${outputScale}x scale...`);

            // --- Define variables that will hold large objects for this iteration ---
            let page, viewport, canvas, context, renderedPageData;

            try {
                // --- YOUR PDF LIBRARY CODE START ---
                // Example using PDF.js syntax
                page = await pdfDocument.getPage(i);
                viewport = page.getViewport({ scale: outputScale });

                // Create a temporary canvas for rendering this page
                canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                context = canvas.getContext('2d');

                // Render the PDF page into the canvas context
                // await page.render({ canvasContext: context, viewport: viewport }).promise;

                // Get the image data from the canvas
                // renderedPageData = canvas.toDataURL('image/png');
                // --- YOUR PDF LIBRARY CODE END ---

                // Add the processed page data to our final array
                // finalPdfPages.push(renderedPageData);

            } catch (e) {
                console.error(`Failed to process page ${i}:`, e);
                // Optionally, you can add a blank page or skip it
            } finally {
                // 2. REGISTER CLEANUP TASKS for the large objects of this iteration
                // This is the most important step. It ensures that once the loop moves to the next page,
                // the memory from the *previous* page is explicitly targeted for cleanup.
                MemoryManager.registerCleanupTask(() => {
                    console.log(`Cleaning up resources for page ${i}`);
                    if (page && typeof page.cleanup === 'function') {
                        page.cleanup(); // Use the library's own cleanup method if available
                    }
                    // Nullify all references to release them for garbage collection
                    page = null;
                    viewport = null;
                    renderedPageData = null;
                    if (context) {
                        context.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas content
                        context = null;
                    }
                    if (canvas) {
                        // canvas.remove(); // If you added it to the DOM
                        canvas.width = 1; // Reduce size to a minimum to free memory faster
                        canvas.height = 1;
                        canvas = null;
                    }
                });

                // 3. CALL THE CLEANUP FUNCTION for the just-completed iteration
                // This runs the tasks we just registered.
                MemoryManager.clear();
            }
        }

        console.log("All pages processed. Now combining into final PDF...");
        // --- YOUR CODE TO COMBINE finalPdfPages INTO A SINGLE PDF ---
        // For example, using jsPDF:
        // const { jsPDF } = window.jspdf;
        // const finalPdf = new jsPDF();
        // finalPdfPages.forEach((pageData, index) => {
        //     if (index > 0) finalPdf.addPage();
        //     finalPdf.addImage(pageData, 'PNG', 0, 0, 210, 297); // A4 dimensions
        // });
        // finalPdf.save('final-document.pdf');
        console.log("PDF saved successfully.");


    } catch (error) {
        console.error("A critical error occurred during PDF processing:", error);
        alert("An error occurred while processing the PDF. Please check the console for details.");
    } finally {
        // 4. END the session to perform a final, thorough cleanup
        MemoryManager.endProcessing();
    }
}


/**
 * ===================================================================
 * EVENT LISTENER TO TRIGGER THE PROCESS
 * ===================================================================
 * This connects the logic to your HTML elements.
 */
document.addEventListener('DOMContentLoaded', () => {
    const qualitySelect = document.getElementById('quality-select');
    const processButton = document.getElementById('process-pdf-button'); // Assume you have a button

    if (qualitySelect && processButton) {
        processButton.addEventListener('click', async () => {
            // --- YOU NEED TO PROVIDE THE PDF DOCUMENT OBJECT ---
            // This is just an example. You would get this from a file input or URL.
            // For example, using PDF.js:
            // const fileInput = document.getElementById('pdf-file-input');
            // const file = fileInput.files[0];
            // if (!file) {
            //     alert("Please select a PDF file first.");
            //     return;
            // }
            // const arrayBuffer = await file.arrayBuffer();
            // const pdfDocument = await pdfjsLib.getDocument(arrayBuffer).promise;
            
            // For demonstration, we'll create a dummy object.
            // Replace this with your actual PDF document object.
            const dummyPdfDocument = { numPages: 5 }; 

            // Disable button to prevent multiple clicks
            processButton.disabled = true;
            processButton.textContent = 'Processing...';

            await processPdfSafely(dummyPdfDocument, qualitySelect);

            // Re-enable button
            processButton.disabled = false;
            processButton.textContent = 'Process PDF';
        });
    }
});
</script>



<script>
    // Wait for the document to be fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        
        // Find the input element by its ID
        const hoursInput = document.getElementById('hours-input');
        
        // Make sure the element exists before trying to add a listener
        if (hoursInput) {
            
            // Add an event listener that fires every time the input value changes
            hoursInput.addEventListener('input', function() {
                
                // Get the current value from the input
                let value = parseInt(this.value, 10);
                
                // Check if the value is a number and is greater than 12
                if (!isNaN(value) && value > 20) {
                    
                    // If it is, block it by setting the value back to 12
                   // this.value = 5;
                       hoursInput.value = '';
                    
                    // Optional: Show a message to the user
                    
                    alert('Maximum duration is 20 hours.');
                }
                
                // Also handle cases where the input is cleared or less than 1
                if (this.value === '' || parseInt(this.value, 10) < 1) {
                    // You can decide what to do here.
                    // For now, we'll just let it be, but you could force it to 1.
                    // this.value = 1; 
                }
            });
        }
    });
</script>
<script>

document.addEventListener('DOMContentLoaded', function() {
    // Get the quality select element
    const qualitySelect = document.getElementById('quality-select');

    // --- Configuration ---
    // Define the preferred quality options for each device type.
    // The script will try to select the first available option in this list.
    const mobilePreferredOrder = ['HD'];
    const desktopPreferredOrder = ['print'];

    // --- Device Detection ---
    // A simple and common way to detect mobile devices is by checking the user agent string.
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // --- Logic to Set Quality ---
    function setBestQuality(preferredOrder) {
        for (const quality of preferredOrder) {
            // Check if an option with the desired quality value exists in the dropdown
            if (qualitySelect.querySelector(`option[value="${quality}"]`)) {
                qualitySelect.value = quality;
                console.log(`Quality automatically set to: ${quality}`);
                return; // Stop after finding and setting the first available option
            }
        }
        console.log('No preferred quality options found in the list.');
    }

    // --- Execution ---
    if (isMobile) {
        console.log('Mobile device detected. Setting mobile quality...');
        setBestQuality(mobilePreferredOrder);
    } else {
        console.log('Desktop device detected. Setting desktop quality...');
        setBestQuality(desktopPreferredOrder);
    }
});
    const distanceInput = document.getElementById('distance-input');

    distanceInput.addEventListener('input', function() {
        const value = parseFloat(this.value);

        // Check if the value is a valid number and outside the 1-500 range
        if (!isNaN(value) && (value < 1 || value > 500)) {
            
            // Show the alert notification
            alert('Please enter a distance between 1 and 500 kms.');
            
            // Clear the input field for the user to try again
            this.value = '';
        }
    });
    
    (function() {
    'use strict';

    // --- CONFIGURATION ---
    // Set to false if you want to disable the script for testing.
    // In production, this should be true.
    const isProduction = true; 

    // --- DETECTION & BLOCKING LOGIC ---

    // 1. Block Right-Click Context Menu
    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
    });

    // 2. Block Text Selection
    document.addEventListener('selectstart', function(e) {
        e.preventDefault();
    });

    // 3. Block Keyboard Shortcuts (F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U)
    // Note: Ctrl+C and Ctrl+V are NOT included here, so they will work.
    document.addEventListener('keydown', function(e) {
        // F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
        if (e.keyCode === 123 || 
            (e.ctrlKey && e.shiftKey && (e.keyCode === 73 || e.keyCode === 74)) || 
            (e.ctrlKey && e.keyCode === 85)) {
            e.preventDefault();
            return false;
        }
    });

    // 4. Detect DevTools by checking window dimensions
    function detectDevTools() {
        if (isProduction && 
            window.outerHeight - window.innerHeight > 200 || 
            window.outerWidth - window.innerWidth > 200) {
            
            // DevTools is likely open
            document.body.innerHTML = '<h1 style="text-align:center; margin-top: 50px; color:red;">Developer Tools are detected!</h1><p style="text-align:center;">Please close them to continue using this site.</p>';
        }
    }

    // Check periodically
    setInterval(detectDevTools, 500);

})();
</script>

<script>
/**
 * Configuration for the driver name validation.
 */
const CONFIG = {
    // List of location names that should not be entered in the driver's name field.
    // Stored in uppercase for case-insensitive comparison.
    FORBIDDEN_LOCATION_NAMES: [
        "RAJAKKAD", "RAJAKUMARY", "BAISONVALLY", "ADIMALI", 
        "ANACHAL", "CHINNAKANAL", "KANCHIYAR", "CHEMMANNAR","SURIYANELLY","VATTAPARA","VATAVADA","EZUHUKUMVAYAL"
    ],
    // IDs for the DOM elements we need to interact with.
    ELEMENT_IDS: {
        driverNameInput: 'driver-input',
        driverNameValidationMessage: 'driver-validation-message',
        addressInput: 'address-input',
        addressValidationMessage: 'address-validation-message'
    }
};

/**
 * Initializes the driver name validation logic.
 */
function initializeDriverValidation() {
    'use strict';

    // Get references to the input fields and message containers.
    const driverNameInput = document.getElementById(CONFIG.ELEMENT_IDS.driverNameInput);
    const validationMessage = document.getElementById(CONFIG.ELEMENT_IDS.driverNameValidationMessage);
    const addressInput = document.getElementById(CONFIG.ELEMENT_IDS.addressInput);

    // If the elements don't exist on the page, stop the script and log an error.
    if (!driverNameInput || !validationMessage || !addressInput) {
        console.error("Validation Error: Required elements not found. Check your HTML IDs.");
        alert("SCRIPT ERROR: Could not find required input fields. Please check the console for details.");
        return;
    }

    /**
     * Creates the error overlay element and adds it to the DOM.
     * We only want to create it once.
     */
    function createErrorOverlay() {
        const overlay = document.createElement('div');
        overlay.className = 'error-overlay';
        overlay.innerHTML = '<span class="error-overlay-text">ERROR</span>';
        
        // Add it to the driver name form group
        driverNameInput.parentElement.appendChild(overlay);
        
        // Also add one to the address form group
        const addressOverlay = document.createElement('div');
        addressOverlay.className = 'error-overlay';
        addressOverlay.innerHTML = '<span class="error-overlay-text">ERROR</span>';
        addressInput.parentElement.appendChild(addressOverlay);

        return { driverOverlay: overlay, addressOverlay: addressOverlay };
    }

    // Create the overlay elements once when the script loads
    const { driverOverlay, addressOverlay } = createErrorOverlay();

    /**
     * Handles the 'input' event on both fields to check for duplicates.
     */
    function handleInputForDuplicates() {
        // Get the current values from both fields
        const driverValue = driverNameInput.value.trim().toUpperCase();
        const addressValue = addressInput.value.trim().toUpperCase();

        // --- PRIMARY CHECK: Check for duplicate values ---
        if (driverValue !== "" && driverValue === addressValue) {
            // If they are the same, show the error message and the new overlay
            validationMessage.textContent = `Values are the same. Click to clear.`;
            validationMessage.style.color = '#d50000'; // Red for error
            
            // Add the 'is-visible' class to trigger the animation
            driverOverlay.classList.add('is-visible');
            addressOverlay.classList.add('is-visible');
        } else {
            // If they are different, clear the error message and hide the overlay
            validationMessage.textContent = '';
            driverOverlay.classList.remove('is-visible');
            addressOverlay.classList.remove('is-visible');
        }
    }

    /**
     * Handles the 'input' event specifically on the driver name field for location swapping.
     */
    function handleDriverNameInput() {
        const inputValue = this.value.trim();
        const inputValueUpper = inputValue.toUpperCase();
        const addressValue = addressInput.value.trim();

        // --- SECONDARY CHECK: Check for location name ---
        const isLocation = CONFIG.FORBIDDEN_LOCATION_NAMES.includes(inputValueUpper);

        if (isLocation) {
            // Swap the values: put the driver input in the address field
            // and put the address value in the driver field
            addressInput.value = inputValue;
            this.value = addressValue;

            // Provide feedback to the user that a swap occurred
            validationMessage.textContent = `"${inputValue}" is a location. It has been moved to the Address field.`;
            validationMessage.style.color = '#f39c12'; // Orange for warning/info
        }
        
        // After any potential swap, re-run the duplicate check
        handleInputForDuplicates();
    }

    /**
     * Handles the click event on the error overlay to clear the fields.
     */
    function handleErrorOverlayClick() {
        // Clear both input fields
        driverNameInput.value = '';
        addressInput.value = '';
        
        // Clear the validation message
        validationMessage.textContent = '';
        
        // Hide the error overlays
        driverOverlay.classList.remove('is-visible');
        addressOverlay.classList.remove('is-visible');
        
        // Set focus to the driver name input so the user can start typing again
        driverNameInput.focus();
    }

    // Attach the event listeners.
    // This listener handles the location swapping and then calls the duplicate checker.
    driverNameInput.addEventListener('input', handleDriverNameInput);
    
    // This listener specifically handles the duplicate check when typing in the address field.
    addressInput.addEventListener('input', handleInputForDuplicates);
    
    // Add a click listener to BOTH overlays to handle the clear action.
    driverOverlay.addEventListener('click', handleErrorOverlayClick);
    addressOverlay.addEventListener('click', handleErrorOverlayClick);
}

// Initialize the validation when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', function() {
    initializeDriverValidation();
});
</script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
    // --- 1. GET REFERENCES TO THE HTML ELEMENTS ---
    const hoursInput = document.getElementById('hours-input');
    const distanceInput = document.getElementById('distance-input');

    // --- 2. UPDATED HOURS TO DISTANCE MAPPING (1 to 20 hours) ---
    const hoursToDistance = {
        1: 10,       // 1 hr = 10 km
        1.5: 20,     // 1.5 hrs = 20 km
        2: 40,       // 2 hrs = 40 km
        2.5: 45,     // 2.5 hrs = 45 km
        3: 80,       // 3 hrs = 80 km
        4: 120,      // 4 hrs = 120 km
        5: 151,      // 5 hrs = 151 km
        6: 250,      // 6 hrs = 250 km
        7: 300,      // 7 hrs = 300 km
        8: 301,      // 8 hrs = 301 km
        9: 500,      // 9 hrs = 500 km
        10: 501,     // 10 hrs = 501 km
        11: 700,     // 11 hrs = 700 km
        12: 701,     // 12 hrs = 701 km
        13: 800,     // 13 hrs = 800 km
        14: 801,     // 14 hrs = 801 km
        15: 900,     // 15 hrs = 900 km
        16: 901,     // 16 hrs = 901 km
        17: 1000,    // 17 hrs = 1000 km
        18: 1001,    // 18 hrs = 1001 km
        19: 1100,    // 19 hrs = 1100 km
        20: 1101     // 20 hrs = 1101 km
    };

    // --- 3. CREATE BIG ALERT ELEMENT ---
    function createBigAlert() {
        // Remove existing alert if any
        const existingAlert = document.getElementById('hours-warning-alert');
        if (existingAlert) existingAlert.remove();
        
        const alertDiv = document.createElement('div');
        alertDiv.id = 'hours-warning-alert';
        alertDiv.style.position = 'fixed';
        alertDiv.style.top = '50%';
        alertDiv.style.left = '50%';
        alertDiv.style.transform = 'translate(-50%, -50%)';
        alertDiv.style.zIndex = '9999';
        alertDiv.style.padding = '30px';
        alertDiv.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a24)';
        alertDiv.style.color = 'white';
        alertDiv.style.borderRadius = '15px';
        alertDiv.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
        alertDiv.style.textAlign = 'center';
        alertDiv.style.maxWidth = '500px';
        alertDiv.style.width = '90%';
        alertDiv.style.fontFamily = 'Arial, sans-serif';
        alertDiv.style.display = 'none';
        alertDiv.style.animation = 'pulseAlert 2s infinite';
        
        alertDiv.innerHTML = `
            <div style="font-size: 72px; margin-bottom: 20px;">âš ï¸</div>
            <h2 style="margin: 0 0 15px 0; font-size: 28px; font-weight: bold;">HIGH HOURS WARNING</h2>
            <p style="font-size: 18px; margin-bottom: 20px; line-height: 1.5;">
                You have entered <span id="alert-hours-value" style="font-weight: bold; font-size: 24px;">12</span> hours!
                This is an extended duration trip.
            </p>
            <p style="font-size: 16px; margin-bottom: 25px; opacity: 0.9;">
                Please verify all details carefully. Long duration trips require special attention.
            </p>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button id="alert-accept-btn" style="
                    background: #4CAF50;
                    color: white;
                    border: none;
                    padding: 12px 30px;
                    font-size: 18px;
                    font-weight: bold;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.3s;
                    flex: 1;
                ">ACCEPT & CONTINUE</button>
                <button id="alert-cancel-btn" style="
                    background: #f44336;
                    color: white;
                    border: none;
                    padding: 12px 30px;
                    font-size: 18px;
                    font-weight: bold;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.3s;
                    flex: 1;
                ">CANCEL & CHANGE</button>
            </div>
        `;
        
        document.body.appendChild(alertDiv);
        
        // Add CSS animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulseAlert {
                0% { transform: translate(-50%, -50%) scale(1); }
                50% { transform: translate(-50%, -50%) scale(1.02); }
                100% { transform: translate(-50%, -50%) scale(1); }
            }
            #alert-accept-btn:hover {
                background: #45a049 !important;
                transform: scale(1.05);
            }
            #alert-cancel-btn:hover {
                background: #d32f2f !important;
                transform: scale(1.05);
            }
        `;
        document.head.appendChild(style);
        
        return alertDiv;
    }

    // Create the alert element
    const bigAlert = createBigAlert();

    // --- 4. STATE MANAGEMENT ---
    let hasUserAcceptedAlert = false;

    // --- 5. FUNCTION TO SHOW/HIDE ALERT ---
    function showBigAlert(hours) {
        // Don't show if user already accepted
        if (hasUserAcceptedAlert) {
            return;
        }
        
        if (hours >= 12 && hours <= 20) {
            // Update the hours value in alert
            document.getElementById('alert-hours-value').textContent = hours;
            
            // Show alert with animation
            bigAlert.style.display = 'block';
            bigAlert.style.animation = 'pulseAlert 2s infinite';
            
            // Set up event listeners for buttons
            setupAlertButtons(hours);
        }
    }

    // --- 6. SET UP ALERT BUTTON FUNCTIONALITY ---
    function setupAlertButtons(currentHours) {
        const acceptBtn = document.getElementById('alert-accept-btn');
        const cancelBtn = document.getElementById('alert-cancel-btn');
        
        // Remove any existing listeners first
        acceptBtn.replaceWith(acceptBtn.cloneNode(true));
        cancelBtn.replaceWith(cancelBtn.cloneNode(true));
        
        // Get fresh references
        const newAcceptBtn = document.getElementById('alert-accept-btn');
        const newCancelBtn = document.getElementById('alert-cancel-btn');
        
        // ACCEPT BUTTON - User accepts and continues
        newAcceptBtn.addEventListener('click', function() {
            // Mark as accepted for this session
            hasUserAcceptedAlert = true;
            
            // Hide alert
            bigAlert.style.display = 'none';
            
            // Show confirmation message
            showAcceptNotification(currentHours);
        });
        
        // CANCEL BUTTON - User wants to change hours
        newCancelBtn.addEventListener('click', function() {
            // Hide alert
            bigAlert.style.display = 'none';
            
            // Reset hours to 11 (safe value)
            hoursInput.value = 11;
            hoursInput.dispatchEvent(new Event('input'));
            
            // Focus on hours input so user can change it
            hoursInput.focus();
            hoursInput.select();
            
            // Show cancellation message
            showCancelNotification();
        });
    }

    // --- 7. NOTIFICATION FUNCTIONS ---
    function showAcceptNotification(hours) {
        const notification = document.createElement('div');
        notification.style.position = 'fixed';
        notification.style.top = '20px';
        notification.style.right = '20px';
        notification.style.background = '#4CAF50';
        notification.style.color = 'white';
        notification.style.padding = '15px 20px';
        notification.style.borderRadius = '8px';
        notification.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
        notification.style.zIndex = '10000';
        notification.style.fontSize = '16px';
        notification.style.fontWeight = '500';
        notification.innerHTML = `âœ… Accepted ${hours} hours. You can proceed.`;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(100px)';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }
    
    function showCancelNotification() {
        const notification = document.createElement('div');
        notification.style.position = 'fixed';
        notification.style.top = '20px';
        notification.style.right = '20px';
        notification.style.background = '#f44336';
        notification.style.color = 'white';
        notification.style.padding = '15px 20px';
        notification.style.borderRadius = '8px';
        notification.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
        notification.style.zIndex = '10000';
        notification.style.fontSize = '16px';
        notification.style.fontWeight = '500';
        notification.innerHTML = 'âš ï¸ Hours reset to 11. Please enter a new value.';
        
        document.body.appendChild(notification);
        
        // Auto-remove after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(100px)';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }

    // --- 8. SET UP EVENT LISTENERS FOR TWO-WAY CALCULATION ---

    // LISTENER 1: When the user types in the HOURS input...
    hoursInput.addEventListener('input', function() {
        const hours = parseFloat(this.value);
        
        // Limit to maximum 20 hours
        if (hours > 20) {
            this.value = 20;
            hoursInput.dispatchEvent(new Event('input'));
            return;
        }
        
        if (!isNaN(hours) && hours >= 1 && hours <= 20) {
            const closestHour = findClosestKey(hoursToDistance, hours);
            const calculatedDistance = hoursToDistance[closestHour];
            distanceInput.value = calculatedDistance;
            
            // Show big alert for hours 12-20 (if not already accepted)
            if (!hasUserAcceptedAlert) {
                showBigAlert(hours);
            }
            
        } else if (hours === 0 || hours === '') {
            distanceInput.value = '';
            bigAlert.style.display = 'none';
        } else {
            distanceInput.value = '';
            bigAlert.style.display = 'none';
        }
    });

    // LISTENER 2: When the user types in the DISTANCE input...
    distanceInput.addEventListener('input', function() {
        const distance = parseFloat(this.value);
        
        // Find maximum distance value
        const maxDistance = Math.max(...Object.values(hoursToDistance));
        
        if (distance > maxDistance) {
            this.value = maxDistance;
            distanceInput.dispatchEvent(new Event('input'));
            return;
        }
        
        if (!isNaN(distance) && distance > 0) {
            const closestHour = findClosestValue(hoursToDistance, distance);
            hoursInput.value = closestHour;
            
            // Show big alert if hours are 12-20 (if not already accepted)
            const hours = parseFloat(closestHour);
            if (!hasUserAcceptedAlert) {
                showBigAlert(hours);
            }
            
        } else if (distance === 0 || distance === '') {
            hoursInput.value = '';
            bigAlert.style.display = 'none';
        } else {
            hoursInput.value = '';
            bigAlert.style.display = 'none';
        }
    });

    // --- 9. ADD INPUT VALIDATION FOR HOURS (1-20 only) ---
    hoursInput.addEventListener('keydown', function(e) {
        // Allow: backspace, delete, tab, escape, enter
        if ([46, 8, 9, 27, 13].indexOf(e.keyCode) !== -1 ||
            // Allow: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
            (e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 67 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 86 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 88 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: decimal point (.)
            e.keyCode === 190 ||
            // Allow: numbers on keypad
            (e.keyCode >= 96 && e.keyCode <= 105)) {
            return;
        }
        
        // Ensure that it is a number or decimal point
        if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
            e.preventDefault();
        }
    });

    // Add blur validation for hours input
    hoursInput.addEventListener('blur', function() {
        const hours = parseFloat(this.value);
        
        if (!isNaN(hours)) {
            if (hours < 1) {
                this.value = 1;
                hoursInput.dispatchEvent(new Event('input'));
            } else if (hours > 20) {
                this.value = 20;
                hoursInput.dispatchEvent(new Event('input'));
            }
            
            // Show alert on blur if applicable (and not already accepted)
            if (hours >= 12 && hours <= 20 && !hasUserAcceptedAlert) {
                showBigAlert(hours);
            }
        }
    });

    // --- 10. HELPER FUNCTIONS ---

    function findClosestKey(obj, target) {
        const keys = Object.keys(obj).map(Number).sort((a, b) => a - b);
        
        // Check if exact match exists
        if (obj[target] !== undefined) return target;
        
        let closestKey = keys[0];
        let smallestDiff = Math.abs(target - closestKey);
        
        for (let i = 1; i < keys.length; i++) {
            const diff = Math.abs(target - keys[i]);
            if (diff < smallestDiff) {
                smallestDiff = diff;
                closestKey = keys[i];
            }
        }
        return closestKey;
    }

    function findClosestValue(obj, target) {
        let closestKey = null;
        let smallestDiff = Infinity;
        
        for (const key in obj) {
            const diff = Math.abs(obj[key] - target);
            if (diff < smallestDiff) {
                smallestDiff = diff;
                closestKey = key;
            }
        }
        return closestKey;
    }

    // --- 11. ADD KEYBOARD SHORTCUT TO CLOSE ALERT ---
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && bigAlert.style.display === 'block') {
            bigAlert.style.display = 'none';
        }
    });

    // --- 12. RESET ACCEPTANCE WHEN USER CHANGES HOURS TO BELOW 12 ---
    hoursInput.addEventListener('input', function() {
        const hours = parseFloat(this.value);
        
        // Reset acceptance if user changes hours to below 12
        if (hours < 12 && hasUserAcceptedAlert) {
            hasUserAcceptedAlert = false;
        }
    });

    // --- 13. RESET ACCEPTANCE ON PAGE REFRESH (Optional) ---
    // If you want acceptance to reset on page refresh, uncomment:
    // window.addEventListener('beforeunload', function() {
    //     hasUserAcceptedAlert = false;
    // });
});
</script>
  <script>
    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    }

    // --- VARIABLES ---
    let globalVehiclesData = {};

    // --- 2. NOTIFICATION FUNCTION (GOOGLE MATERIAL DESIGN STYLE) ---
    function showUserNotification(message, type) {
        // Remove any existing notification first
        const existing = document.querySelector('.custom-notification');
        if (existing) {
            existing.classList.add('notification-exit');
            setTimeout(() => existing.remove(), 300);
        }

        const notification = document.createElement('div');
        notification.className = 'custom-notification';
        
        // Create icon based on type
        let icon = '';
        if (type === 'success') {
            icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>';
        } else if (type === 'error') {
            icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>';
        } else {
            icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>';
        }
        
        // Create notification content
        notification.innerHTML = `
            <div class="notification-icon">${icon}</div>
            <div class="notification-message">${message}</div>
            <button class="notification-close">&times;</button>
        `;
        
        // --- GOOGLE MATERIAL DESIGN INLINE STYLES ---
        notification.style.position = 'fixed';
        notification.style.top = '20px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%) translateY(-100px)';
        notification.style.padding = '16px 24px';
        notification.style.borderRadius = '8px';
        notification.style.color = '#fff';
        notification.style.zIndex = '9999';
        notification.style.boxShadow = '0 3px 5px -1px rgba(0,0,0,0.2), 0 6px 10px 0 rgba(0,0,0,0.14), 0 1px 18px 0 rgba(0,0,0,0.12)';
        notification.style.fontSize = '14px';
        notification.style.fontWeight = '500';
        notification.style.opacity = '0';
        notification.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        notification.style.display = 'flex';
        notification.style.alignItems = 'center';
        notification.style.minWidth = '300px';
        notification.style.maxWidth = '500px';

        // Set Color based on TYPE
        if (type === 'success') notification.style.backgroundColor = '#43a047';
        else if (type === 'error') notification.style.backgroundColor = '#e53935';
        else notification.style.backgroundColor = '#1e88e5';

        // Style the icon container
        const iconContainer = notification.querySelector('.notification-icon');
        iconContainer.style.marginRight = '12px';
        iconContainer.style.display = 'flex';
        iconContainer.style.alignItems = 'center';
        iconContainer.style.justifyContent = 'center';
        
        // Style the message
        const messageContainer = notification.querySelector('.notification-message');
        messageContainer.style.flex = '1';
        
        // Style the close button
        const closeButton = notification.querySelector('.notification-close');
        closeButton.style.background = 'none';
        closeButton.style.border = 'none';
        closeButton.style.color = '#fff';
        closeButton.style.fontSize = '20px';
        closeButton.style.cursor = 'pointer';
        closeButton.style.marginLeft = '16px';
        closeButton.style.padding = '0';
        closeButton.style.opacity = '0.7';
        closeButton.style.transition = 'opacity 0.2s';
        
        // Add event listener to close button
        closeButton.addEventListener('click', () => {
            notification.classList.add('notification-exit');
            setTimeout(() => notification.remove(), 300);
        });
        
        // Add hover effect to close button
        closeButton.addEventListener('mouseenter', () => {
            closeButton.style.opacity = '1';
        });
        
        closeButton.addEventListener('mouseleave', () => {
            closeButton.style.opacity = '0.7';
        });

        document.body.appendChild(notification);

        // Animation - slide in from top
        setTimeout(() => { 
            notification.style.transform = 'translateX(-50%) translateY(0)';
            notification.style.opacity = '1'; 
        }, 10);

        // Auto dismiss after 5 seconds
        setTimeout(() => {
            if (document.body.contains(notification)) {
                notification.classList.add('notification-exit');
                setTimeout(() => notification.remove(), 300);
            }
        }, 5000);
    }

    // --- CHECK VEHICLE FUNCTION ---
    function checkVehicle() {
        const vehicleInput = document.getElementById('vehicle-input');
        const messageDisplay = document.getElementById('vehicle-validation-message');
        
        if (!vehicleInput) return;
        const enteredNumber = vehicleInput.value.trim().toUpperCase();
        
      
        if (enteredNumber.length === 0) return;

        // Check Data
        if (globalVehiclesData.hasOwnProperty(enteredNumber)) {
            const vehicleInfo = globalVehiclesData[enteredNumber];
            const name = vehicleInfo.vehicleName || vehicleInfo.name || "Unknown";
            
            // Show Notification with Google Material Design style
            showUserNotification(`Vehicle Name Found: ${name}`, 'success');
        } else {
           
        }
    }

    // --- FETCH DATA ---
    function fetchGlobalVehicles() {
        const ref = db.ref('globalVehicles');
        
        ref.once('value', (snapshot) => {
            if (snapshot.exists()) {
                globalVehiclesData = snapshot.val();
                console.log("Data Loaded");
                showUserNotification('Welcome to PDF Editor 2.0', 'info');
            } else {
                showUserNotification('Database is empty', 'error');
            }
        }).catch((error) => {
            console.error(error);
            showUserNotification('Connection to database failed', 'error');
        });
    }

    // --- LISTENERS ---
    document.addEventListener('DOMContentLoaded', function() {
        const vehicleInput = document.getElementById('vehicle-input');
        if (vehicleInput) {
            vehicleInput.addEventListener('input', checkVehicle);
        }
        fetchGlobalVehicles();
    });
</script>

<style>
/* Additional CSS for notification exit animation */
.notification-exit {
    transform: translateX(-50%) translateY(-100px) !important;
    opacity: 0 !important;
}
</style>
<script>
document.getElementById('FScreen-btn').addEventListener('click', function() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch((e) => {
      console.error(`Error attempting to enable fullscreen: ${e.message}`);
    });
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
});
</script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

<script>
// Field locking system - No auto-fill, only locking
let systemLocks = { security: false, transit: false, bulkTransit: false };
let isConnected = false;

// Initialize Firebase connection
async function initLockSystem() {
    console.log('ðŸ”’ Initializing field locking system...');
    
    if (typeof firebase === 'undefined') {
        console.warn('Firebase not loaded');
        applyFieldLocks();
        return;
    }
    
    try {
        const firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            authDomain: "vipteammod-movies.firebaseapp.com",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com",
            projectId: "vipteammod-movies",
            storageBucket: "vipteammod-movies.appspot.com",
            messagingSenderId: "1024721077525",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c"
        };
        
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        
        const db = firebase.database();
        
        // Check connection
        const connectedRef = db.ref(".info/connected");
        connectedRef.on("value", (snap) => {
            isConnected = snap.val() === true;
            console.log(isConnected ? 'âœ… Connected' : 'âŒ Disconnected');
        });
        
        // Listen for lock changes from admin
        db.ref('systemLocks').on('value', (snapshot) => {
            if (snapshot.exists()) {
                const newLocks = snapshot.val();
                console.log('ðŸ”’ Lock status received:', newLocks);
                systemLocks = newLocks;
                applyFieldLocks();
            }
        });
        
        // Listen for live lock updates
        db.ref('liveUpdates')
            .orderByChild('timestamp')
            .limitToLast(1)
            .on('child_added', (snapshot) => {
                const update = snapshot.val();
                if (update.type === 'locks_updated' && update.data) {
                    console.log('ðŸ“¡ Live lock update:', update.data);
                    systemLocks = { ...systemLocks, ...update.data };
                    applyFieldLocks();
                }
            });
        
        // Load initial lock status
        setTimeout(() => loadInitialLocks(db), 1000);
        
    } catch (error) {
        console.error('Firebase error:', error);
        applyFieldLocks();
    }
}

async function loadInitialLocks(db) {
    try {
        const locksSnapshot = await db.ref('systemLocks').once('value');
        if (locksSnapshot.exists()) {
            systemLocks = locksSnapshot.val();
            console.log('ðŸ”’ Initial locks loaded:', systemLocks);
        }
        applyFieldLocks();
    } catch (error) {
        console.error('Error loading locks:', error);
    }
}

function getFormInputs() {
    return {
        bulk: document.getElementById('Bulk-input'),
        security: document.getElementById('security-input'),
        transit: document.getElementById('transit-input')
    };
}

function applyFieldLocks() {
    const inputs = getFormInputs();
    
    console.log('Applying field locks:', systemLocks);
    
    // Apply locks to Bulk Transit field
    if (inputs.bulk) {
        if (systemLocks.bulkTransit) {
            inputs.bulk.readOnly = true;
            inputs.bulk.style.backgroundColor = '#f5f5f5';
            inputs.bulk.style.color = '#666';
            inputs.bulk.style.cursor = 'not-allowed';
            inputs.bulk.title = 'This field is locked by admin';
        } else {
            inputs.bulk.readOnly = false;
            inputs.bulk.style.backgroundColor = '';
            inputs.bulk.style.color = '';
            inputs.bulk.style.cursor = '';
            inputs.bulk.title = '';
        }
    }
    
    // Apply locks to Security Paper field
    if (inputs.security) {
        if (systemLocks.security) {
            inputs.security.readOnly = true;
            inputs.security.style.backgroundColor = '#f5f5f5';
            inputs.security.style.color = '#666';
            inputs.security.style.cursor = 'not-allowed';
            inputs.security.title = 'This field is locked by admin';
        } else {
            inputs.security.readOnly = false;
            inputs.security.style.backgroundColor = '';
            inputs.security.style.color = '';
            inputs.security.style.cursor = '';
            inputs.security.title = '';
        }
    }
    
    // Apply locks to Transit Pass field
    if (inputs.transit) {
        if (systemLocks.transit) {
            inputs.transit.readOnly = true;
            inputs.transit.style.backgroundColor = '#f5f5f5';
            inputs.transit.style.color = '#666';
            inputs.transit.style.cursor = 'not-allowed';
            inputs.transit.title = 'This field is locked by admin';
        } else {
            inputs.transit.readOnly = false;
            inputs.transit.style.backgroundColor = '';
            inputs.transit.style.color = '';
            inputs.transit.style.cursor = '';
            inputs.transit.title = '';
        }
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('ðŸš€ Starting field locking system...');
    setTimeout(initLockSystem, 1000);
});

// Apply locks when page loads
window.addEventListener('load', function() {
    setTimeout(applyFieldLocks, 1500);
});

// Prevent user from editing locked fields
document.addEventListener('input', function(e) {
    const inputs = getFormInputs();
    
    // Revert Bulk Transit if locked
    if (e.target === inputs.bulk && systemLocks.bulkTransit) {
        const originalValue = e.target.value;
        setTimeout(() => {
            if (e.target.value !== originalValue) {
                e.target.value = originalValue;
                e.target.dispatchEvent(new Event('change', { bubbles: true }));
            }
        }, 0);
    }
    
    // Revert Security Paper if locked
    if (e.target === inputs.security && systemLocks.security) {
        const originalValue = e.target.value;
        setTimeout(() => {
            if (e.target.value !== originalValue) {
                e.target.value = originalValue;
                e.target.dispatchEvent(new Event('change', { bubbles: true }));
            }
        }, 0);
    }
    
    // Revert Transit Pass if locked
    if (e.target === inputs.transit && systemLocks.transit) {
        const originalValue = e.target.value;
        setTimeout(() => {
            if (e.target.value !== originalValue) {
                e.target.value = originalValue;
                e.target.dispatchEvent(new Event('change', { bubbles: true }));
            }
        }, 0);
    }
});

// For debugging
window.fieldLockDebug = {
    getLocks: () => systemLocks,
    refresh: applyFieldLocks
};

</script>






<script>
// ============================================
// AUTOMATIC DESTINATION FIX SYSTEM (BACKGROUND)
// ============================================

// ============================================
// COMPLETE LOCATION DATABASE FOR KERALA
// ============================================
const KERALA_LOCATIONS = [
    // IDUKKI DISTRICT (Tea Plantation Areas)
    'RAJAKKAD', 'RAJAKKUMARY', 'BAISONVALLY', 'ADIMALI', 
    'ANACHAL', 'CHINNAKANAL', 'KANCHIYAR', 'CHEMMANNAR',
    'SURIYANELLY', 'VATTAPARA', 'VATAVADA', 'EZUHUKUMVAYAL',
    'KODIKULAM', 'MUNNAR', 'DEVIKULAM', 'PALLIVASAL',
    'CHITHIRAPURAM', 'ANAYIRANKAL', 'SENAPATHY', 'VANCHIVAYAL',
    'KALIYAR', 'KANJIKUZHI', 'KARADIKUZHI', 'KARIMBAN',
    'KARIVAPARA', 'KARUNARAPPILLY', 'KODANAD', 'KOOVAPALLY',
    'KOTTAKAMBUR', 'KULAMAVU', 'KUMALY', 'KUMILI',
    'KUTTIKKANAM', 'MALAYATTUR', 'MANIMALA', 'MARAYUR',
    'MATTUPATTY', 'MUDAPETTA', 'MULAMATTAM', 'MUNNAR',
    'NEDUMKANDAM', 'PALLIVASAL', 'PAMPADUM PARA', 'PANAMKUTTY',
    'PARATHODE', 'PATTISERY', 'PEERMADE', 'PERIYAR',
    'PERUMBAVOOR', 'PERUVANTHANAM', 'PONMUDY', 'PULIYANMALA',
    'RAJAKKADU', 'SANTHANPARA', 'SENAPATHY', 'THODUPUZHA',
    'UDUMBANNOOR', 'UDUMBANCHOLA', 'VAGAMON', 'VALARA',
    'VANCHIVAYAL', 'VANDANMEDU', 'VANNAPURAM', 'VATTIYOORKAVU', 'KATTAPANA', 'EZHUKUMUVAYAL',
    
    // WAYANAD DISTRICT
    'KALPETTA', 'SULTHAN BATHERY', 'MANANTHAVADY', 'VYTHIRI',
    'AMBAVAYAL', 'BEGUR', 'CHUNDALE', 'KAPPIKAD',
    'KARTHIKULAM', 'KATTIKULAM', 'KENICHIRA', 'KOLAGAPARA',
    'KONDOTTY', 'KURICHARMALA', 'KURUVA ISLAND', 'KUTHIRAKKAL',
    'MANCHERI', 'MEPPADI', 'MUTHANGA', 'NADAPURAM',
    'NADUVIL', 'NARIKKUNI', 'NEDUMANGAD', 'NENMENI',
    'NOOLPUZHA', 'OOTY', 'PADINJARATHARA', 'PALAKKAD',
    'PALAKKAYAM', 'PALAPPALLY', 'PALARAM', 'PAMBRO',
    'PANAMARAM', 'PAPPINISSERI', 'PARAPPANANGADI', 'PATTIKKAD',
    'PAZHASSI RAJA', 'PERIKALLUR', 'PERINGATHUR', 'PERINTHELMANNA',
    'PERUVA', 'POOKKODE', 'POOKKOT', 'PULPALLY',
    'PUTHOOR', 'RIPPON', 'SUGANDHAGIRI', 'THALAPUZHA',
    'THARIODE', 'THIRUNAVAYA', 'THOLAMBRA', 'THOTTIPALAM',
    'THRIKKADAVOOR', 'THRIKKARIPPUR', 'TIRUR', 'TIRURANGADI',
    'VADAKARA', 'VANIAMKULAM', 'VARAM', 'VELLARIKKUNDU',
    'VENMANAD', 'VENGARA', 'VENGARA', 'VENNIYOOR',
    
    // PALAKKAD DISTRICT
    'PALAKKAD', 'OTTAPPALAM', 'MANNARKKAD', 'ALATHUR',
    'CHITTUR', 'KODUVAYUR', 'PATTAMBI', 'SREEKRISHNAPURAM',
    'THRITHALA', 'KOOTANAD', 'KUNNATHUKULAM', 'MALAMPUZHA',
    'NENMARA', 'PALLIPURAM', 'PARLI', 'PERINKULAM',
    'POZHITHODE', 'PUDUKKAD', 'PUDUNKURICHI', 'PULLAZHI',
    'PULLU', 'PUNNAYOORKULAM', 'PURATHUR', 'PUTHANATHANI',
    'PUTHUPPALLY', 'PUTHUPPARIYARAM', 'PUTHUVAIPU', 'PUTTADI',
    'RAMANATTUKARA', 'SHORANUR', 'THACHANATTUKARA', 'THALAKKAD',
    'THALASSERY', 'THAMARASSERY', 'THANNIYAM', 'THAZHEPALAM',
    'THEKKUMKARA', 'THENGANA', 'THENHIPALAM', 'THIRUVALLA',
    'THIRUVAMBADY', 'THIRUVANANTHAPURAM', 'THODIYOOR', 'THOLUR',
    'THRIPRAYAR', 'THRISSUR', 'THUNCHANPARAMBU', 'THURUTHY',
    'TIRUR', 'TIRURANGADI', 'TRIPRANGODE', 'UDMA',
    'VADAKKANCHERY', 'VADAKKUMKARA', 'VADAMALAPURAM', 'VADAVUCODE',
    'VADAVUROAD', 'VADAKARA', 'VADAKKUMBHAGOM', 'VADAKKUMKARA',
    
    // THRISSUR DISTRICT
    'THRISSUR', 'IRINJALAKUDA', 'KODUNGALLUR', 'GURUVAYUR',
    'CHALAKUDY', 'KUNNAMKULAM', 'WADAKKANCHERRY', 'MALA',
    'CHOONDAL', 'CHELAKKARA', 'MULLASSERY', 'PURANATTUKARA',
    'VILVATTOM', 'ANTHIKAD', 'AVINISSERY', 'CHAVAKKAD',
    'CHERP', 'CHETTUVA', 'EDAKKUNNI', 'ENAMAKKAL',
    'ERAVATTUR', 'KAIKULANGARA', 'KANIMANGALAM', 'KARANCHIRA',
    'KARUVANNUR', 'KATTOOR', 'KECHAVAM', 'KODAKARA',
    'KODASSERY', 'KOLAZHY', 'KOLLENGODE', 'KOOTTANAD',
    'KORATTY', 'KOTTAPPADI', 'KULAPULLY', 'KUMARANELLUR',
    'KUTTANELLUR', 'MADAYIKONAM', 'MANALITHARA', 'MANATHALA',
    'MANGAD', 'MANNUTHY', 'MATTOM', 'MUNDATHIKODE',
    'MURIKKASSERY', 'MURIYAD', 'MUTTATHUR', 'NADAKKAVU',
    
    // ERNAKULAM DISTRICT
    'KOCHI', 'ERNAKULAM', 'ALUVA', 'KALAMASSERY',
    'KAKKANAD', 'EDAPPALLY', 'THRIPPUNITHURA', 'VYTTILA',
    'KOTHAMANGALAM', 'MUVATTUPUZHA', 'PERUMBAVOOR', 'PARAVUR',
    'ANGAMALY', 'ELOOR', 'NORTH PARAVUR', 'ALUVA',
    'CHELLANAM', 'CHENGAMANAD', 'CHOONAD', 'EDATHALA',
    'KADUNGALLOOR', 'KANAYANNUR', 'KANJIRAMATTOM', 'KARUKUTTY',
    'KEEZMAD', 'KOLENCHERRY', 'KOOTHATTUKULAM', 'KOTHAD',
    'KUNNUKARA', 'KURUPPAMPADY', 'MALA', 'MANAKKAPADY',
    'MANJALI', 'MARADU', 'MULAVUKAD', 'NAYARAMBALAM',
    'NEDUMBASSERY', 'PAIRA', 'PALLIPPURAM', 'PALLURUTHY',
    'PANAICKEN', 'PANANGAD', 'PARAKKadavu', 'PATTIMATTOM',
    
    // KOLLAM DISTRICT
    'KOLLAM', 'PARAVUR', 'KARUNAGAPPALLY', 'PUNALUR',
    'PATHANAPURAM', 'KOTTARAKKARA', 'KUNDARA', 'ANCHAL',
    'CHADAYAMANGALAM', 'CHATHANNOOR', 'KALLADA', 'KULAKKADA',
    'MANNANAM', 'MUKHATHALA', 'NEDUMPANA', 'NEENDAKARA',
    'OACHIRA', 'PERINAD', 'SASTHAMCOTTAH', 'THAZHAVA',
    'THODIYOOR', 'VELIYAM', 'YEROOR', 'ADICHANALLOOR',
    
    // THIRUVANANTHAPURAM DISTRICT
    'THIRUVANANTHAPURAM', 'NEYYATTINKARA', 'NEDUMANGAD', 'VENJARAMOODU',
    'ATTINGAL', 'VARKALA', 'KILIMANOOR', 'KATTAKADA',
    'PARASSALA', 'KALLIYUR', 'KANIYAPURAM', 'KARAKULAM',
    'KARAVARAM', 'KAZHAKUTTAM', 'KEEZHTHONAKKAL', 'KOCHUVELI',
    'KODUNGAIYUR', 'KOLATHUR', 'KONNI', 'KOTTUKAL',
    'KOVALAM', 'KULATHOOR', 'KUNNATHUKAL', 'MADAVOOR',
    'MANAMBUR', 'MANCHALLUR', 'MANNANTHALA', 'MARANALLUR',
    'MARUTHAMKUZHI', 'MEENAMGALAM', 'MELARANNOR', 'MULLOOR',
    'MUTTATHARA', 'NAGAROOR', 'NAVAIOORKULAM', 'NELLIMOODU',
    'NETTAYAM', 'NIYYATHINKARA', 'PACHALLOOR', 'PALLICHAL',
    'PALLIPPURAM', 'PANAVOOR', 'PARUTHIPALLY', 'PATHAMKALLU',
    'PAZHAMTHOTTAM', 'PERINGAMALA', 'PERUMKUZHI', 'PERUMPAZHUTHOOR',
    'POOJAPPURA', 'POOVAR', 'POTTAKKAD', 'PULLUVILA',
    
    // KANNUR DISTRICT
    'KANNUR', 'THALASSERY', 'PAYYANNUR', 'TALIPARAMBA',
    'IRITTY', 'MATTANNUR', 'PANOOR', 'KUTHUPARAMBA',
    'CHERUKUNNU', 'CHERUTHUTHY', 'EDAKKAD', 'ELAYAVOOR',
    'KADACHIRA', 'KADIRUR', 'KALIYAT', 'KALLIASSERI',
    'KANHILERI', 'KANICHAR', 'KANNAPURAM', 'KARIVELUR',
    'KEEZHALLUR', 'KOLASSERY', 'KOLAYAD', 'KOTTAYAM',
    'KUDIYANMALA', 'KUNHIMANGALAM', 'KURUMATHUR', 'MADAYI',
    'MAYYIL', 'MOKERI', 'MUZHAPPILANGAD', 'NARATH',
    'NEKRAJ', 'PADUVILAI', 'PAPPINISSERI', 'PARAL',
    'PATHIRIYOODU', 'PAZHASSI', 'PERALASSERY', 'PERINGATHUR',
    'PERINGOME', 'PERUMBA', 'PILATHARA', 'PUTHIYANGADI',
    'PUTHUR', 'RAMANTHALI', 'SREEKANDAPURAM', 'THALIPARAMBA',
    'THILLENKERI', 'THRIKKARIPPUR', 'THRIKKULAM', 'UDMA',
    'VALAPATTANAM', 'VARARUCHI', 'VELLARIKKUNDU', 'VIZHINJAM',
    
    // KASARAGOD DISTRICT
    'KASARAGOD', 'KANHANGAD', 'NILESHWAR', 'BEKAL',
    'CHANDERA', 'CHERUVATHUR', 'HOSDURG', 'KADAMBUR',
    'KALIKKADAVU', 'KALLAR', 'KARINDALAM', 'KOTTAMALA',
    'KUMBALA', 'KUNJATHUR', 'KUNNATHUR', 'MADIKKAI',
    'MANJESHWAR', 'MOGRAL', 'MULLERIA', 'NEERESULAM',
    'PADANNA', 'PAIYOOR', 'PARAPPA', 'PERLA',
    'PERUMBA', 'POINACHI', 'POVVAL', 'PULLUR',
    'RANIPURAM', 'SOUTH THRIKARIPPUR', 'TRIKARPUR', 'UDMA',
    'UPPALA', 'VORKADI', 'ADI PARAVUR', 'ANANDASHRAM',
    
    // MALAPPURAM DISTRICT
    'MALAPPURAM', 'MANJERI', 'PERINTHALMANNA', 'TIRUR',
    'PONNANI', 'TIRURANGADI', 'NILAMBUR', 'TANUR',
    'PARAPPANANGADI', 'VALANCHERRY', 'KONDOTTY', 'RAMANATTUKARA',
    'KOTTAKKAL', 'MANGALAM', 'PERUMPADAPPA', 'VENGARA',
    'VANIYAMBALAM', 'WANDOOR', 'KALIKAVU', 'KARUNAGAPPALLY',
    'KARUVARAKUNDU', 'MELATTUR', 'PANDIKKAD', 'PULAMANTHOLE',
    'THIRUNAVAYA', 'THIRUVALI', 'THIRUVANTHAPURAM', 'THRIKKANAPURAM',
    'TUVVUR', 'VAZHAKKAD', 'VEDAKARA', 'VENKITANGU',
    
    // KOZHIKODE DISTRICT
    'KOZHIKODE', 'FEROKE', 'Ramanattukara', 'Koyilandy',
    'Vadakara', 'Thamarassery', 'Sultan Bathery', 'Kalpetta',
    'Kuttiyadi', 'Koduvally', 'Mukkam', 'Perambra',
    'Balussery', 'Elathur', 'Chelannur', 'Beypore',
    'Chaliyam', 'Kadalundi', 'Parappanangadi', 'Tanur',
    'Tirur', 'Tirurangadi', 'Valanchery', 'Kottakkal',
    'Kondotty', 'Malappuram', 'Manjeri', 'Perinthalmanna',
    'Nilambur', 'Sulthan Bathery', 'Kalpetta', 'Meppadi',
    'Vythiri', 'Ambalavayal', 'Pulpally', 'Mananthavady'
];

// ============================================
// COMPLETE LOCATION DATABASE FOR TAMIL NADU
// ============================================
const TAMIL_NADU_LOCATIONS = [
    // THENI DISTRICT
    'CUMBUM', 'THENI', 'BODINAYAKANUR', 'PERIYAKULAM',
    'CHINNAMANUR', 'KAMAYAKOUNDANPATTY', 'THEVARAM', 'VADAPATTI',
    'KOMBAI', 'GUDALUR', 'UPPILIPATTI', 'SURULIPATTI',
    'VEERAPANDI', 'SELVAM', 'ANDIPATTI', 'GOODALUR',
    'CHINNAPPAMPATTI', 'KOTTAIYUR', 'KUMULI', 'BATLAGUNDU',
    'VIRALIPATTI', 'KOTTAIYUR', 'SENNIMALAI', 'KOMBAI',
    'DEVADANAPATTI', 'KADAMALAIGUNDU', 'KADAYAM', 'KADANCHERI',
    'KAMARAJARNAGAR', 'KANAVAYAL', 'KANGAYAM', 'KANIYUR',
    
    // MADURAI DISTRICT
    'MADURAI', 'MELUR', 'USILAMPATTI', 'THIRUMANGALAM',
    'PARAMAKUDI', 'TIRUPUVANAM', 'KALLIKUDI', 'SEDAPATTI',
    'T.KALLUPATTI', 'CHETTIPATTI', 'KALLUPATTI', 'KOTTAIYUR',
    'ALANGANALLUR', 'ARUPPUKOTTAI', 'AVANIYAPURAM', 'CHINNAMANUR',
    'ERODE', 'ILAYANGUDI', 'KARAIKUDI', 'KARUR',
    'KEELAKEERAI', 'KODAIKANAL', 'KULITHALAI', 'MANAMADURAI',
    'MANAPPARAI', 'NAMAKKAL', 'NATHAM', 'PALANI',
    'PARAMATHI', 'PATTUKKOTTAI', 'PERAIYUR', 'PERAMBALUR',
    'POLLACHI', 'PUDUKKOTTAI', 'RAJAPALAYAM', 'RAMANATHAPURAM',
    'RASIPURAM', 'SALEM', 'SANKARANKOIL', 'SATTUR',
    'SIVAGANGA', 'SIVAKASI', 'SRIVILLIPUTHUR', 'TENKASI',
    'THANJAVUR', 'THENI', 'THIRUCHENGODE', 'THIRUPPUR',
    'THIRUTHURAIPOONDI', 'THIRUVARUR', 'TINDIVANAM', 'TIRUCHIRAPPALLI',
    'TIRUNELVELI', 'TIRUPATHUR', 'TIRUPPUR', 'TIRUVANNAMALAI',
    'TUTICORIN', 'UDUMALPET', 'ULUNDURPET', 'VALPARAI',
    'VEDASANDUR', 'VELLORE', 'VIRUDHUNAGAR', 'WALAJAPET',
    
    // COIMBATORE DISTRICT
    'COIMBATORE', 'POLLACHI', 'METTUPALAYAM', 'SOMAYAMPALAYAM',
    'KINATHUKADAVU', 'ANAMALAI', 'VALPARAI', 'UDUMALPET',
    'PALANI', 'DINDIGUL', 'KARUR', 'ERODE',
    'SALEM', 'TIRUPPUR', 'NILGIRIS', 'OOTY',
    'GOONDI', 'KOTAGIRI', 'COONOOR', 'METTUPALAYAM',
    'SULUR', 'KAVUNDAMPALAYAM', 'VADAVALLI', 'RACE COURSE',
    'SAIBABA COLONY', 'RS PURAM', 'GANDHIPURAM', 'UKKADAM',
    'KURICHI', 'KALAPATTI', 'SARAVANAMPATTI', 'NEELAMBUR',
    'CHINNIYAMPALAYAM', 'KARUMATHAMPATTI', 'THUDIYALUR', 'SINGANALLUR',
    'KUNIYAMUTHUR', 'PEELAMEDU', 'SITRA', 'NANJUNDAPURAM',
    'PAPPANAICKENPALAYAM', 'KOVAIPUDUR', 'SAI BABA COLONY', 'VILANKURICHI',
    
    // CHENNAI & SUBURBS
    'CHENNAI', 'ANNA NAGAR', 'T.NAGAR', 'MYLAPORE',
    'ADYAR', 'VELACHERY', 'PALLAVARAM', 'TAMBARAM',
    'CHROMPET', 'PERUNGULATHUR', 'KELAMBAKKAM', 'SHOLINGANALLUR',
    'MEDAVAKKAM', 'MOUNT ROAD', 'EGMORE', 'NUNGAMBAKKAM',
    'KILPAUK', 'PERAMBUR', 'VILLIVAKKAM', 'AMBATTUR',
    'AVADI', 'POONAMALLEE', 'THIRUVALLUR', 'SRI PERUMBUDUR',
    'GUMMIDIPOONDI', 'TIRUTTANI', 'ARAKONAM', 'RANIPET',
    'WALAJAH', 'ARCOT', 'VELLORE', 'KRISHNAGIRI',
    'DHARMAPURI', 'TIRUVANNAMALAI', 'KANCHIPURAM', 'MAHABALIPURAM',
    
    // SALEM DISTRICT
    'SALEM', 'ATTUR', 'EDAPPADI', 'MECHRIPALAYAM',
    'OMALUR', 'SANKAGIRI', 'YERCAUD', 'VELLAKOIL',
    'PETHANAICKENPALAYAM', 'IDAPPADI', 'GANGAVALLI', 'THALAIVASAL',
    'KADAYAMPATTI', 'NANGAVALLI', 'PANAMARATHUPATTI', 'VEERAPANDI',
    'AYOTHAPATTINAM', 'KONGANAPURAM', 'KOLATHUR', 'MAGUDANCHAVADI',
    'PAPPIREDDIPATTI', 'THARAMANGALAM', 'VEERAKKALPUDUR', 'ELAMPILLAI',
    
    // TIRUCHIRAPPALLI DISTRICT
    'TIRUCHIRAPPALLI', 'SRIRANGAM', 'WORAIYUR', 'THILLAINAGAR',
    'CANTONMENT', 'PUTHUR', 'K.K.NAGAR', 'ARIANAGAR',
    'GOLDEN ROCK', 'PONMALAI', 'ABISHEKAPATTI', 'CRAW FORD',
    'MANAPPARAI', 'THURAIYUR', 'MUSIRI', 'THATHENGARPET',
    'MANACHANALLUR', 'LALGUDI', 'THIRUVERUMBUR', 'THUVARANKURICHI',
    'MARUNGAPURI', 'VELLANUR', 'PULLAMBADI', 'UPPILIYAPURAM',
    'PERAMBALUR', 'KUNNAM', 'VELLORE', 'ARIYALUR',
    
    // TIRUNELVELI DISTRICT
    'TIRUNELVELI', 'PALAYAMKOTTAI', 'THATCHANALLUR', 'MELAPALAYAM',
    'TRUNELVELI JUNCTION', 'KORAMPALLAM', 'TISAYANVILAI', 'KADAYANALLUR',
    'SIVAGIRI', 'SANKARANKOIL', 'SIVAKASI', 'RAJAPALAYAM',
    'SRIVILLIPUTHUR', 'SATTUR', 'VASUDEVANALLUR', 'SHENCOTTAH',
    'AMBASAMUDRAM', 'PULIYANKUDI', 'KADAYAM', 'TENKASI',
    'SENKOTTAI', 'ALANGULAM', 'V.K.PUDUR', 'NAGERCOIL',
    'KANYAKUMARI', 'THUCKALAY', 'KULASEKHARAPATNAM', 'MUNCHIRAI',
    'KILLIYUR', 'THIRUVATTAR', 'KURUNTHANCODE', 'THIRUPARAPPU',
    
    // KANCHIPURAM DISTRICT
    'KANCHIPURAM', 'SRI PERUMBUDUR', 'UTHIRAMERUR', 'WALAJABAD',
    'CHENGALPATTU', 'TAMBARAM', 'CHROMEPET', 'PALLAVARAM',
    'MADURANTAKAM', 'CHEYYUR', 'MATHURANTHAKAM', 'TIRUKKALIKUNDRAM',
    'KUNRATHUR', 'MAMALLAPURAM', 'VANDALUR', 'KELAMBAKKAM',
    'THIRUPORUR', 'KARANAI', 'SITHALAPAKKAM', 'PONNERI',
    'GUMIDIPOONDI', 'TIRUTTANI', 'ARAKONAM', 'SHOLINGHUR',
    
    // VELLORE DISTRICT
    'VELLORE', 'KATPADI', 'ARCOT', 'RANIPET',
    'WALAJAPET', 'AVADI', 'AMBUR', 'GUDIYATTAM',
    'TIRUPATTUR', 'VANIYAMBADI', 'AMRITHI', 'ANAKAPUTHUR',
    'JOLARPET', 'KATPADI', 'MELMONI', 'NATHAM',
    'NEMILI', 'PALLIKONDA', 'PERANAMPET', 'SHOLINGHUR',
    'THIMMANAHALLI', 'THIRUPATHUR', 'VADUGAPATTI', 'VEERAPPANCHATRAM',
    
    // TIRUVALLUR DISTRICT
    'TIRUVALLUR', 'POONAMALLEE', 'AMBATTUR', 'AVADI',
    'PATTABIRAM', 'THIRUNAINDRAVUR', 'MANALI', 'MINJUR',
    'PONNERI', 'GUMIDIPOONDI', 'TIRUTTANI', 'ARAKONAM',
    'SHOLINGHUR', 'PERIYAPALAYAM', 'KADAMBATHUR', 'TIRUVETTIYUR',
    'ENNORE', 'KATHIRVEDU', 'KORATTUR', 'MADHAVARAM',
    'MATHUR', 'MINJUR', 'MOGAPPAIR', 'PERAMBUR',
    
    // DINDIGUL DISTRICT
    'DINDIGUL', 'KODAIKANAL', 'PALANI', 'ODDANCHATRAM',
    'VEDASANDUR', 'NATHAM', 'GUZILIAMPARAI', 'ATHOOR',
    'NILAKKOTTAI', 'BATLAGUNDU', 'REDDIARCHATRAM', 'VADIPATTI',
    'SEMPATTI', 'SHANARPATTI', 'SITHARAI', 'THOPPAMPATTI',
    'VADAMADURAI', 'VEERAPANDI', 'AMBASAMUDRAM', 'KADAYANALLUR',
    
    // ERODE DISTRICT
    'ERODE', 'GOBI', 'SATHYAMANGALAM', 'BHAVANI',
    'PERUNDURAI', 'KODUMUDI', 'ANTHIYUR', 'AMMAPET',
    'CHITHODE', 'KANGAYAM', 'MUTHUR', 'Nambiyur',
    'Pallipalayam', 'Sivagiri', 'T.N.PALAYAM', 'Vellakoil',
    'Vijayamangalam', 'Arachalur', 'Bhavanisagar', 'Chennimalai',
    'Gobichettipalayam', 'Kunnathur', 'Modakurichi', 'Perundurai',
    
    // NAMAKKAL DISTRICT
    'NAMAKKAL', 'RASIPURAM', 'TIRUCHENGODE', 'PARAMATHI',
    'KOMARAPALAYAM', 'MOHANUR', 'PUDUCHATRAM', 'SENDAMANGALAM',
    'KALAPPANAICKENPATTI', 'KUMARAPALAYAM', 'MALLUR', 'PALLIPALAYAM',
    'VELUR', 'ERUMAPATTI', 'KABILARMALAI', 'KOLATHUR',
    'MUTHUGAPATTI', 'NAMAGIRIPETTAI', 'PAPPIREDDIPATTI', 'SELAKKARAI',
    
    // KARUR DISTRICT
    'KARUR', 'KULITHALAI', 'KADAVUR', 'KRISHNARAYAPURAM',
    'THANTHONI', 'THOGAMALAI', 'ARAVAKURICHI', 'K.PARAMATHI',
    'PUGALUR', 'VELAYUDHAMPALAYAM', 'ANNAPPET', 'KADAYAMPATTI',
    'KALIAMUTHANPATTI', 'KALLIMANDAYAM', 'KAMARAJARNAGAR', 'KANNAPURAM',
    'KARUMANDAPAM', 'KATTALAI', 'KAVUNDAMPALAYAM', 'KODAIKADU',
    
    // VIRUDHUNAGAR DISTRICT
    'VIRUDHUNAGAR', 'SIVAKASI', 'RAJAPALAYAM', 'SRIVILLIPUTHUR',
    'SATTUR', 'ARUPPUKOTTAI', 'TIRUCHULI', 'WATRAP',
    'KARAIKUDI', 'DEVAKOTTAI', 'KANADUKATHAN', 'KALLAAL',
    'MANAMADURAI', 'PARAMAKUDI', 'MUDUKULATHUR', 'KAMUDHI',
    'NALATTINPUTHUR', 'PALAVOOR', 'PANDALKudi', 'SANKARANKOIL',
    
    // RAMANATHAPURAM DISTRICT
    'RAMANATHAPURAM', 'PARAMAKUDI', 'MUDUKULATHUR', 'KAMUDHI',
    'RAMESWARAM', 'THIRUVADANAI', 'KALKAULAM', 'KEEZHAKARAI',
    'MANDAPAM', 'PAMBAN', 'THANGACHIMADAM', 'THIRUPULLANI',
    'UPPOOR', 'VALINOKKAM', 'VEDALAI', 'VEMBAR',
    
    // THANJAVUR DISTRICT
    'THANJAVUR', 'KUMBAKONAM', 'PATTUKKOTTAI', 'THIRUVARUR',
    'NAGAPATTINAM', 'MAYILADUTHURAI', 'THIRUTHURAIPOONDI', 'ORATHANADU',
    'PAPANASAM', 'BUDALUR', 'GANDHARVAKOTTAI', 'PERAVURANI',
    'THIRUVIDAIMARUDUR', 'TIRUPPANANDAL', 'VELLANUR', 'AMMAPET',
    'ARANTANGI', 'AVUDAYARKOIL', 'KARAIKUDI', 'KOTTAR',
    'KULATHUR', 'MANNARGUDI', 'MUTHUPET', 'NACHIYARKOIL',
    
    // NAGAPATTINAM DISTRICT
    'NAGAPATTINAM', 'VELANKANNI', 'SIRKALI', 'MAYILADUTHURAI',
    'THARANGAMBADI', 'VEEDUR', 'KEEZHAVELUR', 'KILVELUR',
    'KUTHANALLUR', 'MANNARGUDI', 'MUTHUPET', 'NAGORE',
    'NELLIKADU', 'PERALAM', 'POOMPUHAR', 'PORAYAR',
    'SEMPATTUR', 'THALAINAYAR', 'THIRUKKADAIYUR', 'THIRUMARAikkADU',
    
    // TIRUVARUR DISTRICT
    'TIRUVARUR', 'KODAVASAL', 'NANNILAM', 'THIRUTHURAIPOONDI',
    'MUTHUPET', 'VALANGIMAN', 'KOLLUMANGUDI', 'MANNARGUDI',
    'NEEDAMANGALAM', 'KOTTAIYUR', 'KURUMBALUR', 'PANDANALLUR',
    'PERALAM', 'POOMPUHAR', 'TIRUVIDAIMARUDUR', 'VADAMADURAI',
    
    // DHARMAPURI DISTRICT
    'DHARMAPURI', 'HOSUR', 'KRISHNAGIRI', 'PENNAGARAM',
    'PAPPIREDDIPATTI', 'PALACODE', 'HARUR', 'KAMBHAINALLUR',
    'KARIMANGALAM', 'MORAPPUR', 'NAGAVALI', 'NALLAMPATTI',
    'PENNAGARAM', 'POCHAMPALLI', 'SHOOLAGIRI', 'VEDASANDUR',
    
    // KRISHNAGIRI DISTRICT
    'KRISHNAGIRI', 'HOSUR', 'DENKANIKOTTAI', 'Pochampalli',
    'Uthangarai', 'Bargur', 'Kelamangalam', 'Shoolagiri',
    'Thalli', 'Veppanapalli', 'Anchetty', 'Hogenakkal',
    'Krishnagiri', 'Mathur', 'Palacode', 'Pochampalli',
    
    // THE NILGIRIS DISTRICT
    'OOTY', 'COONOOR', 'KOTAGIRI', 'GOONDI',
    'KUNDAH', 'GUDALUR', 'PYNKARA', 'EMARALD',
    'AVALANCHE', 'KILKUNDA', 'KETTI', 'NADUVATTAM',
    'SHOLUR', 'HULICAL', 'DEVALA', 'BURLIAR',
    
    // KANYAKUMARI DISTRICT
    'KANYAKUMARI', 'NAGERCOIL', 'KULASEKHARAPATNAM', 'THUCKALAY',
    'KURUNTHANCODE', 'MUNCHIRAI', 'THIRUVATTAR', 'KILLIYUR',
    'MELPUTHOOR', 'MARTHANDAM', 'KULASEKHARAM', 'THIRUPARAPPU',
    'PECHIPARAI', 'PERUNKANNI', 'SUCHINDRAM', 'THOVALA'
];

// ============================================
// COMPLETE LOCATION DATABASE
// ============================================
const LOCATIONS = {
    KERALA: KERALA_LOCATIONS,
    TAMIL_NADU: TAMIL_NADU_LOCATIONS
};

// ============================================
// DETECTION FUNCTIONS
// ============================================

function getVehicleState(vehicleNum) {
    if (!vehicleNum) return null;
    const num = vehicleNum.trim().toUpperCase();
    if (num.startsWith('KL')) return 'KL';
    if (num.startsWith('TN')) return 'TN';
    return null;
}

function getAddressState(address) {
    if (!address) return null;
    const addr = address.trim().toUpperCase();
    
    for (const loc of LOCATIONS.KERALA) {
        if (addr.includes(loc)) return 'KERALA';
    }
    
    for (const loc of LOCATIONS.TAMIL_NADU) {
        if (addr.includes(loc)) return 'TAMIL_NADU';
    }
    
    return null;
}

function getSelectedDestination() {
    const keralaRadio = document.getElementById('kerala-radio');
    const tamilnaduRadio = document.getElementById('tamilnadu-radio');
    
    if (keralaRadio && keralaRadio.checked) return 'KERALA';
    if (tamilnaduRadio && tamilnaduRadio.checked) return 'TAMIL_NADU';
    
    return null;
}

// ============================================
// AUTOMATIC DESTINATION FIX
// ============================================

function checkAndFixDestinationMismatch() {
    // Get elements
    const vehicleInput = document.getElementById('vehicle-input');
    const addressInput = document.getElementById('address-input');
    const keralaRadio = document.getElementById('kerala-radio');
    const tamilnaduRadio = document.getElementById('tamilnadu-radio');
    
    if (!vehicleInput || !addressInput || !keralaRadio || !tamilnaduRadio) {
        return false;
    }
    
    const vehicleNum = vehicleInput.value.trim();
    const address = addressInput.value.trim();
    
    // Skip if empty
    if (!vehicleNum || !address) return false;
    
    // Get values
    const vehicleState = getVehicleState(vehicleNum);
    const addressState = getAddressState(address);
    const currentDest = getSelectedDestination();
    
    // Skip if can't detect all
    if (!vehicleState || !addressState || !currentDest) return false;
    
    let shouldFix = false;
    let newDest = '';
    
    // Rule 1: KL vehicle + Tamil Nadu address + Kerala destination
    // Should set destination to TAMILNADU
    if (vehicleState === 'KL' && 
        addressState === 'TAMIL_NADU' && 
        currentDest === 'KERALA') {
        shouldFix = true;
        newDest = 'TAMIL_NADU';
    }
    
    // Rule 2: TN vehicle + Kerala address + Tamil Nadu destination
    // Should set destination to KERALA
    if (vehicleState === 'TN' && 
        addressState === 'KERALA' && 
        currentDest === 'TAMIL_NADU') {
        shouldFix = true;
        newDest = 'KERALA';
    }
    
    if (shouldFix) {
        // Apply the fix silently in background
        if (newDest === 'KERALA') {
            keralaRadio.checked = true;
            tamilnaduRadio.checked = false;
        } else if (newDest === 'TAMIL_NADU') {
            tamilnaduRadio.checked = true;
            keralaRadio.checked = false;
        }
        
        // Update PDF if function exists
        if (typeof updateDestinationField === 'function') {
            updateDestinationField(newDest === 'KERALA' ? (address + ", Others") : ", Tamilnadu");
        }
        
        return true;
    }
    
    return false;
}

// ============================================
// EVENT LISTENERS - REAL-TIME DETECTION
// ============================================

function initAutoFixSystem() {
    console.log("ðŸš€ Initializing automatic destination fix system (Background)...");
    
    // Get elements
    const vehicleInput = document.getElementById('vehicle-input');
    const addressInput = document.getElementById('address-input');
    const keralaRadio = document.getElementById('kerala-radio');
    const tamilnaduRadio = document.getElementById('tamilnadu-radio');
   
    
    // Real-time detection on every input
    vehicleInput.addEventListener('input', function() {
        setTimeout(checkAndFixDestinationMismatch, 300);
    });
    
    addressInput.addEventListener('input', function() {
        setTimeout(checkAndFixDestinationMismatch, 300);
    });
    
    // Also check when radio buttons change
    keralaRadio.addEventListener('change', function() {
        setTimeout(checkAndFixDestinationMismatch, 300);
    });
    
    tamilnaduRadio.addEventListener('change', function() {
        setTimeout(checkAndFixDestinationMismatch, 300);
    });
    
    // Check when address field loses focus
    addressInput.addEventListener('blur', function() {
        setTimeout(checkAndFixDestinationMismatch, 200);
    });
    
    // Check when vehicle field loses focus
    vehicleInput.addEventListener('blur', function() {
        setTimeout(checkAndFixDestinationMismatch, 200);
    });
    
    // Periodic check every 5 seconds for any changes
    setInterval(checkAndFixDestinationMismatch, 5000);
    
    console.log("âœ… Automatic background fix system ready!");
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(initAutoFixSystem, 1000);
});

// Also check when user logs in (if using auth)
if (typeof auth !== 'undefined') {
    auth.onAuthStateChanged(function(user) {
        if (user) {
            setTimeout(initAutoFixSystem, 500);
        }
    });
}

// Initial check after all content is loaded
window.addEventListener('load', function() {
    setTimeout(checkAndFixDestinationMismatch, 2000);
});
</script>



<script>

// Define valid Kerala locations
const KERALA_LOCATIONS2 = [
  // IDUKKI DISTRICT (Tea Plantation Areas)
    'RAJAKKAD', 'RAJAKKUMARY', 'BAISONVALLY', 'ADIMALI', 
    'ANACHAL', 'CHINNAKANAL', 'KANCHIYAR', 'CHEMMANNAR',
    'SURIYANELLY', 'VATTAPARA', 'VATAVADA', 'EZUHUKUMVAYAL',
    'KODIKULAM', 'MUNNAR', 'DEVIKULAM', 'PALLIVASAL',
    'CHITHIRAPURAM', 'ANAYIRANKAL', 'SENAPATHY', 'VANCHIVAYAL',
    'KALIYAR', 'KANJIKUZHI', 'KARADIKUZHI', 'KARIMBAN',
    'KARIVAPARA', 'KARUNARAPPILLY', 'KODANAD', 'KOOVAPALLY',
    'KOTTAKAMBUR', 'KULAMAVU', 'KUMALY', 'KUMILI',
    'KUTTIKKANAM', 'MALAYATTUR', 'MANIMALA', 'MARAYUR',
    'MATTUPATTY', 'MUDAPETTA', 'MULAMATTAM', 'MUNNAR',
    'NEDUMKANDAM', 'PALLIVASAL', 'PAMPADUM PARA', 'PANAMKUTTY',
    'PARATHODE', 'PATTISERY', 'PEERMADE', 'PERIYAR',
    'PERUMBAVOOR', 'PERUVANTHANAM', 'PONMUDY', 'PULIYANMALA',
    'RAJAKKADU', 'SANTHANPARA', 'SENAPATHY', 'THODUPUZHA',
    'UDUMBANNOOR', 'UDUMBANCHOLA', 'VAGAMON', 'VALARA',
    'VANCHIVAYAL', 'VANDANMEDU', 'VANNAPURAM', 'VATTIYOORKAVU', 'KATTAPANA', 'EZHUKUMUVAYAL',
    
    // WAYANAD DISTRICT
    'KALPETTA', 'SULTHAN BATHERY', 'MANANTHAVADY', 'VYTHIRI',
    'AMBAVAYAL', 'BEGUR', 'CHUNDALE', 'KAPPIKAD',
    'KARTHIKULAM', 'KATTIKULAM', 'KENICHIRA', 'KOLAGAPARA',
    'KONDOTTY', 'KURICHARMALA', 'KURUVA ISLAND', 'KUTHIRAKKAL',
    'MANCHERI', 'MEPPADI', 'MUTHANGA', 'NADAPURAM',
    'NADUVIL', 'NARIKKUNI', 'NEDUMANGAD', 'NENMENI',
    'NOOLPUZHA', 'OOTY', 'PADINJARATHARA', 'PALAKKAD',
    'PALAKKAYAM', 'PALAPPALLY', 'PALARAM', 'PAMBRO',
    'PANAMARAM', 'PAPPINISSERI', 'PARAPPANANGADI', 'PATTIKKAD',
    'PAZHASSI RAJA', 'PERIKALLUR', 'PERINGATHUR', 'PERINTHELMANNA',
    'PERUVA', 'POOKKODE', 'POOKKOT', 'PULPALLY',
    'PUTHOOR', 'RIPPON', 'SUGANDHAGIRI', 'THALAPUZHA',
    'THARIODE', 'THIRUNAVAYA', 'THOLAMBRA', 'THOTTIPALAM',
    'THRIKKADAVOOR', 'THRIKKARIPPUR', 'TIRUR', 'TIRURANGADI',
    'VADAKARA', 'VANIAMKULAM', 'VARAM', 'VELLARIKKUNDU',
    'VENMANAD', 'VENGARA', 'VENGARA', 'VENNIYOOR',
    
    // PALAKKAD DISTRICT
    'PALAKKAD', 'OTTAPPALAM', 'MANNARKKAD', 'ALATHUR',
    'CHITTUR', 'KODUVAYUR', 'PATTAMBI', 'SREEKRISHNAPURAM',
    'THRITHALA', 'KOOTANAD', 'KUNNATHUKULAM', 'MALAMPUZHA',
    'NENMARA', 'PALLIPURAM', 'PARLI', 'PERINKULAM',
    'POZHITHODE', 'PUDUKKAD', 'PUDUNKURICHI', 'PULLAZHI',
    'PULLU', 'PUNNAYOORKULAM', 'PURATHUR', 'PUTHANATHANI',
    'PUTHUPPALLY', 'PUTHUPPARIYARAM', 'PUTHUVAIPU', 'PUTTADI',
    'RAMANATTUKARA', 'SHORANUR', 'THACHANATTUKARA', 'THALAKKAD',
    'THALASSERY', 'THAMARASSERY', 'THANNIYAM', 'THAZHEPALAM',
    'THEKKUMKARA', 'THENGANA', 'THENHIPALAM', 'THIRUVALLA',
    'THIRUVAMBADY', 'THIRUVANANTHAPURAM', 'THODIYOOR', 'THOLUR',
    'THRIPRAYAR', 'THRISSUR', 'THUNCHANPARAMBU', 'THURUTHY',
    'TIRUR', 'TIRURANGADI', 'TRIPRANGODE', 'UDMA',
    'VADAKKANCHERY', 'VADAKKUMKARA', 'VADAMALAPURAM', 'VADAVUCODE',
    'VADAVUROAD', 'VADAKARA', 'VADAKKUMBHAGOM', 'VADAKKUMKARA',
    
    // THRISSUR DISTRICT
    'THRISSUR', 'IRINJALAKUDA', 'KODUNGALLUR', 'GURUVAYUR',
    'CHALAKUDY', 'KUNNAMKULAM', 'WADAKKANCHERRY', 'MALA',
    'CHOONDAL', 'CHELAKKARA', 'MULLASSERY', 'PURANATTUKARA',
    'VILVATTOM', 'ANTHIKAD', 'AVINISSERY', 'CHAVAKKAD',
    'CHERP', 'CHETTUVA', 'EDAKKUNNI', 'ENAMAKKAL',
    'ERAVATTUR', 'KAIKULANGARA', 'KANIMANGALAM', 'KARANCHIRA',
    'KARUVANNUR', 'KATTOOR', 'KECHAVAM', 'KODAKARA',
    'KODASSERY', 'KOLAZHY', 'KOLLENGODE', 'KOOTTANAD',
    'KORATTY', 'KOTTAPPADI', 'KULAPULLY', 'KUMARANELLUR',
    'KUTTANELLUR', 'MADAYIKONAM', 'MANALITHARA', 'MANATHALA',
    'MANGAD', 'MANNUTHY', 'MATTOM', 'MUNDATHIKODE',
    'MURIKKASSERY', 'MURIYAD', 'MUTTATHUR', 'NADAKKAVU',
    
    // ERNAKULAM DISTRICT
    'KOCHI', 'ERNAKULAM', 'ALUVA', 'KALAMASSERY',
    'KAKKANAD', 'EDAPPALLY', 'THRIPPUNITHURA', 'VYTTILA',
    'KOTHAMANGALAM', 'MUVATTUPUZHA', 'PERUMBAVOOR', 'PARAVUR',
    'ANGAMALY', 'ELOOR', 'NORTH PARAVUR', 'ALUVA',
    'CHELLANAM', 'CHENGAMANAD', 'CHOONAD', 'EDATHALA',
    'KADUNGALLOOR', 'KANAYANNUR', 'KANJIRAMATTOM', 'KARUKUTTY',
    'KEEZMAD', 'KOLENCHERRY', 'KOOTHATTUKULAM', 'KOTHAD',
    'KUNNUKARA', 'KURUPPAMPADY', 'MALA', 'MANAKKAPADY',
    'MANJALI', 'MARADU', 'MULAVUKAD', 'NAYARAMBALAM',
    'NEDUMBASSERY', 'PAIRA', 'PALLIPPURAM', 'PALLURUTHY',
    'PANAICKEN', 'PANANGAD', 'PARAKKadavu', 'PATTIMATTOM',
    
    // KOLLAM DISTRICT
    'KOLLAM', 'PARAVUR', 'KARUNAGAPPALLY', 'PUNALUR',
    'PATHANAPURAM', 'KOTTARAKKARA', 'KUNDARA', 'ANCHAL',
    'CHADAYAMANGALAM', 'CHATHANNOOR', 'KALLADA', 'KULAKKADA',
    'MANNANAM', 'MUKHATHALA', 'NEDUMPANA', 'NEENDAKARA',
    'OACHIRA', 'PERINAD', 'SASTHAMCOTTAH', 'THAZHAVA',
    'THODIYOOR', 'VELIYAM', 'YEROOR', 'ADICHANALLOOR',
    
    // THIRUVANANTHAPURAM DISTRICT
    'THIRUVANANTHAPURAM', 'NEYYATTINKARA', 'NEDUMANGAD', 'VENJARAMOODU',
    'ATTINGAL', 'VARKALA', 'KILIMANOOR', 'KATTAKADA',
    'PARASSALA', 'KALLIYUR', 'KANIYAPURAM', 'KARAKULAM',
    'KARAVARAM', 'KAZHAKUTTAM', 'KEEZHTHONAKKAL', 'KOCHUVELI',
    'KODUNGAIYUR', 'KOLATHUR', 'KONNI', 'KOTTUKAL',
    'KOVALAM', 'KULATHOOR', 'KUNNATHUKAL', 'MADAVOOR',
    'MANAMBUR', 'MANCHALLUR', 'MANNANTHALA', 'MARANALLUR',
    'MARUTHAMKUZHI', 'MEENAMGALAM', 'MELARANNOR', 'MULLOOR',
    'MUTTATHARA', 'NAGAROOR', 'NAVAIOORKULAM', 'NELLIMOODU',
    'NETTAYAM', 'NIYYATHINKARA', 'PACHALLOOR', 'PALLICHAL',
    'PALLIPPURAM', 'PANAVOOR', 'PARUTHIPALLY', 'PATHAMKALLU',
    'PAZHAMTHOTTAM', 'PERINGAMALA', 'PERUMKUZHI', 'PERUMPAZHUTHOOR',
    'POOJAPPURA', 'POOVAR', 'POTTAKKAD', 'PULLUVILA',
    
    // KANNUR DISTRICT
    'KANNUR', 'THALASSERY', 'PAYYANNUR', 'TALIPARAMBA',
    'IRITTY', 'MATTANNUR', 'PANOOR', 'KUTHUPARAMBA',
    'CHERUKUNNU', 'CHERUTHUTHY', 'EDAKKAD', 'ELAYAVOOR',
    'KADACHIRA', 'KADIRUR', 'KALIYAT', 'KALLIASSERI',
    'KANHILERI', 'KANICHAR', 'KANNAPURAM', 'KARIVELUR',
    'KEEZHALLUR', 'KOLASSERY', 'KOLAYAD', 'KOTTAYAM',
    'KUDIYANMALA', 'KUNHIMANGALAM', 'KURUMATHUR', 'MADAYI',
    'MAYYIL', 'MOKERI', 'MUZHAPPILANGAD', 'NARATH',
    'NEKRAJ', 'PADUVILAI', 'PAPPINISSERI', 'PARAL',
    'PATHIRIYOODU', 'PAZHASSI', 'PERALASSERY', 'PERINGATHUR',
    'PERINGOME', 'PERUMBA', 'PILATHARA', 'PUTHIYANGADI',
    'PUTHUR', 'RAMANTHALI', 'SREEKANDAPURAM', 'THALIPARAMBA',
    'THILLENKERI', 'THRIKKARIPPUR', 'THRIKKULAM', 'UDMA',
    'VALAPATTANAM', 'VARARUCHI', 'VELLARIKKUNDU', 'VIZHINJAM',
    
    // KASARAGOD DISTRICT
    'KASARAGOD', 'KANHANGAD', 'NILESHWAR', 'BEKAL',
    'CHANDERA', 'CHERUVATHUR', 'HOSDURG', 'KADAMBUR',
    'KALIKKADAVU', 'KALLAR', 'KARINDALAM', 'KOTTAMALA',
    'KUMBALA', 'KUNJATHUR', 'KUNNATHUR', 'MADIKKAI',
    'MANJESHWAR', 'MOGRAL', 'MULLERIA', 'NEERESULAM',
    'PADANNA', 'PAIYOOR', 'PARAPPA', 'PERLA',
    'PERUMBA', 'POINACHI', 'POVVAL', 'PULLUR',
    'RANIPURAM', 'SOUTH THRIKARIPPUR', 'TRIKARPUR', 'UDMA',
    'UPPALA', 'VORKADI', 'ADI PARAVUR', 'ANANDASHRAM',
    
    // MALAPPURAM DISTRICT
    'MALAPPURAM', 'MANJERI', 'PERINTHALMANNA', 'TIRUR',
    'PONNANI', 'TIRURANGADI', 'NILAMBUR', 'TANUR',
    'PARAPPANANGADI', 'VALANCHERRY', 'KONDOTTY', 'RAMANATTUKARA',
    'KOTTAKKAL', 'MANGALAM', 'PERUMPADAPPA', 'VENGARA',
    'VANIYAMBALAM', 'WANDOOR', 'KALIKAVU', 'KARUNAGAPPALLY',
    'KARUVARAKUNDU', 'MELATTUR', 'PANDIKKAD', 'PULAMANTHOLE',
    'THIRUNAVAYA', 'THIRUVALI', 'THIRUVANTHAPURAM', 'THRIKKANAPURAM',
    'TUVVUR', 'VAZHAKKAD', 'VEDAKARA', 'VENKITANGU',
    
    // KOZHIKODE DISTRICT
    'KOZHIKODE', 'FEROKE', 'Ramanattukara', 'Koyilandy',
    'Vadakara', 'Thamarassery', 'Sultan Bathery', 'Kalpetta',
    'Kuttiyadi', 'Koduvally', 'Mukkam', 'Perambra',
    'Balussery', 'Elathur', 'Chelannur', 'Beypore',
    'Chaliyam', 'Kadalundi', 'Parappanangadi', 'Tanur',
    'Tirur', 'Tirurangadi', 'Valanchery', 'Kottakkal',
    'Kondotty', 'Malappuram', 'Manjeri', 'Perinthalmanna',
    'Nilambur', 'Sulthan Bathery', 'Kalpetta', 'Meppadi',
    'Vythiri', 'Ambalavayal', 'Pulpally', 'Mananthavady',
    
    
       'CUMBUM', 'THENI', 'BODINAYAKANUR', 'PERIYAKULAM',
    'CHINNAMANUR', 'KAMAYAKOUNDANPATTY', 'THEVARAM', 'VADAPATTI',
    'KOMBAI', 'GUDALUR', 'UPPILIPATTI', 'SURULIPATTI',
    'VEERAPANDI', 'SELVAM', 'ANDIPATTI', 'GOODALUR',
    'CHINNAPPAMPATTI', 'KOTTAIYUR', 'KUMULI', 'BATLAGUNDU',
    'VIRALIPATTI', 'KOTTAIYUR', 'SENNIMALAI', 'KOMBAI',
    'DEVADANAPATTI', 'KADAMALAIGUNDU', 'KADAYAM', 'KADANCHERI',
    'KAMARAJARNAGAR', 'KANAVAYAL', 'KANGAYAM', 'KANIYUR',
    
    // MADURAI DISTRICT
    'MADURAI', 'MELUR', 'USILAMPATTI', 'THIRUMANGALAM',
    'PARAMAKUDI', 'TIRUPUVANAM', 'KALLIKUDI', 'SEDAPATTI',
    'T.KALLUPATTI', 'CHETTIPATTI', 'KALLUPATTI', 'KOTTAIYUR',
    'ALANGANALLUR', 'ARUPPUKOTTAI', 'AVANIYAPURAM', 'CHINNAMANUR',
    'ERODE', 'ILAYANGUDI', 'KARAIKUDI', 'KARUR',
    'KEELAKEERAI', 'KODAIKANAL', 'KULITHALAI', 'MANAMADURAI',
    'MANAPPARAI', 'NAMAKKAL', 'NATHAM', 'PALANI',
    'PARAMATHI', 'PATTUKKOTTAI', 'PERAIYUR', 'PERAMBALUR',
    'POLLACHI', 'PUDUKKOTTAI', 'RAJAPALAYAM', 'RAMANATHAPURAM',
    'RASIPURAM', 'SALEM', 'SANKARANKOIL', 'SATTUR',
    'SIVAGANGA', 'SIVAKASI', 'SRIVILLIPUTHUR', 'TENKASI',
    'THANJAVUR', 'THENI', 'THIRUCHENGODE', 'THIRUPPUR',
    'THIRUTHURAIPOONDI', 'THIRUVARUR', 'TINDIVANAM', 'TIRUCHIRAPPALLI',
    'TIRUNELVELI', 'TIRUPATHUR', 'TIRUPPUR', 'TIRUVANNAMALAI',
    'TUTICORIN', 'UDUMALPET', 'ULUNDURPET', 'VALPARAI',
    'VEDASANDUR', 'VELLORE', 'VIRUDHUNAGAR', 'WALAJAPET',
    
    // COIMBATORE DISTRICT
    'COIMBATORE', 'POLLACHI', 'METTUPALAYAM', 'SOMAYAMPALAYAM',
    'KINATHUKADAVU', 'ANAMALAI', 'VALPARAI', 'UDUMALPET',
    'PALANI', 'DINDIGUL', 'KARUR', 'ERODE',
    'SALEM', 'TIRUPPUR', 'NILGIRIS', 'OOTY',
    'GOONDI', 'KOTAGIRI', 'COONOOR', 'METTUPALAYAM',
    'SULUR', 'KAVUNDAMPALAYAM', 'VADAVALLI', 'RACE COURSE',
    'SAIBABA COLONY', 'RS PURAM', 'GANDHIPURAM', 'UKKADAM',
    'KURICHI', 'KALAPATTI', 'SARAVANAMPATTI', 'NEELAMBUR',
    'CHINNIYAMPALAYAM', 'KARUMATHAMPATTI', 'THUDIYALUR', 'SINGANALLUR',
    'KUNIYAMUTHUR', 'PEELAMEDU', 'SITRA', 'NANJUNDAPURAM',
    'PAPPANAICKENPALAYAM', 'KOVAIPUDUR', 'SAI BABA COLONY', 'VILANKURICHI',
    
    // CHENNAI & SUBURBS
    'CHENNAI', 'ANNA NAGAR', 'T.NAGAR', 'MYLAPORE',
    'ADYAR', 'VELACHERY', 'PALLAVARAM', 'TAMBARAM',
    'CHROMPET', 'PERUNGULATHUR', 'KELAMBAKKAM', 'SHOLINGANALLUR',
    'MEDAVAKKAM', 'MOUNT ROAD', 'EGMORE', 'NUNGAMBAKKAM',
    'KILPAUK', 'PERAMBUR', 'VILLIVAKKAM', 'AMBATTUR',
    'AVADI', 'POONAMALLEE', 'THIRUVALLUR', 'SRI PERUMBUDUR',
    'GUMMIDIPOONDI', 'TIRUTTANI', 'ARAKONAM', 'RANIPET',
    'WALAJAH', 'ARCOT', 'VELLORE', 'KRISHNAGIRI',
    'DHARMAPURI', 'TIRUVANNAMALAI', 'KANCHIPURAM', 'MAHABALIPURAM',
    
    // SALEM DISTRICT
    'SALEM', 'ATTUR', 'EDAPPADI', 'MECHRIPALAYAM',
    'OMALUR', 'SANKAGIRI', 'YERCAUD', 'VELLAKOIL',
    'PETHANAICKENPALAYAM', 'IDAPPADI', 'GANGAVALLI', 'THALAIVASAL',
    'KADAYAMPATTI', 'NANGAVALLI', 'PANAMARATHUPATTI', 'VEERAPANDI',
    'AYOTHAPATTINAM', 'KONGANAPURAM', 'KOLATHUR', 'MAGUDANCHAVADI',
    'PAPPIREDDIPATTI', 'THARAMANGALAM', 'VEERAKKALPUDUR', 'ELAMPILLAI',
    
    // TIRUCHIRAPPALLI DISTRICT
    'TIRUCHIRAPPALLI', 'SRIRANGAM', 'WORAIYUR', 'THILLAINAGAR',
    'CANTONMENT', 'PUTHUR', 'K.K.NAGAR', 'ARIANAGAR',
    'GOLDEN ROCK', 'PONMALAI', 'ABISHEKAPATTI', 'CRAW FORD',
    'MANAPPARAI', 'THURAIYUR', 'MUSIRI', 'THATHENGARPET',
    'MANACHANALLUR', 'LALGUDI', 'THIRUVERUMBUR', 'THUVARANKURICHI',
    'MARUNGAPURI', 'VELLANUR', 'PULLAMBADI', 'UPPILIYAPURAM',
    'PERAMBALUR', 'KUNNAM', 'VELLORE', 'ARIYALUR',
    
    // TIRUNELVELI DISTRICT
    'TIRUNELVELI', 'PALAYAMKOTTAI', 'THATCHANALLUR', 'MELAPALAYAM',
    'TRUNELVELI JUNCTION', 'KORAMPALLAM', 'TISAYANVILAI', 'KADAYANALLUR',
    'SIVAGIRI', 'SANKARANKOIL', 'SIVAKASI', 'RAJAPALAYAM',
    'SRIVILLIPUTHUR', 'SATTUR', 'VASUDEVANALLUR', 'SHENCOTTAH',
    'AMBASAMUDRAM', 'PULIYANKUDI', 'KADAYAM', 'TENKASI',
    'SENKOTTAI', 'ALANGULAM', 'V.K.PUDUR', 'NAGERCOIL',
    'KANYAKUMARI', 'THUCKALAY', 'KULASEKHARAPATNAM', 'MUNCHIRAI',
    'KILLIYUR', 'THIRUVATTAR', 'KURUNTHANCODE', 'THIRUPARAPPU',
    
    // KANCHIPURAM DISTRICT
    'KANCHIPURAM', 'SRI PERUMBUDUR', 'UTHIRAMERUR', 'WALAJABAD',
    'CHENGALPATTU', 'TAMBARAM', 'CHROMEPET', 'PALLAVARAM',
    'MADURANTAKAM', 'CHEYYUR', 'MATHURANTHAKAM', 'TIRUKKALIKUNDRAM',
    'KUNRATHUR', 'MAMALLAPURAM', 'VANDALUR', 'KELAMBAKKAM',
    'THIRUPORUR', 'KARANAI', 'SITHALAPAKKAM', 'PONNERI',
    'GUMIDIPOONDI', 'TIRUTTANI', 'ARAKONAM', 'SHOLINGHUR',
    
    // VELLORE DISTRICT
    'VELLORE', 'KATPADI', 'ARCOT', 'RANIPET',
    'WALAJAPET', 'AVADI', 'AMBUR', 'GUDIYATTAM',
    'TIRUPATTUR', 'VANIYAMBADI', 'AMRITHI', 'ANAKAPUTHUR',
    'JOLARPET', 'KATPADI', 'MELMONI', 'NATHAM',
    'NEMILI', 'PALLIKONDA', 'PERANAMPET', 'SHOLINGHUR',
    'THIMMANAHALLI', 'THIRUPATHUR', 'VADUGAPATTI', 'VEERAPPANCHATRAM',
    
    // TIRUVALLUR DISTRICT
    'TIRUVALLUR', 'POONAMALLEE', 'AMBATTUR', 'AVADI',
    'PATTABIRAM', 'THIRUNAINDRAVUR', 'MANALI', 'MINJUR',
    'PONNERI', 'GUMIDIPOONDI', 'TIRUTTANI', 'ARAKONAM',
    'SHOLINGHUR', 'PERIYAPALAYAM', 'KADAMBATHUR', 'TIRUVETTIYUR',
    'ENNORE', 'KATHIRVEDU', 'KORATTUR', 'MADHAVARAM',
    'MATHUR', 'MINJUR', 'MOGAPPAIR', 'PERAMBUR',
    
    // DINDIGUL DISTRICT
    'DINDIGUL', 'KODAIKANAL', 'PALANI', 'ODDANCHATRAM',
    'VEDASANDUR', 'NATHAM', 'GUZILIAMPARAI', 'ATHOOR',
    'NILAKKOTTAI', 'BATLAGUNDU', 'REDDIARCHATRAM', 'VADIPATTI',
    'SEMPATTI', 'SHANARPATTI', 'SITHARAI', 'THOPPAMPATTI',
    'VADAMADURAI', 'VEERAPANDI', 'AMBASAMUDRAM', 'KADAYANALLUR',
    
    // ERODE DISTRICT
    'ERODE', 'GOBI', 'SATHYAMANGALAM', 'BHAVANI',
    'PERUNDURAI', 'KODUMUDI', 'ANTHIYUR', 'AMMAPET',
    'CHITHODE', 'KANGAYAM', 'MUTHUR', 'Nambiyur',
    'Pallipalayam', 'Sivagiri', 'T.N.PALAYAM', 'Vellakoil',
    'Vijayamangalam', 'Arachalur', 'Bhavanisagar', 'Chennimalai',
    'Gobichettipalayam', 'Kunnathur', 'Modakurichi', 'Perundurai',
    
    // NAMAKKAL DISTRICT
    'NAMAKKAL', 'RASIPURAM', 'TIRUCHENGODE', 'PARAMATHI',
    'KOMARAPALAYAM', 'MOHANUR', 'PUDUCHATRAM', 'SENDAMANGALAM',
    'KALAPPANAICKENPATTI', 'KUMARAPALAYAM', 'MALLUR', 'PALLIPALAYAM',
    'VELUR', 'ERUMAPATTI', 'KABILARMALAI', 'KOLATHUR',
    'MUTHUGAPATTI', 'NAMAGIRIPETTAI', 'PAPPIREDDIPATTI', 'SELAKKARAI',
    
    // KARUR DISTRICT
    'KARUR', 'KULITHALAI', 'KADAVUR', 'KRISHNARAYAPURAM',
    'THANTHONI', 'THOGAMALAI', 'ARAVAKURICHI', 'K.PARAMATHI',
    'PUGALUR', 'VELAYUDHAMPALAYAM', 'ANNAPPET', 'KADAYAMPATTI',
    'KALIAMUTHANPATTI', 'KALLIMANDAYAM', 'KAMARAJARNAGAR', 'KANNAPURAM',
    'KARUMANDAPAM', 'KATTALAI', 'KAVUNDAMPALAYAM', 'KODAIKADU',
    
    // VIRUDHUNAGAR DISTRICT
    'VIRUDHUNAGAR', 'SIVAKASI', 'RAJAPALAYAM', 'SRIVILLIPUTHUR',
    'SATTUR', 'ARUPPUKOTTAI', 'TIRUCHULI', 'WATRAP',
    'KARAIKUDI', 'DEVAKOTTAI', 'KANADUKATHAN', 'KALLAAL',
    'MANAMADURAI', 'PARAMAKUDI', 'MUDUKULATHUR', 'KAMUDHI',
    'NALATTINPUTHUR', 'PALAVOOR', 'PANDALKudi', 'SANKARANKOIL',
    
    // RAMANATHAPURAM DISTRICT
    'RAMANATHAPURAM', 'PARAMAKUDI', 'MUDUKULATHUR', 'KAMUDHI',
    'RAMESWARAM', 'THIRUVADANAI', 'KALKAULAM', 'KEEZHAKARAI',
    'MANDAPAM', 'PAMBAN', 'THANGACHIMADAM', 'THIRUPULLANI',
    'UPPOOR', 'VALINOKKAM', 'VEDALAI', 'VEMBAR',
    
    // THANJAVUR DISTRICT
    'THANJAVUR', 'KUMBAKONAM', 'PATTUKKOTTAI', 'THIRUVARUR',
    'NAGAPATTINAM', 'MAYILADUTHURAI', 'THIRUTHURAIPOONDI', 'ORATHANADU',
    'PAPANASAM', 'BUDALUR', 'GANDHARVAKOTTAI', 'PERAVURANI',
    'THIRUVIDAIMARUDUR', 'TIRUPPANANDAL', 'VELLANUR', 'AMMAPET',
    'ARANTANGI', 'AVUDAYARKOIL', 'KARAIKUDI', 'KOTTAR',
    'KULATHUR', 'MANNARGUDI', 'MUTHUPET', 'NACHIYARKOIL',
    
    // NAGAPATTINAM DISTRICT
    'NAGAPATTINAM', 'VELANKANNI', 'SIRKALI', 'MAYILADUTHURAI',
    'THARANGAMBADI', 'VEEDUR', 'KEEZHAVELUR', 'KILVELUR',
    'KUTHANALLUR', 'MANNARGUDI', 'MUTHUPET', 'NAGORE',
    'NELLIKADU', 'PERALAM', 'POOMPUHAR', 'PORAYAR',
    'SEMPATTUR', 'THALAINAYAR', 'THIRUKKADAIYUR', 'THIRUMARAikkADU',
    
    // TIRUVARUR DISTRICT
    'TIRUVARUR', 'KODAVASAL', 'NANNILAM', 'THIRUTHURAIPOONDI',
    'MUTHUPET', 'VALANGIMAN', 'KOLLUMANGUDI', 'MANNARGUDI',
    'NEEDAMANGALAM', 'KOTTAIYUR', 'KURUMBALUR', 'PANDANALLUR',
    'PERALAM', 'POOMPUHAR', 'TIRUVIDAIMARUDUR', 'VADAMADURAI',
    
    // DHARMAPURI DISTRICT
    'DHARMAPURI', 'HOSUR', 'KRISHNAGIRI', 'PENNAGARAM',
    'PAPPIREDDIPATTI', 'PALACODE', 'HARUR', 'KAMBHAINALLUR',
    'KARIMANGALAM', 'MORAPPUR', 'NAGAVALI', 'NALLAMPATTI',
    'PENNAGARAM', 'POCHAMPALLI', 'SHOOLAGIRI', 'VEDASANDUR',
    
    // KRISHNAGIRI DISTRICT
    'KRISHNAGIRI', 'HOSUR', 'DENKANIKOTTAI', 'Pochampalli',
    'Uthangarai', 'Bargur', 'Kelamangalam', 'Shoolagiri',
    'Thalli', 'Veppanapalli', 'Anchetty', 'Hogenakkal',
    'Krishnagiri', 'Mathur', 'Palacode', 'Pochampalli',
    
    // THE NILGIRIS DISTRICT
    'OOTY', 'COONOOR', 'KOTAGIRI', 'GOONDI',
    'KUNDAH', 'GUDALUR', 'PYNKARA', 'EMARALD',
    'AVALANCHE', 'KILKUNDA', 'KETTI', 'NADUVATTAM',
    'SHOLUR', 'HULICAL', 'DEVALA', 'BURLIAR',
    
    // KANYAKUMARI DISTRICT
    'KANYAKUMARI', 'NAGERCOIL', 'KULASEKHARAPATNAM', 'THUCKALAY',
    'KURUNTHANCODE', 'MUNCHIRAI', 'THIRUVATTAR', 'KILLIYUR',
    'MELPUTHOOR', 'MARTHANDAM', 'KULASEKHARAM', 'THIRUPARAPPU',
    'PECHIPARAI', 'PERUNKANNI', 'SUCHINDRAM', 'THOVALA'
];

// Create a search-optimized data structure
const LOCATION_SEARCH_MAP = {
    // Map for quick prefix searches
    byPrefix: {},
    // Map for case-insensitive lookup
    byLowercase: {}
};

// Initialize search maps
KERALA_LOCATIONS2.forEach(location => {
    const lower = location.toLowerCase();
    
    // Store for case-insensitive lookup
    LOCATION_SEARCH_MAP.byLowercase[lower] = location;
    
    // Create prefix map for auto-complete
    for (let i = 1; i <= location.length; i++) {
        const prefix = location.substring(0, i).toLowerCase();
        if (!LOCATION_SEARCH_MAP.byPrefix[prefix]) {
            LOCATION_SEARCH_MAP.byPrefix[prefix] = [];
        }
        if (!LOCATION_SEARCH_MAP.byPrefix[prefix].includes(location)) {
            LOCATION_SEARCH_MAP.byPrefix[prefix].push(location);
        }
    }
});

// Function to find matches by prefix
function findMatchesByPrefix(prefix) {
    const lowerPrefix = prefix.toLowerCase();
    return LOCATION_SEARCH_MAP.byPrefix[lowerPrefix] || [];
}

// Function to find exact or close match
function findLocationMatch(input) {
    const trimmed = input.trim();
    if (!trimmed) return null;
    
    const lowerInput = trimmed.toLowerCase();
    
    // 1. Check for exact case-insensitive match
    if (LOCATION_SEARCH_MAP.byLowercase[lowerInput]) {
        return {
            type: 'exact',
            match: LOCATION_SEARCH_MAP.byLowercase[lowerInput],
            confidence: 1.0
        };
    }
    
    // 2. Check for prefix matches (for auto-complete)
    const prefixMatches = findMatchesByPrefix(trimmed);
    if (prefixMatches.length === 1) {
        // Only one match for this prefix
        return {
            type: 'prefix',
            match: prefixMatches[0],
            confidence: 0.9,
            allMatches: prefixMatches
        };
    } else if (prefixMatches.length > 1) {
        // Multiple matches - find best one
        const exactPrefixMatch = prefixMatches.find(loc => 
            loc.toLowerCase() === lowerInput
        );
        if (exactPrefixMatch) {
            return {
                type: 'exact',
                match: exactPrefixMatch,
                confidence: 1.0,
                allMatches: prefixMatches
            };
        }
        return {
            type: 'suggestions',
            matches: prefixMatches,
            confidence: 0.8,
            allMatches: prefixMatches
        };
    }
    
    // 3. Try fuzzy matching if no prefix matches
    const fuzzyResult = fuzzyMatchLocation(lowerInput);
    if (fuzzyResult) {
        return {
            type: 'fuzzy',
            match: fuzzyResult.match,
            confidence: fuzzyResult.confidence,
            allMatches: [fuzzyResult.match]
        };
    }
    
    return null;
}

// Fuzzy matching function
function fuzzyMatchLocation(input) {
    let bestMatch = null;
    let bestScore = 0;
    
    for (const location of KERALA_LOCATIONS) {
        const lowerLocation = location.toLowerCase();
        
        // Check if input is contained in location
        if (lowerLocation.includes(input) && input.length >= 3) {
            const score = input.length / location.length;
            if (score > bestScore) {
                bestScore = score;
                bestMatch = location;
            }
        }
        
        // Check if location is contained in input
        if (input.includes(lowerLocation) && input.length >= location.length) {
            const score = location.length / input.length;
            if (score > bestScore) {
                bestScore = score;
                bestMatch = location;
            }
        }
    }
    
    if (bestScore > 0.6) { // Minimum 60% similarity
        return {
            match: bestMatch,
            confidence: bestScore
        };
    }
    
    return null;
}

// Create and manage suggestion dropdown
class LocationSuggestionDropdown {
    constructor(inputElement, onSelectCallback) {
        this.input = inputElement;
        this.onSelect = onSelectCallback;
        this.dropdown = null;
        this.currentMatches = [];
        this.selectedIndex = -1;
        
        this.initialize();
    }
    
    initialize() {
        // Create dropdown element
        this.dropdown = document.createElement('div');
        this.dropdown.className = 'location-suggestions';
        this.dropdown.style.cssText = `
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            width: ${this.input.offsetWidth}px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        `;
        
        // Insert after input
        this.input.parentNode.insertBefore(this.dropdown, this.input.nextSibling);
        
        // Add event listeners
        this.input.addEventListener('input', this.handleInput.bind(this));
        this.input.addEventListener('keydown', this.handleKeydown.bind(this));
        this.input.addEventListener('blur', () => {
            setTimeout(() => this.hide(), 200);
        });
        this.input.addEventListener('focus', this.handleInput.bind(this));
    }
    
    handleInput(e) {
        const value = this.input.value.trim();
        
        // Auto-capitalize as user types
        if (value && value === value.toUpperCase()) {
            // User is typing in caps, don't change
        } else if (value) {
            // Auto-capitalize first letter of each word
            const words = value.split(' ');
            const capitalized = words.map(word => {
                if (word.length > 0) {
                    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                }
                return word;
            }).join(' ');
            
            // Update input without triggering new event
            if (capitalized !== value) {
                const cursorPos = this.input.selectionStart;
                this.input.value = capitalized;
                this.input.setSelectionRange(cursorPos, cursorPos);
            }
        }
        
        if (value.length < 2) {
            this.hide();
            return;
        }
        
        const result = findLocationMatch(value);
        
        if (!result) {
            this.hide();
            return;
        }
        
        if (result.type === 'exact' || result.type === 'prefix') {
            // Auto-complete for single match
            this.autoComplete(result.match, value);
        } else if (result.type === 'suggestions' || result.type === 'fuzzy') {
            // Show dropdown for multiple matches
            this.showSuggestions(result.allMatches || result.matches, value);
        }
    }
    
    autoComplete(fullLocation, partialInput) {
        if (fullLocation.toLowerCase().startsWith(partialInput.toLowerCase())) {
            // Select the text that should be auto-completed
            const startPos = partialInput.length;
            const endPos = fullLocation.length;
            
            // Set the full value
            this.input.value = fullLocation;
            
            // Select the auto-completed portion
            this.input.setSelectionRange(startPos, endPos);
            
            // Hide dropdown if shown
            this.hide();
        }
    }
    
    showSuggestions(matches, currentValue) {
        this.currentMatches = matches;
        this.selectedIndex = -1;
        
        // Clear previous suggestions
        this.dropdown.innerHTML = '';
        
        // Add new suggestions
        matches.forEach((match, index) => {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            item.textContent = match;
            item.style.cssText = `
                padding: 8px 12px;
                cursor: pointer;
                border-bottom: 1px solid #f0f0f0;
            `;
            
            item.addEventListener('mouseenter', () => {
                this.highlightItem(index);
            });
            
            item.addEventListener('click', () => {
                this.selectItem(index);
            });
            
            // Highlight matching part
            if (match.toLowerCase().startsWith(currentValue.toLowerCase())) {
                const span = document.createElement('span');
                span.textContent = match.substring(0, currentValue.length);
                span.style.fontWeight = 'bold';
                
                const rest = document.createElement('span');
                rest.textContent = match.substring(currentValue.length);
                
                item.innerHTML = '';
                item.appendChild(span);
                item.appendChild(rest);
            }
            
            this.dropdown.appendChild(item);
        });
        
        // Show dropdown
        this.dropdown.style.display = 'block';
        this.dropdown.style.width = `${this.input.offsetWidth}px`;
    }
    
    hide() {
        this.dropdown.style.display = 'none';
        this.selectedIndex = -1;
    }
    
    highlightItem(index) {
        // Remove previous highlight
        const items = this.dropdown.querySelectorAll('.suggestion-item');
        items.forEach(item => {
            item.style.background = 'white';
            item.style.color = 'black';
        });
        
        // Add new highlight
        if (items[index]) {
            items[index].style.background = '#007bff';
            items[index].style.color = 'white';
            this.selectedIndex = index;
        }
    }
    
    selectItem(index) {
        if (this.currentMatches[index]) {
            this.input.value = this.currentMatches[index];
            this.hide();
            this.input.focus();
            
            if (this.onSelect) {
                this.onSelect(this.currentMatches[index]);
            }
        }
    }
    
    handleKeydown(e) {
        if (!this.dropdown.style.display || this.dropdown.style.display === 'none') {
            return;
        }
        
        const items = this.dropdown.querySelectorAll('.suggestion-item');
        
        switch (e.key) {
            case 'ArrowDown':
                e.preventDefault();
                this.selectedIndex = Math.min(this.selectedIndex + 1, items.length - 1);
                this.highlightItem(this.selectedIndex);
                break;
                
            case 'ArrowUp':
                e.preventDefault();
                this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
                if (this.selectedIndex === -1) {
                    const items = this.dropdown.querySelectorAll('.suggestion-item');
                    items.forEach(item => {
                        item.style.background = 'white';
                        item.style.color = 'black';
                    });
                } else {
                    this.highlightItem(this.selectedIndex);
                }
                break;
                
            case 'Enter':
                if (this.selectedIndex >= 0) {
                    e.preventDefault();
                    this.selectItem(this.selectedIndex);
                }
                break;
                
            case 'Escape':
                this.hide();
                break;
        }
    }
}

// Main validation function
function validateAndCorrectAddress(inputId, messageId) {
    const inputElement = document.getElementById(inputId);
    const messageElement = document.getElementById(messageId);
    
    if (!inputElement || !messageElement) {
        console.error('Input or message element not found');
        return null;
    }
    
    const userInput = inputElement.value.trim();
    
    if (!userInput) {
        messageElement.textContent = 'Please enter an address';
        messageElement.style.color = '#ff4444';
        return null;
    }
    
    const result = findLocationMatch(userInput);
    
    if (!result) {
        messageElement.textContent = 'Location not found. Please select from suggestions.';
        messageElement.style.color = '#ff4444';
        return null;
    }
    
    if (result.type === 'exact') {
        messageElement.textContent = 'âœ“ Valid location';
        messageElement.style.color = '#00aa00';
        return {
            found: true,
            corrected: result.match,
            original: userInput,
            confidence: result.confidence
        };
    } else if (result.type === 'prefix' && result.confidence > 0.8) {
        // Auto-correct for high confidence prefix matches
        inputElement.value = result.match;
        messageElement.textContent = 'âœ“ Auto-corrected to: ' + result.match;
        messageElement.style.color = '#00aa00';
        return {
            found: true,
            corrected: result.match,
            original: userInput,
            confidence: result.confidence
        };
    } else {
        messageElement.textContent = 'Multiple matches found. Please select from suggestions.';
        messageElement.style.color = '#ff8800';
        return null;
    }
}

// Initialize the address validation with auto-complete
function initializeAddressValidation(inputId = 'address-input', messageId = 'address-validation-message') {
    const inputElement = document.getElementById(inputId);
    const messageElement = document.getElementById(messageId);
    
    if (!inputElement) return;
    
    // Create suggestion dropdown
    const suggestionDropdown = new LocationSuggestionDropdown(inputElement, (selectedLocation) => {
        if (messageElement) {
            messageElement.textContent = 'âœ“ Selected: ' + selectedLocation;
            messageElement.style.color = '#00aa00';
        }
    });
    
    // Validate on blur
    inputElement.addEventListener('blur', function() {
        validateAndCorrectAddress(inputId, messageId);
        suggestionDropdown.hide();
    });
    
    // Clear message on focus
    inputElement.addEventListener('focus', function() {
        if (messageElement) {
            messageElement.textContent = 'Start typing to see suggestions (e.g., "Kanc" for "KANCHIYAR")';
            messageElement.style.color = '#666';
        }
    });
    
    // Add placeholder example
    if (!inputElement.hasAttribute('placeholder')) {
        inputElement.placeholder = 'Type "Kanc" for KANCHIYAR...';
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    initializeAddressValidation();
    
    // Add some styles for the suggestions
    const style = document.createElement('style');
    style.textContent = `
        .suggestion-item:hover {
            background-color: #f0f0f0 !important;
            color: #333 !important;
        }
        
        .validation-message {
            font-size: 12px;
            margin-top: 4px;
            min-height: 18px;
            font-weight: normal;
        }
        
        .form-input {
            position: relative;
        }
    `;
    document.head.appendChild(style);
});

// Export for use in other modules
window.KeralaAddressAutoComplete = {
    validateAndCorrectAddress,
    initializeAddressValidation,
    findLocationMatch,
    locations: KERALA_LOCATIONS2
};
</script>
</body>
</html>

