<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Editor</title>

    <!-- QR Code Library -->
    <script src="Pdf/qrcode.min.js"></script>
    
    
<style>
    /* All your existing CSS styles remain the same */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
/* --- BODY HIDE/SHOW STYLES --- */
    body {
        margin: 0;
        padding: 0;
        font-family: 'Roboto', Arial, sans-serif;
        height: 100vh;
        overflow: hidden;
    }
    
    /* When the body has the 'locked' class, it will hide everything */
    body.locked {
        display: none;
    }
    
    
    /* Login Page Styles */
    .login-container {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        position: relative;
        overflow: hidden;
    }
    
    .login-container::before {
        content: "";
        position: absolute;
        width: 200%;
        height: 200%;
        background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        animation: bgMove 20s linear infinite;
    }
    
    @keyframes bgMove {
        0% { transform: translate(0, 0); }
        100% { transform: translate(-50px, -50px); }
    }
    
    .login-card {
        background-color: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        width: 400px;
        padding: 40px;
        text-align: center;
        position: relative;
        z-index: 10;
        transform: translateY(0);
        transition: transform 0.3s ease;
    }
    
    .login-card:hover {
        transform: translateY(-5px);
    }
    
    .login-title {
        font-size: 28px;
        font-weight: 700;
        margin-bottom: 10px;
        color: #667eea;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .form-group {
        margin-bottom: 25px;
        text-align: left;
    }
    
    .form-label {
        display: block;
        font-size: 14px;
        color: #555;
        font-weight: 500;
        margin-bottom: 8px;
    }
    
    .form-input {
        width: 100%;
        padding: 14px;
        border: 2px solid #e0e0e0;
        border-radius: 10px;
        background-color: white;
        font-family: 'Roboto', Arial, sans-serif;
        font-size: 14px;
        transition: all 0.3s ease;
    }
    
    .form-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .login-btn {
        width: 100%;
        padding: 14px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }
    
    .login-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    
    .login-btn:disabled {
        background: linear-gradient(135deg, #a0a0a0 0%, #808080 100%);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
    }
    
    .error-message {
        color: #e74c3c;
        margin-top: 10px;
        font-size: 14px;
        display: none;
    }

    /* App Container Styles */
    .app-container {
        display: none;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
    }
    
    header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 25px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        z-index: 100;
    }
    
    .title {
        font-size: 22px;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .title::before {
        content: "ðŸ“„";
        font-size: 24px;
    }
    
    .header-controls {
        display: flex;
        gap: 15px;
    }
    
    .save-btn {
        padding: 10px 20px;
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .save-btn#save-btn {
        background-color: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
    }
    .save-btn#save-btn:hover {
        background-color: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
    }
    
    .save-btn#logout-btn {
        background-color: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
    }
    .save-btn#logout-btn:hover {
        background-color: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
    }
    
    /* QR Code Button */
    .save-btn#qr-btn {
        background-color: rgba(76, 175, 80, 0.7);
    }
    .save-btn#qr-btn:hover {
        background-color: rgba(76, 175, 80, 0.9);
        transform: translateY(-2px);
    }
    
    .form-section {
        background: linear-gradient(to bottom, #f8f9fa, #ffffff);
        padding: 20px 25px;
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: flex-end;
        box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        max-height: 240px;
        overflow-y: auto;
        border-bottom: 1px solid #eaeaea;
    }
    
    .form-section::-webkit-scrollbar {
        width: 8px;
    }
    
    .form-section::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    
    .form-section::-webkit-scrollbar-thumb {
        background: #ddd;
        border-radius: 10px;
    }
    
    .form-section::-webkit-scrollbar-thumb:hover {
        background: #ccc;
    }
    
    .form-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
        flex: 1;
        min-width: 200px;
    }
    
    .form-label {
        font-size: 14px;
        color: #555;
        font-weight: 600;
    }
    
    .form-input {
        padding: 10px 14px;
        border: 2px solid #e0e0e0;
        border-radius: 10px;
        background-color: white;
        font-family: 'Roboto', Arial, sans-serif;
        font-size: 14px;
        width: 100%;
        transition: all 0.3s ease;
    }
    
    .form-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .distance-input-group {
        display: flex;
        align-items: center;
    }
    
    .distance-input {
        flex: 1;
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
    }
    
    .distance-suffix {
        background-color: #f8f9fa;
        border: 2px solid #e0e0e0;
        border-left: none;
        border-top-right-radius: 10px;
        border-bottom-right-radius: 10px;
        padding: 10px 14px;
        font-family: 'Roboto', Arial, sans-serif;
        font-size: 14px;
        color: #555;
        font-weight: 600;
    }
    
    .radio-group {
        display: flex;
        gap: 15px;
        margin-top: 5px;
    }
    
    .radio-option {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .radio-option input[type="radio"] {
        margin: 0;
        width: 18px;
        height: 18px;
    }
    
    .radio-option label {
        font-size: 14px;
        color: #555;
        cursor: pointer;
        font-weight: 500;
    }
    
    .apply-btn {
        padding: 10px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        height: 42px;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }
    
    .apply-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    
    .toolbar {
        background-color: #f8f9fa;
        padding: 15px 25px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    }
    
    .toolbar-group {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .toolbar-label {
        font-size: 14px;
        color: #555;
        font-weight: 600;
    }
    
    .page-nav {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .page-btn {
        width: 36px;
        height: 36px;
        border: 1px solid #e0e0e0;
        background-color: white;
        border-radius: 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        transition: all 0.3s ease;
    }
    
    .page-btn:hover:not(:disabled) {
        background-color: #f8f9fa;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .page-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .page-info {
        font-size: 14px;
        font-weight: 600;
        min-width: 80px;
        text-align: center;
        color: #667eea;
    }
    
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .zoom-btn {
        width: 36px;
        height: 36px;
        border: 1px solid #e0e0e0;
        background-color: white;
        border-radius: 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        transition: all 0.3s ease;
    }
    
    .zoom-btn:hover {
        background-color: #f8f9fa;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .zoom-level {
        font-size: 14px;
        font-weight: 600;
        min-width: 50px;
        text-align: center;
        color: #667eea;
    }
    
     .pdf-container {
            flex: 1;
            overflow: auto;
            background-color: #eaeaea;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            position: relative;
        }
        
        .pdf-page {
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            background-color: white;
            margin: 20px;
        }
        
        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }
        
        #pdf-canvas, #edit-canvas {
            display: block;
        }
        
        #edit-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }
        
    
    .text-box {
        position: absolute;
        border: 2px dashed #667eea;
        background-color: rgba(102, 126, 234, 0.15);
        cursor: pointer;
        z-index: 20;
        transition: all 0.3s ease;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        border-radius: 6px;
    }
    
    .text-box:hover {
        background-color: rgba(102, 126, 234, 0.25);
        border-color: #764ba2;
        transform: scale(1.02);
    }
    
    .text-box.edited {
        border-color: #27ae60;
        background-color: rgba(39, 174, 96, 0.15);
    }
    
    .text-input {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 20px;
        border: none;
        background-color: white;
        font-family: 'Roboto', Arial, sans-serif;
        z-index: 10000;
        outline: none;
        box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        border-radius: 15px;
        font-size: 16px;
        min-width: 400px;
        max-width: 80%;
    }
    
    .text-input:focus {
        box-shadow: 0 0 0 5px rgba(102, 126, 234, 0.2);
    }
    
    .edit-controls {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
        flex-wrap: wrap;
    }
    
    .control-group {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .control-label {
        font-size: 14px;
        color: #555;
        font-weight: 600;
        min-width: 50px;
    }
    
    .color-input {
        width: 50px;
        height: 35px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        cursor: pointer;
    }
    
    .font-select {
        padding: 8px 12px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        background-color: white;
        font-family: 'Roboto', Arial, sans-serif;
        cursor: pointer;
        font-size: 14px;
    }
    
    .font-btn {
        padding: 8px 15px;
        border: 2px solid #e0e0e0;
        background-color: white;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
    }
    
    .font-btn.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
    }
    
    .font-btn:hover {
        background-color: #f8f9fa;
    }
    
    .bold-btn {
        padding: 8px 15px;
        border: 2px solid #e0e0e0;
        background-color: white;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        font-size: 14px;
        transition: all 0.3s ease;
    }
    
    .bold-btn.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
    }
    
    .bold-btn:hover {
        background-color: #f8f9fa;
    }
    
    .dialog-buttons {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-top: 20px;
    }
    
    .dialog-btn {
        padding: 12px 24px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
    }
    
    .dialog-btn-save {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }
    
    .dialog-btn-save:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    
    .dialog-btn-cancel {
        background-color: #f8f9fa;
        color: #7f8c8d;
        border: 1px solid #e0e0e0;
    }
    
    .dialog-btn-cancel:hover {
        background-color: #e1e4e8;
    }
    
    .notification {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        z-index: 1000;
        opacity: 0;
        transition: all 0.3s ease;
        font-size: 16px;
        font-weight: 500;
    }
    
    .notification.show {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
    }
    
    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255,255,255,0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    
    .loading-overlay.show {
        opacity: 1;
        pointer-events: all;
    }
    
    .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(102, 126, 234, 0.2);
        border-radius: 50%;
        border-top-color: #667eea;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    
    
    /* New buttons for save/load edits */
.save-btn#save-edits-btn {
    background-color: rgba(76, 175, 80, 0.7);
}
.save-btn#save-edits-btn:hover {
    background-color: rgba(76, 175, 80, 0.9);
    transform: translateY(-2px);
}

.save-btn#load-edits-btn {
    background-color: rgba(33, 150, 243, 0.7);
}
.save-btn#load-edits-btn:hover {
    background-color: rgba(33, 150, 243, 0.9);
    transform: translateY(-2px);
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    overflow: auto;
}

.modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: none;
    border-radius: 15px;
    width: 50%;
    max-width: 500px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}

.modal-title {
    font-size: 18px;
    font-weight: 600;
    color: #333;
}

.close {
    color: #aaa;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover {
    color: #333;
}

.modal-body {
    margin-bottom: 20px;
}

.modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.modal-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.modal-btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.modal-btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
}

.modal-btn-secondary {
    background-color: #f8f9fa;
    color: #7f8c8d;
    border: 1px solid #e0e0e0;
}

.modal-btn-secondary:hover {
    background-color: #e1e4e8;
}

.file-input-wrapper {
    position: relative;
    overflow: hidden;
    display: inline-block;
    width: 100%;
}

.file-input-wrapper input[type=file] {
    position: absolute;
    left: -9999px;
}

.file-input-label {
    display: block;
    padding: 10px 14px;
    border: 2px dashed #667eea;
    border-radius: 10px;
    background-color: rgba(102, 126, 234, 0.05);
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    color: #667eea;
    font-weight: 500;
}

.file-input-label:hover {
    background-color: rgba(102, 126, 234, 0.1);
}

.file-name {
    margin-top: 10px;
    font-size: 14px;
    color: #555;
    word-break: break-all;
}

/* QR Code Modal Styles */
#qr-modal .modal-content {
    width: 60%;
    max-width: 600px;
}

#qr-code-container {
    display: flex;
    justify-content: center;
    margin: 20px 0;
}

#qr-code-preview {
    border: 1px solid #e0e0e0;
    padding: 15px;
    background-color: white;
    border-radius: 10px;
}

.qr-size-controls {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.qr-size-slider {
    flex: 1;
    display:none;
}

.qr-size-value {
    min-width: 60px;
    text-align: center;
    font-weight: 600;
    color: #667eea;
    
}

.qr-position-controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 15px;
}

.position-btn {
    padding: 10px;
    border: 2px solid #e0e0e0;
    background-color: white;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
}

.position-btn:hover {
    background-color: #f8f9fa;
}

.position-btn.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-color: #667eea;
}

/* QR Code Box */
.qr-box {
    position: absolute;
    border: 2px dashed #27ae60;
    background-color: rgba(39, 174, 96, 0.15);
    cursor: move;
    z-index: 25;
    transition: all 0.3s ease;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.qr-box:hover {
    background-color: rgba(39, 174, 96, 0.25);
    border-color: #219653;
    transform: scale(1.02);
}

.qr-box img {
    max-width: 100%;
    max-height: 100%;
}

.qr-box .resize-handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: #27ae60;
    border: 1px solid white;
    border-radius: 50%;
}

.qr-box .resize-handle.se {
    bottom: -5px;
    right: -5px;
    cursor: se-resize;
}

/* Mobile and Desktop Responsive Fixes */

/* Mobile Devices (Portrait) */
@media (max-width: 768px) {
    /* Login Page */
    .login-card {
        width: 90%;
        padding: 30px 20px;
    }
    
    /* App Container */
    header {
        padding: 10px 15px;
        flex-wrap: wrap;
        flex-direction: column;
        gap: 10px;
    }
    
    .title {
        font-size: 18px;
        width: 100%;
        text-align: center;
    }
    
    .header-controls {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
        gap: 10px;
    }
    
    .save-btn {
        padding: 8px 12px;
        font-size: 12px;
        flex: 1;
        min-width: 120px;
        justify-content: center;
    }
    
    /* Form Section */
    .form-section {
        max-height: none;
        padding: 15px;
    }
    
    .form-group {
        min-width: 100%;
        flex: 1 1 100%;
    }
    
    .apply-btn {
        width: 100%;
        margin-top: 10px;
    }
    
    /* Toolbar */
    .toolbar {
        padding: 10px;
        flex-wrap: wrap;
        justify-content: center;
    }
    
    .page-nav, .zoom-controls {
        width: 100%;
        justify-content: center;
    }
    
    /* PDF Container */
    .pdf-container {
        padding: 10px;
    }
    
    .pdf-page {
        margin: 10px;
    }
    
    .canvas-wrapper {
        max-width: 100%;
        overflow: auto;
    }
    
    #pdf-canvas, #edit-canvas {
        max-width: 100%;
        height: auto;
    }
    
    /* Text Input Dialog */
    .text-input {
        min-width: 250px;
        max-width: 90%;
    }
    
    /* Modal */
    .modal-content {
        width: 95%;
        margin: 10% auto;
        padding: 15px;
    }
    
    .modal-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }
    
    .modal-footer {
        flex-direction: column;
        gap: 10px;
    }
    
    .modal-btn {
        width: 100%;
    }
    
    /* QR Code Modal */
    #qr-modal .modal-content {
        width: 95%;
    }
    
    .qr-position-controls {
        grid-template-columns: repeat(2, 1fr);
    }
}

/* Mobile Devices (Landscape) */
@media (max-width: 1024px) and (orientation: landscape) {
    .form-section {
        max-height: 200px;
    }
    
    .pdf-container {
        padding: 0px;
    }
}

/* Tablets and Small Desktops */
@media (min-width: 769px) and (max-width: 1024px) {
    .login-card {
        width: 70%;
    }
    
    .form-group {
        min-width: 45%;
    }
    
    .header-controls {
        flex-wrap: wrap;
    }
    
    .save-btn {
        padding: 8px 15px;
        font-size: 13px;
    }
}

/* Large Desktops */
@media (min-width: 1200px) {
    .login-card {
        width: 400px;
    }
    
    .app-container {
        max-width: 1400px;
        margin: 0 auto;
    }
}

/* Ultra-wide Desktops */
@media (min-width: 1600px) {
    .pdf-container {
        padding: 40px;
    }
    
    .pdf-page {
        margin: 40px;
    }
}

/* Fix for iOS Safari */
@supports (-webkit-touch-callout: none) {
    .header-controls {
        padding-bottom: env(safe-area-inset-bottom);
    }
    
    .form-section {
        padding-bottom: env(safe-area-inset-bottom);
    }
}

/* Fix for Android devices */
@media screen and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: .001dpcm) {
    .form-input, .page-btn, .zoom-btn, .apply-btn {
        touch-action: manipulation;
    }
}
/* --- Modern Quality Selection Dropdown --- */
.quality-selection {
    display: flex;
    align-items: center;
    gap: 15px; /* Increased space for a cleaner look */
    padding: 15px 20px;
    background-color: #ffffff;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Soft, modern shadow */
    border: 1px solid #e9ecef;
    margin-bottom: 20px; /* More space to separate from other elements */
}

.quality-selection label {
    font-family: 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    font-size: 15px;
    font-weight: 600; /* Bolder font for the label */
    color: #343a40; /* A strong, dark grey */
    white-space: nowrap; /* Prevents the label from wrapping */
}

.quality-select {
    /* The select element itself */
    padding: 10px 35px 10px 15px; /* More padding, and extra on the right for the arrow */
    border: 1px solid #ced4da;
    border-radius: 6px;
    background-color: #fff;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e"); /* Custom SVG arrow */
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px;
    font-family: 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    font-size: 15px;
    color: #495057;
    cursor: pointer;
    appearance: none; /* Hides the default browser arrow */
    -webkit-appearance: none; /* For Safari */
    -moz-appearance: none; /* For Firefox */
    transition: all 0.2s ease-in-out;
}

/* Hover state */
.quality-select:hover {
    border-color: #adb5bd;
}

/* Focus state for better accessibility */
.quality-select:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}


        .image-box {
            position: absolute;
            border: 2px dashed #667eea;
            
            cursor: pointer;
            z-index: 20;
            transition: all 0.2s;
        }

        .image-box:hover {
            
            border-color: #667eea;
        }

/* --- RESPONSIVE RADIO BUTTON GROUP FIX --- */

/* Target the container for the radio buttons */
.form-group .radio-group {
    display: flex;              /* Use Flexbox for layout */
    flex-wrap: wrap;           /* Allow items to wrap to the next line */
    gap: 15px;               /* Space between items */
    margin-top: 5px;
}

/* Target each individual radio button option */
.form-group .radio-option {
    display: flex;             /* Use Flexbox to align icon and text */
    align-items: center;        /* Vertically center the icon and text */
    gap: 5px;                 /* Space between the radio circle and its label */
    white-space: nowrap;        /* Prevent the label text from wrapping */
    flex-shrink: 0;           /* Prevent the item from shrinking on small screens */
}

/* Optional: Ensure radio buttons have a minimum size on very small screens */
@media (max-width: 480px) {
    .form-group .radio-option {
        min-width: 45%; /* Force items to take up nearly half the screen width */
    }
}

.validation-message {
    font-size: 12px;
    margin-top: 5px;
    min-height: 16px;
}

.validation-message.error {
    color: #e74c3c;
}

.validation-message.success {
    color: #27ae60;
}

.form-input.error {
    border-color: #e74c3c;
}

.form-input.success {
    border-color: #27ae60;
}
.saved-data-list {
    max-height: 400px;
    overflow-y: auto;
}

.saved-data-item {
    padding: 15px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.saved-data-item:hover {
    background-color: #f8f9fa;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.saved-data-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.saved-data-item-date {
    font-weight: 600;
    color: #667eea;
}

.saved-data-item-delete {
    color: #e74c3c;
    cursor: pointer;
    font-size: 18px;
}

.saved-data-item-content {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}

.saved-data-item-field {
    font-size: 14px;
}

.saved-data-item-field-name {
    font-weight: 600;
    color: #555;
}

.saved-data-item-field-value {
    color: #333;
}

.empty-list-message {
    text-align: center;
    padding: 20px;
    color: #7f8c8d;
    font-style: italic;
}
/* QR Code Download Button */
#qr-download-btn {
    /* Inherit base styles from your modal buttons */
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: background-color 0.3s, transform 0.1s;
    margin-right: 10px; /* Adds space between this and the Cancel button */
}

/* Default state - A nice, friendly blue */
#qr-download-btn.modal-btn-info {
    background-color: #17a2b8;
    color: white;
}

/* Hover state - A slightly darker blue */
#qr-download-btn.modal-btn-info:hover {
    background-color: #138496;
    transform: translateY(-1px);
}

/* Active/Clicked state */
#qr-download-btn.modal-btn-info:active {
    transform: translateY(0);
    background-color: #117a8b;
}

/* Disabled state - Important for when the QR code isn't ready yet */
#qr-download-btn:disabled {
    background-color: #cccccc;
    color: #666666;
    cursor: not-allowed;
    transform: none;
}
/* --- END OF RADIO BUTTON FIX --- */
</style>
</head>
<body>
    <!-- Login Page -->
    <div class="login-container" id="login-container">
        <div class="login-card">
            <h1 class="login-title">PDF Form Editor</h1>
            <p style="margin-bottom: 30px; color: #7f8c8d;">Please sign in to continue</p>
            
            <form id="login-form">
                <div class="form-group">
                    <label class="form-label" for="username">Username</label>
                    <input type="text" id="username" class="form-input" placeholder="Enter your username" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="password">Password</label>
                    <input type="password" id="password" class="form-input" placeholder="Enter your password" required>
                </div>
                <button type="submit" class="login-btn" id="login-btn">Login</button>
                <div class="error-message" id="login-error"></div>
            </form>
        </div>
    </div>
    
    <!-- PDF Editor App (hidden initially) -->
    <div class="app-container" id="app-container">
        <header>
            <div class="title">PDF Form Editor</div>
            <div class="header-controls">
                <button class="save-btn" id="save-btn">ðŸ’¾ Save PDF</button>
                <button class="save-btn" id="logout-btn">ðŸšª Logout</button>
                <!-- In the <header> element, inside .header-controls -->
<button class="save-btn" id="save-edits-btn">ðŸ’¾ Save Edits</button>
<button class="save-btn" id="load-edits-btn">ðŸ“‚ Load Edits</button>
<button class="save-btn" id="qr-btn">ðŸ”² QR Code</button>
            </div>
        </header>
              
<div class="quality-selection">
    <label for="quality-select">Output Quality:</label>
    <select id="quality-select">
        <option value="standard">Standard</option>
        <option value="high">High</option>
        <option value="ultra">Ultra</option>
        <option value="HD" selected>HD</option>
        <option value="pc">PC</option>
        <option value="ultraHD">Ultra HD</option>
        <option value="print">Print Quality</option>
        
    </select>
</div>

    <!-- Hidden file input for images -->
    <input type="file" id="image-input" accept="image/*" style="display: none;">
    
        <div class="form-section">
            <div class="form-group">
                <label class="form-label" for="purchaser-input">Name of Purchaser:</label>
                <input type="text" id="purchaser-input" class="form-input" placeholder="BIG B TRANZ" required>
            </div>
            
              <div class="form-group">

                <label class="form-label" for="Bulk-input">Bulk Transit Pass No:</label>
                       <input type="text" id="Bulk-input" class="form-input" placeholder="THNSY250001534" required>
            </div>
            
            
            
            <div class="form-group">
                <label class="form-label" for="security-input">Security Paper Serial No:</label>
                <input type="text" id="security-input" class="form-input" placeholder="TSPS01907125" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="transit-input">Transit Pass Serial No:</label>
                <input type="text" id="transit-input" class="form-input" placeholder="THN000000056770/2025" required>
            </div>
            <div class="form-group">
                <label class="form-label">Destination and State:</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="tamilnadu-radio" name="destination-option" value="tamilnadu">
                        <label for="tamilnadu-radio">Tamilnadu</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="kerala-radio" name="destination-option" value="kerala" checked>
                        <label for="kerala-radio">Kerala</label>
                    </div>
                </div>
            </div>
<div class="form-group">
    <label class="form-label" for="address-input">Address of the Purchaser:</label>
    <input type="text" id="address-input" class="form-input" placeholder="ANACHAL" required>
    <div id="address-validation-message" class="validation-message"></div>
</div>
<div class="form-group">
    <label class="form-label" for="driver-input">Name of Vehicle Driver:</label>
    <input type="text" id="driver-input" class="form-input" placeholder="SREEJITH" required>
    <div id="driver-validation-message" class="validation-message"></div>
</div>
<div class="form-group">
    <label class="form-label" for="vehicle-input">Vehicle No:</label>
    <input type="text" id="vehicle-input" class="form-input" placeholder="KL69D3996" required>
    <div id="vehicle-validation-message" class="validation-message"></div>
</div>
            <div class="form-group">
                <label class="form-label">Name of Mineral / Mineral Products:</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="msand-radio" name="mineral-option" value="Rough Stone / M-Sand" checked>
                        <label for="msand-radio">M-Sand</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="psand-radio" name="mineral-option" value="Rough Stone / P-Sand">
                        <label for="psand-radio">P-Sand</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="jelly-radio" name="mineral-option" value="Rough Stone / Jelly">
                        <label for="jelly-radio">Jelly</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="dust-radio" name="mineral-option" value="Rough Stone / Dust">
                        <label for="dust-radio">Dust</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="roughstone-radio" name="mineral-option" value="Rough Stone / Rough Stone">
                        <label for="roughstone-radio">Rough Stone</label>
                    </div>
                </div>
            </div>
<div class="form-group">
    <label class="form-label" for="quantity-input">Quantity(in MT):</label>
    <input type="number" id="quantity-input" class="form-input" placeholder="35" required>
    <div id="quantity-validation-message" class="validation-message"></div>
</div>
            <div class="form-group">
                <label class="form-label" for="hours-input">Duration (hours):</label>
                <input type="number" id="hours-input" class="form-input" placeholder="5" min="1" max="24" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="timestart-input">Start Time:</label>
                <input type="text" id="timestart-input" class="form-input" placeholder="19-11-2025 08:32" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="timeend-input">End Time:</label>
                <input type="text" id="timeend-input" class="form-input" placeholder="13-11-2025 13:32" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="dispatchdatetime-input">Date & Time of Dispatch:</label>
                <input type="text" id="dispatchdatetime-input" class="form-input" placeholder="17-11-2025 09:00" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="distance-input">Approximate Distance:</label>
                <div class="distance-input-group">
                    <input type="number" id="distance-input" class="form-input distance-input" placeholder="151" min="0" required>
                    <div class="distance-suffix">kms</div>
                </div>
            </div>
            <button class="apply-btn" id="apply-btn">Apply to PDF</button>
        </div>
        
        <div class="toolbar">
            <div class="page-nav">
                <button class="page-btn" id="prev-page">â€¹</button>
                <span class="page-info" id="page-info">Page 1 of 1</span>
                <button class="page-btn" id="next-page">â€º</button>
            </div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoom-out">âˆ’</button>
                <span class="zoom-level" id="zoom-level">150%</span>
                <button class="zoom-btn" id="zoom-in">+</button>
            </div>
        </div>
        
        <div class="pdf-container" id="pdf-container">
            <div class="pdf-page" id="pdf-page">
                <div class="canvas-wrapper" id="canvas-wrapper">
                    <canvas id="pdf-canvas"></canvas>
                    <canvas id="edit-canvas"></canvas>
                </div>
                <div class="loading-overlay" id="loading-overlay">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        
        <!-- Save Edits Modal -->
<div id="save-edits-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">Save PDF Edits</h2>
            <span class="close" id="save-modal-close">&times;</span>
        </div>
        <div class="modal-body">
            <p>Save your PDF edits to a file for later use.</p>
            <div class="form-group">
                <label class="form-label" for="save-filename">File Name:</label>
                <input type="text" id="save-filename" class="form-input" placeholder="My PDF Edits" value="My PDF Edits">
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-btn modal-btn-secondary" id="save-modal-cancel">Cancel</button>
            <button class="modal-btn modal-btn-primary" id="save-modal-confirm">Save</button>
        </div>
    </div>
</div>

<!-- Load Edits Modal -->
<div id="load-edits-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">Load PDF Edits</h2>
            <span class="close" id="load-modal-close">&times;</span>
        </div>
        <div class="modal-body">
            <p>Load your previously saved PDF edits from a file.</p>
            <div class="file-input-wrapper">
                <input type="file" id="load-file-input" accept=".json">
                <label for="load-file-input" class="file-input-label">
                    Choose a file
                </label>
                <div class="file-name" id="load-file-name">No file selected</div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-btn modal-btn-secondary" id="load-modal-cancel">Cancel</button>
            <button class="modal-btn modal-btn-primary" id="load-modal-confirm">Load</button>
        </div>
    </div>
</div>

<!-- QR Code Modal -->
<div id="qr-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">QR Code Generator</h2>
            <span class="close" id="qr-modal-close">&times;</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label class="form-label" for="qr-text-input">QR Code Content:</label>
                <input type="text" id="qr-text-input" class="form-input" placeholder="Enter text or URL for QR code">
            </div>
            
            <div class="qr-size-controls">
                <label class="form-label" for="qr-size-slider">Size:</label>
                <input type="range" id="qr-size-slider" class="qr-size-slider" min="50" max="300" value="198">
                <div class="qr-size-value" id="qr-size-value">198px</div>
            </div>
            
            <div class="form-group">
                <label class="form-label">Position on PDF:</label>
                <div class="qr-position-controls">
                    <button class="position-btn" data-position="top-left">Top Left</button>
                    <button class="position-btn" data-position="top-center">Top Center</button>
                    <button class="position-btn" data-position="top-right">Top Right</button>
                    <button class="position-btn" data-position="middle-left">Middle Left</button>
                    <button class="position-btn active" data-position="middle-center">Middle Center</button>
                    <button class="position-btn" data-position="middle-right">Middle Right</button>
                    <button class="position-btn" data-position="bottom-left">Bottom Left</button>
                    <button class="position-btn" data-position="bottom-center">Bottom Center</button>
                    <button class="position-btn" data-position="bottom-right">Bottom Right</button>
                </div>
            </div>
            
            <div id="qr-code-container">
                <div id="qr-code-preview"></div>
            </div>
        </div>
        <div class="modal-footer">
  <button class="modal-btn modal-btn-primary" id="qr-download-btn">Download QR Code</button>
            <button class="modal-btn modal-btn-secondary" id="qr-modal-cancel">Cancel</button>
            <button class="modal-btn modal-btn-primary" id="qr-modal-confirm">Add to PDF</button>
        </div>
    </div>
</div>

<!-- Saved Data List Modal -->
<div id="saved-data-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">Saved Form Data</h2>
            <span class="close" id="saved-data-modal-close">&times;</span>
        </div>
        <div class="modal-body">
            <div id="saved-data-list" class="saved-data-list">
                <!-- Saved data items will be added here dynamically -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-btn modal-btn-secondary" id="saved-data-modal-close-btn">Close</button>
        </div>
    </div>
</div>

        <!-- Edit Dialog -->
        <div class="text-input" id="edit-dialog" style="display: none;">
            <div class="edit-controls">
                <div class="control-group">
                    <label class="control-label">Font:</label>
                    <select class="font-select" id="font-select">
                        <option value="Roboto Thin">Roboto Thin</option>
                        <option value="Roboto Light">Roboto Light</option>
                        <option value="Roboto" selected>Roboto Regular</option>
                        <option value="Roboto Medium">Roboto Medium</option>
                        <option value="Roboto Bold">Roboto Bold</option>
                        <option value="Roboto Black">Roboto Black</option>
                        <option value="Arial">Arial</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Color:</label>
                    <input type="color" class="color-input" id="text-color" value="#000000">
                </div>
                <div class="control-group">
                    <label class="control-label">Style:</label>
                    <button class="font-btn" id="thin-btn">Thin</button>
                    <button class="bold-btn" id="bold-btn">B</button>
                </div>
            </div>
            <input type="text" id="dialog-input" placeholder="Enter new text...">
            <div class="dialog-buttons">
                <button class="dialog-btn dialog-btn-save" id="dialog-save">Save</button>
                <button class="dialog-btn dialog-btn-cancel" id="dialog-cancel">Cancel</button>
            </div>
        </div>
        
        <div class="notification" id="notification"></div>
    </div>

  
  
     <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js"></script>
    
    <!-- PDF.js and other libraries -->
    <script src="Pdf/pdf.min.js"></script>
    <script src="Pdf/jspdf.umd.min.js"></script>
    <script src="Pdf/crypto-js.min.js"></script>
    
    <script>
    // Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
        authDomain: "vipteammod-movies.firebaseapp.com",
        projectId: "vipteammod-movies",
        storageBucket: "vipteammod-movies.appspot.com",
        messagingSenderId: "1024721077525",
        appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
        databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();

    // --- FIREBASE CONTROL ---
    const body = document.body;
    const appLockRef = db.ref("featureControl/appLock");
    const logoutControlRef = db.ref("featureControl/logoutControl");
    const appTitleRef = db.ref("featureControl/appTitle");
    const redirectUrlRef = db.ref("featureControl/redirectUrl");
    const redirectEnabledRef = db.ref("featureControl/redirectEnabled"); // <-- ADD THIS
    

    let isAppLocked = false;

    // Function to update app title
    function updateAppTitle(newTitle) {
        const titleElement = document.querySelector('.login-title');
        if (titleElement) {
            titleElement.textContent = newTitle;
        }
    }

    // Function to hide/show app based on lock status
    function handleAppLock(isLocked) {
        isAppLocked = isLocked;
        if (isLocked) {
            body.classList.add('locked');
        } else {
            body.classList.remove('locked');
        }
    }

    // Function to handle logout
    function handleLogout() {
        auth.signOut()
            .then(() => {
                document.getElementById('login-container').style.display = 'flex';
                document.getElementById('app-container').style.display = 'none';
                showNotification('Logged out successfully');
                document.getElementById('login-form').reset();
                document.getElementById('login-btn').textContent = 'Login';
                document.getElementById('login-btn').disabled = false;
                document.getElementById('login-error').style.display = 'none';
            })
            .catch((error) => {
                console.error('Logout error:', error);
                showNotification('Error during logout');
            });
    }

    // Listen for changes to app lock status
    appLockRef.on("value", (snapshot) => {
        const isLocked = snapshot.val() === true;
        handleAppLock(isLocked);
    });

    // Listen for changes to logout control
    logoutControlRef.on("value", (snapshot) => {
        const shouldLogout = snapshot.val() === true;
        if (shouldLogout) {
            handleLogout();
            logoutControlRef.set(false); // Reset the control
        }
    });

    // Listen for changes to app title
    appTitleRef.on("value", (snapshot) => {
        const newTitle = snapshot.val();
        if (newTitle) {
            updateAppTitle(newTitle);
        }
    });

    // Listen for changes to redirect URL
redirectUrlRef.on("value", (urlSnapshot) => {
    const redirectUrl = urlSnapshot.val();
    
    // First, check if a URL exists and is a non-empty string
    if (redirectUrl && redirectUrl.trim() !== '') {
        // THEN, check if redirect is ENABLED in the admin panel
        redirectEnabledRef.once("value", (enabledSnapshot) => {
            const isRedirectEnabled = enabledSnapshot.val() === true;
            
            // Only proceed if BOTH conditions are met
            if (isRedirectEnabled) {
                try {
                    // Validate URL to ensure it's properly formatted
                    const url = new URL(redirectUrl);
                    
                    // If it's a valid URL, show a notification and redirect
                    showNotification(`ðŸ”— Redirecting to: ${redirectUrl}`);
                    
                    // Perform redirect after a short delay to allow the user to see the notification
                    setTimeout(() => {
                        window.location.href = redirectUrl;
                    }, 1500); // 1.5 second delay

                } catch (e) {
                    // If the URL is invalid, log an error to the console
                    console.error("Invalid redirect URL received from Firebase:", redirectUrl);
                }
            } else {
                // Optional: Log to console that redirect is disabled
                console.log("Redirect URL received, but redirect is DISABLED in admin panel.");
            }
        });
    }
});

// UPDATED: Listen for changes to redirect URL and status
redirectUrlRef.on("value", (urlSnapshot) => {
    const redirectUrl = urlSnapshot.val();
    
    if (redirectUrl && redirectUrl.trim() !== '') {
        redirectEnabledRef.once("value", (enabledSnapshot) => {
            const isRedirectEnabled = enabledSnapshot.val() === true;
            
            if (isRedirectEnabled) {
                try {
                    const url = new URL(redirectUrl);
                    showNotification(`ðŸ”— Redirecting to: ${redirectUrl}`);
                    setTimeout(() => {
                        window.location.href = redirectUrl;
                    }, 1500);
                } catch (e) {
                    console.error("Invalid redirect URL received from Firebase:", redirectUrl);
                }
            } else {
                console.log("Redirect URL received, but redirect is DISABLED in admin panel.");
            }
        });
    }
});
    // Check if user is already signed in
    auth.onAuthStateChanged((user) => {
        if (user && !isAppLocked) {
            document.getElementById('login-container').style.display = 'none';
            document.getElementById('app-container').style.display = 'flex';
        } else {
            document.getElementById('login-container').style.display = 'flex';
            document.getElementById('app-container').style.display = 'none';
        }
    });
    
    // Handle login form submission
    document.getElementById('login-form').addEventListener('submit', (e) => {
        e.preventDefault();
        
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        const loginBtn = document.getElementById('login-btn');
        const errorMessage = document.getElementById('login-error');
        
        // Update button state
        loginBtn.textContent = 'Logging in...';
        loginBtn.disabled = true;
        errorMessage.style.display = 'none';
        
        // For Firebase authentication, we need an email address
        // We'll append a domain to the username to create a valid email
        const email = username + '@gmail.com';
        
        // Sign in with Firebase
        auth.signInWithEmailAndPassword(email, password)
            .then((userCredential) => {
                // Signed in successfully
                const user = userCredential.user;
                document.getElementById('login-container').style.display = 'none';
                document.getElementById('app-container').style.display = 'flex';
                
                showNotification('Login successful');
            })
            .catch((error) => {
                // Handle errors
                const errorCode = error.code;
                let errorText = 'Login failed. Please check your username and password.';
                
                if (errorCode === 'auth/user-not-found') {
                    errorText = 'User not found. Please check your username.';
                } else if (errorCode === 'auth/wrong-password') {
                    errorText = 'Incorrect password. Please try again.';
                } else if (errorCode === 'auth/invalid-email') {
                    errorText = 'Invalid username format.';
                }
                
                errorMessage.textContent = errorText;
                errorMessage.style.display = 'block';
                
                // Reset button state
                loginBtn.textContent = 'Login';
                loginBtn.disabled = false;
            });
    });
    
    // Add logout functionality
    document.getElementById('logout-btn').addEventListener('click', () => {
        auth.signOut()
            .then(() => {
                // Sign-out successful
                document.getElementById('login-container').style.display = 'flex';
                document.getElementById('app-container').style.display = 'none';
                showNotification('Logged out successfully');
                
                // Reset login form
                document.getElementById('login-form').reset();
                document.getElementById('login-btn').textContent = 'Login';
                document.getElementById('login-btn').disabled = false;
                document.getElementById('login-error').style.display = 'none';
            })
            .catch((error) => {
                // An error happened
                console.error('Logout error:', error);
                showNotification('Error during logout');
            });
    });
    
    // Function to show notification
    function showNotification(message) {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.classList.add('show');
        
        setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }
    
    // Set up PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'Pdf/pdf.worker.min.js';
</script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // State variables
        let pdfDoc = null;
        let pageNum = 1;
        let pageCount = 1;
        let scale = 1.5;
        let pdfHash = ''; // Unique identifier for current PDF
        let allPageEdits = {}; // Holds edits for all pages of current PDF
        let textItems = []; // Holds text items for currently rendered page
        let imageItems = []; // Holds image items for currently rendered page
        let textBoxes = [];
        let imageBoxes = [];
        let currentViewport = null;
        let originalPageSize = { width: 0, height: 0 }; // Store original PDF page dimensions
        let currentEditingTextItem = null;
        let currentEditingTextBox = null;
        let currentEditingImageItem = null;
        let currentTextColor = '#000000';
        let currentTextBold = false;
        let currentTextThin = false;
        let currentFontFamily = 'Roboto';
        let originalTextStyles = {}; // Store all original text styles
        let formFields = {}; // Store form field positions
        let qrCodeBoxes = []; // Store QR code boxes
        let qrCodePosition = 'middle-center'; // Default QR code position
        let qrCodeSize = 198; // Default QR code size in pixels
        let qrcode = null; // QR code instance
        let currentQRCodeBox = null; // Current QR code box on the page

        // DOM elements
        const purchaserInput = document.getElementById('purchaser-input');
        const BulkTransitInput = document.getElementById('Bulk-input');
        const securityInput = document.getElementById('security-input');
        const transitInput = document.getElementById('transit-input');
        const addressInput = document.getElementById('address-input');
        const driverInput = document.getElementById('driver-input');
        const vehicleInput = document.getElementById('vehicle-input');
        const mineralInput = document.getElementById('mineral-input');
        const quantityInput = document.getElementById('quantity-input');
        const hoursInput = document.getElementById('hours-input');
        const timestartInput = document.getElementById('timestart-input');
        const timeendInput = document.getElementById('timeend-input');
        const dispatchdatetimeInput = document.getElementById('dispatchdatetime-input');
        const distanceInput = document.getElementById('distance-input');
        const tamilnaduRadio = document.getElementById('tamilnadu-radio');
        const keralaRadio = document.getElementById('kerala-radio');
        const msandRadio = document.getElementById('msand-radio');
        const psandRadio = document.getElementById('psand-radio');
        const jellyRadio = document.getElementById('jelly-radio');
        const dustRadio = document.getElementById('dust-radio');
        const roughstoneRadio = document.getElementById('roughstone-radio');
        const applyBtn = document.getElementById('apply-btn');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const editCanvas = document.getElementById('edit-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const editCtx = editCanvas.getContext('2d');
        const pdfContainer = document.getElementById('pdf-container');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const pdfPage = document.getElementById('pdf-page');
        const loadingOverlay = document.getElementById('loading-overlay');
        const notification = document.getElementById('notification');
        const editDialog = document.getElementById('edit-dialog');
        const dialogInput = document.getElementById('dialog-input');
        const dialogSave = document.getElementById('dialog-save');
        const dialogCancel = document.getElementById('dialog-cancel');
        const textColorInput = document.getElementById('text-color');
        const boldBtn = document.getElementById('bold-btn');
        const thinBtn = document.getElementById('thin-btn');
        const fontSelect = document.getElementById('font-select');
        const qualitySelect = document.getElementById('quality-select');
        const imageInput = document.getElementById('image-input');
        
        // Modal elements
        const saveEditsModal = document.getElementById('save-edits-modal');
        const loadEditsModal = document.getElementById('load-edits-modal');
        const saveModalClose = document.getElementById('save-modal-close');
        const loadModalClose = document.getElementById('load-modal-close');
        const saveModalCancel = document.getElementById('save-modal-cancel');
        const loadModalCancel = document.getElementById('load-modal-cancel');
        const saveModalConfirm = document.getElementById('save-modal-confirm');
        const loadModalConfirm = document.getElementById('load-modal-confirm');
        const saveFilenameInput = document.getElementById('save-filename');
        const loadFileInput = document.getElementById('load-file-input');
        const loadFileName = document.getElementById('load-file-name');
        
        // QR Code Modal elements
        const qrModal = document.getElementById('qr-modal');
        const qrModalClose = document.getElementById('qr-modal-close');
        const qrModalCancel = document.getElementById('qr-modal-cancel');
        const qrModalConfirm = document.getElementById('qr-modal-confirm');
        const qrTextInput = document.getElementById('qr-text-input');
        const qrSizeSlider = document.getElementById('qr-size-slider');
        const qrSizeValue = document.getElementById('qr-size-value');
        const qrCodePreview = document.getElementById('qr-code-preview');
        const qrPositionBtns = document.querySelectorAll('.position-btn');
        const qrDownloadBtn = document.getElementById('qr-download-btn');
        qrDownloadBtn.addEventListener('click', downloadQRCode);
        securityInput.value = 'TSPS02631997';
        transitInput.value = 'THN000000061914/2025';
        BulkTransitInput.value = 'THNSY250001592';
        distanceInput.value = '151';
        
                    dispatchdatetimeInput.value = '';
        timeendInput.value = '';
        timestartInput.value = '';
        hoursInput.value = '';
        quantityInput.value = '';
        vehicleInput.value = '';
        driverInput.value = '';
        addressInput.value = '';
        purchaserInput.value = '';
        
        
        
        // Add this to your setupEventListeners function or in a separate script section
function setupDriverNameValidation() {
    const driverInput = document.getElementById('driver-input');
    const validationMessage = document.getElementById('driver-validation-message');
    
    // Function to validate driver name
    function validateDriverName() {
        const driverName = driverInput.value.trim();
        
        // Reset validation state
        driverInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!driverName) {
            return false;
        }
        
        // Check if it contains numbers (likely a vehicle number)
        if (/\d/.test(driverName)) {
            driverInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'This appears to be a vehicle number, not a name. Driver names should contain only letters.';
            return false;
        }
        
        // Check if it contains only letters and spaces
        const nameRegex = /^[A-Za-z\s]+$/;
        if (nameRegex.test(driverName)) {
            driverInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid driver name';
            return true;
        } else {
            driverInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Invalid driver name. Names should contain only letters and spaces.';
            return false;
        }
    }
    
    // Add event listener to validate on input
    driverInput.addEventListener('input', validateDriverName);
    
    // Also validate on blur (when user clicks away)
    driverInput.addEventListener('blur', validateDriverName);
}

// Add this to your setupEventListeners function or in a separate script section
function setupQuantityValidation() {
    const quantityInput = document.getElementById('quantity-input');
    const validationMessage = document.getElementById('quantity-validation-message');
    
    // Allowed quantity values
    const allowedQuantities = [5, 10, 18, 19, 25, 35];
    
    // Function to validate quantity
    function validateQuantity() {
        const quantityValue = quantityInput.value.trim();
        
        // Reset validation state
        quantityInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!quantityValue) {
            return false;
        }
        
        // Check if it contains only numbers
        if (!/^\d+$/.test(quantityValue)) {
            quantityInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Quantity must be a number';
            return false;
        }
        
        // Convert to integer for comparison
        const quantity = parseInt(quantityValue, 10);
        
        // Check if it's one of the allowed values
        if (allowedQuantities.includes(quantity)) {
            quantityInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid quantity';
            return true;
        } else {
            quantityInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = `Invalid quantity. Allowed values: ${allowedQuantities.join(', ')}`;
            return false;
        }
    }
    
    // Function to filter input to only allow numbers
    function filterNumberInput(e) {
        // Allow backspace, delete, tab, escape, enter
        if ([8, 9, 27, 13].indexOf(e.keyCode) !== -1 ||
            // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
            (e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 67 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 86 && (e.ctrlKey === true || e.metaKey === true)) ||
            (e.keyCode === 88 && (e.ctrlKey === true || e.metaKey === true))) {
            return;
        }
        
        // Ensure that it is a number and stop the keypress
        if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
            e.preventDefault();
        }
    }
    
    // Add event listener to filter non-numeric input
    quantityInput.addEventListener('keydown', filterNumberInput);
    
    // Add event listener to validate on input
    quantityInput.addEventListener('input', validateQuantity);
    
    // Also validate on blur (when user clicks away)
    quantityInput.addEventListener('blur', validateQuantity);
}


// Add this to your setupEventListeners function or in a separate script section
function setupAddressValidation() {
    const addressInput = document.getElementById('address-input');
    const validationMessage = document.getElementById('address-validation-message');
    
    // Function to validate the address
    function validateAddress() {
        const addressValue = addressInput.value.trim();
        
        // Reset validation state
        addressInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!addressValue) {
            return false;
        }
        
        // This regex allows ONLY:
        // Uppercase and lowercase letters (A-Z, a-z)
        // Spaces (\s)
        const addressRegex = /^[A-Za-z\s]+$/;
        
        if (addressRegex.test(addressValue)) {
            addressInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid address format';
            return true;
        } else {
            addressInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Invalid format. Only letters and spaces are allowed.';
            return false;
        }
    }
    
    // Add event listener to validate on input
    addressInput.addEventListener('input', validateAddress);
    
    // Also validate on blur (when user clicks away)
    addressInput.addEventListener('blur', validateAddress);
}


        // Add this to your setupEventListeners function or in a separate script section
function setupVehicleNumberValidation() {
    const vehicleInput = document.getElementById('vehicle-input');
    const validationMessage = document.getElementById('vehicle-validation-message');
    
    // Function to validate vehicle number format
    function validateVehicleNumber() {
        const vehicleNumber = vehicleInput.value.trim().toUpperCase();
        
        // Reset validation state
        vehicleInput.classList.remove('error', 'success');
        validationMessage.classList.remove('error', 'success');
        validationMessage.textContent = '';
        
        if (!vehicleNumber) {
            return false;
        }
        
        // Check if it contains only letters (likely a name)
        if (/^[A-Z]+$/.test(vehicleNumber)) {
            vehicleInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'This appears to be a name, not a vehicle number. Vehicle numbers should contain both letters and numbers.';
            return false;
        }
        
        // Check if it matches Indian vehicle number format
        const vehicleRegex = /^[A-Z]{2}[0-9]{1,2}[A-Z]{0,3}[0-9]{4}$/;
        if (vehicleRegex.test(vehicleNumber)) {
            vehicleInput.classList.add('success');
            validationMessage.classList.add('success');
            validationMessage.textContent = 'Valid vehicle number format';
            return true;
        } else {
            vehicleInput.classList.add('error');
            validationMessage.classList.add('error');
            validationMessage.textContent = 'Invalid vehicle number format. Example: KL69D3996';
            return false;
        }
    }
    
    // Add event listener to validate on input
    vehicleInput.addEventListener('input', validateVehicleNumber);
    
    // Also validate on blur (when user clicks away)
    vehicleInput.addEventListener('blur', validateVehicleNumber);
}


// Add an 'input' event listener to validate the value as the user types
quantityInput.addEventListener('input', function (e) {
    // 1. Remove any non-digit characters from the input value
    // This replaces anything that is NOT a number (0-9) with an empty string
    let value = this.value.replace(/[^0-9]/g, '');

    // 2. Limit the value to a maximum of 2 digits
    // The 'slice' method cuts the string if it's longer than 2 characters
    if (value.length > 2) {
        value = value.slice(0, 2);
    }

    // 3. Update the input field with the cleaned and limited value
    this.value = value;
});

// --- END OF QUANTITY INPUT VALIDATION ---
        // Initialize
        function init() {
            setupEventListeners();
            loadSamplePdf();
        }
        
        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('prev-page').addEventListener('click', () => { 
                if (pageNum > 1) { pageNum--; renderPage(pageNum); }
            });
            document.getElementById('next-page').addEventListener('click', () => { 
                if (pageNum < pageCount) { pageNum++; renderPage(pageNum); }
            });
            document.getElementById('zoom-in').addEventListener('click', () => { 
                scale = Math.min(scale * 1.2, 3.0); renderPage(pageNum); 
            });
            document.getElementById('zoom-out').addEventListener('click', () => { 
                scale = Math.max(scale / 1.2, 0.5); renderPage(pageNum); 
            });
            document.getElementById('save-btn').addEventListener('click', savePDF);
            applyBtn.addEventListener('click', applyFormData);
            
            // New buttons for save/load edits
            document.getElementById('save-edits-btn').addEventListener('click', openSaveEditsModal);
            document.getElementById('load-edits-btn').addEventListener('click', openLoadEditsModal);
            
            // QR Code button
            document.getElementById('qr-btn').addEventListener('click', openQRModal);
            
            // Image input event listener
            imageInput.addEventListener('change', handleImageSelect);
            
            // Modal event listeners
            saveModalClose.addEventListener('click', closeSaveEditsModal);
            loadModalClose.addEventListener('click', closeLoadEditsModal);
            saveModalCancel.addEventListener('click', closeSaveEditsModal);
            loadModalCancel.addEventListener('click', closeLoadEditsModal);
            saveModalConfirm.addEventListener('click', saveEditsToFile);
            loadModalConfirm.addEventListener('click', loadEditsFromFile);
            loadFileInput.addEventListener('change', updateLoadFileName);
            
            // QR Code Modal event listeners
            qrModalClose.addEventListener('click', closeQRModal);
            qrModalCancel.addEventListener('click', closeQRModal);
            qrModalConfirm.addEventListener('click', addQRCodeToPDF);
            qrTextInput.addEventListener('input', generateQRCodePreview);
            qrSizeSlider.addEventListener('input', updateQRSize);
            
            // QR Position button listeners
            qrPositionBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    qrPositionBtns.forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    qrCodePosition = e.target.dataset.position;
                });
            });
            
            // Radio button change handlers
            tamilnaduRadio.addEventListener('change', () => {
                if (tamilnaduRadio.checked) {
                    updateDestinationField(', Tamilnadu');
                }
            });
            
            keralaRadio.addEventListener('change', () => {
                if (keralaRadio.checked) {
                    updateDestinationField('ANACHAL, Others');
                }
            });
            
            // Mineral radio button change handlers
            [msandRadio, psandRadio, jellyRadio, dustRadio, roughstoneRadio].forEach(radio => {
                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        updateMineralField(radio.value);
                    }
                });
            });
            
// --- UPDATED HOURS INPUT HANDLER ---

hoursInput.addEventListener('input', () => {
    // Get the value from the hours input
    const hours = parseInt(hoursInput.value) || 0;

    // Check if the input is empty or has a valid number
    if (hoursInput.value.trim() === '') {
        // If the input is EMPTY, clear all related fields
        timestartInput.value = '';
        timeendInput.value = '';
        dispatchdatetimeInput.value = '';
    } else if (hours > 0) {
        // If the input has a number, calculate the times
        const now = new Date();
        const startDate = new Date(now);
        const endDate = new Date(now);
        endDate.setHours(endDate.getHours() + hours);
        
        // Format dates as dd-MM-yyyy HH:mm
        const formatDate = (date) => {
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${day}-${month}-${year} ${hours}:${minutes}`;
        };
        
        timestartInput.value = formatDate(startDate);
        timeendInput.value = formatDate(endDate);
        
        // Also update the dispatch time when hours are entered
        setDefaultDispatchTime();
        setupVehicleNumberValidation();
        setupQuantityValidation();
        setupDriverNameValidation();
        setupAddressValidation();
    }
});
setupVehicleNumberValidation();
setupAddressValidation();
setupDriverNameValidation();
setupQuantityValidation();

// --- END OF UPDATED HANDLER ---
// --- CORRECTED DISPATCH DATE & TIME LOGIC (REAL DATE) ---

// Get the dispatch input element
const dispatchdatetimeInput = document.getElementById('dispatchdatetime-input');

// 1. Set a default value to the current time + 2 minutes
function setDefaultDispatchTime() {
    // Create a new date object with the ORIGINAL current date and time
    const dispatchDate = new Date();
    
    // Add exactly 2 minutes to the current time
    dispatchDate.setMinutes(dispatchDate.getMinutes() + 2);
    
    // --- REMOVE THIS LINE ---
    // dispatchDate.setFullYear(2025, 10, 25); // Month is 0-indexed (10 = November)
    
    // Format the date as dd-MM-yyyy hh:mm:ss (12-hour format)
    const day = String(dispatchDate.getDate()).padStart(2, '0');
    const month = String(dispatchDate.getMonth() + 1).padStart(2, '0');
    const year = dispatchDate.getFullYear();
    
    // Get hours and convert to 12-hour format
    let hours = dispatchDate.getHours();
    hours = hours % 12;
    hours = hours ? hours : 12; // The hour '0' should be '12'
    
    const minutes = String(dispatchDate.getMinutes()).padStart(2, '0');
    const seconds = String(dispatchDate.getSeconds()).padStart(2, '0');

    dispatchdatetimeInput.value = `${day}-${month}-${year} ${String(hours).padStart(2, '0')}:${minutes}:${seconds}`;
}

// 2. Add validation for when the user changes the input
dispatchdatetimeInput.addEventListener('input', () => {
    const value = dispatchdatetimeInput.value.trim();
    
    // Basic check for the correct format "dd-MM-yyyy hh:mm:ss"
    const formatRegex = /^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}$/;
    if (!formatRegex.test(value)) {
        dispatchdatetimeInput.setCustomValidity('Invalid format. Please use dd-MM-yyyy hh:mm:ss');
        dispatchdatetimeInput.reportValidity();
        return; // Stop further checks
    }

    try {
        // Parse the parts of the date and time
        const parts = value.split(' ');
        const dateParts = parts[0].split('-');
        const timeParts = parts[1].split(':');

        const day = parseInt(dateParts[0]);
        const month = parseInt(dateParts[1]);
        const year = parseInt(dateParts[2]);
        const hours = parseInt(timeParts[0]);
        const minutes = parseInt(timeParts[1]);
        const seconds = parseInt(timeParts[2]);

        // Validate the date and time components
        if (month < 1 || month > 12) {
            throw new Error("Month must be between 01 and 12.");
        }
        if (day < 1 || day > 31) {
            throw new Error("Day must be between 01 and 31.");
        }
        // Validation for 12-hour format (1 to 12)
        if (hours < 1 || hours > 12) {
            throw new Error("Hours must be between 01 and 12.");
        }
        if (minutes < 0 || minutes > 59) {
            throw new Error("Minutes must be between 00 and 59.");
        }
        if (seconds < 0 || seconds > 59) {
            throw new Error("Seconds must be between 00 and 59.");
        }

        // If all checks pass, clear any previous errors
        dispatchdatetimeInput.setCustomValidity('');

    } catch (e) {
        // If any check fails, show an error message
        dispatchdatetimeInput.setCustomValidity(e.message);
        dispatchdatetimeInput.reportValidity();
    }
});


// --- END OF CORRECTED LOGIC ---
            // Address input change handler
            addressInput.addEventListener('input', updateAddressAndDestination);
            
            // Distance input change handler
            distanceInput.addEventListener('input', () => {
                let value = distanceInput.value.replace(/[^0-9]/g, '');
                distanceInput.value = value;
            });
            
            dialogSave.addEventListener('click', saveDialogText);
            dialogCancel.addEventListener('click', closeDialog);
            dialogInput.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter') saveDialogText(); 
                else if (e.key === 'Escape') closeDialog(); 
            });
            textColorInput.addEventListener('change', (e) => { currentTextColor = e.target.value; });
            boldBtn.addEventListener('click', () => { 
                currentTextBold = !currentTextBold; 
                boldBtn.classList.toggle('active'); 
                if (currentTextBold) {
                    currentTextThin = false;
                    thinBtn.classList.remove('active');
                }
            });
            thinBtn.addEventListener('click', () => { 
                currentTextThin = !currentTextThin; 
                thinBtn.classList.toggle('active'); 
                if (currentTextThin) {
                    currentTextBold = false;
                    boldBtn.classList.remove('active');
                }
            });
            fontSelect.addEventListener('change', (e) => { 
                currentFontFamily = e.target.value;
                if (currentFontFamily === 'Roboto Thin') {
                    currentTextThin = true;
                    currentTextBold = false;
                    thinBtn.classList.add('active');
                    boldBtn.classList.remove('active');
                } else if (currentFontFamily === 'Roboto Bold' || currentFontFamily === 'Roboto Black') {
                    currentTextBold = true;
                    currentTextThin = false;
                    boldBtn.classList.add('active');
                    thinBtn.classList.remove('active');
                } else {
                    currentTextBold = false;
                    currentTextThin = false;
                    boldBtn.classList.remove('active');
                    thinBtn.classList.remove('active');
                }
            });
            
            // Close modals when clicking outside
            window.addEventListener('click', (event) => {
                if (event.target === saveEditsModal) closeSaveEditsModal();
                if (event.target === loadEditsModal) closeLoadEditsModal();
                if (event.target === qrModal) closeQRModal();
            });
        }
        
        // Handle image selection for replacement
        function handleImageSelect(e) {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith('image/') || !currentEditingImageItem) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const imageData = event.target.result;
                const itemIndex = currentEditingImageItem.index;

                // Update master state
                if (!allPageEdits[pageNum]) allPageEdits[pageNum] = { textEdits: [], images: [] };
                const pageEdits = allPageEdits[pageNum];
                const existingImageEdit = pageEdits.images.find(edit => edit.index === itemIndex);
                
                if (existingImageEdit) {
                    existingImageEdit.data = imageData;
                } else {
                    pageEdits.images.push({ index: itemIndex, data: imageData });
                }

                // Update derived state
                const imageItem = imageItems.find(item => item.index === itemIndex);
                if (imageItem) {
                    imageItem.edited = true;
                    imageItem.newImageData = imageData;
                }

                // Redraw UI - IMPORTANT: Clear and redraw everything
                redrawEditedContent();
                if(currentEditingImageItem.box) {
                    currentEditingImageItem.box.classList.add('edited');
                }
                showNotification('Image replaced and saved.');
            };
            reader.readAsDataURL(file);
            imageInput.value = '';
        }
        
        // --- MODAL FUNCTIONS ---
        
        function openSaveEditsModal() {
            saveEditsModal.style.display = 'block';
            const today = new Date();
            const dateStr = today.toISOString().slice(0, 10);
            saveFilenameInput.value = `PDF Edits ${dateStr}`;
        }
        
        function closeSaveEditsModal() {
            saveEditsModal.style.display = 'none';
        }
        
        function openLoadEditsModal() {
            loadEditsModal.style.display = 'block';
        }
        
        function closeLoadEditsModal() {
            loadEditsModal.style.display = 'none';
            loadFileInput.value = '';
            loadFileName.textContent = 'No file selected';
        }
        
        function updateLoadFileName() {
            if (loadFileInput.files.length > 0) {
                loadFileName.textContent = loadFileInput.files[0].name;
            } else {
                loadFileName.textContent = 'No file selected';
            }
        }
        
      // --- QR CODE MODAL FUNCTIONS ---

async function detectQRCodeArea() {
    if (!pdfDoc) return null;
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2.0 });
        
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = viewport.width;
        tempCanvas.height = viewport.height;
        
        await page.render({
            canvasContext: tempCtx,
            viewport: viewport
        }).promise;
        
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const pixels = imageData.data;
        
        const qrAreas = [];
        const minSize = 30;
        const maxSize = 200;
        
        for (let y = 0; y < tempCanvas.height - minSize; y += 10) {
            for (let x = 0; x < tempCanvas.width - minSize; x += 10) {
                for (let size = minSize; size <= maxSize && size < Math.min(tempCanvas.width - x, tempCanvas.height - y); size += 10) {
                    const corners = [
                        { x: x, y: y },
                        { x: x + size - 1, y: y },
                        { x: x, y: y + size - 1 },
                        { x: x + size - 1, y: y + size - 1 }
                    ];
                    
                    const cornerColors = corners.map(corner => {
                        const index = (corner.y * tempCanvas.width + corner.x) * 4;
                        return {
                            r: pixels[index],
                            g: pixels[index + 1],
                            b: pixels[index + 2]
                        };
                    });
                    
                    const hasBlack = cornerColors.some(c => c.r < 50 && c.g < 50 && c.b < 50);
                    const hasWhite = cornerColors.some(c => c.r > 200 && c.g > 200 && c.b > 200);
                    
                    if (hasBlack && hasWhite) {
                        const centerIndex = ((y + size/2) * tempCanvas.width + (x + size/2)) * 4;
                        const centerColor = {
                            r: pixels[centerIndex],
                            g: pixels[centerIndex + 1],
                            b: pixels[centerIndex + 2]
                        };
                        
                        if (centerColor.r > 50 && centerColor.r < 200) {
                            qrAreas.push({
                                x: x / 2.0,
                                y: y / 2.0,
                                width: size / 2.0,
                                height: size / 2.0,
                                confidence: 0.8
                            });
                            break;
                        }
                    }
                }
            }
        }
        
        if (qrAreas.length > 0) {
            qrAreas.sort((a, b) => (b.confidence * b.width) - (a.confidence * a.width));
            return qrAreas[0];
        }
        
        return null;
    } catch (error) {
        console.error('Error detecting QR code area:', error);
        return null;
    }
}

// --- QR CODE MODAL FUNCTIONS ---
// --- QR CODE MODAL FUNCTIONS ---

// This function should be defined somewhere in your script
function getFormDataForQR() {
    // Get all the necessary form elements
    const BulkTransitInput = document.getElementById('Bulk-input');
    const transitInput = document.getElementById('transit-input');
    const vehicleInput = document.getElementById('vehicle-input');
    const addressInput = document.getElementById('address-input');
    const quantityInput = document.getElementById('quantity-input');
    const timestartInput = document.getElementById('timestart-input');
    
    // Get the values from the input fields
    const bulkTransitNo = BulkTransitInput ? BulkTransitInput.value : 'N/A';
    const quantity = quantityInput ? quantityInput.value : 'N/A';
    const startTime = timestartInput ? timestartInput.value : 'N/A';
    const transitPassNo = transitInput ? transitInput.value : 'N/A';
    const vehicleNo = vehicleInput ? vehicleInput.value : 'N/A';
    const address = addressInput ? addressInput.value : 'N/A';

    // Format the data into the desired string for the QR code
    return `${bulkTransitNo},Rough Stone(${quantity}MT),${startTime},${transitPassNo},${vehicleNo},${address}`;
}

async function detectQRCodeArea() {
    if (!pdfDoc) return null;
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2.0 });
        
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = viewport.width;
        tempCanvas.height = viewport.height;
        
        await page.render({
            canvasContext: tempCtx,
            viewport: viewport
        }).promise;
        
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const pixels = imageData.data;
        
        const qrAreas = [];
        const minSize = 30;
        const maxSize = 200;
        
        for (let y = 0; y < tempCanvas.height - minSize; y += 10) {
            for (let x = 0; x < tempCanvas.width - minSize; x += 10) {
                for (let size = minSize; size <= maxSize && size < Math.min(tempCanvas.width - x, tempCanvas.height - y); size += 10) {
                    const corners = [
                        { x: x, y: y },
                        { x: x + size - 1, y: y },
                        { x: x, y: y + size - 1 },
                        { x: x + size - 1, y: y + size - 1 }
                    ];
                    
                    const cornerColors = corners.map(corner => {
                        const index = (corner.y * tempCanvas.width + corner.x) * 4;
                        return {
                            r: pixels[index],
                            g: pixels[index + 1],
                            b: pixels[index + 2]
                        };
                    });
                    
                    const hasBlack = cornerColors.some(c => c.r < 50 && c.g < 50 && c.b < 50);
                    const hasWhite = cornerColors.some(c => c.r > 200 && c.g > 200 && c.b > 200);
                    
                    if (hasBlack && hasWhite) {
                        const centerIndex = ((y + size/2) * tempCanvas.width + (x + size/2)) * 4;
                        const centerColor = {
                            r: pixels[centerIndex],
                            g: pixels[centerIndex + 1],
                            b: pixels[centerIndex + 2]
                        };
                        
                        if (centerColor.r > 50 && centerColor.r < 200) {
                            qrAreas.push({
                                x: x / 2.0,
                                y: y / 2.0,
                                width: size / 2.0,
                                height: size / 2.0,
                                confidence: 0.8
                            });
                            break;
                        }
                    }
                }
            }
        }
        
        if (qrAreas.length > 0) {
            qrAreas.sort((a, b) => (b.confidence * b.width) - (a.confidence * a.width));
            return qrAreas[0];
        }
        
        return null;
    } catch (error) {
        console.error('Error detecting QR code area:', error);
        return null;
    }
}

async function openQRModal() {
    qrModal.style.display = 'block';
    
    // Call the function to get the data from the form
    const qrTextFromForm = getFormDataForQR();
    
    const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
    const existingQRCode = pageEdits.textEdits.find(edit => edit.isQRCode);
    
    if (existingQRCode) {
        qrTextInput.value = qrTextFromForm;
        const existingSize = Math.round(existingQRCode.width / scale);
        qrSizeSlider.value = existingSize;
        qrSizeValue.textContent = `${existingSize}px`;
        qrCodeSize = existingSize;
    } else {
        const detectedQR = await detectQRCodeArea();
        if (detectedQR) {
            qrTextInput.value = qrTextFromForm;

            
        } else {
            qrTextInput.value = qrTextFromForm;
            qrSizeSlider.value = 198;
            qrSizeValue.textContent = '198px';
            qrCodeSize = 198;
        }
    }
    
    generateQRCodePreview();
}

function closeQRModal() {
    qrModal.style.display = 'none';
    qrCodePreview.innerHTML = '';
    qrcode = null;
    // Clear the stored canvas when closing the modal
    if (window.qrCodeCanvas) {
        window.qrCodeCanvas = null;
    }
}

// --- FIXED QR CODE GENERATION AND DOWNLOAD ---

function generateQRCodePreview() {
    const text = qrTextInput.value.trim();
    if (!text) {
        qrCodePreview.innerHTML = '<p>Please enter text for the QR code</p>';
        if (window.qrCodeCanvas) {
            window.qrCodeCanvas = null;
        }
        // Disable download button if there's no QR code
        const downloadBtn = document.getElementById('qr-download-btn');
        if(downloadBtn) downloadBtn.disabled = true;
        return;
    }
    
    qrCodePreview.innerHTML = '<p>Generating QR Code...</p>';
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const padding = 18;
    
    canvas.width = qrCodeSize + (padding * 2);
    canvas.height = qrCodeSize + (padding * 2);
    
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const qrApiImg = new Image();
    qrApiImg.crossOrigin = "Anonymous";

    qrApiImg.onload = function() {
        ctx.drawImage(qrApiImg, padding, padding, qrCodeSize, qrCodeSize);
        
        window.qrCodeCanvas = canvas;
        
        const previewContainer = document.createElement('div');
        previewContainer.style.display = 'inline-block';
        previewContainer.style.boxShadow = '0 0 10px rgba(0,0,0,0.1)';
        
        const previewImg = document.createElement('img');
        previewImg.src = canvas.toDataURL('image/png');
        previewContainer.appendChild(previewImg);
        
        qrCodePreview.innerHTML = ''; // Clear "Generating..." message
        qrCodePreview.appendChild(previewContainer);

        // Enable download button
        const downloadBtn = document.getElementById('qr-download-btn');
        if(downloadBtn) downloadBtn.disabled = false;
    };
    
    qrApiImg.onerror = function() {
        qrCodePreview.innerHTML = '<p>Error generating QR code preview. Please try again.</p>';
        console.error("Failed to load QR code image from API.");
        // Disable download button on error
        const downloadBtn = document.getElementById('qr-download-btn');
        if(downloadBtn) downloadBtn.disabled = true;
    };

    qrApiImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=${qrCodeSize}x${qrCodeSize}&data=${encodeURIComponent(text)}`;
}

// --- UPDATED: The slider now only updates on 'change' event ---
function updateQRSize() {
    qrCodeSize = parseInt(qrSizeSlider.value);
    qrSizeValue.textContent = `198px`;
    
    if (qrTextInput.value.trim()) {
        generateQRCodePreview();
    }
}

// --- UPDATED: The download function is simpler now ---
function downloadQRCode() {
    if (!window.qrCodeCanvas) {
        showNotification('QR code not ready. Please wait for it to generate.');
        return;
    }
    
    const link = document.createElement('a');
    link.download = 'qrcode.png';
    link.href = window.qrCodeCanvas.toDataURL('image/png');
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showNotification('QR code downloaded successfully!');
}

function addQRCodeToPDF() {
    const text = qrTextInput.value.trim();
    if (!text) {
        showNotification('Please enter text for the QR code');
        return;
    }
    
    if (!pdfDoc) {
        showNotification('No PDF loaded');
        return;
    }

    if (!window.qrCodeCanvas) {
        showNotification('Error: QR code has not been generated yet.');
        return;
    }
    
    const qrDataUrl = window.qrCodeCanvas.toDataURL('image/png');
    
    if (currentQRCodeBox) {
        currentQRCodeBox.remove();
    }
    
    const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
    const existingQRCodeIndex = pageEdits.textEdits.findIndex(edit => edit.isQRCode);
    if (existingQRCodeIndex !== -1) {
        pageEdits.textEdits.splice(existingQRCodeIndex, 1);
    }
    
    let x, y, width, height;
    
    if (window.detectedQRPosition) {
        x = window.detectedQRPosition.x;
        y = window.detectedQRPosition.y;
        width = window.detectedQRPosition.width;
        height = window.detectedQRPosition.height;
        window.detectedQRPosition = null;
    } else {
        const padding = 20;
        width = qrCodeSize + (padding * 2);
        height = qrCodeSize + (padding * 2);
        
        switch (qrCodePosition) {
            case 'top-left': x = padding; y = padding; break;
            case 'top-center': x = (currentViewport.width - width) / 2; y = padding; break;
            case 'top-right': x = currentViewport.width - width - padding; y = padding; break;
            case 'middle-left': x = padding; y = (currentViewport.height - height) / 2; break;
            case 'middle-center': x = (currentViewport.width - width) / 2; y = (currentViewport.height - height) / 2; break;
            case 'middle-right': x = currentViewport.width - width - padding; y = (currentViewport.height - height) / 2; break;
            case 'bottom-left': x = padding; y = currentViewport.height - height - padding; break;
            case 'bottom-center': x = (currentViewport.width - width) / 2; y = currentViewport.height - height - padding; break;
            case 'bottom-right': x = currentViewport.width - width - padding; y = currentViewport.height - height - padding; break;
            default: x = (currentViewport.width - width) / 2; y = (currentViewport.height - height) / 2;
        }
    }
    
    const qrBox = document.createElement('div');
    qrBox.className = 'qr-box';
    qrBox.dataset.page = pageNum;
    
    const pdfPageRect = pdfPage.getBoundingClientRect();
    const canvasRect = canvasWrapper.getBoundingClientRect();
    
    const left = (canvasRect.left - pdfPageRect.left) + (x * scale);
    const top = (canvasRect.top - pdfPageRect.top) + ((y - height) * scale);
    
    qrBox.style.left = left + 'px';
    qrBox.style.top = top + 'px';
    qrBox.style.width = (width * scale) + 'px';
    qrBox.style.height = (height * scale) + 'px';
    
    const qrImg = document.createElement('img');
    qrImg.src = qrDataUrl;
    qrBox.appendChild(qrImg);
    
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle se';
    qrBox.appendChild(resizeHandle);
    
    // Drag functionality
    let isDragging = false;
    let startX, startY, initialX, initialY;
    
    qrBox.addEventListener('mousedown', (e) => {
        if (e.target === resizeHandle) return;
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        initialX = qrBox.offsetLeft;
        initialY = qrBox.offsetTop;
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', stopDrag);
        e.preventDefault();
    });
    
    function handleDrag(e) {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        qrBox.style.left = (initialX + dx) + 'px';
        qrBox.style.top = (initialY + dy) + 'px';
    }
    
    function stopDrag() {
        isDragging = false;
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('mouseup', stopDrag);
        updateQRCodeInStorage(qrBox);
    }
    
    // Resize functionality
    let isResizing = false;
    let startWidth, startHeight;
    
    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = qrBox.offsetWidth;
        startHeight = qrBox.offsetHeight;
        document.addEventListener('mousemove', handleResize);
        document.addEventListener('mouseup', stopResize);
        e.stopPropagation();
        e.preventDefault();
    });
    
    function handleResize(e) {
        if (!isResizing) return;
        const width = startWidth + (e.clientX - startX);
        const height = startHeight + (e.clientY - startY);
        const size = Math.max(width, height);
        qrBox.style.width = size + 'px';
        qrBox.style.height = size + 'px';
    }
    
    function stopResize() {
        isResizing = false;
        document.removeEventListener('mousemove', handleResize);
        document.removeEventListener('mouseup', stopResize);
        updateQRCodeInStorage(qrBox);
    }
    
    pdfPage.appendChild(qrBox);
    qrCodeBoxes.push(qrBox);
    currentQRCodeBox = qrBox;
    
    if (!allPageEdits[pageNum]) {
        allPageEdits[pageNum] = { textEdits: [], images: [] };
    }
    
    allPageEdits[pageNum].textEdits.push({
        isQRCode: true,
        text: text,
        x: x,
        y: y,
        width: width,
        height: height,
        qrCodeDataUrl: qrDataUrl
    });
    
    closeQRModal();
    showNotification('QR code added to PDF');
}

function updateQRCodeInStorage(qrBox) {
    if (!allPageEdits[pageNum]) {
        allPageEdits[pageNum] = { textEdits: [], images: [] };
    }
    
    const canvasRect = canvasWrapper.getBoundingClientRect();
    const pdfPageRect = pdfPage.getBoundingClientRect();
    
    const x = (qrBox.offsetLeft - (canvasRect.left - pdfPageRect.left)) / scale;
    const y = (qrBox.offsetTop - (canvasRect.top - pdfPageRect.top) + qrBox.offsetHeight) / scale;
    const width = qrBox.offsetWidth / scale;
    const height = qrBox.offsetHeight / scale;
    
    const qrCodeIndex = allPageEdits[pageNum].textEdits.findIndex(edit => edit.isQRCode);
    
    if (qrCodeIndex !== -1) {
        allPageEdits[pageNum].textEdits[qrCodeIndex].x = x;
        allPageEdits[pageNum].textEdits[qrCodeIndex].y = y;
        allPageEdits[pageNum].textEdits[qrCodeIndex].width = width;
        allPageEdits[pageNum].textEdits[qrCodeIndex].height = height;
    }
}

// --- END OF QR CODE MODAL FUNCTIONS ---

// --- END OF QR CODE MODAL FUNCTIONS ---
        // --- SAVE/LOAD EDIT FUNCTIONS ---
        
        function saveEditsToFile() {
            if (!pdfDoc) {
                showNotification('No PDF loaded to save edits for');
                return;
            }
            
            const filename = saveFilenameInput.value || 'PDF Edits';
            
            const editsData = {
                pdfHash: pdfHash,
                originalTextStyles: originalTextStyles,
                allPageEdits: allPageEdits,
                timestamp: new Date().toISOString()
            };
            
            const jsonStr = JSON.stringify(editsData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            closeSaveEditsModal();
            showNotification('PDF edits saved successfully');
        }
        
        function loadEditsFromFile() {
            if (!loadFileInput.files.length) {
                showNotification('Please select a file to load');
                return;
            }
            
            const file = loadFileInput.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const editsData = JSON.parse(e.target.result);
                    
                    if (!editsData.allPageEdits || !editsData.originalTextStyles) {
                        throw new Error('Invalid edits file format');
                    }
                    
                    allPageEdits = editsData.allPageEdits;
                    originalTextStyles = editsData.originalTextStyles;
                    
                    renderPage(pageNum);
                    
                    closeLoadEditsModal();
                    showNotification('PDF edits loaded successfully');
                } catch (error) {
                    console.error('Error loading edits:', error);
                    showNotification('Error loading edits: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        }
        
        // Load sample PDF automatically
        async function loadSamplePdf() {
            showLoading(true);
            try {
                const response = await fetch('sample.pdf');
                if (!response.ok) {
                    throw new Error('Failed to load sample.pdf');
                }
                const arrayBuffer = await response.arrayBuffer();
                pdfHash = await generatePdfHash(arrayBuffer);
                
                allPageEdits = {};
                originalTextStyles = {};
                formFields = {};
                qrCodeBoxes = [];
                currentQRCodeBox = null;
                imageItems = [];
                imageBoxes = [];
                currentEditingImageItem = null;

                const typedarray = new Uint8Array(arrayBuffer);
                pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                    pdfDoc = pdf;
                    pageCount = pdf.numPages;
                    pageNum = 1;
                    renderPage(pageNum);
                    showNotification('sample.pdf loaded successfully.');
                }).catch(error => {
                    console.error('Error loading sample.pdf:', error);
                    showNotification('Error loading sample.pdf: ' + error.message);
                    showLoading(false);
                });
            } catch (error) {
                console.error('Error loading sample.pdf:', error);
                showNotification('sample.pdf not found. Please ensure sample.pdf is in the same directory.');
                showLoading(false);
            }
        }
        
        // Update destination field based on selection
        function updateDestinationField(value) {
            if (formFields.destinationSelection) {
                const textItem = textItems.find(item => item.originalIndex === formFields.destinationSelection.originalIndex);
                if (textItem) {
                    textItem.text = value;
                    textItem.edited = true;
                    updateTextItem(textItem);
                }
            }
        }
        
        // Update mineral field based on selection
        function updateMineralField(value) {
            if (formFields.mineral) {
                const textItem = textItems.find(item => item.originalIndex === formFields.mineral.originalIndex);
                if (textItem) {
                    textItem.text = value;
                    textItem.edited = true;
                    updateTextItem(textItem);
                }
            }
        }
        
        // Update both address and destination fields when address changes
        function updateAddressAndDestination() {
            const addressValue = addressInput.value.trim();
            
            if (formFields.address && formFields.address.length > 0) {
                formFields.address.forEach((field, index) => {
                    const textItem = textItems.find(item => item.originalIndex === field.originalIndex);
                    if (textItem) {
                        textItem.text = addressValue;
                        textItem.edited = true;
                        updateTextItem(textItem);
                    }
                });
            }
            
            if (formFields.destinationSelection) {
                const textItem = textItems.find(item => item.originalIndex === formFields.destinationSelection.originalIndex);
                if (textItem) {
                    if (keralaRadio.checked) {
                        textItem.text = addressValue + ", Others";
                    } else if (tamilnaduRadio.checked) {
                        textItem.text = ", Tamilnadu";
                    }
                    textItem.edited = true;
                    updateTextItem(textItem);
                }
            }
        }
        

// Add this to your setupEventListeners function or in a separate script section
function setupAutoStateSelection() {
    const vehicleInput = document.getElementById('vehicle-input');
    const keralaRadio = document.getElementById('kerala-radio');
    const tamilnaduRadio = document.getElementById('tamilnadu-radio');
    
    // Function to automatically set state based on vehicle number
    function autoSelectState() {
        const vehicleNumber = vehicleInput.value.trim().toUpperCase();
        
        if (vehicleNumber.startsWith('TN')) {
            // Auto-select Tamil Nadu if vehicle starts with TN
            tamilnaduRadio.checked = true;
            keralaRadio.checked = false;
            showNotification('Destination automatically set to Tamilnadu based on vehicle number');
        } else if (vehicleNumber.startsWith('KL')) {
            // Auto-select Kerala if vehicle starts with KL
            keralaRadio.checked = true;
            tamilnaduRadio.checked = false;
            showNotification('Destination automatically set to Kerala based on vehicle number');
        }
    }
    
    // Add event listener to vehicle input
    vehicleInput.addEventListener('input', autoSelectState);
}

// Call this function when initializing your app
setupAutoStateSelection();
        
        // Generate a simple hash from PDF data
        async function generatePdfHash(arrayBuffer) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return 'pdfEdits_' + hashHex;
        }

        // Extract all styles from a text item
        function extractTextStyles(item) {
            const styles = {
                color: '#000000',
                fontFamily: 'Roboto',
                fontWeight: 'normal',
                isBold: false,
                isThin: false
            };
            
            if (item.color && Array.isArray(item.color) && item.color.length >= 3) {
                const r = Math.round(item.color[0] * 255);
                const g = Math.round(item.color[1] * 255);
                const b = Math.round(item.color[2] * 255);
                styles.color = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            if (item.fontName) {
                const fontName = item.fontName.toLowerCase();
                
                if (fontName.includes('helvetica') || fontName.includes('arial')) {
                    styles.fontFamily = 'Arial';
                } else if (fontName.includes('times')) {
                    styles.fontFamily = 'Times New Roman';
                } else if (fontName.includes('courier')) {
                    styles.fontFamily = 'Courier New';
                } else {
                    styles.fontFamily = 'Roboto';
                }
                
                if (fontName.includes('bold') || fontName.includes('black')) {
                    styles.fontWeight = 'bold';
                    styles.isBold = true;
                } else if (fontName.includes('thin') || fontName.includes('light')) {
                    styles.fontWeight = 'thin';
                    styles.isThin = true;
                } else {
                    styles.fontWeight = 'normal';
                }
            }
            
            return styles;
        }

        // Render PDF page
        function renderPage(num) {
            if (!pdfDoc) return;
            
            showLoading(true);
            clearTextBoxes();
            clearImageBoxes();
            clearQRCodeBoxes();
            
            pdfDoc.getPage(num).then(page => {
                currentViewport = page.getViewport({ scale: scale });
                originalPageSize = { width: currentViewport.width, height: currentViewport.height };

                pdfCanvas.width = currentViewport.width;
                pdfCanvas.height = currentViewport.height;
                editCanvas.width = currentViewport.width;
                editCanvas.height = currentViewport.height;
                canvasWrapper.style.width = currentViewport.width + 'px';
                canvasWrapper.style.height = currentViewport.height + 'px';
                
                const renderContext = { canvasContext: pdfCtx, viewport: currentViewport };
                return page.render(renderContext).promise;
            }).then(() => {
                return pdfDoc.getPage(pageNum).then(page => {
                    return page.getTextContent({ normalizeWhitespace: false, disableCombineTextItems: false });
                });
            }).then(textContent => {
                const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
                const newTextItems = [];

                if (textContent && textContent.items) {
                    const allTextItems = [];
                    textContent.items.forEach((item, index) => {
                        if (item.str && item.str.trim() !== '') {
                            const transform = item.transform;
                            const tx = pdfjsLib.Util.transform(currentViewport.transform, transform);
                            const x = tx[4];
                            const y = tx[5];
                            const width = item.width * scale;
                            const height = (item.height || 12) * scale;
                            
                            allTextItems.push({
                                text: item.str,
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                fontSize: (item.height || 12) * scale,
                                originalIndex: index,
                                item: item
                            });
                        }
                    });
                    
                    const groupedTextItems = groupTextItems(allTextItems);
                    
                    groupedTextItems.forEach((item, index) => {
                        const itemKey = `${pageNum}_${index}`;
                        
                        if (!originalTextStyles[itemKey]) {
                            originalTextStyles[itemKey] = extractTextStyles(item.item);
                        }
                        
                        const existingEdit = pageEdits.textEdits.find(edit => edit.originalIndex === index);
                        
                        const finalStyles = existingEdit ? {
                            color: existingEdit.color || originalTextStyles[itemKey].color,
                            fontFamily: existingEdit.fontFamily || originalTextStyles[itemKey].fontFamily,
                            fontWeight: existingEdit.fontWeight || originalTextStyles[itemKey].fontWeight,
                            isBold: existingEdit.isBold !== undefined ? existingEdit.isBold : originalTextStyles[itemKey].isBold,
                            isThin: existingEdit.isThin !== undefined ? existingEdit.isThin : originalTextStyles[itemKey].isThin
                        } : originalTextStyles[itemKey];

                        newTextItems.push({
                            text: existingEdit ? existingEdit.text : item.text,
                            x: item.x,
                            y: item.y,
                            width: item.width,
                            height: item.height,
                            fontSize: item.fontSize,
                            originalIndex: index,
                            edited: !!existingEdit,
                            color: finalStyles.color,
                            fontFamily: finalStyles.fontFamily,
                            fontWeight: finalStyles.fontWeight,
                            isBold: finalStyles.isBold,
                            isThin: finalStyles.isThin,
                            originalIndices: item.originalIndices || [index]
                        });
                    });
                }
                
                textItems = newTextItems;
                identifyFormFields(textItems);
                createTextBoxes();
                
                return pdfDoc.getPage(pageNum).then(page => {
                    return page.getOperatorList();
                });
            }).then(operatorList => {
                const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
                const newImageItems = [];
                
                let imageIndex = 0;
                if(operatorList && operatorList.fnArray) {
                    for (let i = 0; i < operatorList.fnArray.length; i++) {
                        if (operatorList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                            for (let j = i - 1; j >= 0; j--) {
                                if (operatorList.fnArray[j] === pdfjsLib.OPS.transform) {
                                    const transform = operatorList.argsArray[j];
                                    const [a, b, c, d, e, f] = transform;
                                    const imageWidth = Math.sqrt(a * a + b * b) * scale;
                                    const imageHeight = Math.sqrt(c * c + d * d) * scale;
                                    const x = e * scale;
                                    const y = (currentViewport.height - f * scale - imageHeight);

                                    const existingEdit = pageEdits.images.find(edit => edit.index === imageIndex);
                                    
                                    newImageItems.push({
                                        index: imageIndex,
                                        x: x,
                                        y: y,
                                        width: imageWidth,
                                        height: imageHeight,
                                        edited: !!existingEdit,
                                        newImageData: existingEdit ? existingEdit.data : null
                                    });
                                    imageIndex++;
                                    break;
                                }
                            }
                        }
                    }
                }
                imageItems = newImageItems;
                
                createImageBoxes();
                loadQRCodeBoxes();
                redrawEditedContent();
                showLoading(false);
            }).catch(error => {
                console.error('Error rendering page:', error);
                showNotification('Error rendering page: ' + error.message);
                showLoading(false);
            });
            
            updatePageInfo();
            updateZoomLevel();
        }
        
        // Group text items that should be treated as a single element
        function groupTextItems(allTextItems) {
            const groupedItems = [];
            const processed = new Set();
            
            for (let i = 0; i < allTextItems.length; i++) {
                if (processed.has(i)) continue;
                
                const currentItem = allTextItems[i];
                let groupItem = { ...currentItem, originalIndices: [i] };
                
                if (i < allTextItems.length - 1) {
                    const nextItem = allTextItems[i + 1];
                    
                    const xDistance = Math.abs(nextItem.x - (currentItem.x + currentItem.width));
                    const yDistance = Math.abs(nextItem.y - currentItem.y);
                    
                    if (xDistance < 20 && yDistance < 5) {
                        groupItem.text += nextItem.text;
                        groupItem.width = nextItem.x + nextItem.width - currentItem.x;
                        groupItem.originalIndices.push(i + 1);
                        processed.add(i + 1);
                        
                        if (i < allTextItems.length - 2) {
                            const thirdItem = allTextItems[i + 2];
                            const xDistance2 = Math.abs(thirdItem.x - (nextItem.x + nextItem.width));
                            const yDistance2 = Math.abs(thirdItem.y - currentItem.y);
                            
                            if (xDistance2 < 20 && yDistance2 < 5) {
                                groupItem.text += thirdItem.text;
                                groupItem.width = thirdItem.x + thirdItem.width - currentItem.x;
                                groupItem.originalIndices.push(i + 2);
                                processed.add(i + 2);
                            }
                        }
                        
                        if (i < allTextItems.length - 3) {
                            const fourthItem = allTextItems[i + 3];
                            const xDistance3 = Math.abs(fourthItem.x - (allTextItems[i + 2].x + allTextItems[i + 2].width));
                            const yDistance3 = Math.abs(fourthItem.y - currentItem.y);
                            
                            if (xDistance3 < 20 && yDistance3 < 5) {
                                groupItem.text += fourthItem.text;
                                groupItem.width = fourthItem.x + fourthItem.width - currentItem.x;
                                groupItem.originalIndices.push(i + 3);
                                processed.add(i + 3);
                            }
                        }
                    }
                }
                
                groupedItems.push(groupItem);
                processed.add(i);
            }
            
            return groupedItems;
        }
        
        // Identify form fields in the text items
        function identifyFormFields(allTextItems) {
            formFields = {};
            
            allTextItems.forEach((item, index) => {
                const text = item.text.trim();
                
                if (text === "BIG B TRANZ") {
                    formFields.purchaser = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                }  else if (text === "THNSY250001534") {
                    formFields.BulkTransit = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "TSPS01907125") {
                    formFields.security = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "THN000000056770/2025") {
                    formFields.transit = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "ANACHAL, Others") {
                    formFields.destinationSelection = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "ANACHAL") {
                    if (!formFields.address) {
                        formFields.address = [];
                    }
                    formFields.address.push({ x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index });
                } else if (text === "SREEJITH") {
                    formFields.driver = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "KL69D3996") {
                    formFields.vehicle = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text.includes("M-Sand") || text.includes("P-Sand") || text.includes("Jelly") || text.includes("Dust") || text.includes("Rough Stone")) {
                    const mineralKeywords = ["M-Sand", "P-Sand", "Jelly", "Dust", "Rough Stone"];
                    let foundKeyword = null;
                    let prefix = "";
                    let suffix = "";
                    
                    for (const keyword of mineralKeywords) {
                        if (text.includes(keyword)) {
                            foundKeyword = keyword;
                            const startIndex = text.indexOf(keyword);
                            prefix = text.substring(0, startIndex);
                            suffix = text.substring(startIndex + keyword.length);
                            break;
                        }
                    }
                    
                    if (foundKeyword) {
                        formFields.mineral = { 
                            x: item.x, y: item.y, width: item.width, height: item.height, 
                            fontSize: item.fontSize, 
                            originalIndex: index,
                            fullText: item.text,
                            prefix: prefix,
                            suffix: suffix
                        };
                    }
                } else if (text === "35") {
                    formFields.quantity = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "13-11-2025 08:32") {
                    formFields.timestart = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text === "13-11-2025 13:32") {
                    formFields.timeend = { x: item.x, y: item.y, width: item.width, height: item.height, fontSize: item.fontSize, originalIndex: index };
                } else if (text.includes("Date & Time of Dispatch")) {
                    const colonIndex = text.indexOf(':');
                    if (colonIndex !== -1) {
                        const prefix = text.substring(0, colonIndex + 1);
                        
                        formFields.dispatchdatetime = { 
                            x: item.x, y: item.y, width: item.width, height: item.height, 
                            fontSize: item.fontSize, 
                            originalIndex: index,
                            fullText: item.text,
                            prefix: prefix
                        };
                    }
                } else if (text.includes("Sec Code")) {
                    const colonIndex = text.indexOf(':');
                    if (colonIndex !== -1) {
                        const prefix = text.substring(0, colonIndex + 1);
                        
                        formFields.security = { 
                            x: item.x, y: item.y, width: item.width, height: item.height, 
                            fontSize: item.fontSize, 
                            originalIndex: index,
                            fullText: item.text,
                            prefix: prefix
                        };
                    }
                } else if (text === "151kms") {
                    formFields.distance = { 
                        x: item.x, y: item.y, width: item.width, height: item.height, 
                        fontSize: item.fontSize, 
                        originalIndex: index,
                        fullText: item.text
                    };
                }
            });

            if (formFields.dispatchdatetime) {
                const dispatchField = formFields.dispatchdatetime;
                let secondsField = null;
                
                const dispatchTextItem = textItems.find(item => item.originalIndex === dispatchField.originalIndex);
                
                if (dispatchTextItem) {
                    const secondsItem = textItems.find(item => {
                        const isToRight = item.x > (dispatchTextItem.x + dispatchTextItem.width - 20);
                        const isSameLine = Math.abs(item.y - dispatchTextItem.y) < 10;
                        const isSecondsPattern = /^:\d{2}$/.test(item.text.trim());
                        
                        return isToRight && isSameLine && isSecondsPattern;
                    });
                    
                    if (secondsItem) {
                        formFields.dispatchdatetimeSeconds = {
                            x: secondsItem.x,
                            y: secondsItem.y,
                            width: secondsItem.width,
                            height: secondsItem.height,
                            fontSize: secondsItem.fontSize,
                            originalIndex: secondsItem.originalIndex
                        };
                    }
                }
            }
        }
        
        // Create text boxes around PDF text
        function createTextBoxes() {
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();
            
            textItems.forEach((item, index) => {
                const textBox = document.createElement('div');
                textBox.className = 'text-box';
                if (item.edited) textBox.classList.add('edited');
                textBox.dataset.index = item.originalIndex;
                textBox.title = item.text;
                
                const left = (canvasRect.left - pdfPageRect.left) + item.x;
                const top = (canvasRect.top - pdfPageRect.top) + (item.y - item.height);
                
                textBox.style.left = left + 'px';
                textBox.style.top = top + 'px';
                textBox.style.width = item.width + 'px';
                textBox.style.height = item.height + 'px';
                
                textBox.addEventListener('click', (e) => { e.stopPropagation(); editText(item, textBox); });
                pdfPage.appendChild(textBox);
                textBoxes.push(textBox);
            });
        }
        
        // Create clickable overlays for images
        function createImageBoxes() {
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();

            imageItems.forEach((item) => {
                const imageBox = document.createElement('div');
                imageBox.className = 'image-box';
                if (item.edited) imageBox.classList.add('edited');
                imageBox.title = "Click to replace image";
                
                const left = (canvasRect.left - pdfPageRect.left) + item.x;
                const top = (canvasRect.top - pdfPageRect.top) + item.y;
                
                imageBox.style.left = left + 'px';
                imageBox.style.top = top + 'px';
                imageBox.style.width = item.width + 'px';
                imageBox.style.height = item.height + 'px';
                
                imageBox.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    replaceImage(item, imageBox); 
                });
                
                pdfPage.appendChild(imageBox);
                imageBoxes.push(imageBox);
            });
        }
        
        // Handle image replacement click
        function replaceImage(imageItem, imageBoxElement) {
            currentEditingImageItem = { ...imageItem, box: imageBoxElement };
            imageInput.click();
        }
        
        // Clear text boxes
        function clearTextBoxes() {
            textBoxes.forEach(textBox => textBox.remove());
            textBoxes = [];
        }
        
        // Clear image boxes
        function clearImageBoxes() {
            imageBoxes.forEach(box => box.remove());
            imageBoxes = [];
        }
        
        // Load QR code boxes for the current page
        function loadQRCodeBoxes() {
            const pageEdits = allPageEdits[pageNum] || { textEdits: [], images: [] };
            const qrCodeEdits = pageEdits.textEdits.filter(edit => edit.isQRCode);
            
            if (qrCodeEdits.length === 0) {
                currentQRCodeBox = null;
                return;
            }
            
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();
            
            const edit = qrCodeEdits[0];
            
            const qrBox = document.createElement('div');
            qrBox.className = 'qr-box';
            qrBox.dataset.page = pageNum;
            
            const left = (canvasRect.left - pdfPageRect.left) + (edit.x * scale);
            const top = (canvasRect.top - pdfPageRect.top) + ((edit.y - edit.height) * scale);
            
            qrBox.style.left = left + 'px';
            qrBox.style.top = top + 'px';
            qrBox.style.width = (edit.width * scale) + 'px';
            qrBox.style.height = (edit.height * scale) + 'px';
            
            const qrImg = document.createElement('img');
            qrImg.src = edit.qrCodeDataUrl;
            qrBox.appendChild(qrImg);
            
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle se';
            qrBox.appendChild(resizeHandle);
            
            // Drag functionality
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            qrBox.addEventListener('mousedown', (e) => {
                if (e.target === resizeHandle) return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = qrBox.offsetLeft;
                initialY = qrBox.offsetTop;
                
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', stopDrag);
                e.preventDefault();
            });
            
            function handleDrag(e) {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                qrBox.style.left = (initialX + dx) + 'px';
                qrBox.style.top = (initialY + dy) + 'px';
            }
            
            function stopDrag() {
                isDragging = false;
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
                updateQRCodeInStorage(qrBox);
            }
            
            // Resize functionality
            let isResizing = false;
            let startWidth, startHeight;
            
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = qrBox.offsetWidth;
                startHeight = qrBox.offsetHeight;
                
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.stopPropagation();
                e.preventDefault();
            });
            
            function handleResize(e) {
                if (!isResizing) return;
                
                const width = startWidth + (e.clientX - startX);
                const height = startHeight + (e.clientY - startY);
                
                const size = Math.max(width, height);
                
                qrBox.style.width = size + 'px';
                qrBox.style.height = size + 'px';
            }
            
            function stopResize() {
                isResizing = false;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
                updateQRCodeInStorage(qrBox);
            }
            
            pdfPage.appendChild(qrBox);
            qrCodeBoxes.push(qrBox);
            currentQRCodeBox = qrBox;
        }
        
        // Clear QR code boxes
        function clearQRCodeBoxes() {
            qrCodeBoxes.forEach(qrBox => qrBox.remove());
            qrCodeBoxes = [];
            currentQRCodeBox = null;
        }
        
        // Apply form data to PDF
        function applyFormData() {
            const purchaser = purchaserInput.value.trim();
            const BulkTransit = BulkTransitInput.value.trim();
            const security = securityInput.value.trim();
            const transit = transitInput.value.trim();
            const address = addressInput.value.trim();
            const driver = driverInput.value.trim();
            const vehicle = vehicleInput.value.trim();
            const quantity = quantityInput.value.trim();
            const timestart = timestartInput.value.trim();
            const timeend = timeendInput.value.trim();
            const dispatchdatetime = dispatchdatetimeInput.value.trim();
            const distance = distanceInput.value.trim();
            
            // Get selected mineral value
            let mineral = '';
            if (msandRadio.checked) mineral = 'M-Sand';
            else if (psandRadio.checked) mineral = 'P-Sand';
            else if (jellyRadio.checked) mineral = 'Jelly';
            else if (dustRadio.checked) mineral = 'Dust';
            else if (roughstoneRadio.checked) mineral = 'Rough Stone';
            
            let fieldsFound = 0;
            
            if (formFields.purchaser && purchaser) {
                applyFormValue('purchaser', purchaser);
                fieldsFound++;
            } else if (purchaser) {
                showNotification('"BIG B TRANZ" text not found in PDF');
            }
            
                
            if (formFields.BulkTransit && BulkTransit) {
                applyFormValue('BulkTransit', BulkTransit);
                fieldsFound++;
            } else if (BulkTransit) {
                showNotification('"THNSY250001534" text not found in PDF');
            }
            
            if (formFields.security && security) {
                applyFormValue('security', security);
                fieldsFound++;
            } else if (security) {
                showNotification('"TSPS01907125" text not found in PDF');
            }
            
            if (formFields.transit && transit) {
                applyFormValue('transit', transit);
                fieldsFound++;
            } else if (transit) {
                showNotification('"THN000000056770/2025" text not found in PDF');
            }
            
            if (formFields.destinationSelection) {
                if (tamilnaduRadio.checked) {
                    applyFormValue('destinationSelection', ', Tamilnadu');
                    fieldsFound++;
                } else if (keralaRadio.checked) {
                    const destinationValue = address + ", Others";
                    applyFormValue('destinationSelection', destinationValue);
                    fieldsFound++;
                }
            }
            
            if (formFields.address && address) {
                formFields.address.forEach((field, index) => {
                    applyFormValue('address', address, index);
                });
                fieldsFound++;
            } else if (address) {
                showNotification('"ANACHAL" text not found in PDF');
            }
            
            if (formFields.driver && driver) {
                applyFormValue('driver', driver);
                fieldsFound++;
            } else if (driver) {
                showNotification('"SREEJITH" text not found in PDF');
            }
            
            if (formFields.vehicle && vehicle) {
                applyFormValue('vehicle', vehicle);
                fieldsFound++;
            } else if (vehicle) {
                showNotification('"KL69D3996" text not found in PDF');
            }
            
            if (formFields.mineral && mineral) {
                applyFormValue('mineral', mineral);
                fieldsFound++;
            } else if (mineral) {
                showNotification('Mineral field not found in PDF');
            }
            
            if (formFields.quantity && quantity) {
                applyFormValue('quantity', quantity);
                fieldsFound++;
            } else if (quantity) {
                showNotification('"35" text not found in PDF');
            }
            
            if (formFields.timestart && timestart) {
                applyFormValue('timestart', timestart);
                fieldsFound++;
            } else if (timestart) {
                showNotification('"Start Time" text not found in PDF');
            }
            
            if (formFields.timeend && timeend) {
                applyFormValue('timeend', timeend);
                fieldsFound++;
            } else if (timeend) {
                showNotification('"End Time" text not found in PDF');
            }
            
            if (formFields.dispatchdatetime && dispatchdatetime) {
                let mainPart = '';
                let secondsPart = '';

                const lastSpaceIndex = dispatchdatetime.lastIndexOf(' ');
                
                if (lastSpaceIndex !== -1) {
                    const timePart = dispatchdatetime.substring(lastSpaceIndex + 1);
                    const timeComponents = timePart.split(':');

                    if (timeComponents.length >= 3) {
                        mainPart = dispatchdatetime.substring(0, lastSpaceIndex + 1) + timeComponents.slice(0, 2).join(':');
                        secondsPart = ':' + timeComponents[2];
                    } else if (timeComponents.length === 2) {
                        mainPart = dispatchdatetime;
                        if (formFields.dispatchdatetimeSeconds) {
                            const secondsTextItem = textItems.find(item => item.originalIndex === formFields.dispatchdatetimeSeconds.originalIndex);
                            if (secondsTextItem) {
                                secondsPart = secondsTextItem.text;
                            }
                        }
                    }
                } else {
                    mainPart = dispatchdatetime;
                }

                applyFormValue('dispatchdatetime', mainPart, true);
                fieldsFound++;
                
                if (formFields.dispatchdatetimeSeconds && secondsPart) {
                    applyFormValue('dispatchdatetimeSeconds', secondsPart);
                    fieldsFound++;
                }
            } else if (dispatchdatetime) {
                showNotification('"Date & Time of Dispatch" text not found in PDF');
            }
            
            if (formFields.distance && distance) {
                const distanceWithUnit = distance + "kms";
                applyFormValue('distance', distanceWithUnit);
                fieldsFound++;
            } else if (distance) {
                showNotification('"Approximate Distance" text not found in PDF');
            }
            
            if (fieldsFound > 0) {
                showNotification(`${fieldsFound} fields updated in PDF`);
            } else {
                showNotification('No matching text found in PDF');
            }
        }
        
        // Apply a single form value
        function applyFormValue(fieldType, value, increaseWidth = false, index = 0) {
            let field;
            
            if (fieldType === 'address' && Array.isArray(formFields[fieldType])) {
                field = formFields[fieldType][index];
            } else {
                field = formFields[fieldType];
            }
            
            if (!field) return;
            
            const textItem = textItems.find(item => item.originalIndex === field.originalIndex);
            if (!textItem) return;
            
            if (field.prefix !== undefined) {
                textItem.text = field.prefix + " " + value;
            } else {
                textItem.text = value;
            }
            
            textItem.edited = true;
            
            const originalWidth = textItem.width;
            
            if (increaseWidth) {
                const context = editCanvas.getContext('2d');
                context.font = `${textItem.fontWeight} ${textItem.fontSize}px ${textItem.fontFamily}`;
                const textWidth = context.measureText(textItem.text).width;
                
                textItem.width = Math.max(textItem.width, textWidth * 1.03);
            }
            
            updateTextItem(textItem);
            
            if (fieldType === 'dispatchdatetime' && increaseWidth && formFields.dispatchdatetimeSeconds) {
                const secondsTextItem = textItems.find(item => item.originalIndex === formFields.dispatchdatetimeSeconds.originalIndex);
                if (secondsTextItem) {
                    const widthDifference = textItem.width - originalWidth;
                    
                    secondsTextItem.x += widthDifference;
                    updateTextItem(secondsTextItem);
                }
            }
        }
        
        // Update the text boxes after applying form data
        function updateTextBoxes() {
            const pdfPageRect = pdfPage.getBoundingClientRect();
            const canvasRect = canvasWrapper.getBoundingClientRect();
            
            textItems.forEach((item, index) => {
                const textBox = textBoxes.find(box => parseInt(box.dataset.index) === item.originalIndex);
                if (textBox) {
                    const left = (canvasRect.left - pdfPageRect.left) + item.x;
                    const top = (canvasRect.top - pdfPageRect.top) + (item.y - item.height);
                    
                    textBox.style.left = left + 'px';
                    textBox.style.top = top + 'px';
                    textBox.style.width = item.width + 'px';
                    textBox.style.height = item.height + 'px';
                    textBox.title = item.text;
                }
            });
        }
        
        // Update a text item and save to storage
        function updateTextItem(textItem) {
            if (!allPageEdits[pageNum]) {
                allPageEdits[pageNum] = { textEdits: [], images: [] };
            }
            const pageEditList = allPageEdits[pageNum].textEdits;
            const editIndex = pageEditList.findIndex(edit => edit.originalIndex === textItem.originalIndex);
            
            const editData = {
                originalIndex: textItem.originalIndex,
                text: textItem.text,
                color: textItem.color,
                fontFamily: textItem.fontFamily,
                fontWeight: textItem.fontWeight,
                isBold: textItem.isBold,
                isThin: textItem.isThin,
                originalIndices: textItem.originalIndices
            };

            if (editIndex > -1) {
                pageEditList[editIndex] = editData;
            } else {
                pageEditList.push(editData);
            }
            
            const textBox = textBoxes.find(box => parseInt(box.dataset.index) === textItem.originalIndex);
            if (textBox) {
                textBox.classList.add('edited');
                textBox.title = textItem.text;
            }
            
            updateTextBoxes();
            redrawEditedContent();
        }
        
        // Edit text
        function editText(textItem, textBoxElement) {
            if (currentEditingTextItem === textItem) return;
            currentEditingTextItem = textItem;
            currentEditingTextBox = textBoxElement;
            
            dialogInput.value = textItem.text;
            
            textColorInput.value = textItem.color;
            fontSelect.value = textItem.fontFamily;
            
            if (textItem.isThin) {
                currentTextThin = true;
                currentTextBold = false;
                thinBtn.classList.add('active');
                boldBtn.classList.remove('active');
            } else if (textItem.isBold) {
                currentTextBold = true;
                currentTextThin = false;
                boldBtn.classList.add('active');
                thinBtn.classList.remove('active');
            } else {
                currentTextBold = false;
                currentTextThin = false;
                boldBtn.classList.remove('active');
                thinBtn.classList.remove('active');
            }
            
            editDialog.style.display = 'block';
            dialogInput.focus();
            dialogInput.select();
        }
        
        // Save dialog text
        function saveDialogText() {
            if (dialogInput.value.trim() && currentEditingTextItem) {
                currentEditingTextItem.text = dialogInput.value;
                currentEditingTextItem.color = textColorInput.value;
                currentEditingTextItem.fontFamily = currentFontFamily;
                currentEditingTextItem.isBold = currentTextBold;
                currentEditingTextItem.isThin = currentTextThin;
                
                if (currentTextBold) {
                    currentEditingTextItem.fontWeight = 'bold';
                } else if (currentTextThin) {
                    currentEditingTextItem.fontWeight = 'thin';
                } else {
                    currentEditingTextItem.fontWeight = 'normal';
                }
                
                currentEditingTextItem.edited = true;

                updateTextItem(currentEditingTextItem);
                redrawEditedContent();
                currentEditingTextBox.classList.add('edited');
                showNotification('Text updated and saved with original style preserved.');
            }
            closeDialog();
        }
        
        // Close dialog
        function closeDialog() {
            editDialog.style.display = 'none';
            currentEditingTextItem = null;
            currentEditingTextBox = null;
        }
        
        // Redraw all edited content (text and images) on the edit canvas
        function redrawEditedContent() {
            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            
            // Draw edited text
            textItems.forEach(item => {
                if (item.edited) {
                    const padding = 2.5;
                    editCtx.fillStyle = 'white';
                    editCtx.fillRect(item.x - padding, item.y - item.height - padding, item.width + padding * 4.1, item.height + padding * 4.1);
                    
                    let fontWeight = 'normal';
                    if (item.isThin) {
                        fontWeight = '500';
                    } else if (item.isBold) {
                        fontWeight = 'bold';
                    } else {
                        fontWeight = '500';
                    }
                    
                    editCtx.font = `${fontWeight} ${item.fontSize}px ${item.fontFamily}`;
                    editCtx.fillStyle = item.color;
                    editCtx.fillText(item.text, item.x, item.y);
                }
            });
            
            // Draw edited images - CRITICAL FIX: Clear the area first to prevent double images
            imageItems.forEach(item => {
                if (item.edited && item.newImageData) {
                    // Clear the area where the original image was
                    editCtx.fillStyle = 'white';
                    editCtx.fillRect(item.x, item.y, item.width, item.height);
                    
                    // Draw the new image
                    const img = new Image();
                    img.onload = () => {
                        editCtx.drawImage(img, item.x, item.y, item.width, item.height);
                    };
                    img.src = item.newImageData;
                }
            });
        }

        // HIGH-QUALITY SAVE PDF FUNCTION - FIXED IMAGE HANDLING
        async function savePDF() {
            if (!pdfDoc) { 
                showNotification('No PDF to save'); 
                return; 
            }
            
            showLoading(true);
            try {
    const quality = qualitySelect.value;
    let outputScale = 5.0;
    
    switch(quality) {
        case 'standard':
            outputScale = 1.5;
            break;
        case 'high':
            outputScale = 2.0;
            break;
        case 'ultra':
            outputScale = 3.0;
            break;
        case 'HD':
            outputScale = 5.0;
            break;
        case 'pc':
            outputScale = 8.0;
            break;
        // Additional quality options
        case 'ultraHD':
            outputScale = 10.0;
            break;
        case 'print':
            outputScale = 12.0;
            break;
        // Add a default case to handle unexpected values
        default:
            outputScale = 5.0;
            console.warn(`Unknown quality setting: ${quality}, defaulting to HD (5.0)`);
    }
    
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.imageSmoothingEnabled = true;
                tempCtx.imageSmoothingQuality = 'high';
                
                const pageImages = [];
                
                async function renderAllPages() {
                    for (let i = 1; i <= pageCount; i++) {
                        const page = await pdfDoc.getPage(i);
                        const viewport = page.getViewport({ scale: outputScale });
                        
                        const devicePixelRatio = window.devicePixelRatio || 1;
                        
                        tempCanvas.width = viewport.width * devicePixelRatio;
                        tempCanvas.height = viewport.height * devicePixelRatio;
                        
                        tempCtx.scale(devicePixelRatio, devicePixelRatio);
                        
                        // First, get the page edits for this page
                        const pageEdits = allPageEdits[i] || { textEdits: [], images: [] };
                        
                        // Get operator list to identify images that need to be replaced
                        const operatorList = await page.getOperatorList();
                        const imageReplacements = new Map();
                        
                        // Map image indices to their replacement data
                        let imageIndex = 0;
                        if(operatorList && operatorList.fnArray) {
                            for (let j = 0; j < operatorList.fnArray.length; j++) {
                                if (operatorList.fnArray[j] === pdfjsLib.OPS.paintImageXObject) {
                                    const existingEdit = pageEdits.images.find(edit => edit.index === imageIndex);
                                    if (existingEdit && existingEdit.data) {
                                        imageReplacements.set(imageIndex, existingEdit.data);
                                    }
                                    imageIndex++;
                                }
                            }
                        }
                        
                        // Create custom render context with image replacement
                        const renderContext = {
                            canvasContext: tempCtx,
                            viewport: viewport,
                            enableWebGL: true,
                            // Custom image rendering function
                            renderForms: false,
                            intent: 'print'
                        };
                        
                        // Override the paintImageXObject function if we have replacements
                        if (imageReplacements.size > 0) {
                            const originalPaintImageXObject = renderContext.canvasContext.constructor.prototype.paintImageXObject;
                            let currentImageIndex = 0;
                            
                            // We need to intercept the rendering process
                            // This is a simplified approach - in a real implementation, you'd need more sophisticated interception
                        }
                        
                        // Render the PDF page
                        await page.render(renderContext).promise;
                        
                        // Get the text content for this page
                        const textContent = await page.getTextContent({ normalizeWhitespace: false, disableCombineTextItems: false });
                        
                        // Process text items for this page
                        if (textContent && textContent.items) {
                            const allTextItems = [];
                            textContent.items.forEach((item, index) => {
                                if (item.str && item.str.trim() !== '') {
                                    const transform = item.transform;
                                    const tx = pdfjsLib.Util.transform(viewport.transform, transform);
                                    const x = tx[4];
                                    const y = tx[5];
                                    const width = item.width * outputScale;
                                    const height = (item.height || 12) * outputScale;
                                    
                                    allTextItems.push({
                                        text: item.str,
                                        x: x,
                                        y: y,
                                        width: width,
                                        height: height,
                                        fontSize: (item.height || 12) * outputScale,
                                        originalIndex: index,
                                        item: item
                                    });
                                }
                            });
                            
                            const groupedTextItems = groupTextItems(allTextItems);
                            
                            const newTextItems = [];
                            groupedTextItems.forEach((item, index) => {
                                const existingEdit = pageEdits.textEdits.find(edit => edit.originalIndex === index);
                                
                                newTextItems.push({
                                    text: existingEdit ? existingEdit.text : item.text,
                                    x: item.x,
                                    y: item.y,
                                    width: item.width,
                                    height: item.height,
                                    fontSize: item.fontSize,
                                    originalIndex: index,
                                    edited: !!existingEdit,
                                    color: existingEdit ? existingEdit.color : '#000000',
                                    fontFamily: existingEdit ? existingEdit.fontFamily : 'Roboto',
                                    fontWeight: existingEdit ? existingEdit.fontWeight : 'normal',
                                    isBold: existingEdit ? existingEdit.isBold : false,
                                    isThin: existingEdit ? existingEdit.isThin : false
                                });
                            });
                            
                            // Draw edited text on the canvas
                            newTextItems.forEach(item => {
                                if (item.edited) {
                                    const padding = 2.5;
                                    tempCtx.fillStyle = 'white';
                                    tempCtx.fillRect(item.x - padding, item.y - item.height - padding, item.width + padding * 4.1, item.height + padding * 4.1);
                                        
                                    let fontWeight = 'normal';
                                    if (item.isThin) {
                                        fontWeight = '500';
                                    } else if (item.isBold) {
                                        fontWeight = 'bold';
                                    } else {
                                        fontWeight = '500';
                                    }
                                    
                                    tempCtx.font = `${fontWeight} ${item.fontSize}px ${item.fontFamily}`;
                                    tempCtx.fillStyle = item.color;
                                    tempCtx.fillText(item.text, item.x, item.y);
                                }
                            });
                        }
                        
                        // Now handle image replacements
                        imageIndex = 0;
                        if(operatorList && operatorList.fnArray) {
                            for (let j = 0; j < operatorList.fnArray.length; j++) {
                                if (operatorList.fnArray[j] === pdfjsLib.OPS.paintImageXObject) {
                                    const replacementData = imageReplacements.get(imageIndex);
                                    
                                    if (replacementData) {
                                        // Find the transform for this image
                                        for (let k = j - 1; k >= 0; k--) {
                                            if (operatorList.fnArray[k] === pdfjsLib.OPS.transform) {
                                                const transform = operatorList.argsArray[k];
                                                const [a, b, c, d, e, f] = transform;
                                                const imageWidth = Math.sqrt(a * a + b * b) * outputScale;
                                                const imageHeight = Math.sqrt(c * c + d * d) * outputScale;
                                                const x = e * outputScale;
                                                const y = (viewport.height - f * outputScale - imageHeight);

                                                // Clear the area and draw the replacement image
                                                tempCtx.fillStyle = 'white';
                                                tempCtx.fillRect(x, y, imageWidth, imageHeight);
                                                
                                                const img = new Image();
                                                await new Promise(resolve => {
                                                    img.onload = resolve;
                                                    img.src = replacementData;
                                                });
                                                tempCtx.drawImage(img, x, y, imageWidth, imageHeight);
                                                break;
                                            }
                                        }
                                    }
                                    imageIndex++;
                                }
                            }
                        }
                        
                        // Add QR codes from page edits
                        pageEdits.textEdits.forEach(edit => {
                            if (edit.isQRCode) {
                                const img = new Image();
                                img.onload = () => {
                                    tempCtx.drawImage(img, edit.x * outputScale, edit.y * outputScale - edit.height * outputScale, edit.width * outputScale, edit.height * outputScale);
                                };
                                img.src = edit.qrCodeDataUrl;
                            }
                        });
                        
                        // Convert the canvas to an image with high quality
                        const imgData = tempCanvas.toDataURL('image/jpeg', 0.95);
                        pageImages.push(imgData);
                    }
                    
                    // Create the PDF with all pages using jsPDF
                    const { jsPDF } = window.jspdf;
                    
                    // Get the dimensions of the first page to set up the PDF
                    const firstPageImg = new Image();
                    firstPageImg.src = pageImages[0];
                    await new Promise(resolve => {
                        firstPageImg.onload = resolve;
                    });
                    
                    // Calculate PDF dimensions based on original page size
                    const pdfWidth = originalPageSize.width * 0.3528;
                    const pdfHeight = originalPageSize.height * 0.3528;
                    
                    // Create PDF with proper dimensions
                    const pdf = new jsPDF({
                        orientation: pdfWidth > pdfHeight ? 'landscape' : 'portrait',
                        unit: 'mm',
                        format: [pdfWidth, pdfHeight],
                        compress: true
                    });
                    
                    // Add all pages to the PDF
                    for (let i = 0; i < pageImages.length; i++) {
                        if (i > 0) pdf.addPage([pdfWidth, pdfHeight]);
                        pdf.addImage(pageImages[i], 'JPEG', 0, 0, pdfWidth, pdfHeight, undefined, 'FAST');
                    }
                    
                    // Save the PDF
                    pdf.save('edited-document.pdf');
                    showNotification('PDF saved successfully with proper dimensions');
                    dispatchdatetimeInput.value = '';
        timeendInput.value = '';
        timestartInput.value = '';
        hoursInput.value = '';
        quantityInput.value = '';
        vehicleInput.value = '';
        driverInput.value = '';
        addressInput.value = '';
        purchaserInput.value = '';
                }
                
                // Start rendering all pages
                await renderAllPages();
            } catch (error) {
                console.error('Error saving PDF:', error);
                showNotification('Error saving PDF: ' + error.message);
            } finally {
                showLoading(false);
            }
        }
        
        // Update page info
        function updatePageInfo() {
            document.getElementById('page-info').textContent = `Page ${pageNum} of ${pageCount}`;
            document.getElementById('prev-page').disabled = pageNum <= 1;
            document.getElementById('next-page').disabled = pageNum >= pageCount;
        }
        
        // Update zoom level
        function updateZoomLevel() {
            document.getElementById('zoom-level').textContent = Math.round(scale * 100) + '%';
        }
        
        // Show/hide loading overlay
        function showLoading(show) {
            loadingOverlay.classList.toggle('show', show);
        }
        
        // Show notification
        function showNotification(message) {
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 3000);
        }
        
        // Initialize the application
        init();
    });
    
    
</script>


<script>
/**
 * ===================================================================
 * ADVANCED MEMORY MANAGEMENT UTILITY
 * ===================================================================
 * This utility provides robust memory cleanup for intensive browser tasks,
 * particularly useful when processing large files like high-resolution PDFs.
 * It employs multiple strategies to mitigate memory leaks and reduce memory pressure.
 */
const MemoryManager = (() => {
    // Private variables to track state
    let isProcessing = false;
    let cleanupTasks = [];
    let memoryMonitorInterval = null;

    /**
     * Starts a memory-intensive operation session.
     * Call this before you begin processing.
     */
    const startProcessing = () => {
        if (isProcessing) {
            console.warn("MemoryManager: A processing session is already active.");
            return;
        }
        isProcessing = true;
        cleanupTasks = [];
        console.log("MemoryManager: Starting intensive processing session.");
        
        // Start monitoring memory if the API is available
        if (performance.memory) {
            memoryMonitorInterval = setInterval(() => {
                const memInfo = performance.memory;
                // Log a warning if memory usage is critically high
                if (memInfo.usedJSHeapSize > memInfo.jsHeapSizeLimit * 0.85) {
                    console.warn(`MemoryManager: CRITICAL - Heap usage is high: ${(memInfo.usedJSHeapSize / 1048576).toFixed(2)} MB / ${(memInfo.jsHeapSizeLimit / 1048576).toFixed(2)} MB`);
                    // Trigger an immediate cleanup cycle
                    performCleanupCycle();
                }
            }, 5000); // Check every 5 seconds
        }
    };

    /**
     * Ends the processing session and performs a final, thorough cleanup.
     * Call this after you have completely finished.
     */
    const endProcessing = () => {
        if (!isProcessing) {
            console.warn("MemoryManager: No active processing session to end.");
            return;
        }
        console.log("MemoryManager: Ending session and performing final cleanup.");
        
        // Stop monitoring
        if (memoryMonitorInterval) {
            clearInterval(memoryMonitorInterval);
            memoryMonitorInterval = null;
        }

        // Run all registered cleanup tasks
        runAllCleanupTasks();
        
        // Perform a final, aggressive cleanup
        performCleanupCycle(true);

        isProcessing = false;
        cleanupTasks = [];
    };

    /**
     * Registers a cleanup task. This is a function that will be called
     * during cleanup to release specific resources.
     * @param {Function} task - A function that performs cleanup (e.g., () => { largeObject = null; })
     */
    const registerCleanupTask = (task) => {
        if (typeof task === 'function') {
            cleanupTasks.push(task);
        } else {
            console.error("MemoryManager: Cleanup task must be a function.");
        }
    };

    /**
     * Executes all registered cleanup tasks.
     */
    const runAllCleanupTasks = () => {
        cleanupTasks.forEach(task => {
            try {
                task();
            } catch (e) {
                console.error("MemoryManager: Error executing cleanup task:", e);
            }
        });
        cleanupTasks = []; // Clear tasks after running them
    };

    /**
     * The core cleanup logic. This uses multiple techniques to free memory.
     * @param {boolean} aggressive - If true, performs more intensive cleanup steps.
     */
    const performCleanupCycle = (aggressive = false) => {
        console.log("MemoryManager: Performing cleanup cycle...");

        // 1. Nullify large object references in the current scope
        // This needs to be done manually in your processing function, but we can force a pass here.
        // Example: In your loop, you would call: memoryManager.registerCleanupTask(() => { page = null; viewport = null; });
        runAllCleanupTasks();

        // 2. Trigger a Microtask to allow the event loop to process other pending tasks
        // This helps the browser "breathe" and can free up memory associated with those tasks.
        Promise.resolve().then(() => {
            if (aggressive) {
                // 3. In aggressive mode, create and discard a large temporary object
                // This can sometimes fragment the heap enough to allow the GC to reclaim more memory.
                try {
                    const tempArray = new Array(1000000).fill(0);
                    tempArray.length = 0; // Immediately discard it
                } catch (e) {
                    console.warn("MemoryManager: Could not create temporary object for heap pressure:", e.message);
                }
            }
        });

        // 4. Force Garbage Collection if available (e.g., in Chrome with --enable-precise-memory-info flag)
        if (window.gc && aggressive) {
            console.log("MemoryManager: Forcing garbage collection.");
            window.gc();
        }
    };

    // Public API
    return {
        startProcessing,
        endProcessing,
        registerCleanupTask,
        // Expose the single-cycle cleanup for use during processing loops
        clear: () => performCleanupCycle(false)
    };
})();


/**
 * ===================================================================
 * MAIN PDF PROCESSING LOGIC (Example Implementation)
 * ===================================================================
 * This function demonstrates how to use the MemoryManager to process a PDF
 * page-by-page, preventing memory issues.
 * 
 * NOTE: This is a template. You must integrate your actual PDF library calls
 * (e.g., from PDF.js) where indicated.
 */
async function processPdfSafely(pdfDocument, qualitySelect) {
    // 1. START the memory management session
    MemoryManager.startProcessing();

    const quality = qualitySelect.value;
    let outputScale = 5.0;
    
    switch(quality) {
        case 'standard': outputScale = 1.5; break;
        case 'high': outputScale = 2.0; break;
        case 'ultra': outputScale = 3.0; break;
        case 'HD': outputScale = 5.0; break;
        case 'pc': outputScale = 8.0; break;
        default: outputScale = 5.0; break;
    }

    // --- This array will hold the data for the final PDF ---
    const finalPdfPages = [];

    try {
        // --- ASSUMPTION: Your PDF library has a way to get the number of pages ---
        const totalPages = pdfDocument.numPages; 

        for (let i = 1; i <= totalPages; i++) {
            console.log(`Processing page ${i} of ${totalPages} at ${outputScale}x scale...`);

            // --- Define variables that will hold large objects for this iteration ---
            let page, viewport, canvas, context, renderedPageData;

            try {
                // --- YOUR PDF LIBRARY CODE START ---
                // Example using PDF.js syntax
                page = await pdfDocument.getPage(i);
                viewport = page.getViewport({ scale: outputScale });

                // Create a temporary canvas for rendering this page
                canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                context = canvas.getContext('2d');

                // Render the PDF page into the canvas context
                // await page.render({ canvasContext: context, viewport: viewport }).promise;

                // Get the image data from the canvas
                // renderedPageData = canvas.toDataURL('image/png');
                // --- YOUR PDF LIBRARY CODE END ---

                // Add the processed page data to our final array
                // finalPdfPages.push(renderedPageData);

            } catch (e) {
                console.error(`Failed to process page ${i}:`, e);
                // Optionally, you can add a blank page or skip it
            } finally {
                // 2. REGISTER CLEANUP TASKS for the large objects of this iteration
                // This is the most important step. It ensures that once the loop moves to the next page,
                // the memory from the *previous* page is explicitly targeted for cleanup.
                MemoryManager.registerCleanupTask(() => {
                    console.log(`Cleaning up resources for page ${i}`);
                    if (page && typeof page.cleanup === 'function') {
                        page.cleanup(); // Use the library's own cleanup method if available
                    }
                    // Nullify all references to release them for garbage collection
                    page = null;
                    viewport = null;
                    renderedPageData = null;
                    if (context) {
                        context.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas content
                        context = null;
                    }
                    if (canvas) {
                        // canvas.remove(); // If you added it to the DOM
                        canvas.width = 1; // Reduce size to a minimum to free memory faster
                        canvas.height = 1;
                        canvas = null;
                    }
                });

                // 3. CALL THE CLEANUP FUNCTION for the just-completed iteration
                // This runs the tasks we just registered.
                MemoryManager.clear();
            }
        }

        console.log("All pages processed. Now combining into final PDF...");
        // --- YOUR CODE TO COMBINE finalPdfPages INTO A SINGLE PDF ---
        // For example, using jsPDF:
        // const { jsPDF } = window.jspdf;
        // const finalPdf = new jsPDF();
        // finalPdfPages.forEach((pageData, index) => {
        //     if (index > 0) finalPdf.addPage();
        //     finalPdf.addImage(pageData, 'PNG', 0, 0, 210, 297); // A4 dimensions
        // });
        // finalPdf.save('final-document.pdf');
        console.log("PDF saved successfully.");


    } catch (error) {
        console.error("A critical error occurred during PDF processing:", error);
        alert("An error occurred while processing the PDF. Please check the console for details.");
    } finally {
        // 4. END the session to perform a final, thorough cleanup
        MemoryManager.endProcessing();
    }
}


/**
 * ===================================================================
 * EVENT LISTENER TO TRIGGER THE PROCESS
 * ===================================================================
 * This connects the logic to your HTML elements.
 */
document.addEventListener('DOMContentLoaded', () => {
    const qualitySelect = document.getElementById('quality-select');
    const processButton = document.getElementById('process-pdf-button'); // Assume you have a button

    if (qualitySelect && processButton) {
        processButton.addEventListener('click', async () => {
            // --- YOU NEED TO PROVIDE THE PDF DOCUMENT OBJECT ---
            // This is just an example. You would get this from a file input or URL.
            // For example, using PDF.js:
            // const fileInput = document.getElementById('pdf-file-input');
            // const file = fileInput.files[0];
            // if (!file) {
            //     alert("Please select a PDF file first.");
            //     return;
            // }
            // const arrayBuffer = await file.arrayBuffer();
            // const pdfDocument = await pdfjsLib.getDocument(arrayBuffer).promise;
            
            // For demonstration, we'll create a dummy object.
            // Replace this with your actual PDF document object.
            const dummyPdfDocument = { numPages: 5 }; 

            // Disable button to prevent multiple clicks
            processButton.disabled = true;
            processButton.textContent = 'Processing...';

            await processPdfSafely(dummyPdfDocument, qualitySelect);

            // Re-enable button
            processButton.disabled = false;
            processButton.textContent = 'Process PDF';
        });
    }
});
</script>
</body>
</html>



